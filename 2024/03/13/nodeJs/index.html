<!DOCTYPE html><html lang="zh_CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>nodeJs | 音符跳动</title><meta name="author" content="凯"><meta name="copyright" content="凯"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="NODE.JS1.初识Node.js 1.2 Node.js 简介 1. 什么是Node.js Node.js@ is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js 是一个基于Chrome V8 引擎的JavaScript 运行环境。 Node.js官网地址: https:&#x2F;&#x2F;nodejs.org&#x2F;zh-c">
<meta property="og:type" content="article">
<meta property="og:title" content="nodeJs">
<meta property="og:url" content="https://2486125878.github.io/2024/03/13/nodeJs/index.html">
<meta property="og:site_name" content="音符跳动">
<meta property="og:description" content="NODE.JS1.初识Node.js 1.2 Node.js 简介 1. 什么是Node.js Node.js@ is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js 是一个基于Chrome V8 引擎的JavaScript 运行环境。 Node.js官网地址: https:&#x2F;&#x2F;nodejs.org&#x2F;zh-c">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/0bd162d9f2d3572c03d4a3348113632762d0c327.jpg">
<meta property="article:published_time" content="2024-03-13T07:17:22.000Z">
<meta property="article:modified_time" content="2024-03-13T08:22:07.781Z">
<meta property="article:author" content="凯">
<meta property="article:tag" content="nodeJs">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/0bd162d9f2d3572c03d4a3348113632762d0c327.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://2486125878.github.io/2024/03/13/nodeJs/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'nodeJs',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-13 16:22:07'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/header.css?1"><meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="音符跳动" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" src="https://tse3-mm.cn.bing.net/th/id/OIP-C.v8Y5QxZNIiQVIEk3JOCC2QHaGi?rs=1&amp;pid=ImgDetMain"/><div class="loading-image-dot"></div><div id="loading-percentage">0%</div></div></div><script>const loadingPercentage = document.getElementById("loading-percentage");
loadingPercentage.style.color = "black";
let loadingPercentageTimer = setInterval(function() {
  var progressBar = document.querySelector(".pace-progress");
  if (!progressBar) return
  var currentValue = progressBar.getAttribute("data-progress-text");
  if (currentValue !== loadingPercentage.textContent) {
    loadingPercentage.textContent = currentValue;
    if (currentValue === "100%") {
      clearInterval(loadingPercentageTimer);
    }
  }
}, 100);
const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="/css/progress_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.v8Y5QxZNIiQVIEk3JOCC2QHaGi?rs=1&amp;pid=ImgDetMain" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/0bd162d9f2d3572c03d4a3348113632762d0c327.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="音符跳动"><img class="site-icon" src="/img/logo.png"/><span class="site-name">音符跳动</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">nodeJs</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-03-13T07:17:22.000Z" title="Created 2024-03-13 15:17:22">2024-03-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-03-13T08:22:07.781Z" title="Updated 2024-03-13 16:22:07">2024-03-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/qd/">前端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="nodeJs"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"></svg><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="NODE-JS"><a href="#NODE-JS" class="headerlink" title="NODE.JS"></a>NODE.JS</h1><p><strong>1.初识Node.js</strong></p>
<p><strong>1.2 Node.js 简介</strong></p>
<p><strong>1. 什么是Node.js</strong></p>
<p><strong>Node.js@ is a JavaScript runtime built on Chrome’s V8 JavaScript engine.</strong></p>
<p><strong>Node.js 是一个基于Chrome V8 引擎的JavaScript 运行环境。</strong></p>
<p><strong>Node.js官网地址: <a target="_blank" rel="noopener" href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></strong></p>
<p><strong>2. Node.js 中的 JavaScript 运行环境</strong></p>
<p><strong>注意:</strong></p>
<p><strong>①浏览器是JavaScript的前端运行环境。</strong></p>
<p><strong>② Node.js 是 JavaScript的后端运行环境。</strong></p>
<p><strong>③ Node.js 中无法调用DOM和BOM等浏览器内置API。</strong></p>
<p><strong>3. Node.js 可以做什么</strong></p>
<p><strong>Node.js作为一个JavaScript的运行环境,仅仅提供了基础的功能和API。然而,基于Node.js提供的这些基础能,很多强大的工具和框架如雨后春笋,层出不穷,所以学会了Node.js,可以让前端程序员胜任更多的工作和岗位:</strong></p>
<p><strong>① 基于Express 框架(<a target="_blank" rel="noopener" href="http://www.expressjs.com.cn/),%E5%8F%AF%E4%BB%A5%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BAWeb%E5%BA%94%E7%94%A8">http://www.expressjs.com.cn/),可以快速构建Web应用</a></strong></p>
<p><strong>② 基于Electron框架(<a target="_blank" rel="noopener" href="https://electronjs.org/),%E5%8F%AF%E4%BB%A5%E6%9E%84%E5%BB%BA%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8">https://electronjs.org/),可以构建跨平台的桌面应用</a></strong></p>
<p><strong>③ 基于restify 框架(<a target="_blank" rel="noopener" href="http://restify.com/),%E5%8F%AF%E4%BB%A5%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BAAPI%E6%8E%A5%E5%8F%A3%E9%A1%B9%E7%9B%AE">http://restify.com/),可以快速构建API接口项目</a></strong></p>
<p><strong>④读写和操作数据库、创建实用的命令行工具辅助前端开发、etc…</strong></p>
<p><strong>总之: Node.js是大前端时代的“大宝剑“,有了Node.js这个超级buff的加持,前端程序员的行业竞争力会越来越强!</strong></p>
<p><strong>Node.js 的学习路径:JavaScript 基础语法+ Node.js 内置API 模块(fs, path, http等) +第三方API 模块(express, mysql 等)</strong></p>
<h2 id="1-4在Node-js-环境中执行JavaScript代码"><a href="#1-4在Node-js-环境中执行JavaScript代码" class="headerlink" title="1.4在Node.js 环境中执行JavaScript代码"></a><strong>1.4在Node.js 环境中执行JavaScript代码</strong></h2><p><strong>1.终端中的快捷键</strong></p>
<p><strong>在Windows 的 powershell 或 cmd终端中,我们可以通过如下快捷键,来提高终端的操作效率:</strong></p>
<p><strong>①使用1键,可以快速定位到上一次执行的命令</strong></p>
<p><strong>②使用tab键,能够快速补全路径</strong></p>
<p><strong>③使用esc键,能够快速清空当前已输入的命令</strong></p>
<p><strong>④输入cls命令,可以清空终端</strong></p>
<p><strong>2. fs文件系统模块</strong></p>
<h2 id="2-1什么是fs文件系统模块"><a href="#2-1什么是fs文件系统模块" class="headerlink" title="2.1什么是fs文件系统模块"></a><strong>2.1什么是fs文件系统模块</strong></h2><p><strong>fs模块是Node.js官方提供的、用来操作文件的模块。它提供了一系列的方法和属性,用来满足用户对文件的操作需求。</strong></p>
<p><strong>例如:</strong></p>
<p><strong>fs.readFile0方法,用来读取指定文件中的内容.</strong></p>
<p><strong>fs.writeFile0方法,用来向指定的文件中写入内容</strong></p>
<p><strong>如果要在JavaScript代码中,使用fs模块来操作文件,则需要使用如下的方式先导入它:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs =<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2-2读取指定文件中的内容"><a href="#2-2读取指定文件中的内容" class="headerlink" title="2.2读取指定文件中的内容"></a>2.2读取指定文件中的内容</h2><p><strong>1.fs.readFile()的语法格式</strong></p>
<p><strong>使用fs.readFile()方法,可以读取指定文件中的内容,语法格式如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(path[, options], callback)</span><br></pre></td></tr></table></figure>

<p><strong>参数解读:</strong></p>
<p><strong>参数1:必选参数,字符串,表示文件的路径。</strong></p>
<p><strong>参数2:可选参数,表示以什么编码格式来读取文件。</strong></p>
<p><strong>参数3:必选参数,文件读取完成后,通过回调函数拿到读取的结果。</strong></p>
<p><strong>2. fs.readFile()的示例代码以utf8的编码格式,读取指定文件的内容,并打印 err和dataStr的值:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/11.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, dataStr</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;----&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(dataStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>3.判断文件是否读取成功可以判断err对象是否为null,从而知晓文件读取的结果:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>) </span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/1.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;文件读取失!&#x27;</span>+ err.<span class="property">message</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;文件读取成功,内容是: &#x27;</span>+ result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="2-3向指定的文件中写入内容"><a href="#2-3向指定的文件中写入内容" class="headerlink" title="2.3向指定的文件中写入内容"></a><strong>2.3向指定的文件中写入内容</strong></h2><p><strong>1. fs.writeFile()的语法格式</strong></p>
<p><strong>使用fs.writeFile)方法,可以向指定的文件中写入内容,语法格式如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">writeFile</span>(file, data[, options], callback)</span><br></pre></td></tr></table></figure>

<p><strong>参数解读:</strong></p>
<p><strong>参数1:必选参数,需要指定一个文件路径的字符串,表示文件的存放路径。</strong></p>
<p><strong>参数2:必选参数,表示要写入的内容。</strong></p>
<p><strong>参数3:可选参数,表示以什么格式写入文件内容,默认值是utf8。</strong></p>
<p><strong>参数4:必选参数,文件写入完成后的回调函数。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;./files/2.txt&#x27;</span>, <span class="string">&#x27;Hello Node.js!&#x27;</span>, <span class="keyword">function</span>(<span class="params">err</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>3.判断文件是否写入成功</strong></p>
<p><strong>可以判断err对象是否为null,从而知晓文件写入的结果:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;F:/files/2.txt&#x27;</span>, <span class="string">&#x27;Hello Node.js!&#x27;</span>, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;文件写入失!&#x27;</span>+ err.<span class="property">message</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;文件写入成功! &#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="2-6-fs模块-路径动态拼接的问题"><a href="#2-6-fs模块-路径动态拼接的问题" class="headerlink" title="2.6 fs模块-路径动态拼接的问题"></a><strong>2.6 fs模块-路径动态拼接的问题</strong></h2><p><strong>在使用fs模块操作文件时,如果提供的操作路径是以&#x2F;或&#x2F;开头的相对路径时,很容易出现路径动态拼接错误的问题。</strong></p>
<p><strong>原因:代码在运行的时候,会以执行node命令时所处的目录,动态拼接出被操作文件的完整路径。</strong></p>
<p><strong>解决方案:在使用fs模块操作文件时,直接提供完整的路径,不要提供.&#x2F;或..&#x2F;开头的相对路径,从而防止路径动态拼接的问题。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(__dirname + <span class="string">&#x27;/files/1.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, datastr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取文件失败&#x27;</span> + err.<span class="property">message</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取文件成功&#x27;</span> + datastr);</span><br><span class="line">&#125;)fs.<span class="title function_">readFile</span>(__dirname + <span class="string">&#x27;/files/1.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, datastr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取文件失败&#x27;</span> + err.<span class="property">message</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取文件成功&#x27;</span> + datastr);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h1 id="3-path-路径模块"><a href="#3-path-路径模块" class="headerlink" title="3. path 路径模块"></a><strong>3. path 路径模块</strong></h1><h2 id="3-1什么是path-路径模块"><a href="#3-1什么是path-路径模块" class="headerlink" title="3.1什么是path 路径模块"></a><strong>3.1什么是path 路径模块</strong></h2><p><strong>path模块是 Node.js 官方提供的、用来处理路径的模块。它提供了一系列的方法和属性,用来满足用户对路径的处理需求。</strong></p>
<p><strong>例如:</strong></p>
<p>**path.join0方法,用来将多个路径片段拼接成一个完整的路径字符串. **</p>
<p><strong>path.basename0 方法,用来从路径字符串中,将文件名解析出来</strong></p>
<p><strong>如果要在JavaScript代码中,使用path模块来处理路径,则需要使用如下的方式先导入它:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3-2-路径拼接"><a href="#3-2-路径拼接" class="headerlink" title="3.2 路径拼接"></a>3.2 路径拼接</h2><p><strong>1.path.join() 的语法格式</strong></p>
<p><strong>使用path.join0方法,可以把多个路径片段拼接为完整的路径字符串,语法格式如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.<span class="title function_">join</span>([...paths])</span><br></pre></td></tr></table></figure>

<p><strong>参数解读:</strong></p>
<p><strong>…paths<string> 路径片段的序列</strong></p>
<p><strong>返回值: <string></strong></p>
<p><strong>2. path.join()的代码示例</strong></p>
<p><strong>使用path.join0方法,可以把多个路径片段拼接为完整的路径字符串:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pathStr = path.<span class="title function_">join</span>(<span class="string">&#x27;/a&#x27;</span>, <span class="string">&#x27;/b/c&#x27;</span>, <span class="string">&#x27;../&#x27;</span>,<span class="string">&#x27;./d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pathStr) <span class="comment">// 输 \a\b\d\e</span></span><br><span class="line"><span class="keyword">const</span> pathStr2 path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;./files/1.txt&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pathStr2) <span class="comment">// 输出 当前文件所处目录\files\1.txt</span></span><br></pre></td></tr></table></figure>

<p><strong>注意:今后凡是涉及到路径拼接的操作,都要使用path.join0方法进行处理。不要直接使用+进行字符串的拼接。</strong></p>
<h2 id="3-3获取路径中的文件名"><a href="#3-3获取路径中的文件名" class="headerlink" title="3.3获取路径中的文件名"></a><strong>3.3获取路径中的文件名</strong></h2><p><strong>1. path.basename()的语法格式</strong></p>
<p><strong>使用 path.basename0方法,可以获取路径中的最后一部分,经常通过这个方法获取路径中的文件名,语法格式如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.<span class="title function_">basename</span>(path[, ext])</span><br></pre></td></tr></table></figure>

<p><strong>参数解读:</strong></p>
<p>**path <string> 必选参数,表示一个路径的字符串. **</p>
<p><strong>ext <string>可选参数,表示文件扩展名.</strong></p>
<p><strong>返回: <string>表示路径中的最后一部分</strong></p>
<p><strong>2. path.basename() 的代码示例</strong></p>
<p><strong>使用 path.basename0方法,可以从一个文件路径中,获取到文件的名称部分:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fpath = <span class="string">&#x27;/a/b/c/index.html&#x27;</span> <span class="comment">// 文件的存放路径</span></span><br><span class="line"><span class="keyword">var</span> fullName = path. <span class="title function_">basename</span>(path)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fullName) <span class="comment">// 输 index.html</span></span><br><span class="line"><span class="keyword">var</span> namewithoutExt = path.<span class="title function_">basename</span>(fpath, <span class="string">&#x27;.html&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(namewithoutExt) <span class="comment">// 输 index</span></span><br></pre></td></tr></table></figure>



<p><strong>3.4 获取路径中的文件扩展名</strong></p>
<p><strong>1. path.extname()的语法格式</strong></p>
<p><strong>使用path.extname()方法,可以获取路径中的扩展名部分,语法格式如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.<span class="title function_">extname</span>(path)</span><br></pre></td></tr></table></figure>

<p><strong>参数解读:</strong></p>
<p><strong>path <string>必选参数,表示一个路径的字符串.</strong></p>
<p><strong>返回: <string>返回得到的扩展名字符串</strong></p>
<p><strong>2. path.extname() 的代码示例</strong></p>
<p><strong>使用path.extname()方法,可以获取路径中的扩展名部分:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fpath = <span class="string">&#x27;/a/b/c/index.html&#x27;</span> <span class="comment">// 路径字符串</span></span><br><span class="line"><span class="keyword">const</span> fext = path.<span class="title function_">extname</span>(fpath)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fext) <span class="comment">// 输.html</span></span><br></pre></td></tr></table></figure>

<h2 id="3-5综合案例-时钟案例"><a href="#3-5综合案例-时钟案例" class="headerlink" title="3.5综合案例-时钟案例"></a><strong>3.5综合案例-时钟案例</strong></h2><p><strong>3.步骤1-导入需要的模块并创建正则表达式</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.1 导入 fs文件系统模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="comment">//1.2导入 path路径处理模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="comment">//1.3匹配&lt;style&gt;&lt;/style&gt;标签的正则</span></span><br><span class="line"><span class="comment">//其中\s表示空白字符; \S表示非空白字符; *表示匹配任意次</span></span><br><span class="line"><span class="keyword">const</span> regStyle = <span class="regexp">/&lt;style&gt;[\s\S]*&lt;\/style&gt;/</span></span><br><span class="line"><span class="comment">//1.4 匹配&lt;script&gt;&lt;/script&gt;标签的正则</span></span><br><span class="line"><span class="keyword">const</span> regScript = <span class="regexp">/&lt;script&gt;[\s\S]*&lt;\/script&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>3.步骤2-使用fs模块读取需要被处理的html文件</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.1读取需要被处理的HTML文件</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;../素才/index.html&#x27;</span>), <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, dataStr</span>) =&gt;</span>&#123;</span><br><span class="line"> <span class="comment">//2.2 读取HTML文件失败</span></span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取HTML文件失!&#x27;</span> + err.<span class="property">message</span>)</span><br><span class="line"> <span class="comment">// 2.3 读取HTML文件成功后,调用对应的方法,拆解出css.js 和html文件</span></span><br><span class="line">    <span class="title function_">resolveCSS</span>(dataStr)</span><br><span class="line">    <span class="title function_">resolveJS</span>(dataStr)</span><br><span class="line">    <span class="title function_">resolveHTML</span>(dataStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>3.步骤3-自定义resolveCSS方法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.1处理CSS样式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolveCSS</span>(<span class="params">htmlStr</span>)&#123;</span><br><span class="line"><span class="comment">//3.2使用正则提取页面中的&lt;style&gt;&lt;/style&gt;标签</span></span><br><span class="line"> <span class="keyword">const</span> r1 regStyle.<span class="title function_">exec</span>(htmlStr)</span><br><span class="line"><span class="comment">//3.3将提取出来的样式字符串,做进一步的处理</span></span><br><span class="line"> <span class="keyword">const</span> newCSS = r1[<span class="number">0</span>].<span class="title function_">replace</span>(<span class="string">&#x27;&lt;style&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>).<span class="title function_">replace</span>(<span class="string">&#x27;&lt;/style&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">// 3.4将提取出来的CSS样式,写入到index.css文件中</span></span><br><span class="line"> fs.<span class="title function_">writeFile</span>(path.<span class="title function_">join</span>(dirname, <span class="string">&#x27;./clock/index.css&#x27;</span>), newCSS, <span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (err) </span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入 CSS 样式失!&#x27;</span>+ err.<span class="property">message</span>)</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入CSS 样式成功!&#x27;</span>)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.步骤4-自定义resolveJS方法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.1处理js脚本</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolveJS</span>(<span class="params">htmlStr</span>)&#123;</span><br><span class="line"><span class="comment">//4.2使用正则提取页面中的&lt;script&gt;&lt;/script&gt;标签</span></span><br><span class="line"> <span class="keyword">const</span> r2 =regScript.<span class="title function_">exec</span>(htmlStr)</span><br><span class="line"><span class="comment">//4.3将提取出来的脚本字符串,做进一步的处理</span></span><br><span class="line"> <span class="keyword">const</span> newJS = r2[<span class="number">0</span>].<span class="title function_">replace</span>(<span class="string">&#x27;&lt;script&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>).<span class="title function_">replace</span>(<span class="string">&#x27;&lt;/script&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">//4.4将提取出来的js脚本,写入到index.js文件中</span></span><br><span class="line"> fs.<span class="title function_">writeFile</span>(path.<span class="title function_">join</span>(_dirname, <span class="string">&#x27;./clock/index.js&#x27;</span>), newJS, <span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入 JavaScript脚本 失败!&#x27;</span>+ err.<span class="property">message</span>)</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;写入JS 脚本成功!&#x27;)</span></span><br><span class="line"><span class="string">                 &#125;)</span></span><br><span class="line"><span class="string"> &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>3.步骤5-自定义resolveHTML方法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.处理html文件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolveHTML</span>(<span class="params">htmlStr</span>)&#123;</span><br><span class="line"><span class="comment">//5.1使用字符事的replace方法,把内嵌的&lt;style&gt;和&lt;script&gt;标签,替换为外联的&lt;link&gt;和&lt;script&gt;标签</span></span><br><span class="line"> <span class="keyword">const</span> newHTML htmlStr</span><br><span class="line"> .<span class="title function_">replace</span>(regStyle, <span class="string">&#x27;&lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;/&gt;&#x27;</span>)</span><br><span class="line">    .<span class="title function_">replace</span>(regScript, <span class="string">&#x27;&lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;&#x27;</span>)</span><br><span class="line"> <span class="comment">//5.2将替换完成之后的html代码,写入到index.html文件中</span></span><br><span class="line">  fs.<span class="title function_">writeFile</span>(path.<span class="title function_">join</span>(dirname, <span class="string">&#x27;./clock/index.html&#x27;</span>), newHTML, <span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入HTML文件失败!&#x27;</span>+ err.<span class="property">message</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入HTML页面成功! &#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.案例的两个注意点</strong></p>
<p><strong>① fs.writeFile0方法只能用来创建文件,不能用来创建路径</strong></p>
<p><strong>② 重复调用fs.writeFile0 写入同一个文件,新写入的内容会覆盖之前的旧内容</strong></p>
<h1 id="4-http模块"><a href="#4-http模块" class="headerlink" title="4. http模块"></a><strong>4. http模块</strong></h1><h2 id="4-1-什么是http模块"><a href="#4-1-什么是http模块" class="headerlink" title="4.1 什么是http模块"></a><strong>4.1 什么是http模块</strong></h2><p><strong>回顾:什么是客户端、什么是服务器?</strong></p>
<p><strong>在网络节点中,负责消费资源的电脑,叫做客户端;</strong></p>
<p><strong>负责对外提供网络资源的电脑,叫做服务器。</strong></p>
<p><strong>http 模块是Node.js官方提供的、用来创建web服务器的模块。通过http模块提供的http.createServer()方法,就能方便的把一台普通的电脑,变成一台Web服务器,从而对外提供Web资源服务。</strong></p>
<p><strong>如果要希望使用http模块创建Web服务器,则需要先导入它:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="4-2进一步理解http模块的作用"><a href="#4-2进一步理解http模块的作用" class="headerlink" title="4.2进一步理解http模块的作用"></a><strong>4.2进一步理解http模块的作用</strong></h2><p><strong>服务器和普通电脑的区别在于,服务器上安装了web服务器软件,例如: IIS,Apache等。通过安装这些服务器软件,就能把一台普通的电脑变成一台web服务器。</strong></p>
<p><strong>在Node.js 中,我们不需要使用IS, Apache等这些第三方web服务器软件。因为我们可以基于Node.js提供的http模块,通过几行简单的代码,“就能轻松的手写一个服务器软件,从而对外提供web服务。</strong></p>
<h2 id="4-3服务器相关的概念"><a href="#4-3服务器相关的概念" class="headerlink" title="4.3服务器相关的概念"></a><strong>4.3服务器相关的概念</strong></h2><p><strong>1. IP 地址IP地址就是互联网上每台计算机的唯一地址,因此IP地址具有唯一性。如果把“个人电脑”比作“一台电话”,那么”IP地址”就相当于“电话号码”,只有在知道对方IP地址的前提下,才能与对应的电脑之间进行数据通信。</strong></p>
<p><strong>IP地址的格式:通常用“点分十进制”表示成(a.b.c.d)的形式,其中,a,b,c,d都是0~255之间的十进制整数。例如:用点分十进表示的IP地址(192.168.1.1)</strong></p>
<p><strong>注意:</strong></p>
<p><strong>①互联网中每台Web服务器,都有自己的IP地址,例如:大家可以在Windows的终端中运行ping <a target="_blank" rel="noopener" href="http://www.baidu.com命令,即可查看到百度服务器的ip地址./">www.baidu.com命令,即可查看到百度服务器的IP地址。</a></strong></p>
<p><strong>②在开发期间,自己的电脑既是一台服务器,也是一个客户端,为了方便测试,可以在自己的浏览器中输入127.0.0.1这个IP地址,就能把自己的电脑当做一台服务器进行访问了。</strong></p>
<p><strong>2.域名和域名服务器</strong></p>
<p><strong>尽管IP地址能够唯一地标记网络上的计算机,但IP地址是一长串数字,不直观,而且不便于记忆,于是人们又发明了另一套字符型的地址方案,即所谓的域名(Domain Name)地址。</strong></p>
<p><strong>IP地址和域名是–对应的关系,这份对应关系存放在一种叫做域名服务器(DNS, Domain name server)的电脑中。使用者只需通过好记的域名访问对应的服务器即可,对应的转换工作由域名服务器实现。因此,域名服务器就是提供IP地址和域名之间的转换服务的服务器。</strong></p>
<p><strong>注意:</strong></p>
<p><strong>①单纯使用IP地址,互联网中的电脑也能够正常工作。但是有了域名的加持,能让互联网的世界变得更加方便。</strong></p>
<p><strong>②在开发测试期间, 127.0.0.1 对应的域名是 localhost,它们都代表我们自己的这台电脑,在使用效果上没有任何区别。</strong></p>
<p><strong>3.端口号</strong></p>
<p><strong>计算机中的端口号,就好像是现实生活中的门牌号一样。通过门牌号,外卖小哥可以在整栋大楼众多的房间中,准确把外卖送到你的手中。</strong></p>
<p><strong>同样的道理,在一台电脑中,可以运行成百上干个web服务。每个web服务都对应一个唯一的端口号。客户端发送过来的网络请求,通过端口号,可以被准确地交给对应的web服务进行处理。</strong></p>
<p><strong>注意:</strong></p>
<p><strong>①每个端口号不能同时被多个web服务占用。</strong></p>
<p><strong>②在实际应用中,URL中的80端口可以被省略。</strong></p>
<p><strong>1.创建web服务器的基本步骤</strong></p>
<p><strong>① 导入http模块</strong></p>
<p><strong>②创建web服务器实例</strong></p>
<p><strong>③为服务器实例绑定request事件,监听客户端的请求</strong></p>
<p><strong>④启动服务器</strong></p>
<p><strong>4.4 创建最基本的web服务器</strong></p>
<p><strong>2.步骤3-为服务器实例绑定request事件</strong></p>
<p><strong>为服务器实例绑定request事件,即可监听客户端发送过来的网络请求</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//使用服务器实例的.on()方法,为服务器绑定一个request事件</span><br><span class="line"> server.on(&#x27;request&#x27;. (req. res) =&gt;&#123;</span><br><span class="line"> //只要有客户端来请求我们自己的服务器,就会触发request事件,从而调用这个事件处理函数</span><br><span class="line"> console.log(&#x27;Someone visit our web server&#x27;)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>2.步骤4-启动服务器</strong></p>
<p><strong>调用服务器实例的.listen0方法,即可启动当前的web服务器实例:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用 server.listen(端口号, cb回调)方法,即可启动web服务器</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">80</span>, <span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;http server running at http://127.0.0.1&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>3. req请求对象只要服务器接收到了客户端的请求,就会调用通过server.on0为服务器绑定的request事件处理函数。</strong></p>
<p><strong>如果想在事件处理函数中,访问与客户端相关的数据或属性,可以使用如下的方式:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>. (req) =&gt;&#123;</span><br><span class="line">    <span class="comment">//req 是请求对象,它包合了与客户端相关的数据和属性,例如:</span></span><br><span class="line">    <span class="comment">// req.url是客户端请求的URL地址</span></span><br><span class="line">    <span class="comment">// req.method是客户的method请求类型</span></span><br><span class="line">    <span class="keyword">const</span> str = <span class="string">&quot;Your request url is $(req.url), and request method is $&#123;req.method&#125;</span></span><br><span class="line"><span class="string">    console.log(str)</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure>

<p><strong>4. res 响应对象在服务器的request事件处理函数中,如果想访问与服务器相关的数据或属性,可以使用如下的方式:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span>&#123;</span><br><span class="line"> <span class="comment">// res 是响应对象,它包含了与服务器相关的数据和属性,例如:</span></span><br><span class="line"> <span class="comment">//要发送到客户端的字符串</span></span><br><span class="line">    <span class="keyword">const</span> str= <span class="string">&#x27;Your request url is $&#123;req.url&#125;, and request method is $&#123;req.method&#125;`</span></span><br><span class="line"><span class="string">    // res.end()方法的作用:</span></span><br><span class="line"><span class="string">    //向客户端发送指定的内容,并结束这次请求的处理过程</span></span><br><span class="line"><span class="string">    res.end(str)</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure>

<p><strong>5.解决中文乱码问题当调用res.end0方法,向客户端发送中文内容的时候,会出现乱码问题,此时,需要手动设置内容的编码格式:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//发送的内容包含中文</span></span><br><span class="line">    <span class="keyword">const</span> str=<span class="string">`您请求的ur1地址是<span class="subst">$&#123;req.url&#125;</span>,请求的method 类型是 <span class="subst">$&#123;req.method&#125;</span>`</span></span><br><span class="line">    <span class="comment">//为了防止中文显示乱码的问题,需要设置响应头Content-Type的值为text/html; charset=utf-8</span></span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html; charset=utf-8&#x27;</span>)</span><br><span class="line">    <span class="comment">//把包含中文的内容,响应给客户端</span></span><br><span class="line">    res.<span class="title function_">end</span>(str)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="4-5-根据不同的url响应不同的html内容"><a href="#4-5-根据不同的url响应不同的html内容" class="headerlink" title="4.5 根据不同的url响应不同的html内容"></a><strong>4.5 根据不同的url响应不同的html内容</strong></h2><p><strong>1.核心实现步骤</strong></p>
<p><strong>①获取请求的url地址</strong></p>
<p><strong>②设置默认的响应内容为404 Not found</strong></p>
<p><strong>③判断用户请求的是否为&#x2F;或&#x2F;index.html首页</strong></p>
<p><strong>④判断用户请求的是否为&#x2F;about.html关于页面</strong></p>
<p><strong>⑤设置Content-Type 响应头,防止中文乱码</strong></p>
<p><strong>6使用res.end()把内容响应给客户端</strong></p>
<p><strong>2.动态响应内容</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> url=req.<span class="property">url</span></span><br><span class="line">   <span class="comment">// 1.获取请求的url地址</span></span><br><span class="line">    <span class="keyword">let</span> content<span class="string">&#x27;&lt;h1&gt;404 Not found!&lt;/h1&gt;&#x27;</span></span><br><span class="line">    <span class="comment">// 2. 设置认的内容为404 Not found</span></span><br><span class="line">    <span class="keyword">if</span> (url ===<span class="string">&#x27;/&#x27;</span> || url ===<span class="string">&#x27;/index.html&#x27;</span>)&#123;</span><br><span class="line">      content =<span class="string">&#x27;&lt;h1&gt;首页&lt;/h1&gt;</span></span><br><span class="line"><span class="string">     //3.用户请求的是首页</span></span><br><span class="line"><span class="string">    &#125;else if (url ===&#x27;</span>/about.<span class="property">html</span><span class="string">&#x27;) &#123;</span></span><br><span class="line"><span class="string">        content = &#x27;</span>&lt;h1&gt;关于页&lt;/h1&gt;<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">   //4.用户请求的是关于页面</span></span><br><span class="line"><span class="string">    res.setHeader(&#x27;</span><span class="title class_">Content</span>-<span class="title class_">Type</span><span class="string">&#x27;, &#x27;</span>text/html; charset=utf-<span class="number">8</span><span class="string">&#x27;) </span></span><br><span class="line"><span class="string">    // 5. 设置Content-Type 响应头,防止中文乱研</span></span><br><span class="line"><span class="string">    res.end(content)</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">    //6.把内容发送给客户端</span></span><br></pre></td></tr></table></figure>

<p><strong>1.核心思路把文件的实际存放路径,作为每个资源的请求url地址。</strong></p>
<p><strong>2.实现步骤</strong></p>
<p><strong>① 导入需要的模块</strong></p>
<p><strong>②创建基本的web服务器</strong></p>
<p><strong>③将资源的请求url地址映射为文件的存放路径</strong></p>
<p><strong>④读取文件内容并响应给客户端</strong></p>
<p><strong>⑤优化资源的请求路径</strong></p>
<p><strong>3.步骤1-导入需要的模块</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.1 导入 http模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="comment">//1.2 导入 fs文件系统模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="comment">// 1.3 导入path路径处理模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>3.步骤2-创建基本的web服务器</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.1创建web服务器</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>()</span><br><span class="line"><span class="comment">// 2.2 监听web服务器的request事件</span></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;&#125;)</span><br><span class="line"><span class="comment">//2.3 启动web服务器</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">80</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server listen at http://127.0.0.1&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>3.步骤3-将资源的请求url地址映射为文件的存放路径</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.1获取到客户端请求的url地址</span></span><br><span class="line"><span class="keyword">const</span> url req.<span class="property">url</span></span><br><span class="line"><span class="comment">// 3.2把请求的url地址,映射为本地文件的存放路径</span></span><br><span class="line"><span class="keyword">const</span> fpath = path.<span class="title function_">join</span>(__dirname, url)</span><br></pre></td></tr></table></figure>

<p><strong>3.步骤4-读取文件的内容并响应给客户端</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.1根据“映射“过来的文件路径读取文件</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(fpath, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, dataStr</span>) =&gt;</span>&#123;</span><br><span class="line"> <span class="comment">// 4.2读取文件失败后,向客户端响应同定的“错误消息”</span></span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> res.<span class="title function_">end</span>(<span class="string">&#x27;404 Not fount. &#x27;</span>)</span><br><span class="line">  <span class="comment">// 4.3 读取文件成功后,将&quot;读取成功的内容”响应给客户端</span></span><br><span class="line">    res.<span class="title function_">end</span>(dataStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="1-模块化的基本概念"><a href="#1-模块化的基本概念" class="headerlink" title="1.模块化的基本概念"></a><strong>1.模块化的基本概念</strong></h2><h3 id="1-1什么是模块化"><a href="#1-1什么是模块化" class="headerlink" title="1.1什么是模块化"></a><strong>1.1什么是模块化</strong></h3><p><strong>模块化是指解决一个复杂问题时,自顶向下逐层把系统划分成若干模块的过程。对于整个系统来说,模块是可组合、分解和更换的单元。</strong></p>
<p><strong>2.编程领域中的模块化</strong></p>
<p><strong>编程领域中的模块化,就是遵守固定的规则,把一个大文件拆成独立并互相依赖的多个小模块。</strong></p>
<p><strong>把代码进行模块化拆分的好处:</strong></p>
<p><strong>①提高了代码的复用性</strong></p>
<p><strong>②提高了代码的可维护性</strong></p>
<p><strong>③可以实现按需加载</strong></p>
<p><strong>1.2模块化规范</strong></p>
<p><strong>模块化规范就是对代码进行模块化的拆分与组合时,需要遵守的那些规则。</strong></p>
<p><strong>例如:</strong></p>
<p><strong>使用什么样的语法格式来引用模块</strong></p>
<p><strong>在模块中使用什么样的语法格式向外暴露成员</strong></p>
<p><strong>模块化规范的好处:大家都遵守同样的模块化规范写代码,降低了沟通的成本,极大方便了各个模块之间的相互调用,利人利己。</strong></p>
<h2 id="2-Node-js中的模块化"><a href="#2-Node-js中的模块化" class="headerlink" title="2. Node.js中的模块化"></a><strong>2. Node.js中的模块化</strong></h2><h3 id="2-1-Node-js-中模块的分类"><a href="#2-1-Node-js-中模块的分类" class="headerlink" title="2.1 Node.js 中模块的分类"></a><strong>2.1 Node.js 中模块的分类</strong></h3><p><strong>Node.js中根据模块来源的不同,将模块分为了3大类,分别是:.</strong></p>
<p><strong>内置模块(内置模块是由Node.js官方提供的,例如fs, path, http等).</strong></p>
<p><strong>自定义模块(用户创建的每个.js文件,都是自定义模块)·</strong></p>
<p><strong>第三方模块(由第三方开发出来的模块,并非官方提供的内置模块,也不是用户创建的自定义模块,使用前需要先下载)</strong></p>
<h3 id="2-2加载模块"><a href="#2-2加载模块" class="headerlink" title="2.2加载模块"></a><strong>2.2加载模块</strong></h3><p><strong>使用强大的require0方法,可以加载需要的内置模块、用户自定义模块、第三方模块进行使用。例如:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.加载内置的fs模块</span></span><br><span class="line"><span class="keyword">const</span> fs = requireC<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="comment">// 2.加载用户的自定义模块</span></span><br><span class="line"><span class="keyword">const</span> custom = <span class="built_in">require</span>(<span class="string">&#x27;./custom.js&#x27;</span>)</span><br><span class="line"><span class="comment">// 3.加载第三方模块</span></span><br><span class="line"><span class="keyword">const</span> moment =<span class="built_in">require</span>(<span class="string">&#x27;moment&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意:使用requireO方法加载其它模块时,会执行被加载模块中的代码。</strong></p>
<h3 id="2-3-Node-js-中的模块作用域"><a href="#2-3-Node-js-中的模块作用域" class="headerlink" title="2.3 Node.js 中的模块作用域"></a><strong>2.3 Node.js 中的模块作用域</strong></h3><p><strong>1.什么是模块作用域和函数作用域类似,在自定义模块中定义的变量、方法等成员,只能在当前模块内被访问,这种模块级别的访问限制,叫做模块作用域。</strong></p>
<p><strong>2.模块作用域的好处</strong></p>
<p><strong>防止了全局变量污染的问题</strong></p>
<h3 id="2-4-向外共享模块作用域中的成员"><a href="#2-4-向外共享模块作用域中的成员" class="headerlink" title="2.4 向外共享模块作用域中的成员"></a><strong>2.4 向外共享模块作用域中的成员</strong></h3><p><strong>1. module 对象</strong></p>
<p><strong>在每个.js自定义模块中都有一个module对象,它里面存储了和当前模块有关的信息,打印如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Module</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;D:\\node&#x27;</span>,</span><br><span class="line">  <span class="attr">exports</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">filename</span>: <span class="string">&#x27;D:\\node\\17演示module对象.js&#x27;</span>,</span><br><span class="line">  <span class="attr">loaded</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">children</span>: [],</span><br><span class="line">  <span class="attr">paths</span>: [ <span class="string">&#x27;D:\\node\\node_modules&#x27;</span>, <span class="string">&#x27;D:\\node_modules&#x27;</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>2. module.exports 对象</strong></p>
<p><strong>在自定义模块中,可以使用module.exports对象,将模块内的成员共享出去,供外界使用。</strong></p>
<p><strong>外界用require0方法导入自定义模块时,得到的就是module.exports所指向的对象。</strong></p>
<p><strong>3.共享成员时的注意点</strong></p>
<p><strong>使用require0方法导入模块时,导入的结果,永远以module.exports指向的对象为准。</strong></p>
<p><strong>4.exports 对象</strong></p>
<p><strong>由于module.exports单词写起来比较复杂,为了简化向外共享成员的代码,Node提供了exports对象。默认情况下, exports 和module.exports指向同一个对象。最终共享的结果,还是以module.exports指向的对象为准。</strong></p>
<p><strong>4. exports 和 module.exports 的使用误区</strong></p>
<p><strong>时刻谨记, requireO模块时,得到的永远是module.exports指向的对象:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">username</span> =<span class="string">&#x27;zs&#x27;</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;<span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span>, <span class="attr">age</span>: <span class="number">22</span>&#125;  </span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">username</span> = <span class="string">&#x27;zs&#x27;</span></span><br><span class="line"><span class="built_in">exports</span> = &#123;</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;<span class="attr">username</span>: <span class="string">&#x27;zs&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">username</span>= <span class="string">&#x27;zs&#x27;</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">gender</span> = <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#123; <span class="attr">username</span>: <span class="string">&#x27;zs&#x27;</span>, <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span> = &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="built_in">exports</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">age</span> = <span class="string">&#x27;22&#x27;</span></span><br><span class="line">&#123; <span class="attr">username</span>: <span class="string">&#x27;zs&#x27;</span>, <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span>, <span class="attr">age</span>: <span class="string">&#x27;22&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意:为了防止混乱,建议大家不要在同一个模块中同时使用 exports 和module.exports</strong></p>
<h1 id="3-npm与包"><a href="#3-npm与包" class="headerlink" title="3. npm与包"></a><strong>3. npm与包</strong></h1><h2 id="3-1包"><a href="#3-1包" class="headerlink" title="3.1包"></a><strong>3.1包</strong></h2><p><strong>1.什么是包</strong></p>
<p><strong>Node.js中的第三方模块又叫做包。</strong></p>
<p><strong>就像电脑和计算机指的是相同的东西,第三方模块和包指的是同一个概念,只不过叫法不同。</strong></p>
<p><strong>2.包的来源</strong></p>
<p><strong>不同于Node.js中的内置模块与自定义模块,包是由第三方个人或团队开发出来的,免费供所有人使用。</strong></p>
<p><strong>注意: Node.js中的包都是免费且开源的,不需要付费即可免费下载使用。</strong></p>
<p><strong>3.为什么需要包</strong></p>
<p><strong>由于Node.js的内置模块仅提供了一些底层的API,导致在基于内置模块进行项目开发的时,效率很低。</strong></p>
<p><strong>包是基于内置模块封装出来的,提供了更高级、更方便的API,极大的提高了开发效率。</strong></p>
<p><strong>包和内置模块之间的关系,类似于jQuery和浏览器内置API之间的关系。</strong></p>
<p><strong>4.从哪里下载包</strong></p>
<p><strong>国外有一家IT公司,叫做npm, Inc.这家公司旗下有一个非常著名的网站: <a target="_blank" rel="noopener" href="https://www.npmjs.com/,%E5%AE%83%E6%98%AF%E5%85%A8%E7%90%83%E6%9C%80%E5%A4%A7%E7%9A%84%E5%8C%85%E5%85%B1%E4%BA%AB%E5%B9%B3%E5%8F%B0,%E4%BD%A0%E5%8F%AF%E4%BB%A5%E4%BB%8E%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99%E4%B8%8A%E6%90%9C%E7%B4%A2%E5%88%B0%E4%BB%BB%E4%BD%95%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9A%84%E5%8C%85,%E5%8F%AA%E8%A6%81%E4%BD%A0%E6%9C%89%E8%B6%B3%E5%A4%9F%E7%9A%84%E8%80%90%E5%BF%83">https://www.npmjs.com/,它是全球最大的包共享平台,你可以从这个网站上搜索到任何你需要的包,只要你有足够的耐心</a>!</strong></p>
<p><strong>到目前位置,全球约1100 多万的开发人员,通过这个包共享平台,开发并共享了超过120多万个包 供我们使用。</strong></p>
<p><strong>npm, Inc. 公司提供了一个地址为hps:&#x2F;&#x2F;registry.npmjs.org&#x2F;的服务器,来对外共享所有的包,我们可以从这个服务器上下载自己所需要的包。</strong></p>
<p><strong>注意:</strong></p>
<p><strong>.从<a target="_blank" rel="noopener" href="https://www.npmjs.com/%E7%BD%91%E7%AB%99%E4%B8%8A%E6%90%9C%E7%B4%A2%E8%87%AA%E5%B7%B1%E6%89%80%E9%9C%80%E8%A6%81%E7%9A%84%E5%8C%85">https://www.npmjs.com/网站上搜索自己所需要的包</a></strong></p>
<p><strong>.从<a target="_blank" rel="noopener" href="https://registry.npmjs.org/">https://registry.npmjs.org/</a> 服务器上下载自己需要的包</strong></p>
<p><strong>5.如何下载包</strong></p>
<p><strong>npm, Inc.公司提供了一个包管理工具,我们可以使用这个包管理T具,从<a target="_blank" rel="noopener" href="https://registry.npmjs.org/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8A%8A%E9%9C%80%E8%A6%81%E7%9A%84%E5%8C%85%E4%B8%8B%E8%BD%BD%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BD%BF%E7%94%A8%E3%80%82">https://registry.npmjs.org/服务器把需要的包下载到本地使用。</a></strong></p>
<p><strong>这个包管理工具的名字叫做Node Package Manager(简称npm包管理工具),这个包管理T具随着Node.js的安装包一起被安装到了用户的电脑上。</strong></p>
<h2 id="3-2-npm-初体验"><a href="#3-2-npm-初体验" class="headerlink" title="3.2 npm 初体验"></a><strong>3.2 npm 初体验</strong></h2><p><strong>1.格式化时间的传统做法</strong></p>
<p><strong>①创建格式化时间的自定义模块</strong></p>
<p><strong>②定义格式化时间的方法</strong></p>
<p><strong>③创建补零函数</strong></p>
<p><strong>④从自定义模块中导出格式化时间的函数</strong></p>
<p><strong>⑤导入格式化时间的自定义模块</strong></p>
<p><strong>6调用格式化时间的函数</strong></p>
<p><strong>2.格式化时间的高级做法</strong></p>
<p><strong>①使用npm包管理T具,在项目中安装格式化时间的包moment</strong></p>
<p><strong>②使用requireO导入格式化时间的包</strong></p>
<p><strong>③参考moment的官方API文档对时间进行格式化</strong></p>
<p><strong>3.在项目中安装包的命令</strong></p>
<p><strong>如果想在项目中安装指定名称的包,需要运行如下的命令:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install 包的完整名称</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i 完整的包名称</span><br></pre></td></tr></table></figure>

<p><strong>4.初次装包后多了哪些文件</strong></p>
<p><strong>初次装包完成后,在项目文件夹下多一个叫做node_modules的文件夹和package-lock.json的配置文件。</strong></p>
<p><strong>其中:</strong></p>
<p><strong>node_modules文件夹用来存放所有已安装到项目中的包。 requireO导入第三方包时,就是从这个目录中查找并加载包。</strong></p>
<p><strong>package-lock.json配置文件用来记录 node_modules 目录下的每一个包的下载信息,例如包的名字、版本号、下载地址等。</strong></p>
<p><strong>注意:程序员不要手动修改node_modules 或 package-lock.json文件中的任何代码,npm包管理工具会自动维护它们。</strong></p>
<p><strong>5.安装指定版本的包默认情况下,使用npm install 命令安装包的时候,会自动安装最新版本的包。如果需要安装指定版本的包,可以在包名之后,通过@符号指定具体的版本,例如:</strong></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i moment@<span class="number">2</span>.<span class="number">22</span>.<span class="number">2</span></span><br></pre></td></tr></table></figure>



<p><strong>6.包的语义化版本规范</strong></p>
<p><strong>包的版本号是以“点分十进制”形式进行定义的,总共有三位数字,例如2.24.0其中每一位数字所代表的的含义如下:</strong></p>
<p><strong>第1位数字:大版本</strong></p>
<p><strong>第2位数字:功能版本</strong></p>
<p><strong>第3位数字: Bug修复版本</strong></p>
<p><strong>版本号提升的规则:只要前面的版本号增长了,则后面的版本号归零。</strong></p>
<p><strong>3.3包管理配置文件</strong></p>
<p><strong>npm规定,在项目根目录中,必须提供一个叫做 package.json的包管理配置文件。用来记录与项目有关的一些配置信息。例如:</strong></p>
<p><strong>.项目的名称、版本号、描述等.</strong></p>
<p><strong>项目中都用到了哪些包.</strong></p>
<p><strong>哪些包只在开发期间会用到</strong></p>
<p><strong>.那些包在开发和部署时都需要用到</strong></p>
<p><strong>整个项目的体积是30.4M</strong></p>
<p><strong>第三方包的体积是 28.8M</strong></p>
<p><strong>项目源代码的体积1.6M</strong></p>
<p><strong>遇到的问题:第三方包的体积过大,不方便团队成员之间共享项目源代码。</strong></p>
<p><strong>解决方案:共享时剔除node_modules</strong></p>
<p><strong>2.如何记录项目中安装了哪些包</strong></p>
<p><strong>在项目根目录中,创建一个叫做package.json的配置文件,即可用来记录项目中安装了哪些包。从而方便剔除node_modules 目录之后,在团队成员之间共享项目的源代码。</strong></p>
<p><strong>注意:今后在项目开发中,一定要把node_modules文件夹,添加到.gitignore忽略文件中。</strong></p>
<p><strong>3. 快速创建 package.jsonnpm包管理工具提供了一个快捷命令,可以在执行命令时所处的目录中,快速创建 package.json这个包管理配置文件:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作用:在执行命令所处的目录中,快速新建package.json文件</span></span><br><span class="line">npm init -y</span><br></pre></td></tr></table></figure>

<p><strong>注意:①上述命令只能在英文的目录下成功运行!所以,项目文件夹的名称一定要使用英文命名,不要使用中文,不能出现空格。</strong></p>
<p><strong>②运行npm install 命令安装包的时候, npm包管理工具会自动把包的名称和版本号,记录到package.json中。</strong></p>
<p><strong>4. dependencies 节点</strong></p>
<p><strong>package.json文件中,有一个 dependencies 节点,专门用来记录您使用npm install命令安装了哪些包。</strong></p>
<p><strong>5.一次性安装所有的包当我们拿到一个剔除了node_modules的项目之后,需要先把所有的包下载到项目中,才能将项目运行起来。否则会报类似于下面的错误:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于项目运行依赖于moment这个包,如果没有提前安装好这个包,就会报如下的错误:</span></span><br><span class="line"><span class="title class_">Error</span>: <span class="title class_">Cannot</span> find <span class="variable language_">module</span> <span class="string">&#x27;moment&quot;</span></span><br></pre></td></tr></table></figure>



<p><strong>5.一次性安装所有的包</strong></p>
<p><strong>可以运行npm install 命令(或 npm i)一次性安装所有的依赖包:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行npm install 命令时, npm包管理工具会先读取package.json 中的dependencies 节点</span></span><br><span class="line"><span class="comment">//读取到记录的所有依赖包名称和版本号之后,npm包管理工具会把这些包一次性下载到项目中</span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>



<p><strong>6.卸载包</strong></p>
<p><strong>可以运行npm uninstall 命令,来卸载指定的包:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用npm uninstall 具体的包名 来卸载包</span></span><br><span class="line">npm uninstall moment</span><br></pre></td></tr></table></figure>

<p><strong>注意: npm uninstall 命令执行成功后,会把卸载的包,自动从package.json的dependencies中移除掉。</strong></p>
<p><strong>7. devDependencies 节点</strong></p>
<p><strong>如果某些包只在项目开发阶段会用到,在项目上线之后不会用到,则建议把这些包记录到devDependencies节点中。</strong></p>
<p><strong>与之对应的,如果某些包在开发和项目上线之后都需要用到,则建议把这些包记录到dependencies节点中。</strong></p>
<p><strong>您可以使用如下的命令,将包记录到devDependencies节点中:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安装指定的包,并记录到devDependencies 节点中</span></span><br><span class="line">npm i 包名 -D</span><br><span class="line"><span class="comment">//注意:上述命令是简写形式,等价于下面完整的写法:</span></span><br><span class="line">npm install 包名 --save-dev</span><br></pre></td></tr></table></figure>



<p><strong>3.4 解决下包速度慢的问题</strong></p>
<p><strong>1.为什么下包速度慢</strong></p>
<p><strong>在使用npm下包的时候,默认从国外的<a target="_blank" rel="noopener" href="https://registry.npmjs.org/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E4%B8%8B%E8%BD%BD,%E6%AD%A4%E6%97%B6,%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BC%A0%E8%BE%93%E9%9C%80%E8%A6%81%E7%BB%8F%E8%BF%87%E6%BC%AB%E9%95%BF%E7%9A%84%E6%B5%B7%E5%BA%95%E5%85%89%E7%BC%86,%E5%9B%A0%E6%AD%A4%E4%B8%8B%E5%8C%85%E9%80%9F%E5%BA%A6%E4%BC%9A%E5%BE%88%E6%85%A2%E3%80%82">https://registry.npmjs.org/服务器进行下载,此时,网络数据的传输需要经过漫长的海底光缆,因此下包速度会很慢。</a></strong></p>
<p><strong>2.淘宝NPM 镜像服务器</strong></p>
<p><strong>淘宝在国内搭建了一个服务器,专门把国外官方服务器上的包同步到国内的服务器,然后在国内提供下包的服务。从而极大的提高了下包的速度。</strong></p>
<p><strong>扩展:镜像(Mirroring)是一种文件存储形式,一个磁盘上的数据在另一个磁盘上存在一个完全相同的副木即为镜像。</strong></p>
<p><strong>3.切换npm的下包镜像源</strong></p>
<p><strong>下包的镜像源,指的就是下包的服务器地址。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看当前的下包镜像源</span></span><br><span class="line">npm config get registry</span><br><span class="line"><span class="comment">//将下包的镜像源切换为淘宝镜像源</span></span><br><span class="line">npm config set registry=<span class="attr">https</span>:<span class="comment">//registry.npm.taobao.org/</span></span><br><span class="line"><span class="comment">//检查镜像源是否下载成功</span></span><br><span class="line">npm config get registry</span><br></pre></td></tr></table></figure>



<p><strong>4. nrm</strong></p>
<p><strong>为了更方便的切换下包的镜像源,我们可以安装nrm这个小工具,利用nrm提供的终端命令,可以快速查看和切换下包的镜像源。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过npm包管理器,将nrm安装为全局可用的工具</span></span><br><span class="line">npm i nrm -g</span><br><span class="line"><span class="comment">//查看所有可用的镜像源</span></span><br><span class="line">nrm 1s</span><br><span class="line"><span class="comment">//将下包的镜像源切换为taobao镜像</span></span><br><span class="line">nrm use taobao</span><br></pre></td></tr></table></figure>



<h3 id="3-5包的分类"><a href="#3-5包的分类" class="headerlink" title="3.5包的分类"></a><strong>3.5包的分类</strong></h3><p><strong>使用npm包管理工具下载的包,共分为两大类,分别是:·项目包.全局包</strong></p>
<p><strong>项目包又分为两类,分别是:.</strong></p>
<p><strong>开发依赖包(被记录到devDependencies节点中的包,只在开发期间会用到)</strong></p>
<p><strong>核心依赖包(被记录到dependencies节点中的包,在开发期间和项目上线之后都会用到)</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i 包名 -D <span class="comment">//开发依赖包(会被记录到 devDependencies 节点下)&quot;</span></span><br><span class="line">npm i 包名   <span class="comment">//核心依赖包(会被记录到dependencies节点下)</span></span><br></pre></td></tr></table></figure>



<p><strong>2.全局包</strong></p>
<p><strong>在执行npm install 命令时,如果提供了-g参数,则会把包安装为全局包。</strong></p>
<p><strong>全局包会被安装到 C:Usersl用e目录AppDatalRoaming\npmlnode_modules 目录下。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i 包名 -g        <span class="comment">//全局安装指定的包</span></span><br><span class="line">npm uninstall 包名 -g <span class="comment">//载全局安装的包</span></span><br></pre></td></tr></table></figure>

<p><strong>①只有工具性质的包,才有全局安装的必要性。因为它们提供了好用的终端命令。</strong></p>
<p><strong>②判断某个包是否需要全局安装后才能使用,可以参考官方提供的使用说明即可。</strong></p>
<p><strong>3. i5ting_toc</strong></p>
<p><strong>iSting_toc 是一个可以把md文档转为html页面的小工具,使用步骤如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将i5ting_toc安装为全局包</span></span><br><span class="line">npm install -g i5ting_toc</span><br><span class="line"><span class="comment">//调用i5ting_toc,轻松实现md转html的功能</span></span><br><span class="line">i5ting_toc -f 要转换的md文件路径 -o</span><br></pre></td></tr></table></figure>



<p><strong>3.6规范的包结构</strong></p>
<p><strong>在清楚了包的概念、以及如何下载和使用包之后,接下来,我们深入了解一下包的内部结构。</strong></p>
<p><strong>一个规范的包,它的组成结构,必须符合以下3点要求:</strong></p>
<p><strong>①包必须以单独的目录而存在</strong></p>
<p><strong>②包的顶级目录下要必须包含package.json这个包管理配置文件</strong></p>
<p><strong>③ package.json 中必须包含name, version, main这三个属性,分别代表包的名字、版本号、包的入口。</strong></p>
<p><strong>注意:以上3点要求是一个规范的包结构必须遵守的格式,关于更多的约束,可以参考如下网址:</strong></p>
<p><strong><a target="_blank" rel="noopener" href="https://yarnpkg.com/zh-Hans/docs/package-json">https://yarnpkg.com/zh-Hans/docs/package-json</a></strong></p>
<h3 id="3-7开发属于自己的包"><a href="#3-7开发属于自己的包" class="headerlink" title="3.7开发属于自己的包"></a><strong>3.7开发属于自己的包</strong></h3><p><strong>1.需要实现的功能格式化日期</strong></p>
<p><strong>①格式化日期</strong></p>
<p><strong>2.转义HTML中的特殊字符</strong></p>
<p><strong>③还原HTML中的特殊字符</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.导入自己的包</span></span><br><span class="line"><span class="keyword">const</span> itheima = <span class="built_in">require</span>(<span class="string">&#x27;itehima-utils&#x27;</span>)</span><br><span class="line"><span class="comment">//-功能1:格式化日期…</span></span><br><span class="line"><span class="keyword">const</span> dt = itheima.<span class="title function_">dateFormat</span>(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line"><span class="comment">//输出2020-01-20 10:09:45</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dt)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入自己的包</span></span><br><span class="line"><span class="keyword">const</span> itheima= <span class="built_in">require</span>(<span class="string">&#x27;itehima-utils&#x27;</span>)</span><br><span class="line"><span class="comment">//----功能2:转义HTML中的特殊字符</span></span><br><span class="line"><span class="keyword">const</span> htmlStr = <span class="string">&#x27;&lt;h1 style=&quot;color: red; &quot;&gt;你好! &amp;copy; &lt;span&gt;小黄! &lt;/span&gt;&lt;/h1&gt;&#x27;</span></span><br><span class="line"><span class="keyword">const</span> str= itheima.<span class="title function_">htmlEscape</span>(htmlStr)</span><br><span class="line"><span class="comment">// &amp;lt;h1 style=&amp;quot; color: red; &amp;quot;&amp;gt:你好! &amp;amp; copy: &amp;lt; span&amp;gt;小黄! &amp;lt;/span&amp;gt; &amp;lt;/h1&amp;gt;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入自己的包</span></span><br><span class="line"><span class="keyword">const</span> itheima = <span class="built_in">require</span>(<span class="string">&#x27;itehima-utils&#x27;</span>)</span><br><span class="line"><span class="comment">//功能3:还原HTML中的特殊字符</span></span><br><span class="line"><span class="keyword">const</span> rawHTML = itheima.<span class="title function_">htmlUnEscape</span>(str)</span><br><span class="line"><span class="comment">//输出&lt;h1 style=&quot;color: red; &quot;&gt;你好! &amp;copy;&lt;span&gt;小黄! &lt;/span&gt;&lt;/h1&gt;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rawHTML)</span><br></pre></td></tr></table></figure>



<h3 id="3-7-开发属于自己的包"><a href="#3-7-开发属于自己的包" class="headerlink" title="3.7 开发属于自己的包"></a><strong>3.7 开发属于自己的包</strong></h3><p><strong>2.初始化包的基本结构</strong></p>
<p><strong>①新建itheima-tools文件夹,作为包的根目录</strong></p>
<p><strong>②在itheima-tools文件夹中,新建如下三个文件:</strong></p>
<p><strong>package.json (包管理配置文件)</strong></p>
<p><strong>index.js (包的入口文件)</strong></p>
<p><strong>README.md (包的说明文档)</strong></p>
<p><strong>3. 初始化 package.json</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;itheima-tools&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;提供了格式化时间, HTMLEscape的功能&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;keywords&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;itheima&quot;</span><span class="punctuation">,</span> <span class="string">&quot;dateFormat&quot;</span><span class="punctuation">,</span> <span class="string">&quot;escape&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>关于更多license许可协议相关的内容,可参考<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/86251523e898">https://www.jianshu.com/p/86251523e898</a></strong></p>
<p><strong>4. 在index.js中定义格式化时间的方法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式化时间的方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dateFormat</span> (dateStr) &#123; <span class="comment">/*省略其余代码*/</span> &#125;</span><br><span class="line"> <span class="comment">//补零的方法</span></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">padZero</span>(<span class="params">n</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> n &gt; <span class="number">9</span> ? n : <span class="string">&#x27;0&#x27;</span> +n</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="variable language_">module</span>.<span class="property">exports</span> =&#123;</span><br><span class="line">     dateFormat</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 在index.js中定义转义HTML的方法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">htmlEscape</span>(<span class="params">htmlStr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> htmlStr.<span class="title function_">replace</span>(<span class="regexp">/&lt;|&gt;|&quot;|&amp;/g</span>, <span class="function">(<span class="params">match</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (match) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&amp;lt;&#x27;</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&amp;gt;&#x27;</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&amp;quot;&#x27;</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&amp;amp;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>6. 在index.js中定义还原HTML的方法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">htmlUnEscape</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">replace</span>(<span class="regexp">/&amp;lt;|&amp;gt;|&amp;quot;|&amp;amp;/g</span>, <span class="function">(<span class="params">math</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (math) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&amp;lt;&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&amp;gt;&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&amp;quot;&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&amp;amp;&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&amp;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>7.将不同的功能进行模块化拆分</strong></p>
<p><strong>① 将格式化时间的功能,拆分到src-&gt;dateFormat.js中</strong></p>
<p><strong>②将处理HTML字符串的功能,拆分到src-&gt; htmlEscape.js中</strong></p>
<p><strong>③在index.js中,导入两个模块,得到需要向外共享的方法</strong></p>
<p><strong>④在index.js 中,使用module.exports把对应的方法共享出去</strong></p>
<p><strong>8.编写包的说明文档</strong></p>
<p><strong>包根目录中的README.md文件,是包的使用说明文档。通过它,我们可以事先把包的使用说明,以markdown的格式写出来,方便用户参考。</strong></p>
<p><strong>README文件中具体写什么内容,没有强制性的要求;只要能够清晰地把包的作用、用法、注意事项等描述清楚即可。</strong></p>
<p><strong>我们所创建的这个包的README.md文档中,会包含以下6项内容:安装方式、导入方式、格式化时间、转义HTML中的特殊字符、还原HTML中的特殊字符、开源协议</strong></p>
<h3 id="3-8-发布包"><a href="#3-8-发布包" class="headerlink" title="3.8 发布包"></a><strong>3.8 发布包</strong></h3><p><strong>1.注册npm账号</strong></p>
<p><strong>①访问<a target="_blank" rel="noopener" href="https://www.npmjs.com/%E7%BD%91%E7%AB%99,%E7%82%B9%E5%87%BBsign">https://www.npmjs.com/网站,点击sign</a> up按钮,进入注册用户界面</strong></p>
<p><strong>②填写账号相关的信息: Full Name, Public Email, Username, Password</strong></p>
<p><strong>③点击Create an Account按钮,注册账号</strong></p>
<p><strong>2.登录npm账号</strong></p>
<p><strong>npm账号注册完成后,可以在终端中执行npm login命令,依次输入用户名、密码、邮箱后,即可登录成功。</strong></p>
<p><strong>3.把包发布到npm上</strong></p>
<p><strong>将终端切换到包的根目录之后,运行npm publish命令,即可将包发布到npm上(注意:包名不能雷同)。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">C</span>: <span class="title class_">Userslliulongbin</span>(<span class="title class_">Desktoplitheima</span>-utilsl)npm publish</span><br></pre></td></tr></table></figure>

<p><strong>4.删除已发布的包</strong></p>
<p><strong>运行npm unpublish 包名–force 命令,即可从npm删除已发布的包。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">C</span>:\<span class="title class_">Users</span>\liulongbin\<span class="title class_">Desktop</span>\itheima-utilsl&gt;npm unpublish itheima-utils --force</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<p><strong>① npm unpublish 命令只能删除72 小时以内发布的包</strong></p>
<p><strong>② npm unpublish 删除的包,在24 小时内不允许重复发布</strong></p>
<p><strong>③发布包的时候要慎重,尽量不要往npm上发布没有意义的包</strong></p>
<h1 id="4-模块的加载机制"><a href="#4-模块的加载机制" class="headerlink" title="4.模块的加载机制"></a><strong>4.模块的加载机制</strong></h1><h2 id="4-1优先从缓存中加载"><a href="#4-1优先从缓存中加载" class="headerlink" title="4.1优先从缓存中加载"></a><strong>4.1优先从缓存中加载</strong></h2><p><strong>模块在第一次加载后会被缓存。这也意味着多次调用require0不会导致模块的代码被执行多次。</strong></p>
<p><strong>注意:不论是内置模块、用户自定义模块、还是第三方模块,它们都会优先从缓存中加载,从而提高模块的加载效率。</strong></p>
<h2 id="4-2内置模块的加载机制"><a href="#4-2内置模块的加载机制" class="headerlink" title="4.2内置模块的加载机制"></a><strong>4.2内置模块的加载机制</strong></h2><p><strong>内置模块是由Node.js官方提供的模块,内置模块的加载优先级最高。</strong></p>
<p><strong>例如, require(‘fs’)始终返回内置的fs模块,即使在node_modules目录下有名字相同的包也叫做fs。</strong></p>
<h2 id="4-3-自定义模块的加载机制"><a href="#4-3-自定义模块的加载机制" class="headerlink" title="4.3 自定义模块的加载机制"></a><strong>4.3 自定义模块的加载机制</strong></h2><p><strong>使用require0加载自定义模块时,必须指定以.&#x2F;或..&#x2F;开头的路径标识符。在加载自定义模块时,如果没有指定&#x2F;或..&#x2F;这样的路径标识符,则node会把它当作内置模块或第三方模块进行加载。</strong></p>
<p><strong>同时,在使用requireO导入自定义模块时,如果省略了文件的扩展名,则Node.js会按顺序分别尝试加载以下的文件:</strong></p>
<p><strong>①按照确切的文件名进行加载</strong></p>
<p><strong>②补全.js扩展名进行加载</strong></p>
<p><strong>③补全.json扩展名进行加载</strong></p>
<p><strong>④补全.node扩展名进行加载</strong></p>
<p><strong>⑤加载失败,终端报错</strong></p>
<p><strong>4.4 第三方模块的加载机制</strong></p>
<p><strong>如果传递给require0的模块标识符不是一个内置模块,也没有以’&#x2F;‘或’.&#x2F;开头,则Node.js会从当前模块的父目录开始,尝试从&#x2F;node_modules文件夹中加载第三方模块。</strong></p>
<p><strong>例如,假设在’C:AUserslitheimalprojectlfoos’文件里调用了require(‘tools’),则Node.js会按以下顺序查找:</strong></p>
<p>**①CAUserslitheimalprojectlnode_modulesltgols **</p>
<p>**② CUserslitheimalnode_modules(tools **</p>
<p><strong>3.CUsersInode modules)tools</strong></p>
<p><strong>④C:Inode modulesltools</strong></p>
<p><strong>4.5目录作为模块</strong></p>
<p><strong>当把目录作为模块标识符,传递给requireO进行加载的时候,有三种加载方式:</strong></p>
<p><strong>①在被加载的目录下查找一个叫做package.json的文件,并寻找main属性,作为require0加载的入口</strong></p>
<p><strong>②如果目录里没有package.json文件,或者main入口不存在或无法解析,则Node.js将会试图加载目录下的index.js文件。</strong></p>
<p><strong>③如果以上两步都失败了,则Node.js 会在终端打印错误消息,报告模块的缺失: Error: Cannot find module ‘xxx’</strong></p>
<h1 id="1-初识Express"><a href="#1-初识Express" class="headerlink" title="1. 初识Express"></a><strong>1. 初识Express</strong></h1><h2 id="1-1-Express-简介"><a href="#1-1-Express-简介" class="headerlink" title="1.1 Express 简介"></a><strong>1.1 Express 简介</strong></h2><p><strong>1. 什么是Express</strong></p>
<p><strong>官方给出的概念:Express是基于Node.js平台,快速、开放、极简的Web开发框架。</strong></p>
<p><strong>通俗的理解: Express的作用和Node.js内置的http模块类似,是专门用来创建Web服务器的。</strong></p>
<p><strong>Express 的本质:就是一个npm上的第三方包,提供了快速创建Web服务器的便捷方法。</strong></p>
<p><strong>Express 中文官网: <a target="_blank" rel="noopener" href="http://www.expressjs.com.cn/">http://www.expressjs.com.cn/</a></strong></p>
<p><strong>2. 进一步理解Express</strong></p>
<p><strong>思考:不使用Express能否创建Web服务器?</strong></p>
<p><strong>答案:能,使用Node.js提供的原生http模块即可。</strong></p>
<p><strong>思考:既生瑜何生亮(有了http内置模块,为什么还有用Express) ?</strong></p>
<p><strong>答案: http内置模块用起来很复杂,开发效率低:Express是基于内置的http模块进一步封装出来的,能够极大的提高开发效率。</strong></p>
<p><strong>思考: http内置模块与Express是什么关系?</strong></p>
<p><strong>答案:类似于浏览器中Web API和jQuery的关系。后者是基于前者进一步封装出来的。</strong></p>
<p><strong>3. Express 能做什么</strong></p>
<p><strong>对于前端程序员来说,最常见的两种服务器,分别是:</strong></p>
<p><strong>Web网站服务器:专门对外提供Web网页资源的服务器。</strong></p>
<p><strong>API接口服务器:专门对外提供API接口的服务器。</strong></p>
<p><strong>使用Express,我们可以方便、快速的创建Web网站的服务器或API接口的服务器。</strong></p>
<h2 id="1-2-Express-的基本使用"><a href="#1-2-Express-的基本使用" class="headerlink" title="1.2 Express 的基本使用"></a><strong>1.2 Express 的基本使用</strong></h2><p><strong>1.安装</strong></p>
<p><strong>在项目所处的目录中,运行如下的终端命令,即可将express安装到项目中使用:</strong></p>
<p><strong>npm i <a href="mailto:&#x65;&#x78;&#112;&#x72;&#x65;&#x73;&#x73;&#64;&#52;&#46;&#x31;&#55;&#46;&#x31;">&#x65;&#x78;&#112;&#x72;&#x65;&#x73;&#x73;&#64;&#52;&#46;&#x31;&#55;&#46;&#x31;</a></strong></p>
<p><strong>2.创建基本的Web服务器</strong></p>
<p><strong>1. 导入 express</strong></p>
<p><strong>const express &#x3D;”require(‘express’)</strong></p>
<p><strong>&#x2F;&#x2F; 2.创建web服务器</strong></p>
<p><strong>const app &#x3D; express()</strong></p>
<p><strong>&#x2F;&#x2F; 3.调用app.listen(端口号,启动成功后的回调函数),启动服务器</strong></p>
<p><strong>app.listen(80, () &#x3D;&gt; {</strong></p>
<p><strong>console.log(‘express server running at <a target="_blank" rel="noopener" href="http://127.0.0.1/">http://127.0.0.1</a>‘)</strong></p>
<p><strong>})</strong></p>
<p><strong>3.监听GET请求</strong></p>
<p><strong>通过app.geto方法,可以监听客户端的GET请求,具体的语法格式如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数1:客户端请求的URL地址</span></span><br><span class="line"><span class="comment">//参数2:请求对应的处理函数</span></span><br><span class="line"><span class="comment">//req:请求对象(包含了与请求相关的属性与方法)</span></span><br><span class="line"><span class="comment">//res:响应对象(包含了与响应相关的属性与方法)</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;请求URL&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;<span class="comment">/*处理数*/</span> &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>4.监听POST 请求</strong></p>
<p><strong>通过app.post0方法,可以监听客户端的POST请求,具体的语法格式如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数1:客户端请求的URL地址</span></span><br><span class="line"><span class="comment">//参数2:请求对应的处理函数</span></span><br><span class="line"><span class="comment">//req:请求对象(包含了与请求相关的属性与方法)</span></span><br><span class="line"><span class="comment">//res:响应对象(包含了与响应相关的属性与方法)</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;请求URL&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;<span class="comment">/*处理数*/</span> &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>5.把内容响应给客户端</strong></p>
<p><strong>通过res.send(0)方法,可以把处理好的内容,发送给客户端:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/user&#x27;</span>. (req, res) =&gt; &#123;</span><br><span class="line"> <span class="comment">//向客户端发送JSON对象</span></span><br><span class="line">    res.<span class="title function_">send</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span>, <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span> &#125;)</span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/user&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">//向客户端发送文本内容</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;请求成功&#x27;)</span></span><br><span class="line"><span class="string">   &#125;)</span></span><br></pre></td></tr></table></figure>

<p><strong>6.获取URL中携带的查询参数</strong></p>
<p><strong>通过req.query对象,可以访问到客户端通过查询字符串的形式,发送到服务器的参数:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// req.query 默认是一个空对象</span></span><br><span class="line">   <span class="comment">// 客户端使用?name=zs&amp;age=20 这种查询字符串形式,发送到服务器的参数</span></span><br><span class="line">   <span class="comment">//可以通过req.query对象访问到,例如:</span></span><br><span class="line">   <span class="comment">//req.query.name req.query.age</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">query</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p><strong>7.获取URL中的动态参数</strong></p>
<p><strong>通过req.params对象,可以访问到URL中,通过:匹配到的动态参数:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// URL地址中,可以通过:参数名的形式,匹配动态参数值</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27; /user/:id&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// req.params 默认是一个空对象</span></span><br><span class="line">    <span class="comment">//里面存放着通过:动态匹配到的参数值</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">params</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="1-3托管静态资源"><a href="#1-3托管静态资源" class="headerlink" title="1.3托管静态资源"></a><strong>1.3托管静态资源</strong></h2><p><strong>1. express.static()</strong></p>
<p><strong>express提供了一个非常好用的函数,叫做express.static0,通过它,我们可以非常方便地创建一个静态资源服务器,</strong></p>
<p><strong>例如,通过如下代码就可以将public目录下的图片、CSS文件、JavaScript文件对外开放访问了:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;public&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>现在,你就可以访问public目录中的所有文件了:</strong></p>
<p><strong><a target="_blank" rel="noopener" href="http://localhost:3000/images/bg.jpg">http://localhost:3000/images/bg.jpg</a></strong></p>
<p><strong><a target="_blank" rel="noopener" href="http://localhost:3000/css/style.css">http://localhost:3000/css/style.css</a></strong></p>
<p><strong><a target="_blank" rel="noopener" href="http://localhost:3000/js/login.js">http://localhost:3000/js/login.js</a></strong></p>
<p><strong>注意: Express在指定的静态目录中查找文件,并对外提供资源的访问路径。因此,存放静态文件的目录名不会出现在URL中。</strong></p>
<p><strong>2.托管多个静态资源目录</strong></p>
<p><strong>如果要托管多个静态资源目录,请多次调用express.static0函数:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;public&#x27;</span>))</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;files&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>访问静态资源文件时, express.static0函数会根据目录的添加顺序查找所需的文件。</strong></p>
<p><strong>3.挂载路径前缀</strong></p>
<p><strong>如果希望在托管的静态资源访问路径之前,挂载路径前缀,则可以使用如下的方式:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/public&#x27;</span>, express.<span class="title function_">static</span>(<span class="string">&#x27;public&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>现在,你就可以通过带有&#x2F;public前缀地址来访问public目录中的文件了:</strong></p>
<p>**<a target="_blank" rel="noopener" href="http://localhost:3000/public/images/kitten.jpg">http://localhost:3000/public/images/kitten.jpg</a> **</p>
<p><strong><a target="_blank" rel="noopener" href="http://localhost:3000/public/css/style.css">http://localhost:3000/public/css/style.css</a></strong></p>
<p><strong><a target="_blank" rel="noopener" href="http://localhost:3000/public/js/app.js">http://localhost:3000/public/js/app.js</a></strong></p>
<p><strong>1.4 nodemon</strong></p>
<p><strong>1.为什么要使用nodemon</strong></p>
<p><strong>在编写调试 Node.js项目的时候,如果修改了项目的代码,则需要频繁的手动close掉,然后再重新启动,非常繁琐。</strong></p>
<p><strong>现在,我们可以使用nodemon (<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/nodemon)%E8%BF%99%E4%B8%AA%E5%B7%A5%E5%85%B7,%E5%AE%83%E8%83%BD%E5%A4%9F%E7%9B%91%E5%90%AC%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8F%98%E5%8A%A8,%E5%BD%93%E4%BB%A3%E7%A0%81%E8%A2%AB%E4%BF%AE%E6%94%B9%E5%90%8E,nodemon%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%B8%AE%E6%88%91%E4%BB%AC%E9%87%8D%E5%90%AF%E9%A1%B9%E7%9B%AE,%E6%9E%81%E5%A4%A7%E6%96%B9%E4%BE%BF%E4%BA%86%E5%BC%80%E5%8F%91%E5%92%8C%E8%B0%83%E8%AF%95%E3%80%82">https://www.npmjs.com/package/nodemon)这个工具,它能够监听项目文件的变动,当代码被修改后,nodemon会自动帮我们重启项目,极大方便了开发和调试。</a></strong></p>
<p><strong>2. 安装 nodemon在终端中,运行如下命令,即可将nodemon安装为全局可用的工具:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g nodemon</span><br></pre></td></tr></table></figure>

<p> <strong>管理员power开启权限set-ExecutionPolicy RemoteSigned</strong></p>
<p><strong>3. 使用nodemon</strong></p>
<p><strong>当基于Node.js编写了一个网站应用的时候,传统的方式,是运行node app.js命令,来启动项目。这样做的坏处是:代码被修改之后,需要手动重启项目。</strong></p>
<p><strong>现在,我们可以将node命令替换为nodemon命令,使用nodemon app.js来启动项目。这样做的好处是:代码被修改之后,会被nodemon监听到,从而实现自动重启项目的效果。</strong></p>
<h1 id="2-Express-路由"><a href="#2-Express-路由" class="headerlink" title="2. Express 路由"></a><strong>2. Express 路由</strong></h1><h2 id="2-1路由的概念"><a href="#2-1路由的概念" class="headerlink" title="2.1路由的概念"></a><strong>2.1路由的概念</strong></h2><p><strong>2.现实生活中的路由</strong></p>
<p><strong>在这里,路由是按键与服务之间的映射关系</strong></p>
<p><strong>3. Express 中的路由</strong></p>
<p><strong>在Express中,路由指的是客户端的请求与服务器处理函数之间的映射关系。</strong></p>
<p><strong>Express中的路由分3部分组成,分别是请求的类型、请求的URL地址、处理函数,格式如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">METHOD</span>(<span class="variable constant_">PATH</span>, <span class="variable constant_">HANDLER</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4.</span> <span class="title class_">Express</span> 中的路由的例子</span><br><span class="line"><span class="comment">//匹配GET请求,且请求URL为/</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line"></span><br><span class="line"> res.<span class="title function_">send</span>( <span class="string">&#x27;Hello World!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配POST请求,且请求URL为/</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line"></span><br><span class="line"> res. <span class="title function_">send</span>(<span class="string">&#x27;Got a POST request&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p><strong>5.路由的匹配过程</strong></p>
<p><strong>每当一个请求到达服务器之后,需要先经过路由的匹配,只有匹配成功之后,才会调用对应的处理函数。</strong></p>
<p><strong>在匹配时,会按照路由的顺序进行匹配,如果请求类型和请求的URL同时匹配成功,则Express会将这次请求,转交给对应的function函数进行处理。</strong></p>
<p><strong>路由匹配的注意点:</strong></p>
<p><strong>①按照定义的先后顺序进行匹配</strong></p>
<p><strong>②请求类型和请求的URL同时匹配成功,才会调用对应的处理函数</strong></p>
<h2 id="2-2路由的使用"><a href="#2-2路由的使用" class="headerlink" title="2.2路由的使用"></a><strong>2.2路由的使用</strong></h2><p><strong>1.最简单的用法在Express中使用路由最简单的方式,就是把路由挂载到app上,示例代码如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="comment">//创建Web服务器,命名为app</span></span><br><span class="line"><span class="keyword">const</span> app=<span class="title function_">express</span>()</span><br><span class="line"><span class="comment">//挂载路由</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;res,<span class="title function_">send</span>(<span class="string">&#x27;Hello World. &#x27;</span>) &#125;) app.<span class="title function_">post</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span>&#123; res. <span class="title function_">send</span>( <span class="string">&#x27;Post Request. &#x27;</span>)&#125;)</span><br><span class="line"><span class="comment">//启动Web服务器</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server running at http://127.0.0.1&#x27;</span>) &#125;)</span><br></pre></td></tr></table></figure>



<p><strong>2.模块化路由</strong></p>
<p><strong>为了方便对路由进行模块化的管理, Express不建议将路由直接挂载到app上,而是推荐将路由抽离为单独的模块。将路由抽离为单独模块的步骤如下:</strong></p>
<p><strong>① 创建路由模块对应的.js文件</strong></p>
<p><strong>②调用express.Router()函数创建路由对象</strong></p>
<p><strong>③向路由对象上挂载具体的路由</strong></p>
<p><strong>④使用module.exports 向外共享路由对象</strong></p>
<p><strong>⑤使用app.use0函数注册路由模块</strong></p>
<h2 id="3-创建路由模块"><a href="#3-创建路由模块" class="headerlink" title="3.创建路由模块"></a><strong>3.创建路由模块</strong></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> router = express. <span class="title class_">Router</span>()</span><br><span class="line"><span class="comment">// 1. 导入 express</span></span><br><span class="line"><span class="comment">//2.创建路由对象</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/user/list&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line"> <span class="comment">//3,挂载获取用户列表的路由</span></span><br><span class="line">   res.<span class="title function_">send</span>(<span class="string">&#x27;Get user list.&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/user/add&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="comment">// 4.挂载添加用户的路由</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;Add new user.&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router  <span class="comment">//5.向外导出路由对象</span></span><br></pre></td></tr></table></figure>

<p><strong>4.注册路由模块</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入路由模块</span></span><br><span class="line"><span class="keyword">const</span> userRouter = <span class="built_in">require</span>(<span class="string">&#x27;./router/user.js&#x27;</span>)</span><br><span class="line"><span class="comment">//2.使用app.use()注册路由模块</span></span><br><span class="line">app.<span class="title function_">use</span>(userRouter)</span><br></pre></td></tr></table></figure>

<p><strong>5.为路由模块添加前缀类似于托管静态资源时,为静态资源统一挂载访问前缀一样,路由模块添加前缀的方式也非常简单:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入路由模块</span></span><br><span class="line"><span class="keyword">const</span> userRouter = <span class="built_in">require</span>(<span class="string">&#x27;./router/user.js&#x27;</span>)</span><br><span class="line"><span class="comment">// 2.使用app.use()注册路由模块,并添加统一的访问前缀/api</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/api&#x27;</span>, userRouter)</span><br></pre></td></tr></table></figure>



<h1 id="3-Express-中间件"><a href="#3-Express-中间件" class="headerlink" title="3. Express 中间件"></a><strong>3. Express 中间件</strong></h1><h2 id="3-1中间件的概念"><a href="#3-1中间件的概念" class="headerlink" title="3.1中间件的概念"></a><strong>3.1中间件的概念</strong></h2><p><strong>1.什么是中间件</strong></p>
<p><strong>中间件(Middleware),特指业务流程的中间处理环节。</strong></p>
<p><strong>2.现实生活中的例子</strong></p>
<p><strong>在处理污水的时候,一般都要经过三个处理环节,从而保证处理过后的废水,达到排放标准。</strong></p>
<p><strong>处理污水的这三个中间处理环节,就可以叫做中间件。</strong></p>
<p><strong>3. Express 中间件的调用流程当一个请求到达Express的服务器之后,可以连续调用多个中间件,从而对这次请求进行预处理。</strong></p>
<p><strong>4. Express 中间件的格式Express的中间件,本质上就是一个function处理函数, Express中间件的格式如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express= <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = <span class="title function_">express</span>();</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res, next</span>)&#123;</span><br><span class="line">   <span class="title function_">next</span>();</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p><strong>注意:中间件函数的形参列表中,必须包含next参数。而路由处理函数中只包含req和res。</strong></p>
<p><strong>5. next 函数的作用next函数是实现多个中间件连续调用的关键,它表示把流转关系转交给下一个中间件或路由。</strong></p>
<h2 id="3-2-Express-中间件的初体验"><a href="#3-2-Express-中间件的初体验" class="headerlink" title="3.2 Express 中间件的初体验"></a><strong>3.2 Express 中间件的初体验</strong></h2><p><strong>1.定义中间件函数</strong></p>
<p><strong>可以通过如下的方式,定义一个最简单的中间件函数:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量mw所指向的,就是一个中间件函数</span></span><br><span class="line"><span class="keyword">const</span> mw= <span class="keyword">function</span> (<span class="params">req, res, next</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是一个最简单的中间件&#x27;</span>)</span><br><span class="line"><span class="comment">//注意:在当前中间件的业务处理完毕后,必须调用next()函数</span></span><br><span class="line"> <span class="comment">//表示把流转关系转交给下一个中间件或路由</span></span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.全局生效的中间件</strong></p>
<p><strong>客户端发起的任何请求,到达服务器之后,都会触发的中间件,叫做全局生效的中间件。</strong></p>
<p><strong>通过调用app.use(中间件函数),即可定义一个全局生效的中间件,示例代码如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量mw所指向的,就是一个中间件函数</span></span><br><span class="line"><span class="keyword">const</span> mw= <span class="keyword">function</span> (<span class="params">reg, res, next</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是一个最简单的中间件函数&quot;</span>)</span><br><span class="line">    next ()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//全局生效的中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(mw)</span><br></pre></td></tr></table></figure>

<p><strong>3.定义全局中间件的简化形式</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局生效的中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(furction (req, res, next)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是一个最简单的中间件函数&#x27;</span>)</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>4.中间件的作用</strong></p>
<p><strong>多个中间件之间,共享同一份req和res。基于这样的特性,我们可以在上游的中间件中,统一为req 或 res对象添加自定义的属性或方法,供下游的中间件或路由进行使用。</strong></p>
<p><strong>5.定义多个全局中间件</strong></p>
<p><strong>可以使用app.use()连续定义多个全局中间件。客户端请求到达服务器之后,会按照中间件定义的先后顺序依次进行调用,示例代码如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span>(<span class="params">req, res, next</span>) &#123;<span class="comment">// 第1个全局中间件</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;调用了第1个全局中间件&#x27;)</span></span><br><span class="line"><span class="string">    next()</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">app.use(function(req, res, next) &#123;</span></span><br><span class="line"><span class="string">    //1 第2个全局中间件</span></span><br><span class="line"><span class="string">    console.log(&quot;</span>调用了第<span class="number">2</span>个全局中间件<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">    next()</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">app.get(&#x27;</span>/user<span class="string">&#x27;, (req, res) =&gt;&#123;</span></span><br><span class="line"><span class="string">    //请求这个路由,会依次触发上述两个全局中间件</span></span><br><span class="line"><span class="string">    res.send(&#x27;</span><span class="title class_">Hone</span> page.<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure>

<p><strong>6.局部生效的中间件</strong></p>
<p><strong>不使用app.use0定义的中间件,叫做局部生效的中间件,示例代码如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义中间件图数mw</span></span><br><span class="line"><span class="keyword">const</span> mw1 <span class="keyword">function</span>(<span class="params">req, res, next</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是中间件函数&#x27;)</span></span><br><span class="line"><span class="string">     next()</span></span><br><span class="line"><span class="string">// mw1这个中间件只在&quot;</span>当前路由中生效”,这种用法属于<span class="string">&quot;局部生效的中间件&quot;</span></span><br><span class="line">  app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, mw1, <span class="keyword">function</span>(<span class="params">req, res</span>)&#123;</span><br><span class="line">      res.<span class="title function_">send</span>(<span class="string">&#x27;Home page.&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">// mw1这个中间件不会影响下面这个路由</span></span><br><span class="line">  app.<span class="title function_">get</span>(<span class="string">&#x27;/user&#x27;</span>, <span class="keyword">function</span>(<span class="params">req. res</span>) &#123;</span><br><span class="line">       res.<span class="title function_">send</span>( <span class="string">&#x27;User page. &#x27;</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>7.定义多个局部中间件</strong></p>
<p><strong>可以在路由中,通过如下两种等价的方式,使用多个局部中间件:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下两种写法是&quot;完全等价&quot;的,可根据自己的喜好,选择任意一种方式进行使用</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, mw1, <span class="title function_">mw2</span>(req, res) =&gt; &#123;</span><br><span class="line">    res.<span class="title function_">send</span>( <span class="string">&#x27;Home page. &#x27;</span>) &#125;)</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>. [mw1, mw2], <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;Home page.&#x27;</span>) &#125;)</span><br></pre></td></tr></table></figure>



<p><strong>8.了解中间件的5个使用注意事项</strong></p>
<p><strong>一定要在路由之前注册中间件</strong></p>
<p><strong>客户端发送过来的请求,可以连续调用多个中间件进行处理</strong></p>
<p><strong>执行完中间件的业务代码之后,不要忘记调用next()函数</strong></p>
<p><strong>为了防止代码逻辑混乱,调用next0函数后不要再写额外的代码</strong></p>
<p><strong>连续调用多个中间件时,多个中间件之间,共享req和res对象</strong></p>
<p><strong>3.3中间件的分类</strong></p>
<p><strong>为了方便大家理解和记忆中间件的使用,Expres把常见的中间件用法,分成了5大类,分别是:</strong></p>
<p><strong>①应用级别的中间件</strong></p>
<p><strong>2.路由级别的中间件</strong></p>
<p><strong>③错误级别的中间件</strong></p>
<p><strong>4.Express 内置的中间件</strong></p>
<p><strong>5.第三方的中间件</strong></p>
<h2 id="3-3中间件的分类"><a href="#3-3中间件的分类" class="headerlink" title="3.3中间件的分类"></a><strong>3.3中间件的分类</strong></h2><p><strong>1.应用级别的中间件</strong></p>
<p><strong>通过app.use()或 app.get()或 app.post().绑定到app实例上的中间件,叫做应用级别的中间件,代码示例如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//应用级别的中间件(全局中间件)</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">reg, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//应用级别的中间件(局部中间件)</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, mw, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;Home page.&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>2.路由级别的中间件</strong></p>
<p><strong>绑定到express.Router0实例上的中间件,叫做路由级别的中间件。它的用法和应用级别中间件没有任何区别。只不过,应用级别中间件是绑定到app实例上,路由级别中间件绑定到router实例上,代码示例如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app=<span class="title function_">express</span>()</span><br><span class="line"><span class="keyword">var</span> router =express.<span class="title class_">Router</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//路由级别的中间件</span></span><br><span class="line">router.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">req, res, next</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Time:&#x27;</span>, <span class="title class_">Date</span>.<span class="title function_">now</span>())</span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/&#x27;</span>, router)</span><br></pre></td></tr></table></figure>



<p><strong>3.错误级别的中间件</strong></p>
<p><strong>错误级别中间件的作用:专门用来捕获整个项目中发生的异常错误,从而防止项目异常崩溃的问题。</strong></p>
<p><strong>格式:错误级别中间件的function处理函数中,必须有4个形参,形参顺序从前到后,分别是(err, req, res, next)</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 路由</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;服务器内部发生了错误! &#x27;</span>) <span class="comment">// 1.1抛出一个自定义的错误</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;Home Page. &#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">err, req, res, next</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.错误级别的中间件</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发生了错误:&#x27;</span>+ err.<span class="property">message</span>)<span class="comment">// 2.1 在服务器打印错误消息</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;Error! &#x27;</span>+ err.<span class="property">message</span>)<span class="comment">//2.2 向客户端响应错误相关的内容</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>注意:错误级别的中间件,必须注册在所有路由之后!</strong></p>
<p><strong>4. Express内置的中间件</strong></p>
<p><strong>自Express 4.16.0 版本开始, Express内置了3个常用的中间件,极大的提高了Express项目的开发效率和体验:</strong></p>
<p><strong>express.static快速托管静态资源的内置中间件,例如: HTML文件、图片、CSS样式等(无兼容性)</strong></p>
<p><strong>express.json 解析 JSON 格式的请求体数据(有兼容性,仅在4.16.0+版本中可用)</strong></p>
<p><strong>express.urlencoded 解析 URL-encoded 格式的请求体数据(有兼容性,仅在4.16.0+版本中可用)</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置解析 application/json格式数据的内置中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>())</span><br><span class="line"><span class="comment">//配置解析 application/x-www-form-urlencoded格式数据的内置中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;))</span><br></pre></td></tr></table></figure>

<p><strong>5.第三方的中间件</strong></p>
<p><strong>非Express官方内置的,而是由第三方开发出来的中间件,叫做第三方中间件。在项目中,大家可以按需下载并配置第三方中间件,从而提高项目的开发效率。</strong></p>
<p><strong>例如:在<a href="mailto:&#x65;&#120;&#112;&#114;&#x65;&#x73;&#x73;&#64;&#52;&#x2e;&#x31;&#54;&#x2e;&#x30;">&#x65;&#120;&#112;&#114;&#x65;&#x73;&#x73;&#64;&#52;&#x2e;&#x31;&#54;&#x2e;&#x30;</a> 之前的版本中,经常使用body-parser这个第三方中间件,来解析请求体数据。使用步骤如下:</strong></p>
<p><strong>① 运行npm install body-parser安装中间件</strong></p>
<p><strong>②使用require导入中间件</strong></p>
<p><strong>③调用app.use()注册并使用中间件</strong></p>
<p><strong>注意: Express内置的express.urlencoded 中间件,就是基于body-parser这个第三方中间件进一步封装出来的。</strong></p>
<h2 id="3-4-自定义中间件"><a href="#3-4-自定义中间件" class="headerlink" title="3.4 自定义中间件"></a><strong>3.4 自定义中间件</strong></h2><p><strong>1.需求描述与实现步骤</strong></p>
<p><strong>自己手动模拟一个类似于express.urlencoded这样的中间件,来解析POST提交到服务器的表单数据。</strong></p>
<p><strong>实现步骤:</strong></p>
<p><strong>①定义中间件</strong></p>
<p><strong>②监听req 的data事件</strong></p>
<p><strong>3.监听 req的end 事件</strong></p>
<p><strong>④使用querystring模块解析请求体数据</strong></p>
<p><strong>5. 将解析出来的数据对象挂载为req.body</strong></p>
<p><strong>6将自定义中间件封装为模块</strong></p>
<p><strong>2.定义中间件</strong></p>
<p><strong>使用app.use()来定义全局生效的中间件,代码如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span>(<span class="params">req, res, next</span>)&#123;</span><br><span class="line">    <span class="comment">//中间件的业务逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>3.监听req 的data 事件</strong></p>
<p><strong>在中间件中,需要监听req对象的data事件,来获取客户端发送到服务器的数据。</strong></p>
<p><strong>如果数据量比较大,无法一次性发送完毕,则客户端会把数据切割后,分批发送到服务器。所以data事件可能会触发多次,每一次触发data事件时,获取到数据只是完整数据的一部分,需要手动对接收到的数据进行拼接。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义变量,用来存储客户端发送过来的请求体数据</span></span><br><span class="line"><span class="keyword">let</span> str =<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment">//监听req对象的data事件(客户端发送过来的新的请求体数据)</span></span><br><span class="line">req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//拼接请求体数据,险式转换为字符串</span></span><br><span class="line">    str+= chunk</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>4.监听 req 的end事件</strong></p>
<p><strong>当请求体数据接收完毕之后,会自动触发req的end事件。</strong></p>
<p><strong>因此,我们可以在req的end事件中,拿到并处理完整的请求体数据。示例代码如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//监听req对象的end事件(请求体发送完毕后自动触发)</span></span><br><span class="line">req.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//打印完整的请求体数据</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(str)</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>把字符串格式的请求体数据,解析成对象格式</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>5.使用querystring模块解析请求体数据</strong></p>
<p><strong>Node.js 内置了一个 querystring模块,专门用来处理查询字符甲。通过这个模块提供的parse()函数,可以轻松把查询字符串,解析成对象的格式。示例代码如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入处理 querystring的Node.js内置模块</span></span><br><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>)</span><br><span class="line"><span class="comment">//调用qs.parse()方法,把查询字符串解析为对象</span></span><br><span class="line"><span class="keyword">const</span> body = qs.<span class="title function_">parse</span>(str)</span><br></pre></td></tr></table></figure>

<p><strong>6.将解析出来的数据对象挂载为req.body</strong></p>
<p><strong>上游的中间件和下游的中间件及路由之间,共享同一份req 和res。因此,我们可以将解析出来的数据,挂载为req的自定义属性,命名为req.body,供下游使用。示例代码如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">req.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> body = qs.<span class="title function_">parse</span>(str) <span class="comment">//调用qs.parse()方法,把查询字符串解析为对象</span></span><br><span class="line">    req.<span class="property">body</span> = body		  <span class="comment">//将解析出来的请求体对象,挂载为req.body属性</span></span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br><span class="line">    <span class="comment">//最后,一定要调用next()函数,执行后续的业务逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>7.将自定义中间件封装为模块</strong></p>
<p><strong>为了优化代码的结构,我们可以把自定义的中间件函数,封装为独立的模块,示例代码如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// custom-body-parser.js 模块中的代</span></span><br><span class="line"><span class="keyword">const</span> qs=<span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bodyParser</span>(<span class="params">req, res, next</span>) &#123;<span class="comment">/*其它代 *&#125;</span></span><br><span class="line"><span class="comment">module.exports= bodyParser // 向外导出解析请求体数据的中间件通数</span></span><br><span class="line"><span class="comment">-------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//1.导入自定义的中问件模块</span></span><br><span class="line"><span class="comment">const myBodyParser= require(&#x27;custom-body-parser&#x27;)</span></span><br><span class="line"><span class="comment">//2.注册自定义的中间件模块</span></span><br><span class="line"><span class="comment">app.use(myBodyParser)</span></span><br></pre></td></tr></table></figure>



<h1 id="4-使用Express写接口"><a href="#4-使用Express写接口" class="headerlink" title="4.使用Express写接口"></a><strong>4.使用Express写接口</strong></h1><h2 id="4-1创建基本的服务器"><a href="#4-1创建基本的服务器" class="headerlink" title="4.1创建基本的服务器"></a><strong>4.1创建基本的服务器</strong></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 express 模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="comment">//创建 express的服务器实例</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="comment">// write your code here...</span></span><br><span class="line"><span class="comment">//调用app.listen方法,指定端口号并启动web服务器</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Express server running at http://127.0.0.1&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="4-2-创建API-路由模块"><a href="#4-2-创建API-路由模块" class="headerlink" title="4.2 创建API 路由模块"></a><strong>4.2 创建API 路由模块</strong></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// apiRouter.js 【路由模块】</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> apiRouter= express.<span class="title class_">Router</span>()</span><br><span class="line"><span class="comment">// bind your router here...</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = apiRouter</span><br><span class="line">------------------------------------</span><br><span class="line"><span class="comment">// app.js 【导入并注册路由模块】</span></span><br><span class="line"><span class="keyword">const</span> apiRouter = <span class="built_in">require</span>(<span class="string">&#x27;./apiRouter.js&#x27;</span>)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/api&#x27;</span>, apiRouter)</span><br></pre></td></tr></table></figure>

<h2 id="4-3编写GET接口"><a href="#4-3编写GET接口" class="headerlink" title="4.3编写GET接口"></a><strong>4.3编写GET接口</strong></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiRouter.<span class="title function_">get</span>(<span class="string">&#x27;/get&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">//1.获取到客户端通过查询字符串,发送到服务器的数据</span></span><br><span class="line"><span class="keyword">const</span> query= req.<span class="property">query</span></span><br><span class="line"><span class="comment">// 2.调用res.send()方法,把数据响应给客户端</span></span><br><span class="line">res.<span class="title function_">send</span>(&#123;</span><br><span class="line">    <span class="attr">status</span>: <span class="number">0</span>, <span class="comment">//状态,0表示成功,1表示失败</span></span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;GET请求成功! &#x27;</span>, <span class="comment">//状态描述</span></span><br><span class="line">    <span class="attr">data</span>: query   <span class="comment">//需要响应给客户端的具体数据</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="4-4编写POST接口"><a href="#4-4编写POST接口" class="headerlink" title="4.4编写POST接口"></a><strong>4.4编写POST接口</strong></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiRouter.<span class="title function_">post</span>(<span class="string">&#x27;/post&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//1.获取客户端通过请求体,发送到服务器的URL-encoded数据</span></span><br><span class="line">    <span class="keyword">const</span> body = req.<span class="property">body</span></span><br><span class="line">    <span class="comment">// 2.调用res.send()方法,把数据响应给客户端</span></span><br><span class="line">    res.<span class="title function_">send</span>(&#123;</span><br><span class="line">        <span class="attr">status</span>: <span class="number">0</span>,            <span class="comment">//状态,0表示成功,1表示失败</span></span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;POST请求成功! &#x27;</span>, <span class="comment">//状态描述消息</span></span><br><span class="line">        <span class="attr">data</span>: body           <span class="comment">//需要响应给客户端的具体数据</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>注意:如果要获取URL-encoded 格式的请求体数据,必须配置中间件</strong></p>
<p><strong>app.use(express.urlencoded({ extended: false }))</strong></p>
<h2 id="4-5-CORS-跨域资源共享"><a href="#4-5-CORS-跨域资源共享" class="headerlink" title="4.5 CORS 跨域资源共享"></a><strong>4.5 CORS 跨域资源共享</strong></h2><p><strong>1.接口的跨域问题</strong></p>
<p><strong>刚才编写的GET和POST接口,存在一个很严重的问题:不支持跨域请求。</strong></p>
<p><strong>解决接口跨域问题的方案主要有两种:</strong></p>
<p><strong>CORS (主流的解决方案,推荐使用)</strong></p>
<p><strong>JSONP (有缺陷的解决方案:只支持GET请求)</strong></p>
<p><strong>2.使用cors中间件解决跨域问题</strong></p>
<p><strong>cors是Express的一个第三方中间件。通过安装和配置cors中间件,可以很方便地解决跨域问题。</strong></p>
<p><strong>使用步骤分为如下3步:</strong></p>
<p><strong>①运行npm install cors安装中间件</strong></p>
<p><strong>② 使用 const cors &#x3D; require(‘cors’) 导入中间件</strong></p>
<p><strong>③在路由之前调用app.use(cors0)配置中间件</strong></p>
<p><strong>3.什么是 CORS</strong></p>
<p><strong>CORS (Cross-Origin Resource Sharing,跨域资源共享)由一系列HTTP 响应头组成,这些HTTP响应头决定浏览器是否阻止前端JS代码跨域获取资源。</strong></p>
<p><strong>浏览器的同源安全策略默认会阻止网页“跨域”获取资源。但如果接口服务器配置了CORS相关的HTTP 响应头,就可以解除浏览器端的跨域访问限制。</strong></p>
<p><strong>4. CORS 的注意事项</strong></p>
<p><strong>① CORS主要在服务器端进行配置。客户端浏览器无须做任何额外的配置,即可请求开启了CORS的接口。</strong></p>
<p><strong>2.CORS在浏览器中有兼容性。只有支持XMLHttpRequest Level2的浏览器,才能正常访问开启了CORS的服务端接口(例如: IE10+、 Chrome4+, FireFox3.5+) .</strong></p>
<p><strong>5. CORS 响应头部 - Access-Control-Allow-Origin</strong></p>
<p><strong>响应头部中可以携带一个Access-Control-Allow-Origin字段,其语法如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: &lt;origin&gt; | *</span><br></pre></td></tr></table></figure>

<p><strong>其中,origin参数的值指定了允许访问该资源的外域URL</strong></p>
<p><strong>例如,下面的字段值将只允许来自<a target="_blank" rel="noopener" href="http://itcast.cn的请求/">http://itcast.cn的请求</a>:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;http://itcast.cn&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><em><em>如果指定了Access-Control-Allow-Origin字段的值为通配符</em>,表示允许来自任何域的请求,示例代码如下:</em>*</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p><strong>6. CORS 响应头部 - Access-Control-Allow-Headers</strong></p>
<p><strong>默认情况下,CORS 仅支持客户端向服务器发送如下的9个请求头:</strong></p>
<p><strong>Accept, Accept-Language, Content-Language. DPR, Downlink, Save-Data, Viewport-Width, WidthContent-Type (限 text&#x2F;plain, multipart&#x2F;form-data, application&#x2F;x-www-form-urlencoded 三者之一)</strong></p>
<p><strong>如果客户端向服务器发送了额外的请求头信息,则需要在服务器端,通过Access-Control-Allow-Headers对额外的请求头进行声明,否则这次请求会失败!</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 允许客户端额外向服务器发送Content-Type 请求头和X-Custom-Header请求头</span></span><br><span class="line"><span class="comment">//注意:多个请求头之问使用英文的豆号进行分割</span></span><br><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;Content-Type, X-Custom-Header&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p><strong>7. CORS 响应头部 - Access-Control-Allow-Methods</strong></p>
<p><strong>默认情况下, CORS仅支持客户端发起GET, POST, HEAD请求。</strong></p>
<p><strong>如果客户端希望通过PUT、 DELETE等方式请求服务器的资源,则需要在服务器端,通过Access-Control-Alow-Methods来指明实际请求所允许使用的HTTP方法。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只允许POST, GET、 DELETE, HEAD 请求方法</span></span><br><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;POST, GET, DELETE, HEAD&#x27;</span>)</span><br><span class="line"><span class="comment">//允许所有的HTTP 请求方法</span></span><br><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;*&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>8. CORS请求的分类客户端在请求 CORS接口时,根据请求方式和请求头的不同,可以将CORS的请求分为两大类,分别是:</strong></p>
<p><strong>①简单请求</strong></p>
<p><strong>②预检请求</strong></p>
<p><strong>9.简单请求同时满足以下两大条件的请求,就属于简单请求:</strong></p>
<p><strong>1.请求方式: GET, POST, HEAD 三者之一</strong></p>
<p><strong>2.HTTP 头部信息不超过以下几种字段:无自定义头部字段、Accept. Accept-Language, Content-Language, DPR.Downlink, Save-Data, Viewport-Width, Width, Content-Type (只有三个值application&#x2F;x-www-formurlencoded, multipart&#x2F;form-data, text&#x2F;plain)</strong></p>
<p><strong>10.预检请求只要符合以下任何一个条件的请求,都需要进行预检请求:</strong></p>
<p><strong>①请求方式为GET, POST, HEAD 之外的请求Method类型</strong></p>
<p><strong>2.请求头中包含自定义头部字段</strong></p>
<p><strong>③向服务器发送了 application&#x2F;json格式的数据</strong></p>
<p><strong>在浏览器与服务器正式通信之前,浏览器会先发送OPTION请求进行预检,以获知服务器是否允许该实际请求,所以这一次的OPHON 请求称为“预检请求”。服务器成功响应预检请求后,才会发送真正的请求,并且携带真实数据。</strong></p>
<p><strong>11.简单请求和预检请求的区别</strong></p>
<p><strong>简单请求的特点:客户端与服务器之间只会发生一次请求。</strong></p>
<p><strong>预检请求的特点:客户端与服务器之间会发生两次请求, OPTION预检请求成功之后,才会发起真正的请求。</strong></p>
<h2 id="4-6-JSONP-接口"><a href="#4-6-JSONP-接口" class="headerlink" title="4.6 JSONP 接口"></a><strong>4.6 JSONP 接口</strong></h2><p><strong>1.回顾JSONP的概念与特点</strong></p>
<p><strong>概念:浏览器端通过<script>标签的src属性,请求服务器上的数据,同时,服务器返回一个函数的调用。这种请求数据的方式叫做JSONP。</strong></p>
<p><strong>特点:</strong></p>
<p><strong>① JSONP 不属于真正的Ajax请求,因为它没有使用XMLHttpRequest这个对象。</strong></p>
<p><strong>② JSONP仅支持GET请求,不支持POST, PUT, DELETE等请求。</strong></p>
<p><strong>2.创建JSONP接口的注意事项</strong></p>
<p><strong>如果项目中已经配置了CORS跨域资源共享,为了防止冲突,必须在配置CORS 中间件之前声明JSONP的接口。否则USONP接口会被处理成开启了 CORS的接口。示例代码如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优先创建JSONP接口【这个接口不会被处理成CORS接口】</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/api/jsonp&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">//再配置CORS中间件【后续的所有接口,都会被处理成CORS接口】</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cors</span>())</span><br><span class="line"><span class="comment">//这是一个开启了CORS的接口</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/api/get&#x27;</span>. (req, res) =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="4-6-JSONP-接口-1"><a href="#4-6-JSONP-接口-1" class="headerlink" title="4.6 JSONP 接口"></a><strong>4.6 JSONP 接口</strong></h2><p><strong>3.实现JSONP接口的步骤</strong></p>
<p><strong>①获取客户端发送过来的回调函数的名字</strong></p>
<p><strong>② 得到要通过JSONP形式发送给客户端的数据</strong></p>
<p><strong>③根据前两步得到的数据,拼接出一个函数调用的字符串</strong></p>
<p><strong>④把上一步拼接得到的字符串,响应给客户端的<script>标签进行解析执行</strong></p>
<p><strong>4.实现JSONP接口的具体代码</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/api/jsonp&#x27;</span>. (req, res) =&gt;&#123;</span><br><span class="line">   <span class="comment">//1.获取客户端发送过来的回调通数的名字</span></span><br><span class="line">    <span class="keyword">const</span> funcName = req.<span class="property">query</span>.<span class="property">callback</span></span><br><span class="line">   <span class="comment">//2.得到要通过JSONP形式发送给客户端的数据</span></span><br><span class="line">    <span class="keyword">const</span> data = &#123;<span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;</span><br><span class="line">   <span class="comment">//3.根据前两步得到的数据,拼接出一个函数调用的字符串</span></span><br><span class="line">    <span class="keyword">const</span> scriptStr = <span class="string">&#x27;$&#123;funcName&#125;($&#123;JSON.stringify(data)&#125;)&#x27;</span></span><br><span class="line">   <span class="comment">//4.把上一步拼接得到的字符串,响应给客户端的&lt;script&gt;标签进行解析执行</span></span><br><span class="line">    res.<span class="title function_">send</span>(scriptStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>5.在网页中使用jQuery发起JSONP 请求</strong></p>
<p><strong>调用$.ajax()函数,提供JSONP的配置选项,从而发起JSONP请求,示例代码如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#btnJSONP&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;http://127.0.0.1/api/jsonp&#x27;</span>,</span><br><span class="line">        <span class="attr">dataType</span>: <span class="string">&#x27;jsonp&#x27;</span>, <span class="comment">//表示要发起JSONP的请求</span></span><br><span class="line">        <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">res</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>4.在项目中操作MySQL</strong></p>
<p><strong>4.1在项目中操作数据库的步骤</strong></p>
<p><strong>① 安装操作MySQL数据库的第三方模块(mysql)</strong></p>
<p><strong>②通过mysql 模块连接到MySQL数据库</strong></p>
<p><strong>③通过mysql 模块执行SQL语句</strong></p>
<p><strong>1. 安装mysql 模块</strong></p>
<p><strong>mysql 模块是托管于npm上的第三方模块。它提供了在Node.js项目中连接和操作MySQL数据库的能力。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mysql</span><br></pre></td></tr></table></figure>

<p><strong>2.配置mysql 模块在使用mysql 模块操作MySQL数据库之前,必须先对mysql 模块进行必要的配置,主要的配置步骤如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入mysql模块</span></span><br><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql&#x27;</span>)</span><br><span class="line"><span class="comment">// 2.建立与MySQL数据库的连接</span></span><br><span class="line"><span class="keyword">const</span> db = mysql.<span class="title function_">createPool</span>(&#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="comment">//数据库的IP地址</span></span><br><span class="line">    <span class="attr">user</span>: <span class="string">&#x27;root&#x27;</span>,<span class="comment">//登录数据库的账号</span></span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;admin123&#x27;</span>, <span class="comment">// 登录数据库的密码</span></span><br><span class="line">    <span class="attr">database</span>: <span class="string">&#x27;my_db_01&#x27;</span> <span class="comment">//指定要操作哪个数据库</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>3.测试mysql 模块能否正常工作调用db.query0函数,指定要执行的SQL语句,通过回调函数拿到执行的结果:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测mysq1模块能否正常工作</span></span><br><span class="line">db.<span class="title function_">query</span>(<span class="string">&#x27;SELECT 1&#x27;</span>, <span class="function">(<span class="params">err, results</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">   <span class="comment">//只要能打印出[ RowDataPacket &#123;&#x27;1&#x27;: 1&#125; ]的结果,就证明数据库连接正常</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(results)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h1 id="4-在项目中操作MySQL"><a href="#4-在项目中操作MySQL" class="headerlink" title="4.在项目中操作MySQL"></a><strong>4.在项目中操作MySQL</strong></h1><h2 id="4-3-使用mysql-模块操作MySQL数据库"><a href="#4-3-使用mysql-模块操作MySQL数据库" class="headerlink" title="4.3 使用mysql 模块操作MySQL数据库"></a><strong>4.3 使用mysql 模块操作MySQL数据库</strong></h2><p><strong>1.查询数据</strong></p>
<p><strong>查询users表中所有的数据:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询users表中所有的用户数据</span></span><br><span class="line">db.<span class="title function_">query</span>(<span class="string">&#x27;SELECT * FROM users&#x27;</span>, <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">//查询失败</span></span><br><span class="line">   <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">  <span class="comment">//查询成功</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>2.插入数据</strong></p>
<p><strong>向users表中新增数据,其中username 为Spider-Man, ,password 为 pcc321,示例代码如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.要插入到users表中的数据对象</span></span><br><span class="line"><span class="keyword">const</span> user = &#123;<span class="attr">username</span>: <span class="string">&#x27;Spider-Man&#x27;</span>, <span class="attr">password</span>: <span class="string">&#x27;pcc321&#x27;</span> )</span><br><span class="line"><span class="comment">//2.待执行的SQL语句,其中英文的?表示占位符</span></span><br><span class="line"><span class="keyword">const</span> sqlStr = <span class="string">&#x27;INSERT INTO users (username, password) VALUES (?, ?)&#x27;</span></span><br><span class="line"><span class="comment">//3.使用数组的形式,依次为?占位符指定具体的值</span></span><br><span class="line">db.<span class="title function_">query</span>(sqlStr, [user.<span class="property">username</span>, user.<span class="property">password</span>], <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)<span class="comment">//1 失败</span></span><br><span class="line">   <span class="keyword">if</span>(results.<span class="property">affectedRows</span> === <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;插入数据成功&#x27;</span>)&#125;</span><br><span class="line">    <span class="comment">// 成功</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>3.插入数据的便捷方式向表中新增数据时,如果数据对象的每个属性和数据表的字段一-对应,则可以通过如下方式快速插入数据:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.要插入到users 表中的数据对象</span></span><br><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">username</span>: <span class="string">&#x27;Spider-Man2&#x27;</span>, <span class="attr">password</span>: <span class="string">&#x27;pcc4321&#x27;</span>&#125;</span><br><span class="line"><span class="comment">//2.待执行的SQL 语句,其中英文的?表示占位符</span></span><br><span class="line"><span class="keyword">const</span> sqlStr = <span class="string">&#x27;INSERT INTO users SET ?&#x27;</span></span><br><span class="line"><span class="comment">// 3.直接将数据对象当作占位符的值</span></span><br><span class="line">db.<span class="title function_">query</span>(sqlStr, user, <span class="function">(<span class="params">err, results</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>) <span class="comment">// 失败</span></span><br><span class="line">  <span class="keyword">if</span>(results.<span class="property">affectedRows</span>===<span class="number">1</span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;插入数据成功&quot;)&#125;//成功</span></span><br><span class="line"><span class="string"> &#125;)</span></span><br></pre></td></tr></table></figure>

<p><strong>4.更新数据可以通过如下方式,更新表中的数据:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.要更新的数据对象</span></span><br><span class="line"><span class="keyword">const</span> user = &#123;<span class="attr">id</span>: <span class="number">7</span>, <span class="attr">username</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">password</span>: <span class="string">&#x27;000&#x27;</span> &#125;</span><br><span class="line"><span class="comment">//2.要执行的SQL 语句</span></span><br><span class="line"><span class="keyword">const</span> sqlStr = <span class="string">&#x27;UPDATE users SET username=?, password=? WHERE id=?&quot;</span></span><br><span class="line"><span class="string">// 3.调用db.query()执行SQL语句的同时,使用数组依次为占位符指定具体的值</span></span><br><span class="line"><span class="string">db.query(sqlStr, [user.username, user.password, user.id], (err, results) =&gt; &#123;</span></span><br><span class="line"><span class="string">   if (err) return console.log(err.message) // 失败</span></span><br><span class="line"><span class="string">   if (results.affectedRows === 1) &#123;console.log(&#x27;</span>更新数据成功! <span class="string">&#x27;)&#125; //成功</span></span><br></pre></td></tr></table></figure>

<p><strong>5.更新数据的便捷方式</strong></p>
<p><strong>更新表数据时,如果数据对象的每个属性和数据表的字段--对应,则可以通过如下方式快速更新表数据:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.要更新的数据对象</span></span><br><span class="line"><span class="keyword">const</span> user = &#123;<span class="attr">id</span>: <span class="number">7</span>, <span class="attr">username</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">password</span>: <span class="string">&#x27;000&#x27;</span> &#125;</span><br><span class="line"><span class="comment">//2.要执行的SQL 语句</span></span><br><span class="line"><span class="keyword">const</span> sqlStr = <span class="string">&#x27;UPDATE users SET ? WHERE id=?&quot;</span></span><br><span class="line"><span class="string">// 3.调用db.query()执行SQL语句的同时,使用数组依次为占位符指定具体的值</span></span><br><span class="line"><span class="string">db.query(sqlStr, [user, user.id], (err, results) =&gt; &#123;</span></span><br><span class="line"><span class="string">   if (err) return console.log(err.message) // 失败</span></span><br><span class="line"><span class="string">   if (results.affectedRows === 1) &#123;console.log(&#x27;</span>更新数据成功! <span class="string">&#x27;)&#125; //成功</span></span><br></pre></td></tr></table></figure>

<p><strong>6.删除数据</strong></p>
<p><strong>在删除数据时,推荐根据id这样的唯一标识,来删除对应的数据。示例如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.要执行的SQL语句</span></span><br><span class="line"><span class="keyword">const</span> sqlStr = <span class="string">&#x27;DELETE FROM users WHERE id=?&#x27;</span></span><br><span class="line"><span class="comment">//2.调用db.query()执行SQL语句的同时,为占位符指定具体的值</span></span><br><span class="line"><span class="comment">//注意:如果SQL语句中有多个占位符,则必须使用数组为每个占位符指定具体的值</span></span><br><span class="line"><span class="comment">//如果SQL语句中只有一个占位符,则可以省略数组</span></span><br><span class="line">db.<span class="title function_">query</span>(sqlStr, <span class="number">7</span>, <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>) <span class="comment">// 失败</span></span><br><span class="line">    <span class="keyword">if</span> (results.<span class="property">affectedRows</span>=== <span class="number">1</span>)</span><br><span class="line">     <span class="variable language_">console</span>.1og(<span class="string">&#x27;删除数据成功!&#x27;</span>)&#125; <span class="comment">//成功</span></span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>7.标记删除</strong></p>
<p><strong>使用DELETE 语句,会把真正的把数据从表中删除掉。为了保险起见,推荐使用标记删除的形式,来模拟删除的动作。</strong></p>
<p><strong>所谓的标记删除,就是在表中设置类似于status这样的状态字段,来标记当前这条数据是否被删除。</strong></p>
<p><strong>当用户执行了删除的动作时,我们并没有执行DELETE 语句把数据删除掉,而是执行了UPDATE语句,将这条数据对应的status字段标记为删除即可。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标记删除:使用UPDATE 语句替代 DELETE 语句;只更新数据的状态,并没有真正删除</span></span><br><span class="line">db.<span class="title function_">query</span>(<span class="string">&#x27;UPDATE USERS SET status=1 WHERE id=?&#x27;</span>, <span class="number">6</span>, <span class="function">(<span class="params">err, results</span>) =&gt;</span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>) <span class="comment">// 失败</span></span><br><span class="line">    <span class="keyword">if</span> (results.<span class="property">affectedRows</span> === <span class="number">1</span>) &#123;<span class="variable language_">console</span>.1og(<span class="string">&#x27;删除数据成功!)&#125;</span></span><br><span class="line"><span class="string">  &#125;)</span></span><br></pre></td></tr></table></figure>



<h1 id="5-前后端的身份认证"><a href="#5-前后端的身份认证" class="headerlink" title="5.前后端的身份认证"></a><strong>5.前后端的身份认证</strong></h1><p><strong>5.1 Web 开发模式目前主流的Web开发模式有两种,分别是:</strong></p>
<p><strong>① 基于服务端演染的传统Web开发模式</strong></p>
<p><strong>②基于前后端分离的新型Web开发模式</strong></p>
<h2 id="5-1-Web-开发模式"><a href="#5-1-Web-开发模式" class="headerlink" title="5.1 Web 开发模式"></a><strong>5.1 Web 开发模式</strong></h2><p><strong>1.服务端宣染的Web开发模式</strong></p>
<p><strong>服务端演染的概念:服务器发送给客户端的HTML页面,是在服务器通过字符串的拼接,动态生成的。因此,客户端不需要使用Ajax这样的技术额外请求页面的数据。代码票例如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/index.html&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//1.要演染的数据</span></span><br><span class="line">    <span class="keyword">const</span> user=&#123;<span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> )</span><br><span class="line">    <span class="comment">// 2.服务器端通过字符申的拼接,动态生成HTML内容</span></span><br><span class="line">    <span class="keyword">const</span> html = <span class="string">&#x27;&lt;h1&gt;姓名: $&#123;user.name&#125;, 年龄:$&#123;user.age&#125;&lt;/h1&gt;`</span></span><br><span class="line"><span class="string">    //3.把生成好的页面内容响应给客户端。因此,客户端拿到的是带有真实数据的HTML页面</span></span><br><span class="line"><span class="string">  	res.send(html)</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure>

<p><strong>2.服务端宣染的优缺点</strong></p>
<p><strong>优点:</strong></p>
<p><strong>前端耗时少。因为服务器端负责动态生成HTML内容,浏览器只需要直接渲染页面即可。尤其是移动端,更省电。</strong></p>
<p><strong>有利于SEO。因为服务器端响应的是完整的HTML页面内容,所以爬虫更容易爬取获得信息,更有利于SEO。</strong></p>
<p><strong>缺点:</strong></p>
<p><strong>①占用服务器端资源。即服务器端完成HTML页面内容的拼接,如果请求较多,会对服务器造成一定的访问压力。</strong></p>
<p><strong>②不利于前后端分离,开发效率低。使用服务器端演染,则无法进行分工合作,尤其对于前端复杂度高的项目,不利于项目高效开发。</strong></p>
<p><strong>3.前后端分离的Web开发模式</strong></p>
<p><strong>前后端分离的概念:前后端分离的开发模式,依赖于Ajax技术的广泛应用。简而言之,前后端分离的Web开发模式.就是后端只负责提供API接口,前端使用Ajax调用接口的开发模式。</strong></p>
<p><strong>4.前后端分离的优缺点优点:</strong></p>
<p><strong>①开发体验好。前端专注于UI页面的开发,后端专注于api的开发,且前端有更多的选择性。</strong></p>
<p><strong>用户体验好。Ajax技术的广泛应用,极大的提高了用户的体验,可以轻松实现页面的局部刷新。</strong></p>
<p><strong>减轻了服务器端的渲染压力。因为页面最终是在每个用户的浏览器中生成的。</strong></p>
<p><strong>缺点:</strong></p>
<p><strong>不利于SEO。因为完整的HTML页面需要在客户端动态拼接完成,所以爬虫对无法爬取页面的有效信息。(解决方案:利用Vue, React等前端框架的SSR (server side render)技术能够很好的解决SEO问题!)</strong></p>
<p><strong>5.如何选择Web开发模式</strong></p>
<p><strong>不谈业务场景而盲目选择使用何种开发模式都是耍流氓。</strong></p>
<p><strong>比如企业级网站,主要功能是展示而没有复杂的交互,并且需要良好的SEO,则这时我们就需要使用服务器端渲染:</strong></p>
<p><strong>而类似后台管理项目,交互性比较强,不需要考虑SEO,那么就可以使用前后端分离的开发模式。</strong></p>
<p><strong>另外,具体使用何种开发模式并不是绝对的,为了同时兼顾了首页的渲染速度和前后端分离的开发效率,一些网站采用了首屏服务器端谊染+其他页面前后端分离的开发模式。</strong></p>
<h2 id="5-2身份认证"><a href="#5-2身份认证" class="headerlink" title="5.2身份认证"></a><strong>5.2身份认证</strong></h2><p><strong>1.什么是身份认证</strong></p>
<p><strong>身份认证(Authentication)又称“身份验证”、“鉴权”,是指通过一定的手段,完成对用户身份的确认。</strong></p>
<p><strong>日常生活中的身份认证随处可见,例如:高铁的验票乘车,手机的密码或指纹解锁,支付宝或微信的支付密码等。</strong></p>
<p><strong>在Web开发中,也涉及到用户身份的认证,例如:各大网站的手机验证码登录、邮箱密码登录、二维码登录等。</strong></p>
<p><strong>2.为什么需要身份认证</strong></p>
<p><strong>身份认证的目的,是为了确认当前所声称为某种身份的用户,确实是所声称的用户。例如,你去找快递员取快递,你要怎么证明这份快递是你的。</strong></p>
<p><strong>在互联网项目开发中,如何对用户的身份进行认证,是一个值得深入探讨的问题。例如,如何才能保证网站不会错误的将“马云的存款数额”显示到“马化腾的账户”上。</strong></p>
<p><strong>3.不同开发模式下的身份认证</strong></p>
<p><strong>对于服务端渲染和前后端分离这两种开发模式来说,分别有着不同的身份认证方案:</strong></p>
<p><strong>①服务端演染推荐使用Session认证机制</strong></p>
<p><strong>2.前后端分离推荐使用JWT认证机制</strong></p>
<h2 id="5-3-Session-认证机制"><a href="#5-3-Session-认证机制" class="headerlink" title="5.3 Session 认证机制"></a><strong>5.3 Session 认证机制</strong></h2><p><strong>1. HTTP 协议的无状态性了解HTTP 协议的无状态性是进一步学习Session认证机制的必要前提。</strong></p>
<p><strong>HTTP 协议的无状态性,指的是客户端的每次HTTP 请求都是独立的,连续多个请求之间没有直接的关系,服务器不会主动保留每次HTTP 请求的状态。</strong></p>
<p><strong>2.如何突破HTTP无状态的限制</strong></p>
<p><strong>对于超市来说,为了方便收银员在进行结算时给VIP用户打折,超市可以为每个VIP用户发放会员卡。</strong></p>
<p><strong>注意:现实生活中的会员卡身份认证方式,在Web开发中的专业术语叫做Cookie.</strong></p>
<p><strong>3. 什么是CookieCookie 是存储在用户浏览器中的一段不超过4 KB 的字符串。它由一个名称(Name)、一个值(Value)和其它几个用于控制Cookie有效期、安全性、使用范围的可选属性组成。</strong></p>
<p><strong>不同域名下的Cookie各自独立,每当客户端发起请求时,会自动把当前域名下所有未过期的Cookie一同发送到服务器。</strong></p>
<p><strong>Cookie的几大特性:</strong></p>
<p><strong>① 自动发送</strong></p>
<p><strong>②域名独立</strong></p>
<p><strong>③过期时限</strong></p>
<p><strong>④ 4KB 限制</strong></p>
<p><strong>4. Cookie 在身份认证中的作用</strong></p>
<p><strong>客户端第一次请求服务器的时候,服务器通过响应头的形式,向客户端发送一个身份认证的Cookie,客户端会自动将Cookie保存在浏览器中。</strong></p>
<p><strong>随后,当客户端浏览器每次请求服务器的时候,浏览器会自动将身份认证相关的Cookie,通过请求头的形式发送给服务器,服务器即可验明客户端的身份。</strong></p>
<p><strong>5. Cookie 不具有安全性</strong></p>
<p><strong>由于Cookie是存储在浏览器中的,而且浏览器也提供了读写Cookie的API,因此Cookie很容易被伪造,不具有安全性。因此不建议服务器将重要的隐私数据,通过Cookie的形式发送给浏览器。</strong></p>
<p><strong>注意:干万不要使用Cookie存储重要且隐私的数据!比如用户的身份信息、密码等。</strong></p>
<p><strong>6.提高身份认证的安全性</strong></p>
<p><strong>为了防止客户伪造会员卡,收银员在拿到客户出示的会员卡之后,可以在收银机上进行刷卡认证。只有收银机确认存在的会员卡,才能被正常使用。</strong></p>
<p><strong>这种“会员卡+刷卡认证”的设计理念,就是Session认证机制的精髓。</strong></p>
<h2 id="5-4-在Express中使用Session认证"><a href="#5-4-在Express中使用Session认证" class="headerlink" title="5.4 在Express中使用Session认证"></a><strong>5.4 在Express中使用Session认证</strong></h2><p><strong>1. 安装 express-session 中间件</strong></p>
<p><strong>在Express 项目中,只需要安装 express-session中间件,即可在项目中使用Session认证:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express-session</span><br></pre></td></tr></table></figure>

<p><strong>2.配置 express-session 中间件express-session 中间件安装成功后,需要通过app.use()来注册 session中间件,示例代码如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 导入 session 中间件</span></span><br><span class="line"><span class="keyword">var</span> session = <span class="built_in">require</span>(<span class="string">&#x27;express-session&#x27;</span>)</span><br><span class="line"><span class="comment">// 2.配置Session中问件</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">session</span>(&#123;</span><br><span class="line">    <span class="attr">secret</span>: <span class="string">&#x27;keyboard cat&#x27;</span>, <span class="comment">// secret 属性的值可以为任意字符串</span></span><br><span class="line">    <span class="attr">resave</span>: <span class="literal">false</span>, <span class="comment">//固定写法</span></span><br><span class="line">    <span class="attr">saveUninitialized</span>: <span class="literal">true</span> <span class="comment">// 固定写法</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<p><strong>3.向session中存数据</strong></p>
<p><strong>当express-session中间件配置成功后,即可通过req.session来访问和使用session对象,从而存储用户的关健信息:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/api/login&#x27;</span>, <span class="function">(<span class="params">req, res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//判断用户提交的登录信息是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (req.<span class="property">body</span>.<span class="property">username</span> !==<span class="string">&#x27;admin&#x27;</span> || req.<span class="property">body</span>.<span class="property">password</span> !== <span class="string">&#x27;000000&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">send</span>(&#123; <span class="attr">status</span>:<span class="number">1</span> <span class="attr">msg</span>: <span class="string">&#x27;登录失败&#x27;</span>&#125; )&#125;</span><br><span class="line">    req.<span class="property">session</span>.<span class="property">user</span>=req.<span class="property">body</span> <span class="comment">//将用户的信息,存储到 Session中</span></span><br><span class="line">    req.<span class="property">session</span>.<span class="property">islogin</span>=<span class="literal">true</span> <span class="comment">//将用户的登录状志,存储到Session中</span></span><br><span class="line">    res.<span class="title function_">send</span>(&#123; <span class="attr">status</span>: <span class="number">0</span>, <span class="attr">msg</span>: <span class="string">&#x27;登录成功&#x27;</span> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>4. 从 session中取数据</strong></p>
<p><strong>可以直接从req.session对象上获取之前存储的数据,示例代码如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取用户姓名的接口</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/api/username&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//判断用户是否登录</span></span><br><span class="line">    <span class="keyword">if</span> (!req.<span class="property">session</span>.<span class="property">islogin</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">send</span>(&#123;<span class="attr">status</span>: <span class="number">1</span>, <span class="attr">msg</span>: <span class="string">&#x27;fail&#x27;</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">send</span>(&#123; <span class="attr">status</span>: <span class="number">0</span>, <span class="attr">msg</span>: <span class="string">&#x27;success&#x27;</span>, <span class="attr">username</span>: req.<span class="property">session</span>.<span class="property">user</span>.<span class="property">username</span> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>5. 清空session</strong></p>
<p><strong>调用req.session.destroy()函数,即可清空服务器保存的session信息。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//退出登录的接口</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/api/logout&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//清空当前客户端对应的session信息</span></span><br><span class="line">    req.<span class="property">session</span>.<span class="title function_">destroy</span>() </span><br><span class="line">    res.<span class="title function_">send</span>(&#123;<span class="attr">status</span>: <span class="number">0</span>,<span class="attr">msg</span>: <span class="string">&#x27;退出登录成功&#x27;</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="5-5-JWT-认证机制"><a href="#5-5-JWT-认证机制" class="headerlink" title="5.5 JWT 认证机制"></a><strong>5.5 JWT 认证机制</strong></h2><p><strong>1.了解Session认证的局限性</strong></p>
<p><strong>Session认证机制需要配合 Cookie才能实现。由于Cookie默认不支持跨域访问,所以,当涉及到前端跨域请求后端接口的时候,需要做很多额外的配置,才能实现跨域Session认证。</strong></p>
<p><strong>注意:</strong></p>
<p><strong>当前端请求后端接口不存在跨域问题的时候,推荐使用Session身份认证机制。</strong></p>
<p><strong>当前端需要跨域请求后端接口的时候,不推荐使用Session身份认证机制,推荐使用JWT认证机制。</strong></p>
<p><strong>2. 什么是JWTJWT(英文全称: JSON Web Token)是目前最流行的跨域认证解决方案。</strong></p>
<p><strong>3. JWT 的工作原理</strong></p>
<p><strong>总结:用户的信息通过Token字符串的形式,保存在客户端浏览器中。服务器通过还原Token字符串的形式来认证用户的身份。</strong></p>
<p><strong>4. JWT 的组成部分</strong></p>
<p><strong>JWT通常由三部分组成,分别是Header (头部)、Payload (有效荷载)、Signature (签名)。</strong></p>
<p><strong>三者之间使用英文的“."分隔,格式如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Header</span>.<span class="property">Payload</span>.<span class="property">Signature</span></span><br></pre></td></tr></table></figure>

<p><strong>下面是JWT字符串的示例:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGcioiJIUZI1NiIsInR5cCI6IkpxVCJ9.<span class="property">yJpZCI6MSwidXN1cmShbwuioiJhzG1pbiIsInBhc3N3b3JkIjoiliwibmlja25hbWUi0iLms6X1t7T1t7QiLCJlbWFpbCI6Im5pYmFiYUBpdGNhc3QuY24iLCJ1c2VyX3BpYyI61iIsImlhdCI6MTU30DAZNJY4Miw1ZXhwIjoxNTC4MDcyNjgyfwq7GqCXJPK</span>-<span class="title class_">EA8LNrtMG</span>0411Kdz3359KBL3XeuBxuI</span><br></pre></td></tr></table></figure>

<p><strong>6. JWT 的三个部分各自代表的含义</strong></p>
<p><strong>JWT 的三个组成部分,从前到后分别是 Header, Payload, Signature.</strong></p>
<p><strong>其中:</strong></p>
<p><strong>Payload 部分才是真正的用户信息,它是用户信息经过加密之后生成的字符串。</strong></p>
<p><strong>Header 和Signature 是安全性相关的部分,只是为了保证Token的安全性。</strong></p>
<p><strong>7. JWT 的使用方式</strong></p>
<p><strong>客户端收到服务器返回的JWT 之后,通常会将它储存在localStorage 或 sessionStorage中。</strong></p>
<p><strong>此后,客户端每次与服务器通信,都要带上这个JWT的字符串,从而进行身份认证。推荐的做法是把JWT放在HTTP请求头的Authorization字段中,格式如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Authorization</span>: <span class="title class_">Bearer</span> &lt;token&gt;</span><br></pre></td></tr></table></figure>

<p><strong>5.6 在Express 中使用JWT</strong></p>
<p><strong>1.安装JWT相关的包运行如下命令,安装如下两个JWT相关的包:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install jsonwebtoken express-jwt</span><br></pre></td></tr></table></figure>

<p><strong>jsonwebtoken 用于生成 JWT 字符串</strong></p>
<p><strong>express-jwt 用于将 JWT 字符串解析还原成 JSON对象</strong></p>
<p><strong>2.导入JWT 相关的包</strong></p>
<p><strong>使用require()函数,分别导入JWT相关的两个包:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入用于生成JWT 字符串的包</span></span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>)</span><br><span class="line"><span class="comment">//2.导入用于将客户端发送过来的JWT字符串,解析还原成 JSON对象的包</span></span><br><span class="line"><span class="keyword">const</span> express_jwT = <span class="built_in">require</span>(<span class="string">&#x27;express-jwt&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>3.定义secret密钥</strong></p>
<p><strong>为了保证JWT字符串的安全性,防止JWT字符串在网络传输过程中被别人破解,我们需要专门定义一个用于加密和解密的secret密钥:</strong></p>
<p><strong>①当生成JWT字符串的时候,需要使用secret密钥对用户的信息进行加密,最终得到加密好的JWT字符串</strong></p>
<p><strong>②当把JWT字符串解析还原成JSON对象的时候,需要使用secret密钥进行解密</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. secret 密的本质:就是一个字符串</span></span><br><span class="line"><span class="keyword">const</span> secretKey = <span class="string">&#x27;itheima No1&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>4.在登录成功后生成 JWT字符串</strong></p>
<p><strong>调用jsonwebtoken包提供的sign()方法,将用户的信息加密成JWT字符串,响应给客户端:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//登录接口</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/api/login&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>)&#123;</span><br><span class="line"> <span class="comment">//...省略登录失败情况下的代码</span></span><br><span class="line">  <span class="comment">//用户登录成功之后,生成 JWT字符申,通过token属性响应给客户 </span></span><br><span class="line">  res.<span class="title function_">send</span>(&#123;<span class="attr">status</span>: <span class="number">200</span>,<span class="attr">message</span>: <span class="string">&#x27;登录成功!&#x27;</span>,</span><br><span class="line">  <span class="comment">//调用jwt,sign()生成JwT字符串,三个参数分别是:用户信息对象、加密密销、配置对象</span></span><br><span class="line">  <span class="attr">token</span>: jwt.<span class="title function_">sign</span>(&#123;<span class="attr">username</span>:userinfo.<span class="property">username</span>&#125;, secretKey, &#123; <span class="attr">expiresIn</span>: <span class="string">&#x27;30s&#x27;</span> &#125;)</span><br><span class="line">       &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>5.将JWT 字符串还原为JSON对象</strong></p>
<p><strong>客户端每次在访问那些有权限接口的时候,都需要主动通过请求头中的Authorization字段,将Token字符串发送到服务器进行身份认证。</strong></p>
<p><strong>此时,服务器可以通过express-jwt这个中间件,自动将客户端发送过来的Token解析还原成JSON对象:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用app.use()来注册中间件</span></span><br><span class="line"><span class="comment">// expressJWT(&#123;secret: secretKey &#125;)就是用来解析 Token 中件</span></span><br><span class="line"><span class="comment">// .unless(&#123;path: [/^\/api\//] &#125;)用来指定哪些接口不需要访问权限</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">expressJWT</span>(&#123; <span class="attr">secret</span>: secretKey,<span class="attr">algorithms</span>: [<span class="string">&#x27;HS256&#x27;</span>] &#125;).<span class="title function_">unless</span>(&#123; <span class="attr">path</span>: [<span class="regexp">/^\/api\//</span>]&#125;))</span><br></pre></td></tr></table></figure>

<p><strong>6.使用req.user获取用户信息</strong></p>
<p><strong>当express-jwt这个中间件配置成功之后,即可在那些有权限的接口中,使用req.user对象,来访问从JWT字符串中解析出来的用户信息了,示例代码如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个有权限的API接口</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/admin/getinfo&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">user</span>)</span><br><span class="line">    res.<span class="property">send</span> (&#123;</span><br><span class="line">        <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&#x27;获取用户信息成功!&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>: req.<span class="property">user</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>7.捕获解析JWT失败后产生的错误</strong></p>
<p><strong>当使用express-jwt 解析Token字符串时,如果客户端发送过来的Token字符串过期或不合法,会产生一个解析失败的错误,影响项目的正常运行。我们可以通过Express的错误中间件,捕获这个错误并进行相关的处理,示例代码如下:</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">err, req, res, next</span>) =&gt;</span>&#123;</span><br><span class="line"> <span class="comment">// token 解析失败导致的错误</span></span><br><span class="line">  <span class="keyword">if</span>(err.<span class="property">name</span>=== <span class="string">&#x27;UnauthorizedError&#x27;</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> res.<span class="title function_">send</span>(&#123; <span class="attr">status</span>: <span class="number">401</span>, <span class="attr">message</span>: <span class="string">&#x27;无效的token&#x27;</span> &#125;)&#125;</span><br><span class="line">  <span class="comment">//其它原因导致的错误</span></span><br><span class="line">    res.<span class="title function_">send</span>(&#123; <span class="attr">status</span>: <span class="number">500</span>, <span class="attr">message</span>: <span class="string">&#x27;未知错误&#x27;</span> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://2486125878.github.io">凯</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://2486125878.github.io/2024/03/13/nodeJs/">https://2486125878.github.io/2024/03/13/nodeJs/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/nodeJs/">nodeJs</a></div><div class="post_share"><div class="social-share" data-image="https://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/0bd162d9f2d3572c03d4a3348113632762d0c327.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/13/Vue/" title="Vue"><img class="cover" src="https://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/0bd162d9f2d3572c03d4a3348113632762d0c327.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">Vue</div></div></a></div><div class="next-post pull-right"><a href="/2024/03/13/jquery/" title="jQuery"><img class="cover" src="https://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/0bd162d9f2d3572c03d4a3348113632762d0c327.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next</div><div class="next_info">jQuery</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.v8Y5QxZNIiQVIEk3JOCC2QHaGi?rs=1&amp;pid=ImgDetMain" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">凯</div><div class="author-info__description">一个喜欢听音乐的前端攻城狮</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/xu-kai666"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://gitee.com/xu-kai666" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:2486125878@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#NODE-JS"><span class="toc-number">1.</span> <span class="toc-text">NODE.JS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4%E5%9C%A8Node-js-%E7%8E%AF%E5%A2%83%E4%B8%AD%E6%89%A7%E8%A1%8CJavaScript%E4%BB%A3%E7%A0%81"><span class="toc-number">1.1.</span> <span class="toc-text">1.4在Node.js 环境中执行JavaScript代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E4%BB%80%E4%B9%88%E6%98%AFfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%97"><span class="toc-number">1.2.</span> <span class="toc-text">2.1什么是fs文件系统模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E8%AF%BB%E5%8F%96%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">1.3.</span> <span class="toc-text">2.2读取指定文件中的内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%E5%90%91%E6%8C%87%E5%AE%9A%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%AD%E5%86%99%E5%85%A5%E5%86%85%E5%AE%B9"><span class="toc-number">1.4.</span> <span class="toc-text">2.3向指定的文件中写入内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-fs%E6%A8%A1%E5%9D%97-%E8%B7%AF%E5%BE%84%E5%8A%A8%E6%80%81%E6%8B%BC%E6%8E%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.</span> <span class="toc-text">2.6 fs模块-路径动态拼接的问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-path-%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97"><span class="toc-number">2.</span> <span class="toc-text">3. path 路径模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E4%BB%80%E4%B9%88%E6%98%AFpath-%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97"><span class="toc-number">2.1.</span> <span class="toc-text">3.1什么是path 路径模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%B7%AF%E5%BE%84%E6%8B%BC%E6%8E%A5"><span class="toc-number">2.2.</span> <span class="toc-text">3.2 路径拼接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3%E8%8E%B7%E5%8F%96%E8%B7%AF%E5%BE%84%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D"><span class="toc-number">2.3.</span> <span class="toc-text">3.3获取路径中的文件名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B-%E6%97%B6%E9%92%9F%E6%A1%88%E4%BE%8B"><span class="toc-number">2.4.</span> <span class="toc-text">3.5综合案例-时钟案例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-http%E6%A8%A1%E5%9D%97"><span class="toc-number">3.</span> <span class="toc-text">4. http模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E4%BB%80%E4%B9%88%E6%98%AFhttp%E6%A8%A1%E5%9D%97"><span class="toc-number">3.1.</span> <span class="toc-text">4.1 什么是http模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%90%86%E8%A7%A3http%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">4.2进一步理解http模块的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">3.3.</span> <span class="toc-text">4.3服务器相关的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E6%A0%B9%E6%8D%AE%E4%B8%8D%E5%90%8C%E7%9A%84url%E5%93%8D%E5%BA%94%E4%B8%8D%E5%90%8C%E7%9A%84html%E5%86%85%E5%AE%B9"><span class="toc-number">3.4.</span> <span class="toc-text">4.5 根据不同的url响应不同的html内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.5.</span> <span class="toc-text">1.模块化的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">3.5.1.</span> <span class="toc-text">1.1什么是模块化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Node-js%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">3.6.</span> <span class="toc-text">2. Node.js中的模块化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Node-js-%E4%B8%AD%E6%A8%A1%E5%9D%97%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">3.6.1.</span> <span class="toc-text">2.1 Node.js 中模块的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97"><span class="toc-number">3.6.2.</span> <span class="toc-text">2.2加载模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Node-js-%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">3.6.3.</span> <span class="toc-text">2.3 Node.js 中的模块作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%90%91%E5%A4%96%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">3.6.4.</span> <span class="toc-text">2.4 向外共享模块作用域中的成员</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-npm%E4%B8%8E%E5%8C%85"><span class="toc-number">4.</span> <span class="toc-text">3. npm与包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E5%8C%85"><span class="toc-number">4.1.</span> <span class="toc-text">3.1包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-npm-%E5%88%9D%E4%BD%93%E9%AA%8C"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 npm 初体验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5%E5%8C%85%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">4.2.1.</span> <span class="toc-text">3.5包的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7%E5%BC%80%E5%8F%91%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8C%85"><span class="toc-number">4.2.2.</span> <span class="toc-text">3.7开发属于自己的包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E5%BC%80%E5%8F%91%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8C%85"><span class="toc-number">4.2.3.</span> <span class="toc-text">3.7 开发属于自己的包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-%E5%8F%91%E5%B8%83%E5%8C%85"><span class="toc-number">4.2.4.</span> <span class="toc-text">3.8 发布包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">5.</span> <span class="toc-text">4.模块的加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E4%BC%98%E5%85%88%E4%BB%8E%E7%BC%93%E5%AD%98%E4%B8%AD%E5%8A%A0%E8%BD%BD"><span class="toc-number">5.1.</span> <span class="toc-text">4.1优先从缓存中加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">5.2.</span> <span class="toc-text">4.2内置模块的加载机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">5.3.</span> <span class="toc-text">4.3 自定义模块的加载机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%88%9D%E8%AF%86Express"><span class="toc-number">6.</span> <span class="toc-text">1. 初识Express</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Express-%E7%AE%80%E4%BB%8B"><span class="toc-number">6.1.</span> <span class="toc-text">1.1 Express 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Express-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">6.2.</span> <span class="toc-text">1.2 Express 的基本使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3%E6%89%98%E7%AE%A1%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90"><span class="toc-number">6.3.</span> <span class="toc-text">1.3托管静态资源</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Express-%E8%B7%AF%E7%94%B1"><span class="toc-number">7.</span> <span class="toc-text">2. Express 路由</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E8%B7%AF%E7%94%B1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">7.1.</span> <span class="toc-text">2.1路由的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">7.2.</span> <span class="toc-text">2.2路由的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%88%9B%E5%BB%BA%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%9D%97"><span class="toc-number">7.3.</span> <span class="toc-text">3.创建路由模块</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Express-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">8.</span> <span class="toc-text">3. Express 中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">8.1.</span> <span class="toc-text">3.1中间件的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Express-%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%88%9D%E4%BD%93%E9%AA%8C"><span class="toc-number">8.2.</span> <span class="toc-text">3.2 Express 中间件的初体验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">8.3.</span> <span class="toc-text">3.3中间件的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">8.4.</span> <span class="toc-text">3.4 自定义中间件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8Express%E5%86%99%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.</span> <span class="toc-text">4.使用Express写接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E5%88%9B%E5%BB%BA%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">9.1.</span> <span class="toc-text">4.1创建基本的服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%88%9B%E5%BB%BAAPI-%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%9D%97"><span class="toc-number">9.2.</span> <span class="toc-text">4.2 创建API 路由模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3%E7%BC%96%E5%86%99GET%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.3.</span> <span class="toc-text">4.3编写GET接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4%E7%BC%96%E5%86%99POST%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.4.</span> <span class="toc-text">4.4编写POST接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-CORS-%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB"><span class="toc-number">9.5.</span> <span class="toc-text">4.5 CORS 跨域资源共享</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-JSONP-%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.6.</span> <span class="toc-text">4.6 JSONP 接口</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/03/14/thinkphp%E5%90%8E%E5%8F%B0%E7%AC%94%E8%AE%B0/" title="thinkphp后台笔记"><img src="https://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/0bd162d9f2d3572c03d4a3348113632762d0c327.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="thinkphp后台笔记"/></a><div class="content"><a class="title" href="/2024/03/14/thinkphp%E5%90%8E%E5%8F%B0%E7%AC%94%E8%AE%B0/" title="thinkphp后台笔记">thinkphp后台笔记</a><time datetime="2024-03-14T07:51:34.000Z" title="Created 2024-03-14 15:51:34">2024-03-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/14/thinkphp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="thinkphp学习笔记"><img src="https://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/0bd162d9f2d3572c03d4a3348113632762d0c327.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="thinkphp学习笔记"/></a><div class="content"><a class="title" href="/2024/03/14/thinkphp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="thinkphp学习笔记">thinkphp学习笔记</a><time datetime="2024-03-14T07:32:59.000Z" title="Created 2024-03-14 15:32:59">2024-03-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/14/thinkphp%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B6%E4%BB%96/" title="thinkphp数据库其他"><img src="https://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/0bd162d9f2d3572c03d4a3348113632762d0c327.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="thinkphp数据库其他"/></a><div class="content"><a class="title" href="/2024/03/14/thinkphp%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B6%E4%BB%96/" title="thinkphp数据库其他">thinkphp数据库其他</a><time datetime="2024-03-14T04:04:00.000Z" title="Created 2024-03-14 12:04:00">2024-03-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/14/thinkphp%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2/" title="thinkphp多种查询"><img src="https://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/0bd162d9f2d3572c03d4a3348113632762d0c327.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="thinkphp多种查询"/></a><div class="content"><a class="title" href="/2024/03/14/thinkphp%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2/" title="thinkphp多种查询">thinkphp多种查询</a><time datetime="2024-03-14T03:47:23.000Z" title="Created 2024-03-14 11:47:23">2024-03-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/14/thinkphp%E9%93%BE%E5%BC%8F%E6%93%8D%E4%BD%9C/" title="thinkphp链式操作"><img src="https://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/0bd162d9f2d3572c03d4a3348113632762d0c327.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="thinkphp链式操作"/></a><div class="content"><a class="title" href="/2024/03/14/thinkphp%E9%93%BE%E5%BC%8F%E6%93%8D%E4%BD%9C/" title="thinkphp链式操作">thinkphp链式操作</a><time datetime="2024-03-14T03:18:02.000Z" title="Created 2024-03-14 11:18:02">2024-03-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="footer"><div class="bubbles"><div class="bubble" style="--size:2.0223540837403853rem; --distance:8.767642979411889rem; --position:47.10763172946053%; --time:2.2436412298844295s; --delay:-2.3554481265399736s;"></div><div class="bubble" style="--size:3.950246957132137rem; --distance:8.755652371701029rem; --position:-4.916157963885352%; --time:3.7244638026096863s; --delay:-3.382997614843474s;"></div><div class="bubble" style="--size:4.897102275565071rem; --distance:7.042611738362608rem; --position:16.62431437817165%; --time:3.3843006508887323s; --delay:-2.081832775011699s;"></div><div class="bubble" style="--size:2.4615257508140322rem; --distance:8.349406007069678rem; --position:68.42373183607842%; --time:3.501773115735585s; --delay:-3.5497113880932676s;"></div><div class="bubble" style="--size:2.6104689267742707rem; --distance:7.042412109640649rem; --position:90.4205847571559%; --time:3.1573088248470107s; --delay:-2.789426370729899s;"></div><div class="bubble" style="--size:2.5074495399834227rem; --distance:6.219946048006814rem; --position:63.3308120062683%; --time:2.659998839194583s; --delay:-3.3104244291573592s;"></div><div class="bubble" style="--size:4.330338192907684rem; --distance:8.443660585175397rem; --position:65.25040068026576%; --time:3.932343431101319s; --delay:-3.8598253076343894s;"></div><div class="bubble" style="--size:4.300694723434372rem; --distance:8.789052395730302rem; --position:66.14482487129247%; --time:2.494345941274092s; --delay:-3.105638525745861s;"></div><div class="bubble" style="--size:2.221576088902971rem; --distance:6.383035471955614rem; --position:101.94744496198568%; --time:3.2746542126455775s; --delay:-3.7039665000964925s;"></div><div class="bubble" style="--size:4.352806537703627rem; --distance:7.671817851142036rem; --position:73.89899762139214%; --time:3.442488526702143s; --delay:-3.6251513652717096s;"></div><div class="bubble" style="--size:4.254784094008496rem; --distance:9.964473601338659rem; --position:52.838050265332264%; --time:3.481481260162192s; --delay:-3.4614242317187647s;"></div><div class="bubble" style="--size:3.63279029506882rem; --distance:9.379513761449186rem; --position:102.77557637462002%; --time:2.8356948573030447s; --delay:-3.0951493047437593s;"></div><div class="bubble" style="--size:2.9787029483610556rem; --distance:9.879871507650089rem; --position:35.70274894902019%; --time:2.2697733682056445s; --delay:-2.3315387576075253s;"></div><div class="bubble" style="--size:5.349280295330924rem; --distance:7.803295402525922rem; --position:99.98737377852608%; --time:2.9545433084309902s; --delay:-2.9693586699736283s;"></div><div class="bubble" style="--size:4.459095767439761rem; --distance:6.994979319860702rem; --position:4.458209001012239%; --time:2.4991560189917856s; --delay:-2.1086540557996036s;"></div><div class="bubble" style="--size:3.3717290866646197rem; --distance:9.357569479851424rem; --position:36.92236859324521%; --time:2.9489805233118442s; --delay:-3.7253381649471993s;"></div><div class="bubble" style="--size:5.90439575222343rem; --distance:7.130916322279611rem; --position:57.89512937226876%; --time:2.9211951939759753s; --delay:-3.685367390557342s;"></div><div class="bubble" style="--size:2.0383957031219033rem; --distance:6.059800069987557rem; --position:35.30192014167536%; --time:3.4607696280680464s; --delay:-2.485148393696327s;"></div><div class="bubble" style="--size:2.2562888050771095rem; --distance:7.197044079905691rem; --position:8.717942098225322%; --time:2.9904931017405776s; --delay:-3.3300022586233773s;"></div><div class="bubble" style="--size:4.802734567940755rem; --distance:9.291840933147178rem; --position:11.261815936008546%; --time:2.7601133792155323s; --delay:-2.2411964780649107s;"></div><div class="bubble" style="--size:5.897255672087321rem; --distance:6.62439477494092rem; --position:7.21182629637547%; --time:3.7115273182818957s; --delay:-3.888160518223623s;"></div><div class="bubble" style="--size:4.508283872592126rem; --distance:8.683957090465702rem; --position:20.43080697163897%; --time:2.604651180618821s; --delay:-2.5367780206692676s;"></div><div class="bubble" style="--size:3.160681850455422rem; --distance:7.090948721740605rem; --position:73.63342515497578%; --time:3.6324506124005165s; --delay:-2.249647967518229s;"></div><div class="bubble" style="--size:2.9199719240488333rem; --distance:7.903659993325309rem; --position:0.3075652279952905%; --time:3.3388390232016625s; --delay:-2.3832472768093798s;"></div><div class="bubble" style="--size:3.597232335075554rem; --distance:6.219045805190088rem; --position:38.283476278998315%; --time:2.677010353738887s; --delay:-2.3314895857970055s;"></div><div class="bubble" style="--size:2.642413299264846rem; --distance:8.74513419859643rem; --position:11.534768236846247%; --time:2.994731894316844s; --delay:-2.3776503591751483s;"></div><div class="bubble" style="--size:3.21744537899942rem; --distance:9.207322646051697rem; --position:68.40670735581891%; --time:3.1244530458808364s; --delay:-2.85893685444086s;"></div><div class="bubble" style="--size:5.055123391742258rem; --distance:6.009453622480251rem; --position:100.00409886168232%; --time:2.7584496939741747s; --delay:-2.4461630995537664s;"></div><div class="bubble" style="--size:4.9180135183244635rem; --distance:9.44590395562835rem; --position:39.070925756117596%; --time:2.8267745559968778s; --delay:-2.8967527128256005s;"></div><div class="bubble" style="--size:2.3483243236663274rem; --distance:8.673900037328373rem; --position:23.788328149178398%; --time:2.5116778990504796s; --delay:-2.818553547634958s;"></div><div class="bubble" style="--size:3.103057591481945rem; --distance:8.204594439405993rem; --position:24.377660968186426%; --time:3.109541720956889s; --delay:-3.0116804345925634s;"></div><div class="bubble" style="--size:4.944463109669268rem; --distance:8.268904529927056rem; --position:54.804121435319736%; --time:2.720910137858648s; --delay:-2.3223364336109795s;"></div><div class="bubble" style="--size:4.48848624952348rem; --distance:8.521409555102512rem; --position:9.117598917938041%; --time:2.175453804377894s; --delay:-3.6584441390940796s;"></div><div class="bubble" style="--size:4.197674897648237rem; --distance:8.345727351967769rem; --position:35.881396522708116%; --time:2.2055332244291908s; --delay:-3.428539503077651s;"></div><div class="bubble" style="--size:3.159887743526494rem; --distance:8.052013158257315rem; --position:102.86509772044903%; --time:3.8456508111059353s; --delay:-2.5556841642500427s;"></div><div class="bubble" style="--size:2.2905324576904995rem; --distance:7.663272022819781rem; --position:45.19060316314879%; --time:2.85364924741506s; --delay:-2.8333674549394736s;"></div><div class="bubble" style="--size:3.566264815293981rem; --distance:9.35017769224347rem; --position:75.20029113800413%; --time:3.716267756543637s; --delay:-3.7562779204701937s;"></div><div class="bubble" style="--size:2.0416685227078677rem; --distance:6.646304509096632rem; --position:31.5507584249859%; --time:2.3235472041580456s; --delay:-2.065964568435455s;"></div><div class="bubble" style="--size:2.4063950685815803rem; --distance:9.851029343937068rem; --position:24.527530969880896%; --time:2.8260240214723686s; --delay:-2.745585071285214s;"></div><div class="bubble" style="--size:5.312523918342542rem; --distance:7.1820924820816225rem; --position:42.056812530307475%; --time:3.775454228187163s; --delay:-2.15408029916992s;"></div><div class="bubble" style="--size:5.937847161659954rem; --distance:8.794723207841301rem; --position:37.62446996351634%; --time:3.5877530824701895s; --delay:-3.346387867232697s;"></div><div class="bubble" style="--size:4.277140123431885rem; --distance:8.840771451868594rem; --position:49.363787065419146%; --time:2.5717452786823443s; --delay:-2.65023646183884s;"></div><div class="bubble" style="--size:5.645346141138964rem; --distance:6.766551277548252rem; --position:77.7442444166762%; --time:3.4372959792654187s; --delay:-3.3580343376270116s;"></div><div class="bubble" style="--size:3.7081110318903514rem; --distance:6.819287756304814rem; --position:37.025677498131884%; --time:2.54960848760924s; --delay:-2.0071819196344585s;"></div><div class="bubble" style="--size:5.632925834879541rem; --distance:8.943637050793475rem; --position:62.82778459483612%; --time:3.477568295431055s; --delay:-2.565265514542093s;"></div><div class="bubble" style="--size:2.971954724391731rem; --distance:9.064212654616629rem; --position:92.20837954793173%; --time:2.5244375216066812s; --delay:-3.107986730323009s;"></div><div class="bubble" style="--size:3.829547278389689rem; --distance:9.993104948274645rem; --position:67.21931396038592%; --time:3.2653863340600857s; --delay:-3.895089622094339s;"></div><div class="bubble" style="--size:2.783450784731068rem; --distance:6.158823867532616rem; --position:76.5984997200131%; --time:3.5038012188746523s; --delay:-3.7472695431090464s;"></div><div class="bubble" style="--size:4.494553328468255rem; --distance:8.948025220394516rem; --position:61.851086536379356%; --time:3.326005591553527s; --delay:-2.787474236355734s;"></div><div class="bubble" style="--size:5.13918543904916rem; --distance:8.398840050484548rem; --position:48.234360012988084%; --time:2.887196201763291s; --delay:-2.6406789649425506s;"></div><div class="bubble" style="--size:4.793484004723762rem; --distance:8.37764190302224rem; --position:34.476128656318686%; --time:3.98053198909502s; --delay:-2.724483485241627s;"></div><div class="bubble" style="--size:3.9330910938906154rem; --distance:8.2745307509169rem; --position:39.558055500459965%; --time:3.3820238772509006s; --delay:-2.439994277104243s;"></div><div class="bubble" style="--size:5.109502679991662rem; --distance:9.706487689900648rem; --position:-2.631287515038474%; --time:3.1441520403887298s; --delay:-3.5484522150483686s;"></div><div class="bubble" style="--size:5.688521251669419rem; --distance:8.57576349187229rem; --position:85.07294844228693%; --time:2.8507154226630367s; --delay:-3.2534492286311774s;"></div><div class="bubble" style="--size:3.714510264223212rem; --distance:6.418150825491982rem; --position:21.414494728881923%; --time:3.7234003498590353s; --delay:-3.96420123665174s;"></div><div class="bubble" style="--size:5.383512019135821rem; --distance:9.723887349869914rem; --position:3.784703600678071%; --time:3.1847654408919377s; --delay:-3.7282350946959455s;"></div><div class="bubble" style="--size:5.6860526231523165rem; --distance:7.9393974742964195rem; --position:68.32459883084489%; --time:2.6802495733441076s; --delay:-2.1184770936274946s;"></div><div class="bubble" style="--size:3.662563894638555rem; --distance:6.150800430999649rem; --position:92.26205655215564%; --time:3.531298682085154s; --delay:-3.018163833797374s;"></div><div class="bubble" style="--size:2.991457687971004rem; --distance:8.833107010394235rem; --position:12.455066433245218%; --time:2.227639079958873s; --delay:-3.284835474366584s;"></div><div class="bubble" style="--size:4.81418802832055rem; --distance:9.719751355229018rem; --position:47.015976315594834%; --time:2.1311334444580314s; --delay:-2.1249660013418374s;"></div><div class="bubble" style="--size:3.3759247199136784rem; --distance:8.69171570931935rem; --position:99.10016329321708%; --time:3.1058773580466745s; --delay:-3.817261598384551s;"></div><div class="bubble" style="--size:3.9476390363945493rem; --distance:8.585142227418473rem; --position:98.46500964971825%; --time:3.640329961017725s; --delay:-2.15125040931519s;"></div><div class="bubble" style="--size:4.200591233532709rem; --distance:8.056947760626574rem; --position:42.84877912012758%; --time:3.449182590006788s; --delay:-2.8654946618965216s;"></div><div class="bubble" style="--size:5.680097692067772rem; --distance:7.601019328877678rem; --position:26.631044674088923%; --time:3.4612046674701062s; --delay:-3.0795224837211377s;"></div><div class="bubble" style="--size:5.603534146251114rem; --distance:9.972957407658157rem; --position:-3.5850379590477877%; --time:2.2806760706738265s; --delay:-3.48687935313156s;"></div><div class="bubble" style="--size:4.321009176230444rem; --distance:7.577705051986009rem; --position:88.80311228608879%; --time:2.6355004160991835s; --delay:-2.7865905610109647s;"></div><div class="bubble" style="--size:2.9711098891010845rem; --distance:7.152025258537396rem; --position:61.986087752563606%; --time:2.8322781853771843s; --delay:-3.9148736041676675s;"></div><div class="bubble" style="--size:5.757351130092397rem; --distance:7.012385974929453rem; --position:69.63035255798754%; --time:2.2411634807777117s; --delay:-2.2765418440866547s;"></div><div class="bubble" style="--size:4.7169869250559255rem; --distance:9.042001866202893rem; --position:67.66890230282728%; --time:3.8933552745425835s; --delay:-3.0527453101524116s;"></div><div class="bubble" style="--size:4.597309028055669rem; --distance:7.166185577114805rem; --position:104.06880586567335%; --time:3.9082284599697052s; --delay:-2.9226645227034944s;"></div><div class="bubble" style="--size:3.7400464658103534rem; --distance:9.983969643220073rem; --position:18.95580786450442%; --time:3.2036872684665907s; --delay:-3.651580213295117s;"></div><div class="bubble" style="--size:4.217791446520816rem; --distance:6.502916095264279rem; --position:66.6011255904667%; --time:2.0135940380289488s; --delay:-3.479984308067836s;"></div><div class="bubble" style="--size:3.969094162404387rem; --distance:7.444525538063123rem; --position:28.750143865467955%; --time:3.8234510380952638s; --delay:-3.8844283435966855s;"></div><div class="bubble" style="--size:5.874685257040214rem; --distance:6.021363749286142rem; --position:78.71660262734537%; --time:2.8692802608061467s; --delay:-2.354725480980802s;"></div><div class="bubble" style="--size:5.800561757987001rem; --distance:6.655500873283603rem; --position:99.69326708256862%; --time:3.819612788722662s; --delay:-2.125266324059307s;"></div><div class="bubble" style="--size:2.014641270144862rem; --distance:7.008606583653579rem; --position:51.08656808671315%; --time:3.1134370086333916s; --delay:-3.5523473719989433s;"></div><div class="bubble" style="--size:2.1202985337338225rem; --distance:7.629041033360319rem; --position:36.79694489475225%; --time:3.7346107577917063s; --delay:-3.359251755034336s;"></div><div class="bubble" style="--size:5.078843934401027rem; --distance:6.953109897787887rem; --position:34.00969087966922%; --time:3.4994687323131832s; --delay:-3.8764164643718613s;"></div><div class="bubble" style="--size:5.501283496311708rem; --distance:6.232177791937983rem; --position:3.2900129473135316%; --time:2.971282096368665s; --delay:-3.5292650877061638s;"></div><div class="bubble" style="--size:3.3756923226684865rem; --distance:6.815240233387442rem; --position:44.47986523168933%; --time:2.2669392573912175s; --delay:-2.9413645653500873s;"></div><div class="bubble" style="--size:2.670466633029357rem; --distance:8.341208352243385rem; --position:27.03035182700414%; --time:2.437048651904093s; --delay:-3.303596462727643s;"></div><div class="bubble" style="--size:4.939393604540001rem; --distance:8.115330989724544rem; --position:41.84416379434846%; --time:3.90772202455711s; --delay:-3.5824297254206465s;"></div><div class="bubble" style="--size:5.437153766451906rem; --distance:8.472290305983421rem; --position:25.95699977019154%; --time:3.4200437999754s; --delay:-3.708175695900058s;"></div><div class="bubble" style="--size:2.787608796835448rem; --distance:7.6971438011668045rem; --position:38.39261829132503%; --time:2.284571927092984s; --delay:-3.280172082875192s;"></div><div class="bubble" style="--size:5.787045221650445rem; --distance:6.457307004886027rem; --position:76.1519463059708%; --time:3.562898018939507s; --delay:-3.345638238752906s;"></div><div class="bubble" style="--size:5.233671506434746rem; --distance:8.112785290914204rem; --position:40.9769314453478%; --time:2.8760155700978016s; --delay:-2.789063809561299s;"></div><div class="bubble" style="--size:5.761717747189223rem; --distance:6.360196357031294rem; --position:26.63053212678357%; --time:3.4150073337924995s; --delay:-2.9469178968246s;"></div><div class="bubble" style="--size:3.6899150014913165rem; --distance:7.745630492772084rem; --position:26.94476743968766%; --time:2.61187086598395s; --delay:-3.016859179485086s;"></div><div class="bubble" style="--size:3.2776740151218453rem; --distance:9.080534023771463rem; --position:97.45927127185935%; --time:2.8365638854473585s; --delay:-2.2759796736821665s;"></div><div class="bubble" style="--size:4.916038011955209rem; --distance:7.585978978225782rem; --position:53.599345385054235%; --time:2.4980804493013427s; --delay:-2.9918562856766364s;"></div><div class="bubble" style="--size:4.391384527497763rem; --distance:7.657041407014629rem; --position:41.538555082731655%; --time:2.258802212200992s; --delay:-3.8642038441635194s;"></div><div class="bubble" style="--size:3.695154018258724rem; --distance:8.17769576932379rem; --position:104.05175942938435%; --time:3.1580536092495004s; --delay:-3.900306368992888s;"></div><div class="bubble" style="--size:4.820606148822461rem; --distance:6.478826211974814rem; --position:4.85921873226091%; --time:2.3922689504733734s; --delay:-2.9524801645271146s;"></div><div class="bubble" style="--size:5.8387869567489545rem; --distance:7.556884258809362rem; --position:8.12441094672005%; --time:2.3989771140955547s; --delay:-3.6011089993838046s;"></div><div class="bubble" style="--size:2.3516254003767836rem; --distance:7.548600542213886rem; --position:35.25354352872266%; --time:3.837112387250979s; --delay:-2.577873706350878s;"></div><div class="bubble" style="--size:4.989325578331348rem; --distance:7.769022717264752rem; --position:23.720855767043005%; --time:3.150809676085667s; --delay:-3.642304900733545s;"></div><div class="bubble" style="--size:4.4771928190076675rem; --distance:9.006242060766365rem; --position:64.21736121063255%; --time:3.804638273600737s; --delay:-3.8987614408931153s;"></div><div class="bubble" style="--size:2.152207427259344rem; --distance:9.220581629612933rem; --position:18.564204424692537%; --time:3.439305127548428s; --delay:-2.0467120512288255s;"></div><div class="bubble" style="--size:3.926699054535475rem; --distance:6.11508344468965rem; --position:54.986501498436446%; --time:3.1497617065196177s; --delay:-3.8414888261043285s;"></div><div class="bubble" style="--size:5.13671955535201rem; --distance:6.479330178064101rem; --position:91.11110737206803%; --time:3.9151452073238415s; --delay:-2.945265131479994s;"></div><div class="bubble" style="--size:4.861759295646103rem; --distance:8.954673980831272rem; --position:-0.0732147034844477%; --time:3.0815418325420247s; --delay:-2.047159082320659s;"></div><div class="bubble" style="--size:3.953656169457094rem; --distance:6.640912208745869rem; --position:30.91971436226926%; --time:3.99105537335798s; --delay:-3.776484562204942s;"></div><div class="bubble" style="--size:5.061527666236565rem; --distance:7.175267420041949rem; --position:73.82893411766582%; --time:3.635416549711962s; --delay:-2.676205918819809s;"></div><div class="bubble" style="--size:2.4599234203830234rem; --distance:7.680884462192928rem; --position:60.54044276143691%; --time:3.3399422993791554s; --delay:-2.4817698138587736s;"></div><div class="bubble" style="--size:4.639493105501281rem; --distance:6.17415696082025rem; --position:19.409701420386597%; --time:2.9944043873220694s; --delay:-2.4828659242805386s;"></div><div class="bubble" style="--size:5.479111962368168rem; --distance:9.078097894036262rem; --position:40.23021453016027%; --time:2.1446868770056975s; --delay:-3.8124019170453955s;"></div><div class="bubble" style="--size:3.1335715017468635rem; --distance:9.67526067100361rem; --position:82.96824070212399%; --time:2.8946057158063216s; --delay:-2.5331880990572486s;"></div><div class="bubble" style="--size:5.385584797830284rem; --distance:7.104115415797192rem; --position:49.65490302697261%; --time:2.207852634605855s; --delay:-3.1679735036181382s;"></div><div class="bubble" style="--size:2.2900751187270654rem; --distance:7.71386428688858rem; --position:47.18501480920104%; --time:2.409349948839234s; --delay:-2.5076110492744705s;"></div><div class="bubble" style="--size:2.3417121791450413rem; --distance:7.210873172335666rem; --position:32.18982888360097%; --time:3.794542310993936s; --delay:-3.9755709915237225s;"></div><div class="bubble" style="--size:5.899715365790546rem; --distance:9.482238701716154rem; --position:70.27227981191248%; --time:2.3525527388025975s; --delay:-2.976851700821745s;"></div><div class="bubble" style="--size:2.704765553031498rem; --distance:7.824203082680904rem; --position:40.80005073556187%; --time:2.8068426786338962s; --delay:-3.2266570486366284s;"></div><div class="bubble" style="--size:4.252731998285299rem; --distance:9.788878439599294rem; --position:23.464320175119095%; --time:3.097434815232588s; --delay:-2.768991869088671s;"></div><div class="bubble" style="--size:3.8703182221347845rem; --distance:7.33073437394211rem; --position:74.05281712897613%; --time:2.198609109722598s; --delay:-2.6229519556892784s;"></div><div class="bubble" style="--size:4.947420080092644rem; --distance:9.555061371242049rem; --position:6.315256338072356%; --time:2.326708510527707s; --delay:-3.71886204139189s;"></div><div class="bubble" style="--size:3.2656992167718473rem; --distance:9.53590509166403rem; --position:25.628753286886663%; --time:3.2354519918128775s; --delay:-3.4135543067264846s;"></div><div class="bubble" style="--size:2.202619884672159rem; --distance:7.281906087082526rem; --position:51.58069432928571%; --time:3.5931372887444675s; --delay:-3.745994470296078s;"></div><div class="bubble" style="--size:4.167532738643852rem; --distance:8.72750376778382rem; --position:1.0237441221763692%; --time:2.7663230324294883s; --delay:-2.0881827840191396s;"></div><div class="bubble" style="--size:5.4584153667807565rem; --distance:7.071403299564159rem; --position:32.87621299151819%; --time:2.328235677179755s; --delay:-2.38334399761161s;"></div><div class="bubble" style="--size:4.934887708688284rem; --distance:8.865336056141784rem; --position:81.039857202492%; --time:2.4277716368536484s; --delay:-2.932699570079641s;"></div><div class="bubble" style="--size:4.315626065367635rem; --distance:7.758792198743096rem; --position:-1.2412975486057554%; --time:2.1350956944724575s; --delay:-3.8922061731802575s;"></div><div class="bubble" style="--size:5.9799357015739rem; --distance:9.847436418239578rem; --position:22.328418930115554%; --time:2.1911665963630593s; --delay:-3.140487125239976s;"></div><div class="bubble" style="--size:4.94618759500225rem; --distance:7.932820004923349rem; --position:-1.5155447709398628%; --time:3.7073864127858327s; --delay:-3.7482762460994032s;"></div><div class="bubble" style="--size:4.105981118076694rem; --distance:6.280111448625267rem; --position:93.65697971651483%; --time:2.8724247476665035s; --delay:-3.713207082341092s;"></div><div class="bubble" style="--size:3.0629195885796374rem; --distance:8.754051296147242rem; --position:29.8744310238205%; --time:2.871754541055376s; --delay:-3.4125355579372183s;"></div><div class="bubble" style="--size:2.9846710643970553rem; --distance:7.161200407138969rem; --position:71.91146323630151%; --time:3.921309960316313s; --delay:-2.447430728317227s;"></div><div class="bubble" style="--size:5.209677699510812rem; --distance:6.038725358115448rem; --position:24.427385319425653%; --time:2.598155508364641s; --delay:-3.809311374540225s;"></div><div class="bubble" style="--size:2.8093097671822207rem; --distance:7.173916160108204rem; --position:7.384677298476339%; --time:3.9827765619569013s; --delay:-3.0341554631242484s;"></div></div><div class="content"><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>