<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SSM</title>
      <link href="/2024/03/13/SSM/"/>
      <url>/2024/03/13/SSM/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Spring简介"><a href="#1-Spring简介" class="headerlink" title="1.Spring简介"></a>1.Spring简介</h1><h2 id="1-1-Spring是什么"><a href="#1-1-Spring是什么" class="headerlink" title="1.1 Spring是什么"></a>1.1 Spring是什么</h2><p><strong>Spring是分层的Java SE&#x2F;EE应用full-stack轻量级开源框架,以loc ( Inverse Of Control :反转控制)和AOP (Aspect Oriented Programming :面向切面编程)为内核。</strong></p><p><strong>提供了展现层SpringMVC和持久层Spring JDBCTemplate以及业务层事务管理等众多的企业级应用技术还能整合开源世界众多著名的第三方框架和类库,逐渐成为使用最多的JavaEE企业应用开源框架。</strong></p><h2 id="1-2-Spring发展历程"><a href="#1-2-Spring发展历程" class="headerlink" title="1.2 Spring发展历程"></a>1.2 Spring发展历程</h2><p><strong>1997年, IBM提出了EjB的思想</strong></p><p><strong>1998年, SUN制定开发标准规范EjB1.0</strong></p><p><strong>1999年, EJB1.1发布</strong></p><p><strong>2001年, EJB2.0发布</strong></p><p><strong>2003年, EJB2.1发布</strong></p><p><strong>2006年, EJB3.0发布</strong></p><p><strong>Rod Johnson (Spring之父)Expert One-to-One J2EE Design and Development(2002)阐述yJ2EE使用EJB开发设计的优点及解决方案</strong></p><p><strong>Expert One-to-One J2EE Development without EJB(2004)阐述了J2EE开发不使用EJB的解决方式(Spring雏形)</strong></p><p><strong>2017年9月份发布了Spring的最新版本Spring5.0通用版(GA)</strong></p><h2 id="1-3-Spring的优势"><a href="#1-3-Spring的优势" class="headerlink" title="1.3 Spring的优势"></a>1.3 Spring的优势</h2><h3 id="1-方便解耦-简化开发"><a href="#1-方便解耦-简化开发" class="headerlink" title="1)方便解耦,简化开发"></a><strong>1</strong>)方便解耦,简化开发</h3><p><strong>Spring提供的loC容器,可以将对象间的依赖关系交由Spring进行控制,避免硬编码所造成的过度耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码,可以更专注于上层的应用。</strong></p><h3 id="2-AOP编程的支持"><a href="#2-AOP编程的支持" class="headerlink" title="2) AOP编程的支持"></a>2) AOP编程的支持</h3><p><strong>通过Spring的AOP功能,方便进行面向切面编程,许多不容易用传统OOP实现的功能可以通过AOP轻松实现。</strong></p><h3 id="3-声明式事务的支持"><a href="#3-声明式事务的支持" class="headerlink" title="3)声明式事务的支持"></a>3)声明式事务的支持</h3><p><strong>可以将我们从单调烦闷的事务管理代码中解脱出来,通过声明式方式灵活的进行事务管理,提高开发效率和质量。</strong></p><h2 id="4-方便程序的测试"><a href="#4-方便程序的测试" class="headerlink" title="4)方便程序的测试"></a>4)方便程序的测试</h2><p><strong>可以用非容器依赖的编程方式进行几乎所有的测试工作,测试不再是昂贵的操作,而是随手可做的事情。</strong></p><h3 id="5-方便集成各种优秀框架"><a href="#5-方便集成各种优秀框架" class="headerlink" title="5)方便集成各种优秀框架"></a><strong>5)方便集成各种优秀框架</strong></h3><p><strong>Spring对各种优秀框架(Struts, Hibernate, Hessian、 Quart等)的支持。</strong></p><h3 id="6-降低JavaEE-API的使用难度"><a href="#6-降低JavaEE-API的使用难度" class="headerlink" title="6)降低JavaEE API的使用难度"></a>6)降低JavaEE API的使用难度</h3><p><strong>Spring对JavaEE API (如JDBC、 JavaMail、远程调用等)进行了薄薄的封装层,使这些API的使用难度大为降低。</strong></p><h3 id="7-Java源码是经典学习范例"><a href="#7-Java源码是经典学习范例" class="headerlink" title="7.Java源码是经典学习范例"></a>7.Java源码是经典学习范例</h3><p><strong>Spring的源代码设计精妙、结构清晰、匠心独用,处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。它的源代码无意是Java技术的最佳实践的范例。</strong></p><h2 id="1-4-Spring的体系结构"><a href="#1-4-Spring的体系结构" class="headerlink" title="1.4 Spring的体系结构"></a>1.4 Spring的体系结构</h2><p><img src="C:\Users\24861\Desktop\spring.JPG" alt="spring"></p><h1 id="2-Spring快速入门"><a href="#2-Spring快速入门" class="headerlink" title="2.Spring快速入门"></a>2.Spring快速入门</h1><h2 id="2-1-Spring程序开发步骤"><a href="#2-1-Spring程序开发步骤" class="headerlink" title="2.1 Spring程序开发步骤"></a>2.1 Spring程序开发步骤</h2><p><img src="C:\Users\24861\Desktop\spring2.JPG" alt="spring2"></p><p><strong>导入Spring开发的基本包坐标</strong></p><p><strong>编写Dao接口和实现类</strong></p><p><strong>创建Spring核心配置文件</strong></p><p><strong>在Spring配置文件中配置UserDaolmpl</strong></p><p><strong>使用Spring的API获得Bean实例</strong></p><h3 id="Spring的开发步骤"><a href="#Spring的开发步骤" class="headerlink" title="Spring的开发步骤"></a>Spring的开发步骤</h3><p><strong>@导入坐标</strong></p><p><strong>②创建Bean</strong></p><p><strong>③创建applicationContext.xml在配置文件中进行配置</strong></p><p><strong>⑤创建ApplicationContext对象getBean</strong></p><h1 id="3-Spring配置文件"><a href="#3-Spring配置文件" class="headerlink" title="3.Spring配置文件"></a>3.Spring配置文件</h1><h2 id="3-1-Bean标签基本配置"><a href="#3-1-Bean标签基本配置" class="headerlink" title="3.1 Bean标签基本配置"></a>3.1 Bean标签基本配置</h2><p><strong>用于配置对象交由Spring来创建。</strong></p><p><strong>默认情况下它调用的是类中的无参构,函散,如果没有无参构造函数则不能创建成功。</strong></p><p><strong>基本属性</strong></p><p><strong>id: Bean实例在Spring器中的唯一标识</strong></p><p><strong>class: Bean的全限定名称</strong></p><h2 id="3-2-Bean标签范围配置"><a href="#3-2-Bean标签范围配置" class="headerlink" title="3.2 Bean标签范围配置"></a>3.2 Bean标签范围配置</h2><p><strong>scope:指对象的作用范围,取值如下:</strong></p><p><strong>取值范围说明</strong></p><p><strong>singleton默认值,单例的</strong></p><p><strong>prototype多例的</strong></p><p><strong>requestWEB项目中, Spring创建一个Bean的对象,将对象存入到request域中</strong></p><p><strong>sessionWEB项目中, Spring创建一个Bean的对象,将对象存入到session域中</strong></p><p><strong>global sessionWEB项目中,应用在Portlet环境,如果没有Portlet环境那么globalSession相当于session</strong></p><p><strong>1)当scope的取值为singleton时</strong></p><p><strong>Bean的实例化个数: 1个</strong></p><p><strong>Bean的实例化时机:当Spring核心文件被加时,实例化配置的Bean实例</strong></p><p><strong>Bean的生命周期:</strong></p><p>​<strong>对象创建:当应用加载,创建容器时,对象就被创建了</strong></p><p>​<strong>对象运行：只要容器在,对象一直活着</strong></p><p>​<strong>对象销毁:当应用卸载,销毁容器时,对象就被销毁了</strong></p><p><strong>2)当scope的取值为prototype时</strong></p><p><strong>Bean的实例化个数:多</strong></p><p><strong>Bean的实例化时机:当调用getBean0方法时实例化Bean</strong></p><p>​<strong>对象创建:当使用对象时,创建新的对象实例</strong></p><p>​<strong>对象运行:只要对象在使用中,就一直活着</strong></p><p>​<strong>对象销毁:当对象长时间不用时,被Java的垃圾回收器回收了</strong></p><h2 id="3-3-Bean生命周期配置"><a href="#3-3-Bean生命周期配置" class="headerlink" title="3.3 Bean生命周期配置"></a>3.3 Bean生命周期配置</h2><p><strong>init-method:指定类中的初始化方法名称</strong></p><p><strong>destroy-method:指定类中销毁方法名称</strong></p><h2 id="3-4-Bean实例化三种方式"><a href="#3-4-Bean实例化三种方式" class="headerlink" title="3.4 Bean实例化三种方式"></a>3.4 Bean实例化三种方式</h2><p><strong>无参构造方法实例化</strong></p><p><strong>工厂静态方法实例化</strong></p><p><strong>工厂实例方法实例化</strong></p><h2 id="3-6-Bean的依赖注入分析"><a href="#3-6-Bean的依赖注入分析" class="headerlink" title="3.6 Bean的依赖注入分析"></a>3.6 Bean的依赖注入分析</h2><p><strong>目前UserService实例和UserDao实例都存在与Spring容器中,当前的做法是在容器外部获得UserService实例和UserDao实例,然后在程序中进行结合。</strong></p><p><strong>因为UserService和UserDao都在Spring容器中,而最终程序直接使用的是UserService,所以可以在Spring容器中,将UserDao设置到UserService内部。</strong></p><h2 id="3-7-Bean的依赖注入概念"><a href="#3-7-Bean的依赖注入概念" class="headerlink" title="3.7 Bean的依赖注入概念"></a>3.7 Bean的依赖注入概念</h2><p><strong>依赖注入(Dependency Injection) :它是Spring框架核心lOC的具体实现。</strong></p><p><strong>在编写程序时,通过控制反转,把对象的创建交给了Spring,但是代码中不可能出现没有依赖的情况。</strong></p><p><strong>lOC解耦只是降低他们的依赖关系,但不会消除。例如:业务层仍会调用持久层的方法。</strong></p><p><strong>那这种业务层和持久层的依赖关系,在使用Spring之后,就让Spring来维护了简单的说,就是坐等框架把持久层对象传入业务层,而不用我们自己去获取。</strong></p><h2 id="3-7-Bean的依赖注入方式"><a href="#3-7-Bean的依赖注入方式" class="headerlink" title="3.7 Bean的依赖注入方式"></a>3.7 Bean的依赖注入方式</h2><p><strong>怎么将UserDao怎样注入到Userservice内部呢?</strong></p><p><strong>构造方法</strong></p><p><strong>set方法</strong></p><h2 id="3-7-Bean的依赖注入方式-1"><a href="#3-7-Bean的依赖注入方式-1" class="headerlink" title="3.7 Bean的依赖注入方式"></a>3.7 Bean的依赖注入方式</h2><p><strong>1.set方法注入</strong></p><p><strong>p命名空间注入本质也是set方法注入,但比起上述的set方法注入更加防便,主要体现在配置文件中,如下:首先,需要引入P命名空间:</strong></p><p><strong>xmlns:p&#x3D;”<a href="http://www.springframework.org/schema/p">http://www.springframework.org/schema/p</a></strong></p><p><strong>其次,需要修改注入方式</strong></p><bean id="userService" class="com.itheima.service.impl.UserService Impl" p: userDao-ref="userDao"/><h2 id="3-8-Bean的依赖注入的数据类型"><a href="#3-8-Bean的依赖注入的数据类型" class="headerlink" title="3.8 Bean的依赖注入的数据类型"></a>3.8 Bean的依赖注入的数据类型</h2><p><strong>上面的操作,都是注入的引用Bean,除了对象的引用可以注入,普通数据类型,集合等都可以在容器中进行注入</strong></p><p><strong>注入数据的三种数据类型</strong></p><p><strong>普通数据类型</strong></p><p><strong>引用数据类型</strong></p><p><strong>集合数据类型</strong></p><h2 id="3-9引入其他配置文件-分模块开发"><a href="#3-9引入其他配置文件-分模块开发" class="headerlink" title="3.9引入其他配置文件(分模块开发)"></a>3.9引入其他配置文件(分模块开发)</h2><p><strong>实际开发中, Spring的配置内容非常多,这就导致Spring配置很繁杂目体积很大,所以,可以将部分配置拆解到其他配置文件中,而在Spring主配置文件通过import标签进行加载</strong></p><import resource="applicationContext-xxx.xml"/><h2 id="3-6知识要点"><a href="#3-6知识要点" class="headerlink" title="3.6知识要点"></a>3.6知识要点</h2><p><strong>Spring的重点配置</strong></p><p><strong><bean>标签</strong></p><p><strong>id属性:在容器中Bean实例的唯一标识,不允许重复</strong></p><p><strong>class属性:要实例化的Bean的全限定名</strong></p><p><strong>scope属性:Bean的作用范围,常用是singleton (默认)和prototype</strong></p><p><strong><property>标签:属性注入</strong></p><p><strong>name属性:属性名称</strong></p><p><strong>value属性:注入的普通属性值</strong></p><p><strong>ref属性:注入的对象引用值</strong></p><p><strong><list>标签</strong></p><p><strong>1.<map>标签</strong></p><p><strong><properties>标签</strong></p><p><strong><constructor-arg>标签</strong></p><p><strong><import>标签:导入其他的Spring的分文件</strong></p><h1 id="4-Spring相API"><a href="#4-Spring相API" class="headerlink" title="4.Spring相API"></a>4.Spring相API</h1><h2 id="4-1-ApplicationContext继承体系"><a href="#4-1-ApplicationContext继承体系" class="headerlink" title="4.1 ApplicationContext继承体系"></a>4.1 ApplicationContext继承体系</h2><p><strong>applicationContext:接口类型,代表应用上下文,可以通过其实例获得Spring容器中的Bean对象</strong></p><p><img src="C:\Users\24861\Desktop\11.JPG" alt="11"></p><h2 id="4-2-ApplicationContext的实现类"><a href="#4-2-ApplicationContext的实现类" class="headerlink" title="4.2 ApplicationContext的实现类"></a>4.2 ApplicationContext的实现类</h2><p><strong>ClassPathXmlApplicationContext</strong></p><p><strong>它是从类的根路径下加载配置文件推荐使用这种</strong></p><p> <strong>FileSystemXmlApplicationContext</strong></p><p><strong>它是从磁盘路径上加载配置文件,配置文件可以在磁盘的任意位置。</strong></p><p><strong>AnnotationConfigApplicationContext</strong></p><p><strong>当使用注解配置容器对象时,需要使用此类来创健spring容器。它用来读取注解。</strong></p><h2 id="4-3-getBean-方法使用"><a href="#4-3-getBean-方法使用" class="headerlink" title="4.3 getBean()方法使用"></a>4.3 getBean()方法使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">获取id形式</span><br><span class="line"><span class="keyword">public</span> object <span class="title function_">getBean</span><span class="params">(string name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    assertBeanEactorvactive ();</span><br><span class="line">    <span class="keyword">return</span> getBeanFactory().getBean(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    assertBeanFactorvActive();</span><br><span class="line">    <span class="keyword">return</span> getBeanFactory().getBean (requiredType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其中,当参数的数据类型是字符串时,表示根据Bean的id从容器中获得Bean实例,返回是Object,需要强转。当参数的数据类型是Class类型时,表示根据类型从容器中匹配Bean实例,当容器中相同类型的Bean有多个时则此方法会报错。</strong></p><h2 id="4-4知识要点"><a href="#4-4知识要点" class="headerlink" title="4.4知识要点"></a>4.4知识要点</h2><h3 id="Spring的重点API"><a href="#Spring的重点API" class="headerlink" title="Spring的重点API"></a>Spring的重点API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">classpathxmlApplicationContext</span> (<span class="string">&quot;xml文件&quot;</span>)</span><br><span class="line">    app.getBean (<span class="string">&quot;id&quot;</span>)</span><br><span class="line">    app.getBean (Class)</span><br></pre></td></tr></table></figure><h1 id="1-Spring配置数据源"><a href="#1-Spring配置数据源" class="headerlink" title="1.Spring配置数据源"></a>1.Spring配置数据源</h1><h2 id="1-1数据源-连接池-的作用"><a href="#1-1数据源-连接池-的作用" class="headerlink" title="1.1数据源(连接池)的作用"></a>1.1数据源(连接池)的作用</h2><p><strong>数据源(连接池)是提高程序性能如出现的</strong></p><p><strong>事先实例化数据源,初始化部分连接资源</strong></p><p><strong>使用连接资源时从数据源中获取</strong></p><p><strong>使用完毕后将连接资源还给数据源</strong></p><p><strong>常见的数据源(连接池): DBCP, C3P0, BoneCP, Druid等</strong></p><h2 id="1-1数据源的开发步骤"><a href="#1-1数据源的开发步骤" class="headerlink" title="1.1数据源的开发步骤"></a>1.1数据源的开发步骤</h2><p><strong>导入数据源的坐标和数据库驱动坐标</strong></p><p><strong>创建数据源对象</strong></p><p><strong>设置数据源的基本连接数据</strong></p><p><strong>使用数据源获取连接资源和归还连接资源</strong></p><h2 id="1-2数据源的手动创建"><a href="#1-2数据源的手动创建" class="headerlink" title="1.2数据源的手动创建"></a>1.2数据源的手动创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSouceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//测试手动创建c3p0数据源(加载properties配置文件)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//读取配置文件</span></span><br><span class="line">        <span class="type">ResourceBundle</span> <span class="variable">rb</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;jdbc&quot;</span>);</span><br><span class="line">        String driver= rb.getString(<span class="string">&quot;jdbc.driver&quot;</span>);</span><br><span class="line">        String url=rb.getString(<span class="string">&quot;jdbc.url&quot;</span>);</span><br><span class="line">        String username=rb.getString(<span class="string">&quot;jdbc.username&quot;</span>);</span><br><span class="line">        String password= rb.getString(<span class="string">&quot;jdbc.password&quot;</span>);</span><br><span class="line">    <span class="comment">//创建数据源对象</span></span><br><span class="line">        ComboPooledDataSource dataSource=<span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">        dataSource.setDriverClass(driver);</span><br><span class="line">        dataSource.setJdbcUrl(url);</span><br><span class="line">        dataSource.setUser(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//测试手动创建druid数据源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        DruidDataSource dataSource=<span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/db1&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="type">DruidPooledConnection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//测试手动创建c3p0数据源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> PropertyVetoException, SQLException &#123;</span><br><span class="line">        ComboPooledDataSource dataSource=<span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">        dataSource.setDriverClass(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/db1&quot;</span>);</span><br><span class="line">        dataSource.setUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        Connection connection=dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//localhost:3306/db1</span></span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=<span class="number">123456</span></span><br></pre></td></tr></table></figure><h2 id="1-3-Spring配置数据源"><a href="#1-3-Spring配置数据源" class="headerlink" title="1.3 Spring配置数据源"></a>1.3 Spring配置数据源</h2><p><strong>可以将DataSource的创建权交由Spring容器去完成</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSouceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//测试spring容器去产生数据源对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        ApplicationContext app=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContent.xml&quot;</span>);</span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> app.getBean(DataSource.class);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSouce&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/db1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-4抽取jdbc配置文件"><a href="#1-4抽取jdbc配置文件" class="headerlink" title="1.4抽取jdbc配置文件"></a>1.4抽取jdbc配置文件</h2><p><strong>applicationContext.xml加载jdbc.properties配置文件获得连接信息。</strong></p><p><strong>首先,需要引入context命名空间和约束路径:</strong></p><p><strong>命名空间:</strong> </p><p><strong>xmlns:context&#x3D;”<a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a>“</strong></p><p><strong>约束路径:</strong> </p><p><strong><a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a></strong></p><p><strong><a href="http://www.springframework.org/schema/context/spring-context.xsd">http://www.springframework.org/schema/context/spring-context.xsd</a></strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath: jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource &quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">names</span>&quot;<span class="attr">jdbaUrl</span>&quot; <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdba.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-5知识要点"><a href="#1-5知识要点" class="headerlink" title="1.5知识要点"></a>1.5知识要点</h2><p><strong>Spring容器加载properties文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context</span> <span class="attr">:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;xx.properties&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;key&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h1 id="2-Spring注解开发"><a href="#2-Spring注解开发" class="headerlink" title="2.Spring注解开发"></a>2.Spring注解开发</h1><h2 id="2-1-Spring原始注解"><a href="#2-1-Spring原始注解" class="headerlink" title="2.1 Spring原始注解"></a>2.1 Spring原始注解</h2><p><strong>Spring是轻代码而重配置的框架,配置比较繁重,影响开发效率,所以注解开发是一种趋势,注解代替xml配置文件可以简化配置,提高开发效率。</strong></p><p><strong>Spring原始注解主要是替代<Bean>的配置</strong></p><p><strong>注解说明</strong></p><p><strong>@Component使用在类上用于实例化Bean</strong></p><p><strong>@Controller使用在web层类上用于实例化Bean</strong></p><p><strong>@Service使用在service层类上用于实例化Bean</strong></p><p><strong>@Repository使用在dao层类上用于实例化Bean</strong></p><p><strong>@Autowired使用在字段上用于根据类型依赖注入</strong></p><p><strong>@Qualifier结合@Autowired一起使用用于根据名称进行依赖注入</strong></p><p><strong>@Resource相当于@Autowired+@Qualifier,按照名称进行注入</strong></p><p> <strong>@Value注入普通属性</strong></p><p><strong>@Scope标注Bean的作用范围</strong></p><p><strong>@PostConstruct使用在方法上标注该方法是Bean的初始化方法</strong></p><p><strong>@PreDestroy使用在方法上标注该方法是Bean的销毁方法</strong></p><p><strong>注意:使用注解进行开发时,需要在applicationContext.xml中配置组件扫描,作用是指定哪个包及其子包下的Bean需要进行扫描以便识别使用注解配置的类、字段和方法。</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注解的组件扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context</span> <span class="attr">:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="2-Spring注解开发-1"><a href="#2-Spring注解开发-1" class="headerlink" title="2.Spring注解开发"></a>2.Spring注解开发</h1><h2 id="2-2-Spring新注解"><a href="#2-2-Spring新注解" class="headerlink" title="2.2 Spring新注解"></a>2.2 Spring新注解</h2><p><strong>使用上面的注解还不能全部替代xml配置文件,还需要使用注解替代的配置如下:</strong></p><p><strong>非自定义的Bean的配置:<bean></strong></p><p><strong>加载properties文件的配置:<a href="context:property-placeholder">context:property-placeholder</a></strong></p><p>**组件扫描的配置: <a href="context:component-scan**">context:component-scan**</a></p><p><strong>引入其他文件: <import></strong></p><p>​<strong>注解说明</strong></p><p><strong>@Configuration用于指定当前类是一个Spring配置类,当创建容器时会从该类上加载注解</strong></p><p><strong>@ComponentScan用于指定Spring在初始化容器时要扫描的包。</strong></p><p>​<strong>作用和在Spring的xml配置文件中的</strong></p><p>​<strong>&lt;context:component-scan base-package&#x3D;”com.itheima’&#x2F;&gt;一样</strong></p><p><strong>@Bean使用在方法上,标注将该方法的返回值存储到Spring容器中</strong></p><p><strong>@PropertySource用于加载.properties文件中的配置</strong></p><p><strong>@lmport用于导入其他配置类</strong></p><h1 id="3-Spring集成Junit"><a href="#3-Spring集成Junit" class="headerlink" title="3.Spring集成Junit"></a>3.Spring集成Junit</h1><h2 id="3-1原始Junit测试Spring的问题"><a href="#3-1原始Junit测试Spring的问题" class="headerlink" title="3.1原始Junit测试Spring的问题"></a>3.1原始Junit测试Spring的问题</h2><p><strong>在测试类中,每个测试方法都有以下两行代码:</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext app=<span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> app.getBean(<span class="string">&quot;accountService&quot;</span>,IAccountService.class);</span><br></pre></td></tr></table></figure><p><strong>这两行代码的作用是获取容器,如果不写的话,直接会提示空指针异常。所以又不能轻易删掉</strong></p><h2 id="3-2上述问题解决思路"><a href="#3-2上述问题解决思路" class="headerlink" title="3.2上述问题解决思路"></a>3.2上述问题解决思路</h2><p><strong>让SpringJunit负责创建Spring容器,但是需要将配置文件的名称告诉它</strong></p><p><strong>将需要进行测试Bean直接在测试类中进行注入</strong></p><h2 id="3-3-Spring集成Junit步骤"><a href="#3-3-Spring集成Junit步骤" class="headerlink" title="3.3 Spring集成Junit步骤"></a>3.3 Spring集成Junit步骤</h2><p><strong>导入spring集成Junit的坐标</strong></p><p><strong>使用@Runwith注解替换原来的运行期</strong></p><p><strong>使用@ContextConfiguration指定配置文件或配置类</strong></p><p><strong>使用@Autowired注入需要测试的对象</strong></p><p><strong>创建测试方法进行测试</strong> </p><h1 id="1-Spring集成web环境"><a href="#1-Spring集成web环境" class="headerlink" title="1.Spring集成web环境"></a>1.Spring集成web环境</h1><h2 id="1-1-ApplicationContext应用上下文获取方式"><a href="#1-1-ApplicationContext应用上下文获取方式" class="headerlink" title="1.1 ApplicationContext应用上下文获取方式"></a>1.1 ApplicationContext应用上下文获取方式</h2><p><strong>应用上下文对象是通过new ClasspathXmlApplicationContext(spring配置文件)方式获取的,但是每次从容器中获得Bean时都要编写new ClasspathXmlApplicationContext(spring配置文件),这样的弊端是配置文件加载多次,应用上下文对象创建多次。</strong></p><p><strong>在Web项目中,可以使用ServletContextListener监听Web应用的启动,我们可以在Web应用启动时,就加载Spring的配置文件,创建应用上下文对象ApplicationContext,在将其存储到最大的域servletContexttd中,这样就可以在任意位置从域中获得应用上下文ApplicationContext对象了。</strong></p><h2 id="1-2-Spring提供获取应用上下文的工具"><a href="#1-2-Spring提供获取应用上下文的工具" class="headerlink" title="1.2 Spring提供获取应用上下文的工具"></a>1.2 Spring提供获取应用上下文的工具</h2><p><strong>上面的分析不用手动实现, Spring提供了一个监听器ContextLoaderListener就是对上述功能的封装,该监听器内部加载Spring配置文件,创建应用上下文对象,并存储到ServletContext域中,提供了一个客户端工具WebApplicationContextUtils供使用者获得应用上下文对象。</strong> </p><p><strong>所以我们需要做的只有两件事:</strong></p><p><strong>① 在web.xml中配置ContextLoaderListener监听器(导入spring-web坐标)</strong></p><p><strong>② 使用WebApplicationContextUtils获应用上下文对象ApplicationContext</strong></p><h2 id="1-3导入Spring集成web的坐标"><a href="#1-3导入Spring集成web的坐标" class="headerlink" title="1.3导入Spring集成web的坐标"></a>1.3导入Spring集成web的坐标</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependenoy</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br></pre></td></tr></table></figure><h2 id="1-4-配置ContextLoaderListener监听器"><a href="#1-4-配置ContextLoaderListener监听器" class="headerlink" title="1.4 配置ContextLoaderListener监听器"></a>1.4 配置ContextLoaderListener监听器</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--全局参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationcontext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Spring的监听器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">        org. springframework.web.context.Context LoaderListener</span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-5通过工具获得应用上下文对象"><a href="#1-5通过工具获得应用上下文对象" class="headerlink" title="1.5通过工具获得应用上下文对象"></a>1.5通过工具获得应用上下文对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span>webapplicationcontextutils.getwebApplicationContext(servletcontext);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> applicationContext.getBean (<span class="string">&quot;id&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="1-5知识要点-1"><a href="#1-5知识要点-1" class="headerlink" title="1.5知识要点"></a>1.5知识要点</h2><p><strong>Spring集成web环境步骤</strong></p><p><strong>①配置GontextLoaderListener监听器</strong></p><p><strong>②使用WebApplicationContextUtils获得应用上下文</strong></p><h1 id="2-SpringMVC-简介"><a href="#2-SpringMVC-简介" class="headerlink" title="2.SpringMVC 简介"></a>2.SpringMVC 简介</h1><h2 id="2-1-SpringMVC概述"><a href="#2-1-SpringMVC概述" class="headerlink" title="2.1 SpringMVC概述"></a>2.1 SpringMVC概述</h2><p><strong>SpringMVC是一种基于Java的实现MVC设计模型的请求驱动类型的轻量级Web框架,属于SpringFrameWork的后续产品,已经融合在Spring Web Flow中。</strong></p><p><strong>模型-视图-控制</strong></p><p><strong>SpringMVC已经成为目前最主流的MVC框架之一,并且随着Spring3.0的发布,全面超越Struts2,成为最优秀的MVC框架。它通过一套注解,让一个简单的Java类成为处理请求的控制器,而无须实现任何接口。同时它还支持RESTful编程风格的请求。</strong></p><h2 id="2-3-SpringMVC快速入门"><a href="#2-3-SpringMVC快速入门" class="headerlink" title="2.3 SpringMVC快速入门"></a>2.3 SpringMVC快速入门</h2><p><strong>需求:客户端发起请求,服务器端接收请求,执行逻辑并进行视图跳转。</strong></p><p><strong>开发步骤:</strong></p><p><strong>①导入SpringMVC相关坐标</strong></p><p><strong>② 配置SpringMVC核心控制器DispathcerServlet</strong></p><p><strong>3.创建Controller类和视图页面</strong></p><p><strong>4.使用注解配置Controller类中业务方法的映射地址</strong></p><p><strong>5.配置SpringMVC核心文件spring-mvc.xml</strong></p><p><strong>6.客户端发起请求测试</strong></p><h1 id="3-SpringMVC-组件解析"><a href="#3-SpringMVC-组件解析" class="headerlink" title="3.SpringMVC 组件解析"></a>3.SpringMVC 组件解析</h1><h2 id="3-1-SpringMVC的执行流程"><a href="#3-1-SpringMVC的执行流程" class="headerlink" title="3.1 SpringMVC的执行流程"></a>3.1 SpringMVC的执行流程</h2><p><strong>①用户发送请求至前端控制器DispatcherServlet,</strong></p><p><strong>② DispatcherServlet收到请求调用HandlerMapping处理器映射器。</strong> </p><p><strong>③处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找),生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet,</strong></p><p><strong>4.DispatcherServlet调用HandlerAdapter处理器适配器。</strong></p><p><strong>5.HandlerAdapter经过适配调用具体的处理器(Controller, 也叫后端控制器)。</strong></p><p><strong>6 Controller执行完成返回ModelAndView.</strong></p><p><strong>7.HandlerAdaptercontroller执行结果ModelAndView返回给DispatcherServlet.</strong></p><p><strong>8.DispatcherServletModelAndView传给ViewReslover视图解析器。</strong></p><p><strong>9.ViewReslover解析后返回具体View.</strong></p><p><strong>10.DispatcherServlet根据View进行演染视图(即将模型数据填充至视图中) .DispatcherServlet响应用户。</strong></p><h2 id="3-3-SpringMVC注解解析"><a href="#3-3-SpringMVC注解解析" class="headerlink" title="3.3 SpringMVC注解解析"></a>3.3 SpringMVC注解解析</h2><p><strong>@RequestMapping</strong></p><p><strong>作用:用于建立请求URL和处理请求方法之间的对应关系</strong></p><p><strong>位置:.</strong></p><p><strong>类上,请求URL的第一级访问目录。此处不写的话,就相当于应用的根目录.</strong></p><p><strong>方法上,请求URL的第二级访问目录,与类上的使用@ReqquestMapping标注的一级目录一起组成访问虚拟路径属性:</strong></p><p><strong>.value:用于指定请求的URL.它和path属性的作用是一样的</strong></p><p><strong>.method:用于指定请求的方式</strong></p><p><strong>.params:用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和(value必须和配置的一模一样</strong></p><p><strong>params &#x3D; [“accountName”), 表示请求参数必须有accountName</strong></p><p><strong>params &#x3D; [“moeny!100”), 表示请求参数中money不能是100</strong></p><p><strong>1.mvc命名空间引入</strong></p><p><strong>命名空:xmlns: context&#x3D;”<a href="http://www.springframework.org/schema/context%22xmlns:mvc=%22http://www.springframework.org/schema/mvo">http://www.springframework.org/schema/context&quot;xmlns:mvc=&quot;http://www.springframework.org/schema/mvo</a>“</strong></p><p><strong>约束地址: <a href="http://www/">http://www</a>. springframework. org&#x2F;schema&#x2F;contexthttp: &#x2F;&#x2F;www. springframework.org&#x2F;schema&#x2F;aontext&#x2F;spring-aontext. xsdhttp: &#x2F;&#x2F;<a href="http://www.springframework/">www.springframework</a>. org&#x2F;schema&#x2F;mva<a href="http://www.apringframework.org/schema/mvo/spring-mva">http://www.apringframework.org/schema/mvo/spring-mva</a>. xad</strong></p><p><strong>2.组件扫描</strong></p><p><strong>springMvc基于spring容器,所以在进行springMVc操作时,需要将controller存储到spring容器中,如果使用econtroller注解标注的话,就需要使用</strong></p><p><strong>&lt;context:component-scan basepackage&#x3D;”com. itheima. controller”&#x2F;&gt;进行组件扫描。</strong></p><h2 id="3-4-SpringMVC的XML配置解析"><a href="#3-4-SpringMVC的XML配置解析" class="headerlink" title="3.4 SpringMVC的XML配置解析"></a>3.4 SpringMVC的XML配置解析</h2><p><strong>1.视图解析器</strong></p><p><strong>SpringMVc有默认组件配置,默认组件都是DispatcherServlet.properties配置文件中配置的,该配置文件地址org&#x2F;springframework&#x2F;web&#x2F;servlet&#x2F;DispatcherServlet.properties,该文件中配置了默认的视图解析器,如下:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.web.servlet. ViewResolver=org.springframework. web.servlet.view.InternalResourceViewResolver</span><br></pre></td></tr></table></figure><p><strong>翻看该解析器源码,可以看到该解析器的默认设置,如下:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">REDIRECT_URL_PREFIX = &quot;redireat:&quot; --重定前缀</span><br><span class="line">FORWARD_URL_PREFIx = &quot;forward:&quot; --转发前缀(默认值)</span><br><span class="line">prefix = &quot;&quot;; --视图名称前缀</span><br><span class="line">suffix =&quot;&quot;;--视图名称后缀</span><br></pre></td></tr></table></figure><h2 id="3-5-知识要点"><a href="#3-5-知识要点" class="headerlink" title="3.5 知识要点"></a>3.5 知识要点</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SpringMVC的相关组件</span><br><span class="line">前端控制器: DispatcherServlet</span><br><span class="line">处理器映射器: HandlerMapping</span><br><span class="line">处理器适配器: HandlerAdapter</span><br><span class="line">处理器: Handler</span><br><span class="line">视图解析器: View Resolver</span><br><span class="line">视图: View</span><br><span class="line">SpringMVC的注解和配置</span><br><span class="line">请求映射注解: @RequestMapping</span><br><span class="line">视图解析器配置:</span><br><span class="line">REDIRECT_URL_PREFIX = &quot;redirect:&quot;</span><br><span class="line">FORWARD_URL_PREFIX = &quot;forward:&quot;</span><br><span class="line">prefix= &quot;&quot;</span><br><span class="line">suffix= &quot;&quot;</span><br></pre></td></tr></table></figure><h1 id="1-SpringMVC的数据响应"><a href="#1-SpringMVC的数据响应" class="headerlink" title="1.SpringMVC的数据响应"></a>1.SpringMVC的数据响应</h1><h2 id="1-1-SpringMVC的数据响应方式"><a href="#1-1-SpringMVC的数据响应方式" class="headerlink" title="1.1 SpringMVC的数据响应方式"></a>1.1 SpringMVC的数据响应方式</h2><p><strong>1)页面跳转.</strong></p><p><strong>直接返回字符串</strong></p><p><strong>通过ModelAndView对象返回</strong></p><p><strong>2)回写数据</strong></p><p><strong>直接返回字符串</strong></p><p><strong>返回对象或集合</strong></p><h2 id="1-2页面跳转"><a href="#1-2页面跳转" class="headerlink" title="1.2页面跳转"></a>1.2页面跳转</h2><p><strong>1.返回字符串形式直接返回字符串:此种方式会将返回的字符串与视图解析器的前后缀拼接后跳转。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span> (<span class="string">&quot;/quiak&quot;</span>)</span><br><span class="line">publia string <span class="title function_">quickMethod</span> <span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INE/views/&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>转发资源地址: &#x2F;WEB-INE&#x2F;views&#x2F;index.jsp</strong></p><p><strong>返回带有前缀的字符串:</strong></p><p><strong>转发: forward:&#x2F;WEB-INE&#x2F;views&#x2F;index. jsp</strong></p><p><strong>重定向: redirect:&#x2F;index. jsp</strong></p><p><strong>2.返回ModelAndView对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/quick4&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save4</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;博学谷&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/quick3&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">save3</span><span class="params">(ModelAndView modelAndView)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置模型数据</span></span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;itheima555&quot;</span>);</span><br><span class="line">        <span class="comment">//设置视图名称</span></span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/quick2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">save2</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//        Model:模型作用封装数据</span></span><br><span class="line"><span class="comment">//        view:作用展示数据</span></span><br><span class="line">      ModelAndView modelAndView= <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">      <span class="comment">//设置模型数据</span></span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;itcat&quot;</span>);</span><br><span class="line">      <span class="comment">//设置视图名称</span></span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//请求映射 请求地址http://local:8080/user/quick</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/quick&quot;,method = RequestMethod.GET,params = &#123;&quot;username&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;controller save running web&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-3回写数据"><a href="#1-3回写数据" class="headerlink" title="1.3回写数据"></a>1.3回写数据</h2><p><strong>1.直接返回字符串</strong></p><p><strong>Web基础阶段,客户端访问服务器端,如果想直接回写字符串作为响应体返回的话,只需要使用response.getWriter().print( “hello world” )即可,那么在Controller中想直接回写字符串该怎样呢?</strong></p><p><strong>通过SpringMVC框架注入的response对象,使用response.getWriterO.print( “hello world” )回写数据,此时不需要视图跳转,业务方法返回值为void.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span> (<span class="string">&quot;/quick4&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickMethod4</span> <span class="params">(Httpserfletresponse response)</span> throwsIOException&#123;</span><br><span class="line">    response.getwriter().print (<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>将需要回写的字符串直接返回,但此时需要通过@ResponseBody注解告知SpringMVC框架,方法返回的字符串不是跳转是直接在http响应体中返回。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span> (<span class="string">&quot;/quick5&quot;</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> string <span class="title function_">quickMethod5</span> <span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello springMVC!!!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.返回对象或集合</strong></p><p><strong>通过SpringMVC帮助我们对对象或集合进行json字符串的转换并回写,为处理器适配器配置消息转换参数,指定使用jackson进行对象或集合的转换,因此需要在spring-mvc.xml中进行如下配置:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>在方法上添加@ResponseBody就可以返回json格式的字符串,但是这样配置比较麻烦,配置的代码比较多,因此,我们可以使用mvc的注解驱动代替上述配置。</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mvc的注解驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:</span> <span class="attr">annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>在SpringMVC的各个组件中,处理器映射器、处理器适配器、视图解析器称为SpringMVC的三大组件。使用<a href="mvc:annotation-driven">mvc:annotation-driven</a>自动加载 RequestMappingHandlerMapping (处理映射器)和RequestMappingHandlerAdapter (处理适配器),可用在Spring-xml.xml配置文件中使用<a href="mvc:annotation-driven">mvc:annotation-driven</a>替代注解处理器和适配器的配置。同时使用<a href="mvc:annotation-driven">mvc:annotation-driven</a>默认底层就会集成jackson进行对象或集合的json格式字符串的转换。</strong></p><h2 id="1-4-知识要点"><a href="#1-4-知识要点" class="headerlink" title="1.4 知识要点"></a>1.4 知识要点</h2><p><strong>SpringMVC的数据响应方式</strong></p><p><strong>1)页面跳转</strong></p><p><strong>.直接返回字符</strong></p><p><strong>.通过ModelAndView对象返回</strong></p><p><strong>2)回写数据</strong></p><p><strong>.直接返回字符串</strong></p><p><strong>.返回对象或集合</strong></p><h1 id="2-SpringMVC-获得请求数据"><a href="#2-SpringMVC-获得请求数据" class="headerlink" title="2.SpringMVC 获得请求数据"></a>2.SpringMVC 获得请求数据</h1><h2 id="2-1获得请求参数"><a href="#2-1获得请求参数" class="headerlink" title="2.1获得请求参数"></a>2.1获得请求参数</h2><p><strong>客户端请求参数的格式是: name&#x3D;value&amp;name&#x3D;value……</strong></p><p><strong>服务器端要获得请求的参数,有时还需要进行数据的封装, SpringMVC可以接收如下类型的参数:</strong></p><p><strong>基本类型参数</strong></p><p><strong>POJO类型参数</strong></p><p><strong>数组类型参数</strong></p><p><strong>集合类型参数</strong></p><h2 id="2-2获得基本类型参数"><a href="#2-2获得基本类型参数" class="headerlink" title="2.2获得基本类型参数"></a>2.2获得基本类型参数</h2><p><strong>Controller中的业务方法的参数名称要与请求参数的name一致,参数值会自动映射匹配。</strong></p><p><strong><a href="http://localhost:8080/itheima_springmvcl/quick9?username=zhangsan&age=12">http://localhost:8080/itheima_springmvcl/quick9?username=zhangsan&amp;age=12</a></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span> (<span class="string">&quot;/quick9&quot;</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickMethod9</span> <span class="params">(String username, <span class="type">int</span> age)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println (username);</span><br><span class="line">    System.out.println (age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-获得POJO类型参数"><a href="#2-3-获得POJO类型参数" class="headerlink" title="2.3 获得POJO类型参数"></a>2.3 获得POJO类型参数</h2><p><strong>Controller中的业务方法的POJO参数的属性名与请求参数的name一致,参数值会自动映射匹配。</strong></p><p><strong>http;&#x2F;&#x2F;loca1host: 8080&#x2F;itheima springmvc1&#x2F;quick9?cname&#x3D;zhangsan&amp;age&#x3D;12</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    getter/setter...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapsing</span> (<span class="string">&quot;/quick10&quot;</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickMethod10</span> <span class="params">(User user)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println (user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4获得数组类型参数"><a href="#2-4获得数组类型参数" class="headerlink" title="2.4获得数组类型参数"></a>2.4获得数组类型参数</h2><p><strong>Controller中的业务方法数组名称与请求参数的name致,参数值会自动映射匹配。</strong></p><p><a href="http://localhost:8080/itheima_springmvc1/quick11?strs=111&strs=222&strs=333">http://localhost:8080/itheima_springmvc1/quick11?strs=111&amp;strs=222&amp;strs=333</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span> (<span class="string">&quot;/quick11&quot;</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickMethod11</span> <span class="params">(String [] strs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println (Arrays.asList (strs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5获得集合类型参数"><a href="#2-5获得集合类型参数" class="headerlink" title="2.5获得集合类型参数"></a>2.5获得集合类型参数</h2><p><strong>获得集合参数时,要将集合参数包装到一个POJO中才可以。</strong></p><p><strong>当使用ajax提交时,可以指定contentType为json形式,那么在方法参数位置使用@RequestBody可以直接接收集合数据而无需使用POJO进行包装。</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> &lt;script src=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/js/jqury.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> userList=<span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    userList.push(&#123;username:<span class="string">&quot;zhangsan&quot;</span>,age:<span class="string">&quot;18&quot;</span>&#125;)</span><br><span class="line">    userList.push(&#123;username:<span class="string">&quot;lisi&quot;</span>,age:<span class="string">&quot;30&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">        url:<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/user/quick15&quot;</span>,</span><br><span class="line">        data:JSON.stringify(userList),</span><br><span class="line">        contentType:<span class="string">&quot;application/json;charset=utf-8&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="2-6请求数据乱码问题"><a href="#2-6请求数据乱码问题" class="headerlink" title="2.6请求数据乱码问题"></a>2.6请求数据乱码问题</h2><p><strong>当post请求时,数据会出现乱码,我们可以设置一个过滤器来进行编码的过滤。</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Characterencodingrilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web. filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-7-参数定注解-requestParam"><a href="#2-7-参数定注解-requestParam" class="headerlink" title="2.7 参数定注解@requestParam"></a>2.7 参数定注解@requestParam</h2><p><strong>当请求的参数名称与Controller的业务方法参数名称不一致时,就需要通过@RequestParam注解显示的绑定。</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;$(pageContext.request.contextPath]/quick14&quot;</span> method= <span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot; text&quot;</span> name=<span class="string">&quot; name &quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot; submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span> (<span class="string">&quot;/quick14&quot;</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickMethod14</span> <span class="params">(<span class="meta">@RequestParam</span> (<span class="string">&quot;name&quot;</span>)</span> String username) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println (username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注解@RequestParam还有如下参数可以使用:</strong></p><p><strong>.value:与请求参数名称</strong></p><p><strong>.required:此在指定的请求参数是否必须包括,默认是true,提交时如果没有此参数则报错</strong></p><p><strong>.defaultValue:当没有指定请求参数时,则使用指定的默认值赋值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span> (<span class="string">&quot;/quick14&quot;</span>)<span class="meta">@ResponseBodypublic</span> <span class="keyword">void</span> <span class="title function_">quickMethod14</span> <span class="params">(<span class="meta">@RequestParam</span> (value=<span class="string">&quot;name&quot;</span>, required= <span class="literal">false</span>, defaultvalue = <span class="string">&quot;itcast&quot;</span>)</span> string username) <span class="keyword">throws</span> IOException &#123; System.out.println (username);&#125;</span><br></pre></td></tr></table></figure><h2 id="2-8-获得Restful风格的参数"><a href="#2-8-获得Restful风格的参数" class="headerlink" title="2.8 获得Restful风格的参数"></a>2.8 获得Restful风格的参数</h2><p><strong>Restful是一种软件架构风格、设计风格,而不是标准,只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件,基于这个风格设计的软件可以更简洁,更有层次,更易于实现缓存机制等。</strong></p><p><strong>Restful风格的请求是使用”url+请求方式”表示一次请求目的的,HTTP协议里面四个表示操作方式的动词如下:</strong></p><p><strong>.GET:用于获取资源</strong></p><p><strong>.POST:用于新建资源</strong></p><p><strong>.PUT:用于更新资源</strong></p><p><strong>.DELETE:用于删除资源</strong></p><p><strong>例如:</strong></p><p><strong>&#x2F;user&#x2F;1 GET: 得到id &#x3D; 1的user</strong></p><p><strong>&#x2F;user&#x2F;1 DELETE: 删除id &#x3D; 1的user</strong></p><p><strong>&#x2F;user&#x2F;1 PUT: 更新id &#x3D; 1的user</strong></p><p><strong>&#x2F;user&#x2F;1POST: 新增user</strong></p><p><strong>上述url地址&#x2F;user&#x2F;1中的1就是要获得的请求参数,在SpringMVC中可以使用占位符进行参数绑定。地址&#x2F;user&#x2F;1可以写成&#x2F;user&#x2F;(id),占位符(id对应的就是1的值。在业务方法中我们可以使用@PathVariable注解进行占位符的匹配获取工作。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost: 8080/itheima_springmvc1/quick19/zhangsan</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span> (<span class="string">&quot;/quick19/&#123;name&#125;&quot;</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickMethod19</span> <span class="params">(<span class="meta">@Pathvariable</span> (value=<span class="string">&quot;name &quot;</span>required = <span class="literal">true</span>)</span> string name) &#123;</span><br><span class="line">          System.out.println(name);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h2 id="2-9自定义类型转换器"><a href="#2-9自定义类型转换器" class="headerlink" title="2.9自定义类型转换器"></a>2.9自定义类型转换器</h2><p><strong>SpringMVC默认已经提供了一些常用的类型转换器,例如客户端提交的字符串转换成int型进行参数设置。</strong></p><p><strong>但是不是所有的数据类型都提供了转换器,没有提供的就需要自定义转换器,例如:日期类型的数据就需要自定义转换器。</strong></p><p><strong>自定义类型转换器的开发步骤:</strong></p><p><strong>①定义转换器类实现Converter接口</strong></p><p><strong>②在配置文件中声明转换器</strong></p><p><strong>③在<annotation-driven>中引用转换器</strong></p><h2 id="2-10-获得Servlet相关API"><a href="#2-10-获得Servlet相关API" class="headerlink" title="2.10 获得Servlet相关API"></a>2.10 获得Servlet相关API</h2><p><strong>SpringMVC支持使用原始ServletAPI对象作为控制器方法的参数进行注入,常用的对象如下:.</strong></p><p><strong>HttpServletRequest.</strong></p><p><strong>HttpServletResponse</strong></p><p><strong>HttpSession</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span> (<span class="string">&quot; /quick16&quot;</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickMethod16</span> <span class="params">(HttpservletRequest request, HttpservletResponse response,Httpsession session)</span> </span><br><span class="line">&#123;System.out.println (request) ;</span><br><span class="line">     System.out.println (response);</span><br><span class="line">     System. out.println (session);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h2 id="2-11获得请求头"><a href="#2-11获得请求头" class="headerlink" title="2.11获得请求头"></a>2.11获得请求头</h2><p><strong>1.@RequestHeader</strong></p><p><strong>使用@RequestHeader可以获得请求头信息,相当于web阶段学习的request.getHeader(name)</strong></p><p><strong>@RequestHeader注解的属性如下:</strong></p><p><strong>value:请求头的名称</strong></p><p><strong>required:是否必须携带此请求头</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span> (<span class="string">&quot;/quick17&quot;</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickMethod17</span><span class="params">(<span class="meta">@RequestHeader</span> (value = <span class="string">&quot;User-Agent&quot;</span>, required = <span class="literal">false</span>)</span> String headervalue) &#123;</span><br><span class="line">    System.out.println (headervalue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.@CookieValue</strong></p><p><strong>使用@CookieValue可以获得指定Cookie的值</strong></p><p><strong>@CookieValue注解的属性如下:</strong></p><p><strong>.value:指定cookie的名称</strong></p><p><strong>.required: 是否必须携带此cookie</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span> (<span class="string">&quot;/quick18&quot;</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickMethod18</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@cookievalue</span> (value = <span class="string">&quot;JSESSIONID&quot;</span>, required= <span class="literal">false</span>)</span> string jsessionid)&#123;</span><br><span class="line">    system.out.println (jsessiqgid);</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="2-12-文件上传"><a href="#2-12-文件上传" class="headerlink" title="2.12 文件上传"></a>2.12 文件上传</h2><p><strong>1.文件上传客户端三要素</strong></p><p><strong>表单项type&#x3D; “file”</strong></p><p><strong>表单的提交方式是post</strong></p><p><strong>表单的enctype属性是多部分表单形式,及enctype&#x3D; “multipart&#x2F;form-data”</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;$[pagecontext.request.contextPath]/quick20&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">    名称: &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name &quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    文件: &lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;file&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot; submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&lt;br&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p><strong>2.文件上传原理</strong></p><p><strong>.当form表单修改为多部分表单时,request.getParameterO将失效。</strong></p><p><strong>.enctype&#x3D; “application&#x2F;x-www-form-urlencoded” 时, form表单的正文内容格式是:key&#x3D;value&amp;key&#x3D;value&amp;key&#x3D;value.</strong></p><p><strong>当form表单的enctype取值为Mutilpart&#x2F;form-data时,请求正文内容就变成多部分形式:</strong></p><h2 id="2-13-单文件上传步骤"><a href="#2-13-单文件上传步骤" class="headerlink" title="2.13 单文件上传步骤"></a>2.13 单文件上传步骤</h2><p><strong>① 导入fileupload和io坐标</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactid</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactid</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactid</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactid</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>②配置文件上传解析器</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart. commons. CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--上传文件总大小--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxuploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5242800&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--上传单个文件的大小--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxuploadsizePerFile&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5242800&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--上传文件的编码类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>③编写文件上传代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span> (<span class="string">&quot;/quick20&quot;</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickMethod20</span> <span class="params">(string name, MultipartFile uploadFile)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//获得文件名称</span></span><br><span class="line">    <span class="type">string</span> <span class="variable">originalFilename</span> <span class="operator">=</span> uploadFile. getoriginalFilename ();</span><br><span class="line">    <span class="comment">//保存文件</span></span><br><span class="line">    uploadFile.transferTo (<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\upload\\&quot;</span>+originalFilename));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="2-15多文件上传实现"><a href="#2-15多文件上传实现" class="headerlink" title="2.15多文件上传实现"></a>2.15多文件上传实现</h2><p><strong>文件上传,只需要将页面修改为多个文件上传项,将方法参数MultipartFile类型修改为MultipartFile[]即可</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;多文件上传测试&lt;/h1&gt;    &lt;form action=<span class="string">&quot;$(pageContext.request.contextPath)/quick21&quot;</span> method= <span class="string">&quot;post&quot;</span>enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;    名称: &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name &quot;</span>&gt;&lt;br&gt;        文件<span class="number">1</span>: &lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;upladFiles&quot;</span>&gt;&lt;br&gt;            文件<span class="number">2</span>: &lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;uploadFiles&quot;</span>&gt;&lt;br&gt;                文件<span class="number">3</span>: &lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;uploadFiles&quot;</span>&gt;&lt;br&gt;                    &lt;input type=<span class="string">&quot; submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;&lt;br&gt; &lt;/form&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span> (<span class="string">&quot; /quick21&quot;</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickMethod21</span> <span class="params">(string name, Multipartrile [] uploadFiles)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">for</span> (MultipartFile uploadFile : uploadFiles) &#123;</span><br><span class="line">        <span class="type">string</span> <span class="variable">originalFilename</span> <span class="operator">=</span> uploadFile.getoriginalFilename ();</span><br><span class="line">        uploadFile.transferTo (<span class="keyword">new</span> <span class="title class_">File</span> (<span class="string">&quot;C:\\upload\\&quot;</span>+originalFilename));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-14-知识要点"><a href="#2-14-知识要点" class="headerlink" title="2.14 知识要点"></a>2.14 知识要点</h2><p><strong>MVC实现数据请求方式</strong></p><p><strong>基本类型参数.</strong></p><p><strong>POJO类型参数.</strong></p><p><strong>数组类型参数.</strong></p><p><strong>集合类型参数</strong></p><p><strong>MVC获取数据细节</strong></p><p><strong>.中文乱码问题</strong></p><p><strong>@RequestParam和 @Pathvariable</strong></p><p><strong>自定义类型转换器</strong></p><p><strong>获得Servlet相关API</strong></p><p><strong>@RequestHeader 和@Cookievalue</strong></p><p><strong>文件上传</strong></p><h1 id="1-spring-JdbcTemplate基本使用"><a href="#1-spring-JdbcTemplate基本使用" class="headerlink" title="1.spring  JdbcTemplate基本使用"></a>1.spring  JdbcTemplate基本使用</h1><h2 id="1-1-JdbcTemplate概述"><a href="#1-1-JdbcTemplate概述" class="headerlink" title="1.1 JdbcTemplate概述"></a>1.1 JdbcTemplate概述</h2><p><strong>它是spring框架中提供的一个对象,是对原始繁琐的JdbcAPI对象的简单封装。spring框架为我们提供了很多的操作模板类。例如:操作关系型数据的JdbcTemplate和HibernateTemplate,操作nosql数据库的RedisTemplate,操作消息队列的JmsTemplate等等。</strong></p><h2 id="1-2-JdbcTemplate开发步骤"><a href="#1-2-JdbcTemplate开发步骤" class="headerlink" title="1.2 JdbcTemplate开发步骤"></a>1.2 JdbcTemplate开发步骤</h2><p><strong>① 导入spring-jdbc和spring-tx坐标</strong></p><p><strong>②创建数据库表和实体</strong></p><p><strong>③创建JdbcTemplate对象</strong></p><p><strong>④执行数据库操作</strong></p><h2 id="1-4-Spring产生JdbcTemplate对象"><a href="#1-4-Spring产生JdbcTemplate对象" class="headerlink" title="1.4 Spring产生JdbcTemplate对象"></a>1.4 Spring产生JdbcTemplate对象</h2><p><strong>我们可以将JdbcTemplate的创建权交给Spring,将数据源DataSource的创建权也交给Spring,在Spring容器内部将数据源DataSource注入到JdbcTemplate模版对象中,配置如下:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--数据源DataSource--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2. c3p0. Combo PooledDataSource &quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot; com. mysql. jdbo.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot; jdboUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot; jdba :mysql:///test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&lt;/<span class="attr">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&lt;/<span class="attr">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--JdbcTemplate--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbeTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org. springframework. jdbc. core.JdbeTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&lt;/<span class="attr">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-6知识要点"><a href="#1-6知识要点" class="headerlink" title="1.6知识要点"></a>1.6知识要点</h2><p><strong>1.导入spring-jdbc和spring-tx坐标</strong></p><p><strong>2.创建数据库表和实体</strong></p><p><strong>3.创建JdbcTemplate对象</strong></p><p><strong>Jdbctemplate jdbctemplate &#x3D; new Jdbctemplate () ;</strong></p><p><strong>jdbcTemplate.setDatasource (datasource);</strong></p><p><strong>4.执行数据库操作</strong></p><p><strong>更新操作:</strong></p><p><strong>jdbctemplate. update (sql, params)</strong></p><p><strong>查询操作:</strong></p><p><strong>jdbctemplate.query (sql, Mapper, params)</strong></p><p><strong>jdbctemplate.queryForobject (sql, Mapper, params)</strong></p><h1 id="1-Spring练习环境搭建"><a href="#1-Spring练习环境搭建" class="headerlink" title="1.Spring练习环境搭建"></a>1.Spring练习环境搭建</h1><h2 id="1-1-Spring环境搭建步骤"><a href="#1-1-Spring环境搭建步骤" class="headerlink" title="1.1 Spring环境搭建步骤"></a>1.1 Spring环境搭建步骤</h2><p><strong>① 创建工程(Project&amp;Module)</strong></p><p><strong>② 导入静态页面(见资料jsp页面)</strong></p><p><strong>③ 导入需要坐标(见资料中的pom.xml)</strong></p><p><strong>④创建包结构(controller, service, dao, domain, utils)</strong></p><p><strong>⑤导入数据库脚本(见资料testsql)</strong></p><p><strong>6.创建POJO类(见资料User.java和Role.java)</strong></p><p><strong>7.创建配置文件(applicationContext.xml, spring-mvc.xml, jdbc.properties, log4j.properties)</strong></p><p><img src="C:\Users\24861\Desktop\数据库关系.JPG" alt="数据库关系"></p><h1 id="2-角色列表的展示和添加操作"><a href="#2-角色列表的展示和添加操作" class="headerlink" title="2.角色列表的展示和添加操作"></a>2.角色列表的展示和添加操作</h1><h2 id="2-2角色列表的展示步骤分析"><a href="#2-2角色列表的展示步骤分析" class="headerlink" title="2.2角色列表的展示步骤分析"></a>2.2角色列表的展示步骤分析</h2><p><strong>点击角色管理菜单发送请求到服务器端(修改角色管理菜单的url地址)</strong></p><p><strong>创建RoleController和showListO方法</strong></p><p><strong>创建RoleService和showListO方法</strong></p><p><strong>创建RoleDao和findAlIO方法</strong></p><p><strong>使用JdbcTemplate完成查询操作</strong></p><p><strong>将查询数据存储到Model中</strong></p><p><strong>转发到role-list.jsp页面进行展示</strong></p><p><strong>2.4角色添加的步骤分析</strong></p><p><strong>①点击列表页面新建按钮跳转到角色添加页面</strong></p><p><strong>②输入角色信息,点击傑存按钮,表单数据提交服务器</strong></p><p><strong>③编写RoleController的save0方法</strong></p><p><strong>④编写RoleService的save0方法</strong></p><p><strong>⑤编写RoleDao的saveO方法</strong></p><p><strong>6使用JdbcTemplate保存Role数据到sys_role</strong></p><p><strong>7跳转回角色列表页面</strong></p><h1 id="1-SpringMVC拦截器"><a href="#1-SpringMVC拦截器" class="headerlink" title="1.SpringMVC拦截器"></a>1.SpringMVC拦截器</h1><h2 id="1-1-拦截器-interceptor-的作用"><a href="#1-1-拦截器-interceptor-的作用" class="headerlink" title="1.1 拦截器(interceptor)的作用"></a>1.1 拦截器(interceptor)的作用</h2><p><strong>Spring MVC的拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。</strong></p><p><strong>将拦截器按一定的顺序联结成一条链,这条链称为拦截器链(Interceptor Chain).在访问被拦截的方法或字段时,拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是AOP思想的具体实现。</strong></p><h2 id="1-2拦截器和过滤器区别"><a href="#1-2拦截器和过滤器区别" class="headerlink" title="1.2拦截器和过滤器区别"></a>1.2拦截器和过滤器区别</h2><p><strong>区别过滤器(Filter)拦截器(Interceptor)</strong></p><p><strong>使用范围是servlet规范中的一部分,任何Java Web 工程都可以使用是SpringMVC 框架自己的,只有使用了SpringMVC 框架的工程才能用</strong></p><p>*<em>拦截范围在url-pattern中配置了&#x2F;<em>之后,可以对所有要访问的资源拦截在&lt;mvc:mapping path&#x3D; “” &#x2F;&gt;中配置了&#x2F;“之后,可以多所有资源进行拦截,但是可以通以对所有要访问资源拦截过&lt;mvc:exclude-mapping path&#x3D; “”&#x2F;&gt;标签排除不需要拦截的资源</em></em></p><h2 id="1-3拦截器是快速入门"><a href="#1-3拦截器是快速入门" class="headerlink" title="1.3拦截器是快速入门"></a>1.3拦截器是快速入门</h2><p><strong>自定义拦截器很简单,只有如下三步:</strong></p><p><strong>创建拦截器类实现Handlerlnterceptor接口</strong></p><p><strong>配置拦截器</strong></p><p><strong>测试拦截器的拦截效果</strong></p><h2 id="1-5拦截器方法说明"><a href="#1-5拦截器方法说明" class="headerlink" title="1.5拦截器方法说明"></a>1.5拦截器方法说明</h2><p><strong>方法名说明</strong></p><p><strong>preHandle方法将在请求处理之前进行调用,该方法的返回值是布尔值Boolean类型的。</strong></p><p>​<strong>当它返回为false时,表示请求结束,后续的Interceptor和Controller都不会再执行:</strong></p><p>​<strong>当返回值为true时就会继续调用下一个Interceptor的preHandle方法</strong></p><p><strong>postHandle该方法是在当前请求进行处理之后被调用,前提是preHandle方法的返回值为true 时才能</strong></p><p>​<strong>被调用,且它会在DispatcherServlet进行视图返回演染之前被调用,所以我们可以在这个</strong></p><p>​<strong>方法中对Controller处理之后的ModelAndView对象进行操作</strong></p><p><strong>afterCompletion()该方法将在整个请求结束之后,也就是在DispatcherServlet這染了对应的视图之后执行</strong></p><p>​<strong>,前提是preHandle方法的返回值为true时才能被调用</strong></p><h2 id="1-6-知识要点"><a href="#1-6-知识要点" class="headerlink" title="1.6 知识要点"></a>1.6 知识要点</h2><p><strong>自定义拦截器步骤</strong></p><p><strong>创建拦截器类实现Handlerlnterceptor接口</strong></p><p><strong>②配置拦截器</strong></p><p><strong>③测试拦截器的拦截效果</strong></p><h1 id="1-SpringMVC异常处理"><a href="#1-SpringMVC异常处理" class="headerlink" title="1.SpringMVC异常处理"></a>1.SpringMVC异常处理</h1><h2 id="1-1异常处理的思路"><a href="#1-1异常处理的思路" class="headerlink" title="1.1异常处理的思路"></a>1.1异常处理的思路</h2><p><strong>系统中异常包括两类:预期异常和运行时异常RuntimeException,前者通过捕获异常从而获取异常信息,后者主要通过规范代码开发、测试等手段减少运行时异常的发生。</strong></p><p><strong>系统的Dao, Service, Controller出现都通过throws Exception向上抛出,最后由SpringMVC前端控制器交由异常处理器进行异常处理,如下图:</strong></p><p><strong>客户端——前端控制器—-Controller——–Service——-Dao</strong></p><p>​<strong>HandlerExceptionResolver</strong></p><p>​<strong>异常处理器</strong></p><h2 id="1-2异常处理两种方式"><a href="#1-2异常处理两种方式" class="headerlink" title="1.2异常处理两种方式"></a>1.2异常处理两种方式</h2><p><strong>.使用Spring MVC提供的简单异常处理器SimpleMappingExceptionResolver</strong></p><p><strong>实现Spring的异常处理接口HandlerExceptionResolver自定义自己的异常处理器</strong></p><h2 id="1-3-简单异常处理器SimpleMappingExceptionResolver"><a href="#1-3-简单异常处理器SimpleMappingExceptionResolver" class="headerlink" title="1.3 简单异常处理器SimpleMappingExceptionResolver"></a>1.3 简单异常处理器SimpleMappingExceptionResolver</h2><p>S<strong>pringMVC已经定义好了该类型转换器,在使用时可以根据项目情况进行相应异常与视图的映射配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置简单映射异常处理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>&quot;<span class="attr">defaultErrorView</span>&quot; <span class="attr">value</span>=<span class="string">&quot;error&quot;</span>/&gt;</span>//默认错误视图</span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exoeptionMappings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span>//异常类型错误视图</span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;com. itheima. exception. MyException&quot;</span> <span class="attr">value</span>=<span class="string">&#x27;error&quot;/&gt;</span></span></span><br><span class="line"><span class="string"><span class="tag">             &lt;entry key=&quot;java.lang. ClassCastException&quot; value=&quot;error&quot;/&gt;</span></span></span><br><span class="line"><span class="string"><span class="tag">         &lt;/map&gt;</span></span></span><br><span class="line"><span class="string"><span class="tag">  &lt;/property&gt;</span></span></span><br><span class="line"><span class="string"><span class="tag"> &lt;/bean&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="1-4-自定义异常处理步骤"><a href="#1-4-自定义异常处理步骤" class="headerlink" title="1.4 自定义异常处理步骤"></a>1.4 自定义异常处理步骤</h2><p><strong>创建异常处理器类实现HandlerExceptionResolver</strong></p><p><strong>配置异常处理器</strong></p><p><strong>编写异常页面</strong></p><p><strong>测试异常跳转</strong></p><h2 id="1-5知识要点-2"><a href="#1-5知识要点-2" class="headerlink" title="1.5知识要点"></a>1.5知识要点</h2><p><strong>异常处理方式</strong></p><p><strong>.配置简单异常处理器SimpleMappingExceptionResolver.</strong></p><p><strong>自定义异常处理器</strong></p><p><strong>自定义异常处理步骤</strong></p><p><strong>①创建异常处理器类实现HandlerExceptionResolver</strong></p><p><strong>2.配置异常处理器</strong></p><p><strong>③编写异常页面</strong></p><p><strong>④测试异常跳转</strong></p><h1 id="1-Spring-的AOP-简介"><a href="#1-Spring-的AOP-简介" class="headerlink" title="1.Spring 的AOP 简介"></a>1.Spring 的AOP 简介</h1><h2 id="1-1-什么是AOP"><a href="#1-1-什么是AOP" class="headerlink" title="1.1 什么是AOP"></a>1.1 什么是AOP</h2><p><strong>AOP 为Aspect Oriented Programming的缩写,意思为面向切面编程,是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</strong></p><p><strong>AOP是 OOP的延续,是软件开发中的一个热点,也是Spring框架中的一个重要内容,是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离,从而使得业务逻辑各部分之间的耦合度降低,提高程序的可重用性,同时提高了开发的效率。</strong></p><h2 id="1-2-AOP-的作用及其优势"><a href="#1-2-AOP-的作用及其优势" class="headerlink" title="1.2 AOP 的作用及其优势"></a>1.2 AOP 的作用及其优势</h2><p><strong>作用:在程序运行期间,在不修改源码的情况下对方法进行功能增强</strong></p><p><strong>优势:减少重复代码,提高开发效率,并且便于维护</strong></p><h2 id="1-3-AOP-的底层实现"><a href="#1-3-AOP-的底层实现" class="headerlink" title="1.3 AOP 的底层实现"></a>1.3 AOP 的底层实现</h2><p><strong>实际上,AOP的底层是通过Spring提供的的动态代理技术实现的。在运行期间, Spring通过动态代理技术动态的生成代理对象,代理对象方法执行时进行增强功能的介入,在去调用目标对象的方法,从而完成功能的增强。</strong></p><h2 id="1-4-AOP-的动态代理技术"><a href="#1-4-AOP-的动态代理技术" class="headerlink" title="1.4 AOP 的动态代理技术"></a>1.4 AOP 的动态代理技术</h2><p><strong>常用的动态代理技术</strong></p><p><strong>JDK代理:基于接口的动态代理技术</strong></p><p><strong>cglib代理:基于父类的动态代理技术</strong></p><h2 id="1-5-JDK-的动态代理"><a href="#1-5-JDK-的动态代理" class="headerlink" title="1.5 JDK 的动态代理"></a>1.5 JDK 的动态代理</h2><h2 id="1-6-cglib-的动态代理"><a href="#1-6-cglib-的动态代理" class="headerlink" title="1.6 cglib 的动态代理"></a>1.6 cglib 的动态代理</h2><h2 id="1-7-AOP-相关概念"><a href="#1-7-AOP-相关概念" class="headerlink" title="1.7 AOP 相关概念"></a>1.7 AOP 相关概念</h2><p><strong>Spring的 AOP实现底层就是对上面的动态代理的代码进行了封装,封装后我们只需要对需要关注的部分进行代码编写,并通过配置的方式完成指定目标的方法增强。</strong></p><p><strong>在正式讲解AOP的操作之前,我们必须理解AOP的相关术语,常用的术语如下:</strong></p><p><strong>.Target (目标对象) :代理的目标对象</strong></p><p><strong>Proxy (代理) :一个类被AOP织入增强后,就产生一个结果代理类</strong></p><p><strong>Joinpoint (连接点) :所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点</strong></p><p><strong>Pointcut (切入点) :所谓切入点是指我们要对哪些Joinpoint进行拦截的定义</strong></p><p><strong>Advice (通知&#x2F;增强) :所谓通知是指拦截到Joinpoint之后所要做的事情就是通知</strong></p><p><strong>Aspect (切面):是切入点和通知(引介)的结合</strong></p><p><strong>Weaving (织入) :是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入,而Aspect&#x2F;采用编译期织入和类装载期织入</strong></p><h2 id="1-8-AOP-开发明确的事项"><a href="#1-8-AOP-开发明确的事项" class="headerlink" title="1.8 AOP 开发明确的事项"></a>1.8 AOP 开发明确的事项</h2><p><strong>1.需要编写的内容</strong></p><p><strong>编写核心业务代码(目标类的目标方法)</strong></p><p><strong>编写切面类,切面类中有通知(增强功能方法)</strong></p><p><strong>在配置文件中,配置织入关系,即将哪些通知与哪些连接点进行结合</strong></p><p><strong>2.AOP 技术实现的内容</strong></p><p><strong>Spring框架监控切入点方法的执行。一旦监控到切入点方法被运行,使用代理机制,动态创建目标对象的代理对象,根据通知类别,在代理对象的对应位置,将通知对应的功能织入,完成完整的代码逻辑运行。</strong></p><p><strong>3.AOP 底层使用哪种代理方式</strong></p><p><strong>在spring中,框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。</strong></p><h2 id="1-9-知识要点"><a href="#1-9-知识要点" class="headerlink" title="1.9 知识要点"></a>1.9 知识要点</h2><p><strong>aop:面向切面编程</strong></p><p><strong>aop底层实现:基于JDK的动态代理和基于Cglib的动态代理</strong></p><p><strong>aop的重点概念:</strong></p><p><strong>Pointcut (切入点) :被增强的方法</strong></p><p><strong>Advice (通知&#x2F;增强) :封装增强业务逻辑的方法</strong></p><p><strong>Aspect (切面) :切点+通知</strong></p><p><strong>Weaving (织入) :将切点与通知结合的过程</strong></p><p><strong>开发明确事项:</strong></p><p><strong>谁是切点(切点表达式配置)</strong></p><p><strong>谁是通知(切面类中的增强方法)</strong></p><p><strong>将切点和通知进行织入配置</strong></p><h1 id="2-基于XML的AOP开发"><a href="#2-基于XML的AOP开发" class="headerlink" title="2.基于XML的AOP开发"></a>2.基于XML的AOP开发</h1><h2 id="2-1快速入门"><a href="#2-1快速入门" class="headerlink" title="2.1快速入门"></a>2.1快速入门</h2><p><strong>① 导入AOP相关坐标</strong></p><p><strong>②创建目标接口和目标类(内部有切点)</strong></p><p><strong>③创建切面类(内部有增强方法)</strong></p><p><strong>④将目标类和切面类的对象创建权交给spring</strong></p><p><strong>5.在applicationContext.xml中配置织入关系</strong></p><p><strong>6测试代码</strong></p><h2 id="2-2-XML-配置AOP-详解"><a href="#2-2-XML-配置AOP-详解" class="headerlink" title="2.2 XML 配置AOP 详解"></a>2.2 XML 配置AOP 详解</h2><p><strong>1.切点表达式的写法</strong></p><p><strong>表达式语法:</strong></p><p><strong>execution([修饰符]返回值类型包名.类名.方法名(参数))</strong></p><p><strong>访问修饰符可以省略</strong></p><p><strong>返回值类型、包名、类名、方法名可以使用星号*代表任意</strong></p><p><strong>包名与类名之间一个点.代表当前包下的类,两个点..表示当前包及其子包下的类</strong></p><p><strong>参数列表可以使用两个点..表示任意个数,任意类型的参数列表</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">execution (public void com. ithe ima. aop. Target.method ())</span><br><span class="line">execution (void com.itheima.aop.Target.* (..))</span><br><span class="line">execution (* com.itheima.aop. *.* (..))</span><br><span class="line">execution (* com. itheima. aop..*.* (..))</span><br><span class="line">execution (* *..*.* (..))</span><br></pre></td></tr></table></figure><p><strong>2.通知的类型</strong></p><p><strong>通知的配置语法:</strong></p><p><strong>&lt;aop:通知类型method&#x3D; “切面类中方法名” pointcut&#x3D; “切点表达式”&gt;&lt;&#x2F;aop:通知类型&gt;</strong></p><p><strong>名称标签说明</strong></p><p><strong>前置通知<a href="aop:before">aop:before</a>用于配置前置通知。指定增强的方法在切入点方法之前执行</strong></p><p><strong>后置通知<a href="aop:after-returning">aop:after-returning</a>用于配置后置通知。指定增强的方法在切入点方法之后执行</strong></p><p><strong>环绕通知<a href="aop:around">aop:around</a>用于配置环绕通知。指定增强的方法在切入点方法之前和之后都执行</strong></p><p><strong>异常抛出通知<a href="aop:throwing">aop:throwing</a>用于配置异常抛出通知。指定增强的方法在出现异常时执行</strong></p><p><strong>最終通知<a href="aop:after">aop:after</a>用于配置最终通知。无论增强方式执行是否有异常都会执行</strong></p><p><strong>3.切点表达式的抽取</strong></p><p><strong>当多个增强的切点表达式相同时,可以将切点表达式进行抽取,在增强中使用pointcut-ref属性代替pointcut属性来引用抽取后的切点表达式。</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引用myAspect的Bean为切面对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop</span> <span class="attr">:</span> <span class="attr">aspeat</span> <span class="attr">ref</span>=<span class="string">&quot;myAspeat&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop</span> <span class="attr">:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution (* com.itheima.aop.*.*(..)) &quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop</span> <span class="attr">:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.3 知识要点</strong></p><p><strong>.aop织入的配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:</span> <span class="attr">aspect</span> <span class="attr">ref</span>=<span class="string">&quot;切面类&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:</span> <span class="attr">before</span> <span class="attr">method</span>=<span class="string">&quot;通知方法名称&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;切点表达式&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aonfig</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>通知的类型:前置通知、后置通知、环绕通知、异常抛出通知、最终通知.</strong></p><p><strong>切点表达式的写法:</strong></p><p><strong>execution([修饰符]返回值类型包名.类名.方法名(参数))</strong></p><h1 id="3-基于注解的AOP开发"><a href="#3-基于注解的AOP开发" class="headerlink" title="3.基于注解的AOP开发"></a>3.基于注解的AOP开发</h1><h2 id="3-1快速入门"><a href="#3-1快速入门" class="headerlink" title="3.1快速入门"></a>3.1快速入门</h2><p><strong>基于注解的aop开发步骤:</strong></p><p><strong>①创建目标接口和目标类(内部有切点)</strong></p><p><strong>②创建切面类(内部有增强方法)</strong></p><p><strong>③将目标类和切面类的对象创建权交给spring</strong></p><p><strong>④在切面类中使用注解配置织入关系</strong></p><p><strong>⑤在配置文件中开启组件扫描和AOP的自动代理</strong></p><p><strong>6.测试</strong></p><h2 id="3-2注解配置AOP-详解"><a href="#3-2注解配置AOP-详解" class="headerlink" title="3.2注解配置AOP 详解"></a>3.2注解配置AOP 详解</h2><p><strong>1.注解通知的类型</strong></p><p><strong>通知的配置语法:@通知注解(“切点表达式”)</strong></p><p><strong>注解aop开发步骤</strong></p><p><strong>①使用@Aspect标注切面类</strong></p><p><strong>②使用@通知注解标注通知方法</strong></p><p><strong>③在配置文件中配置aop自动代理&lt;aop: aspectj-autoproxy&#x2F;&gt;</strong></p><p><strong>名称注解说明</strong></p><p><strong>前置通知@Before用于配置前置通知。指定增强的方法在切入点方法之前执行</strong></p><p><strong>后置通知@AfterReturning 用于配置后置通知。指定增强的方法在切入点方法之后执行</strong></p><p><strong>环绕通知@Around用于配置环绕通知。指定增强的方法在切入点方法之前和之后都执行</strong></p><p><strong>异常抛出通知@AfterThrowing 用于配置异常抛出通知。指定增强的方法在出现异常时执行</strong></p><p><strong>最终通知@After用于配置最终通知。无论增强方式执行是否有异常都会执行</strong></p><p><strong>2.切点表达式的抽取</strong></p><p><strong>同xml配置aop一样,我们可以将切点表达式抽取。抽取方式是在切面内定义方法,在该方法上使用@Pointcut注解定义切点表达式,然后在在增强注解中进行引用。具体如下:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> (<span class="string">&quot;myAspeat&quot;</span>)</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Before</span> (<span class="string">&quot;MyAspect.myPoint () &quot;</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span> <span class="params">()</span>&#123;</span><br><span class="line">        System.out.println (<span class="string">&quot;前置代码增强....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Pointcut</span> (<span class="string">&quot;exeoution (* com.itheima.aop.*.* (..))&quot;</span>)</span><br><span class="line">    publio <span class="keyword">void</span> <span class="title function_">myPoint</span> <span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1-编程式事务控制相关对象"><a href="#1-编程式事务控制相关对象" class="headerlink" title="1.编程式事务控制相关对象"></a>1.编程式事务控制相关对象</h1><h2 id="1-1-PlatformTransactionManager"><a href="#1-1-PlatformTransactionManager" class="headerlink" title="1.1 PlatformTransactionManager"></a>1.1 PlatformTransactionManager</h2><p><strong>PlatformTransactionManager 接口是spring 的事务管理器,它里面提供了我们常用的操作事务的方法。</strong></p><p><strong>平台事务管理器</strong></p><p><strong>方法说明</strong></p><p><strong>Transactionstatus获取事务的状态信息</strong></p><p><strong>getTransaction (TransactionDefination defination)</strong></p><p>​</p><p><strong>void commit (Transactionstatus status)提交事务</strong></p><p><strong>void rollback (Transactionstatus status)回滚事务</strong></p><p><strong>注意</strong>:</p><p><strong>PlatformTransactionManager 是接口类型,不同的Dao层技术则有不同的实现类,</strong></p><p>**例如: **</p><p><strong>Dao层技术是jdbc或mybatis 时: org.springframework.jdbc.datasource. DatasourcetransactionManager</strong></p><p><strong>Dao 层技术是hibernatel: org.springframework.orm.hibernate5.HibernateTransactionManager</strong></p><h2 id="1-2-TransactionDefinition"><a href="#1-2-TransactionDefinition" class="headerlink" title="1.2 TransactionDefinition"></a>1.2 TransactionDefinition</h2><p><strong>TransactionDefinition是事务的定义信息对象,里面有如下方法:</strong></p><p><strong>事务定义</strong></p><p><strong>方法说明</strong></p><p><strong>int getIsolationLevel ()获得事务的隔离级别</strong></p><p><strong>int getPropogationBehavior ()  获得事务的传播行为</strong></p><p><strong>int gettimeout ()  获得超时时间</strong></p><p><strong>boolean isReadOnly() 是否只读</strong></p><p><strong>1.事务隔离级别</strong></p><p><strong>设置隔离级别,可以解决事务并发产生的问题,如脏读、不可重复读和虚读。</strong></p><p><strong>ISOLATION_DEFAULT</strong></p><p><strong>ISOLATION_READ_UNCOMMITTED</strong></p><p><strong>ISOLATION_READ_COMMITTED</strong></p><p><strong>ISOLATION_REPEATABLE_READ</strong></p><p><strong>ISOLATION_SERIALIZABLE</strong></p><p><strong>2.事务传播行为</strong></p><p><strong>REQUIRED:如果当前没有事务,就新建一个事务,如果已经存在一个事务中,加入到这个事务中。一般的选择(默认值).</strong> </p><p><strong>SUPPORTS:支持当前事务,如果当前没有事务,就以非事务方式执行(没有事务)</strong></p><p><strong>MANDATORY:使用当前的事务,如果当前没有事务,就抛出异常.</strong></p><p><strong>REQUERS_NEW:新建事务,如果当前在事务中,把当前事务挂起。.</strong> </p><p><strong>NOT SUPPORTED:以非事务方式执行操作,如果当前存在事务,就把当前事务挂起.</strong></p><p><strong>NEVER:以非事务方式运行,如果当前存在事务,抛出异常.</strong></p><p><strong>NESTED:如果当前存在事务,则在嵌套事务内执行。如果当前没有事务,则执行REQUIRED类似的操作</strong></p><p><strong>超时时间:默认值是-1,没有超时限制。如果有,以秒为单位进行设置</strong></p><p><strong>是否只读:建议查询时设置为只读</strong></p><h2 id="1-3-TransactionStatus"><a href="#1-3-TransactionStatus" class="headerlink" title="1.3 TransactionStatus"></a>1.3 TransactionStatus</h2><p><strong>TransactionStatus接口提供的是事务具体的运行状态,方法介绍如下。</strong></p><p><strong>方法说明</strong></p><p><strong>boolean hassavepoint ()是否存储回滚点</strong></p><p><strong>boolean iscompleted ()事务是否完成</strong></p><p><strong>boolean isNewrransaction ()是否是新事务</strong></p><p><strong>boolean isRollbackonly ()事务是否回滚</strong></p><h2 id="1-4知识要点"><a href="#1-4知识要点" class="headerlink" title="1.4知识要点"></a>1.4知识要点</h2><p><strong>编程式事务控制三大对象</strong></p><p><strong>PlatformTransactionManager   接口只定义行为</strong></p><p><strong>TransactionDefinition   封装事务参数</strong></p><p><strong>TransactionStatu被动封装状态信息</strong></p><h1 id="2-基于XML的声明式事务控制"><a href="#2-基于XML的声明式事务控制" class="headerlink" title="2.基于XML的声明式事务控制"></a>2.基于XML的声明式事务控制</h1><h2 id="2-1什么是声明式事务控制"><a href="#2-1什么是声明式事务控制" class="headerlink" title="2.1什么是声明式事务控制"></a>2.1什么是声明式事务控制</h2><p><strong>Spring的声明式事务顾名思义就是采用 <u>声明的方式来处理事务</u> 。这里所说的声明,就是指在配置文件中声明用在Spring配置文件中声明式的处理事务来代替代码式的处理事务。</strong></p><h2 id="声明式事务处理的作用"><a href="#声明式事务处理的作用" class="headerlink" title="声明式事务处理的作用"></a><strong>声明式事务处理的作用</strong></h2><p><strong>事务管理不侵入开发的组件。具体来说,业务逻辑对象就不会意识到正在事务管理之中,事实上也应该如此,因为事务管理是属于系统层面的服务,而不是业务逻辑的一部分,如果想要改变事务管理策划的话,也只需要在定义文件中重新配置即可</strong></p><p><strong>在不需要事务管理的时候,只要在设定文件上修改一下,即可移去事务管理服务,无需改变代码重新编译,这样维护起来极其方便</strong></p><p><strong>注意: Spring声明式事务控制底层就是AOP</strong></p><h2 id="2-2声明式事务控制的实现"><a href="#2-2声明式事务控制的实现" class="headerlink" title="2.2声明式事务控制的实现"></a>2.2声明式事务控制的实现</h2><p><strong>声明式事务控制明确事项:.</strong></p><p><strong>谁是切点?.</strong></p><p><strong>谁是通知?.</strong></p><p><strong>配置切面?</strong></p><h2 id="2-3切点方法的事务参数的配置"><a href="#2-3切点方法的事务参数的配置" class="headerlink" title="2.3切点方法的事务参数的配置"></a>2.3切点方法的事务参数的配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--事务增强配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot; transactionManager &quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:me</span> <span class="attr">thod</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>其中,<a href="tx:method">tx:method</a>代表切点方法的事务参数的配置,例如:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot; transfer&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;-1&quot;</span><span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>name:切点方法名称</strong></p><p><strong>isolation:事务的离级别</strong></p><p><strong>propogation: 事务的传播行为</strong></p><p><strong>timeout:超时时间</strong></p><p><strong>read-only: 是否只读</strong></p><h2 id="2-4知识要点"><a href="#2-4知识要点" class="headerlink" title="2.4知识要点"></a>2.4知识要点</h2><p><strong>声明式事务控制的配置要点</strong></p><p><strong>平台事务管理器配置.</strong></p><p><strong>事务通知的配置.</strong></p><p><strong>事务aop织入的配置</strong></p><h1 id="3-基于注解的声明式事务控制"><a href="#3-基于注解的声明式事务控制" class="headerlink" title="3.基于注解的声明式事务控制"></a>3.基于注解的声明式事务控制</h1><h2 id="3-2注解配置声明式事务控制解析"><a href="#3-2注解配置声明式事务控制解析" class="headerlink" title="3.2注解配置声明式事务控制解析"></a>3.2注解配置声明式事务控制解析</h2><p><strong>①使用@Transactional在需要进行事务控制的类或是方法上修饰,注解可用的属性同xml配置方式,例如隔离级别、传播行为等。</strong></p><p><strong>②注解使用在类上,那么该类下的所有方法都使用同一套注解参数配置。</strong></p><p><strong>3.在方法上,不同的方法可以采用不同的事务参数配置。</strong></p><p><strong>④ Xml配置文件中要开启事务的注解驱动&lt;tx: annotation-driven &#x2F;&gt;</strong></p><h2 id="3-3知识要点"><a href="#3-3知识要点" class="headerlink" title="3.3知识要点"></a>3.3知识要点</h2><p><strong>注解声明式事务控制的配置要点.</strong></p><p><strong>平台事务管理器配置(xml方式).</strong></p><p><strong>事务通知的配置(@Transactional注解配置).</strong></p><p><strong>事务注解驱动的配置&lt;tx: annotation-driven&#x2F;&gt;</strong></p><h1 id="1-Mybatis简介"><a href="#1-Mybatis简介" class="headerlink" title="1.Mybatis简介"></a>1.Mybatis简介</h1><h2 id="1-1原始jdbc操作-查询数据"><a href="#1-1原始jdbc操作-查询数据" class="headerlink" title="1.1原始jdbc操作(查询数据)"></a>1.1原始jdbc操作(查询数据)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"><span class="comment">//获得连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url: <span class="string">&quot;jdbc: mysql:///test&quot;</span>, user: <span class="string">&quot;root&quot;</span>, password: <span class="string">&quot;root&quot;</span>);</span><br><span class="line"><span class="comment">//获得statement</span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.prepareStatement( sql: <span class="string">&quot;select id, username, password from user&quot;</span>);</span><br><span class="line"><span class="comment">//执行查询</span></span><br><span class="line">ResultSet resultSet= statement.executeQuery();</span><br><span class="line"><span class="comment">//遍历结果集</span></span><br><span class="line"><span class="keyword">while</span>(resultSet.next())&#123;</span><br><span class="line">    <span class="comment">//封装实体</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setId(resultSet.getInt( columnLabel: <span class="string">&quot;id&quot;</span>));</span><br><span class="line">    user.setUsername (resultSet.getString( columnLabel: <span class="string">&quot;username&quot;</span>));</span><br><span class="line">    user.setPassword(resultSet.getString( columnLabel: <span class="string">&quot;password&quot;</span>));</span><br><span class="line">    <span class="comment">//user实体封装完毕</span></span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">resultSet.close();</span><br><span class="line">statement.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure><h2 id="1-1原始jdbc操作-插入数据"><a href="#1-1原始jdbc操作-插入数据" class="headerlink" title="1.1原始jdbc操作(插入数据)"></a>1.1原始jdbc操作(插入数据)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟实体对象</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setId(<span class="number">2</span>);</span><br><span class="line">user.setUsername(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">user, setPassword(<span class="string">&quot;lucy&quot;</span>)</span><br><span class="line">    <span class="comment">//注册驱动</span></span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"><span class="comment">//获得连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection( url: <span class="string">&quot;jdbc:mysql:///test&quot;</span>, user: <span class="string">&quot;root&quot;</span>, password: <span class="string">&quot;root&quot;</span>);</span><br><span class="line"><span class="comment">//获得statement</span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.prepareStatement( sgl: <span class="string">&quot;insert into user(id, username, password) values(?,?,?)&quot;</span>);</span><br><span class="line"><span class="comment">//设置占位符参数</span></span><br><span class="line">statement. setInt( parameterlndex: <span class="number">1</span>, user-getId());</span><br><span class="line">statement. setString( parameterlndex: <span class="number">2</span>,user.getUsername());</span><br><span class="line">statement,setString( parameterlndexc: <span class="number">3</span>,user.getPassword());</span><br><span class="line"><span class="comment">//执行更新操作</span></span><br><span class="line">statement.executeUpdate();</span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">statement.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure><h2 id="1-2原始jdbc操作的分析"><a href="#1-2原始jdbc操作的分析" class="headerlink" title="1.2原始jdbc操作的分析"></a>1.2原始jdbc操作的分析</h2><p><strong>原始jdbc开发存在的问题如下:</strong></p><p><strong>①数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能</strong></p><p><strong>② sql 语句在代码中硬编码,造成代码不易维护,实际应用sql变化的可能较大, sql变动需要改变java代码。</strong></p><p><strong>③查询操作时,需要手动将结果集中的数据手动封装到实体中。插入操作时,需要手动将实体的数据设置到sql语句的占位,符位置</strong></p><p><strong>应对上述问题给出的解决方案:</strong></p><p><strong>①使用数据库连接池初始化连接资源</strong></p><p><strong>②将sql语句抽取到xml配置文件中</strong></p><p><strong>③使用反射、内省等底层技术,自动将实体与表进行属性与字段的自动映射</strong></p><h2 id="1-3-什么是Mybatis"><a href="#1-3-什么是Mybatis" class="headerlink" title="1.3 什么是Mybatis"></a>1.3 什么是Mybatis</h2><p><strong>. mybatis 是一个优秀的基于java的持久层框架,它内部封装了jdbc,使开发者只需要关注sql语句本身,而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。</strong></p><p><strong>. mybatis通过xml或注解的方式将要执行的各种statement配置起来,并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。</strong></p><p><strong>.最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题,对jdbc进行了封装,屏蔽了jdbcapi底层访问细节,使我们不用与jdbcapi打交道,就可以完成对数据库的持久化操作。</strong></p><h1 id="2-Mybatis的快速入门"><a href="#2-Mybatis的快速入门" class="headerlink" title="2.Mybatis的快速入门"></a>2.Mybatis的快速入门</h1><h2 id="2-1-MyBatis开发步骤"><a href="#2-1-MyBatis开发步骤" class="headerlink" title="2.1 MyBatis开发步骤"></a>2.1 MyBatis开发步骤</h2><p><strong>MyBatis官网地址: <a href="http://www.mybatis.org/mybatis-3/">http://www.mybatis.org/mybatis-3/</a></strong></p><p><strong>MyBatis开发步骤:</strong></p><p><strong>①添加MyBatis的坐标</strong></p><p><strong>②创建user数据表</strong></p><p><strong>③编写User实体类</strong></p><p><strong>④编写映射文件UserMapper.xml</strong></p><p><strong>⑤编写核心文件SqlMapConfig.xml</strong></p><p><strong>6.编写测试类</strong></p><h2 id="2-2-环境搭建"><a href="#2-2-环境搭建" class="headerlink" title="2.2 环境搭建"></a>2.2 环境搭建</h2><p><strong>1.导入MyBatis的坐标和其他相关坐标</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//mybatis坐标</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">//mysql驱动坐标</span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--单元测试坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--日志坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependenoy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifaatId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-2环境搭建"><a href="#2-2环境搭建" class="headerlink" title="2.2环境搭建"></a>2.2环境搭建</h2><p><strong>2.创建user数据表</strong></p><p><strong>3.编写User实体</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"><span class="comment">//省略get个set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.编写UserMapper映射文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;userMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>&gt;</span></span><br><span class="line">        select * from User </span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>5.编写MyBatis核心文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///test&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span> <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/itheima/mapper/UserMapper.xml&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-3编写测试代码"><a href="#2-3编写测试代码" class="headerlink" title="2.3编写测试代码"></a>2.3编写测试代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载核心配置文件</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line"><span class="comment">//获得sqlSession 工厂对象</span></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line"><span class="comment">//获得sqlSession对象</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"><span class="comment">//执行sql语句</span></span><br><span class="line">List&lt;User&gt; userList = sqlSession.selectList(<span class="string">&quot;userMapper.findAll&quot;</span>);</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">System.out.println(userList);</span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure><h2 id="2-4知识小结"><a href="#2-4知识小结" class="headerlink" title="2.4知识小结"></a>2.4知识小结</h2><p><strong>MyBatis开发步骤:</strong></p><p><strong>①添加MyBatis的坐标</strong></p><p><strong>②创建user数据表</strong></p><p><strong>③编写User实体类</strong></p><p><strong>④编写映射文件UserMapper.xml</strong></p><p><strong>⑤编写核心文件SqlMapConfig.xml</strong></p><p><strong>6编写测试类</strong> </p><h1 id="4-MyBatis的增删改查操作"><a href="#4-MyBatis的增删改查操作" class="headerlink" title="4.MyBatis的增删改查操作"></a>4.MyBatis的增删改查操作</h1><h2 id="4-1-MyBatis的插入数据操作"><a href="#4-1-MyBatis的插入数据操作" class="headerlink" title="4.1 MyBatis的插入数据操作"></a>4.1 MyBatis的插入数据操作</h2><p><strong>3.插入操作注意问题</strong></p><p><strong>插入语句使用insert标签</strong></p><p><strong>在映射文件中使用parameterType属性指定要插入的数据类型</strong></p><p><strong>Sql语句中使用#[实体属性名)方式引用实体中的属性值</strong></p><p><strong>插入操作使用的API是sqlSession.insert( “命名空间.id”,实体对象);</strong></p><p><strong>插入操作涉及数据库数据变化,所以要使用sqlSession对象显示的提交事务,即sqlSession.commit)</strong></p><h2 id="4-2-MyBatis的修改数据操作"><a href="#4-2-MyBatis的修改数据操作" class="headerlink" title="4.2 MyBatis的修改数据操作"></a>4.2 MyBatis的修改数据操作</h2><p><strong>1.编写UserMapper映射文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;userMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>&gt;</span></span><br><span class="line">     update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125; </span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.编写修改实体User的代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得核心配置文件</span></span><br><span class="line">      <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line"><span class="comment">//获得session工厂对象</span></span><br><span class="line">      <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line">      <span class="comment">//获得session会话对象</span></span><br><span class="line">      SqlSession sqlSession=sqlSessionFactory.openSession();</span><br><span class="line">      <span class="comment">//执行操作 参数：namespace+id</span></span><br><span class="line">      sqlSession.update(<span class="string">&quot;userMapper.update&quot;</span>,user);</span><br><span class="line">      <span class="comment">//mybatis执行更新操作  除了查询都需要提交事务</span></span><br><span class="line">      sqlSession.commit();</span><br><span class="line">      <span class="comment">//释放资源</span></span><br><span class="line">      sqlSession.close();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>3.修改操作注意问题</strong></p><p><strong>修改语句使用update标签</strong></p><p><strong>修改操作使用的API是sqlSession.update( “命名空间.id”,实体对象);</strong></p><h2 id="4-3-MyBatis的删除数据操作"><a href="#4-3-MyBatis的删除数据操作" class="headerlink" title="4.3 MyBatis的删除数据操作"></a>4.3 MyBatis的删除数据操作</h2><p><strong>3.删除操作注意问题</strong></p><p><strong>删除语句使用delete标签</strong></p><p><strong>Sql语句中使用#(任意字符串)方式引用传递的单个参数</strong></p><p><strong>删除操作使用的API是sqlSession.delete(“命名空间.id” ,Object);</strong></p><h2 id="4-4知识小结增删改查映射配置与API"><a href="#4-4知识小结增删改查映射配置与API" class="headerlink" title="4.4知识小结增删改查映射配置与API:"></a>4.4知识小结增删改查映射配置与API:</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">查询数据:</span><br><span class="line">List<span class="tag">&lt;<span class="name">User</span>&gt;</span> userList = sqlsession.selectList (&quot;userMapper.findAll&quot;);</span><br><span class="line">    <span class="tag">&lt;<span class="name">seleat</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima. domain.User&quot;</span>&gt;</span></span><br><span class="line">        select * from User </span><br><span class="line">      <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">添加数据: </span><br><span class="line">    sqlsession.insert (&quot;userMapper.add&quot;, user);</span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.itheima, domain. User&quot;</span>&gt;</span> </span><br><span class="line">        insert into user values (#(id), #(username), #[password)) <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">修改数据: </span><br><span class="line">    sqlSession.update (&quot;userMapper. update&quot;, user);</span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot; com.itheima. domain.User&quot;</span>&gt;</span></span><br><span class="line">        update user set username=# &#123;username&#125;, password=# &#123;password&#125; where id=#&#123;id&#125; </span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">删除数据: </span><br><span class="line">    sqlsession.delete (&quot;userMapper.delete&quot;,3);</span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang. Integer&quot;</span>&gt;</span></span><br><span class="line">        delete from user where id=# &#123;id&#125; </span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-1-MyBatis核心配置文件层级关系"><a href="#5-1-MyBatis核心配置文件层级关系" class="headerlink" title="5.1 MyBatis核心配置文件层级关系"></a>5.1 MyBatis核心配置文件层级关系</h2><p><strong>configuration 配置</strong></p><p><strong>。properties 属性</strong></p><p><strong>。settings设置</strong></p><p><strong>。typeAliases 类型别名</strong></p><p><strong>。typeHandlers 类型处理器</strong></p><p><strong>。objectFactory 对象工厂plugins 插件</strong></p><p><strong>。environments 环境</strong></p><p>​<strong>..environment 环境变量</strong></p><p>​<strong>…transactionManager 事务管理器</strong></p><p>​<strong>…dataSource数据源</strong></p><p><strong>。databaseldProvider数据库厂商标识</strong></p><p><strong>。mappers 映射器</strong></p><h2 id="5-2-MyBatis常用配置解析"><a href="#5-2-MyBatis常用配置解析" class="headerlink" title="5.2 MyBatis常用配置解析"></a>5.2 MyBatis常用配置解析</h2><p><strong>1.environments标签</strong></p><p><strong>数据库环境的配置,支持多环境配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  配置数据源的环境  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span> //指定默认的环境名称</span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span>//指定当前环境的名称</span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span>//指定事务管理类型是jdbc</span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span> //指定当前数据源类型是连接池</span><br><span class="line">                //数据源配置的基本参数</span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>其中,事务管理器(transactionManager)类型有两种:</strong></p><p><strong>JDBC:这个配置就是直接使用了JDBC的提交和回滚设置,它依赖于从数据源得到的连接来管理事务作用域。</strong></p><p><strong>MANAGED:这个配置几乎没做什么。它从来不提交或回滚一个连接,而是让容器来管理事务的整个生命周期(比如JEE应用服务器的上下文) 。默认情况下它会关闭连接,然而一些容器并不希望这样,因此需要将closeConnection属性设置为false来阻止它默认的关闭行为。</strong></p><p><strong>其中,数据源(dataSource)类型有三种:</strong></p><p><strong>UNPOOLED:这个数据源的实现只是每次被请求时打开和关闭连接。</strong></p><p><strong>POOLED:这种数据源的实现利用“池”的概念将JDBC连接对象组织起来。</strong></p><p><strong>JNDI:这个数据源的实现是为了能在如EJB或应用服务器这类容器中使用,容器可以集中或在外部配置数据源,然后放置一个JNDI上下文的引用。</strong></p><p><strong>2.mapper标签</strong></p><p><strong>该标签的作用是加载映射的,加载方式有如下几种:</strong></p><p><strong>使用相对类路径的资源引用,例如: <mapper resource="org/mybatis/builder/AuthorMapper.xml"/></strong></p><p><strong>使用完全限定资源定位符(URL) ,例如: <mapper url="file:///var/mappers/AuthorMapper.xml"/></strong></p><p><strong>使用映射器接口实现类的完全限定类名,例如: <mapper class="org.mybatis.builder.AuthorMapper"/></strong></p><p><strong>将包内的映射器接口实现全部注册为映射器,例如: <package name="org.mybatis.builder"/></strong></p><p><strong>3.Properties标签</strong></p><p><strong>实际开发中,习惯将数据源的配置信息单独抽取成一个properties文件,该标签可以加载额外配置的properties文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--加载外部proponties--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc, password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="5-2-MyBatis常用配置解析-1"><a href="#5-2-MyBatis常用配置解析-1" class="headerlink" title="5.2 MyBatis常用配置解析"></a>5.2 MyBatis常用配置解析</h2><p><strong>4.typeAliases标签</strong></p><p><strong>类型别名是为Java类型设置一个短的名字。原来的类型名称配置如下</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>&gt;</span></span><br><span class="line">    select * from User </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span>//User全限定名称</span><br></pre></td></tr></table></figure><p><strong>配置typeAliases, 为com.itheima.domain.User定义別名为user</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">typeAlias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;selectid=&quot;findAll&quot; resultType=&quot;user&quot;&gt;</span><br><span class="line">    select * from User</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span>//user为别名</span><br></pre></td></tr></table></figure><p><strong>4.typeAliases标签</strong></p><p><strong>上面我们是自定义的别名, mybatis框架已经为我们设置好的一些常用的类型的别名</strong></p><p><strong>别名数据类型</strong></p><p><strong>string  String</strong></p><p><strong>longLong</strong></p><p><strong>intInteger</strong></p><p><strong>doubleDouble</strong></p><p><strong>boolean     Boolean</strong></p><h2 id="5-3知识小结"><a href="#5-3知识小结" class="headerlink" title="5.3知识小结"></a>5.3知识小结</h2><p><strong>核心配置文件常用配置:</strong></p><p><strong>1.properties标签:该标签可以加载外部的properties文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.typeAliases标签:设置类型别名</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">typeAlias</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3.mappers标签:加载映射配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot; com/itheima/mapper/UserMapper.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>核心配置文件常用配置:</strong></p><p><strong>4, environments标签:数据源环境配置标签</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc, password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="6-MyBatis相应API"><a href="#6-MyBatis相应API" class="headerlink" title="6.MyBatis相应API"></a>6.MyBatis相应API</h1><h2 id="6-1-SqlSessionI厂构建器SqlSessionFactoryBuilder"><a href="#6-1-SqlSessionI厂构建器SqlSessionFactoryBuilder" class="headerlink" title="6.1 SqlSessionI厂构建器SqlSessionFactoryBuilder"></a>6.1 SqlSessionI厂构建器SqlSessionFactoryBuilder</h2><p><strong>常用API: SqlSessionFactory build(InputStream inputStream)</strong></p><p><strong>通过加载mybatis的核心文件的输入流的形式构建一个SqISessionFactory对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">string</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;org/mybatis/builder/mybatis-config.xml&quot;</span>;</span><br><span class="line"><span class="type">Inputstream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream (resource);</span><br><span class="line"><span class="type">SqlsessionFactoryBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span> ();</span><br><span class="line"><span class="type">SqlsessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> builder.build (inputstream);</span><br></pre></td></tr></table></figure><p><strong>其中, Resources T具类,这个类在org.apache.ibatis.io包中。Resources类帮助你从类路径下、文件系统或一个web URL中加载资源文件。</strong></p><h2 id="6-2-SqlSession工厂对象SqlSessionFactory"><a href="#6-2-SqlSession工厂对象SqlSessionFactory" class="headerlink" title="6.2 SqlSession工厂对象SqlSessionFactory"></a>6.2 SqlSession工厂对象SqlSessionFactory</h2><p><strong>SqlSessionFactory有多个个方法创建SqlSession实例。常用的有如下两个:</strong></p><p>​<strong>方法解释</strong></p><p><strong>openSession()会默认开启一个事务,但事务不会自动提交,也就意味着需要手动提交该事务,更新操作数据才会持久化到数据库中</strong></p><p><strong>openSession(booleanautoCommit)参数为是否自动提交,如果设置为true,那么不需要手动提交事务</strong></p><h2 id="6-3-SqlSession会话对象"><a href="#6-3-SqlSession会话对象" class="headerlink" title="6.3 SqlSession会话对象"></a>6.3 SqlSession会话对象</h2><p><strong>SqlSession实例在MyBatis中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。执行语句的方法主要有:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; T <span class="title function_">selectone</span> <span class="params">(string statement, Object parameter)</span></span><br><span class="line">&lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span> <span class="params">(String statement, Object parameter)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span> <span class="params">(String statement, Object parameter)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">update</span> <span class="params">(String statement, Object parameter)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">delete</span> <span class="params">(String statement, Object parameter)</span></span><br></pre></td></tr></table></figure><p><strong>操作事务的方法主要有;</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">()</span></span><br></pre></td></tr></table></figure><h1 id="1-Mybatis的Dao层实现"><a href="#1-Mybatis的Dao层实现" class="headerlink" title="1.Mybatis的Dao层实现"></a>1.Mybatis的Dao层实现</h1><p><strong>1.1传统开发方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>编写UserDao接口</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">find11</span> <span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-2代理开发方式"><a href="#1-2代理开发方式" class="headerlink" title="1.2代理开发方式"></a>1.2代理开发方式</h2><p><strong>1.代理开发方式介绍</strong></p><p><strong>采用Mybatis的代理开发方式实现DAO层的开发,这种方式是我们后面进入企业的主流。</strong></p><p><strong>Mapper接口开发方法只需要程序员编写Mapper接口(相当于Dao接口) ,由Mybatis框架根据接口定义创建接口的动态代理对象,代理对象的方法体同上边Dao接口实现类方法。</strong></p><p><strong>Mapper接口开发需要遵循以下规范:</strong></p><p><strong>1.Mapper.xml文件中的namespace与mapper接口的全限定名相同</strong></p><p><strong>2.Mapper接口方法名和Mapper.xml中定义的每个statement的id相同</strong></p><p><strong>3.Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同</strong></p><p><strong>4.Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同</strong> </p><p><strong>2.编写UserMapper接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line"></span><br><span class="line"> User <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span> ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&#x27;com.itheima.mapper.UserMapper&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">findById</span> <span class="attr">parameterType</span>=<span class="string">&#x27;int&#x27;</span>  <span class="attr">resultType</span>=<span class="string">user</span>&gt;</span></span><br><span class="line">    select * from User where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-测试代理方式"><a href="#3-测试代理方式" class="headerlink" title="3.测试代理方式"></a>3.测试代理方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProxyDao</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    <span class="comment">//获得MyBatis框架生成的UserMapper接口的实现类</span></span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.findByld(<span class="number">1</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3知识小结"><a href="#1-3知识小结" class="headerlink" title="1.3知识小结"></a>1.3知识小结</h2><p><strong>mybatis的Dao层实现的两种方式:.</strong></p><p><strong>手动对Dao进行实现:传统开发方式.</strong></p><p><strong>代理方式对Dao进行实现:</strong></p><p><strong>UserMapper userMapper &#x3D; sqlSession.getMapper (UserMapper.class);</strong></p><h1>1.MyBatis映射文件深入</h1><h2>1.1 动态sql语句</h2><p><strong>1.动态sql语句概述</strong></p><p><strong>Mybatis的映射文件中,前面我们的SQL都是比较简单的,有些时候业务逻辑复杂时,我们的SQL是动态变化的,此时在前面的学习中我们的SQL就不能满足要求了。参考的官方文档,描述如下:</strong></p><p><strong>if</strong></p><p><strong>choose(when ,otherwise)</strong></p><p><strong>trim(where ,set)</strong></p><p><strong>foreach</strong></p><h1>1.MyBatis映射文件深入</h1><p><strong>2.动态SQL之<if></strong></p><p><strong>我们根据实体类的不同取假,使用不同的SQL语句来进行查询。比如在id如果不为空时可以根据id查询,如果username不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByCondition&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from User</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id!=0&quot;</span>&gt;</span></span><br><span class="line">            and id=#[id)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username!=null&quot;</span>&gt;</span></span><br><span class="line">            and username=#(username) </span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3.动态 SQL 之<foreach></strong></p><p><em><em>循环执行sql的拼接操作,例如: SELECT</em> FROM USER WHERE id IN (1,2,5),</em>*</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot; findByIds&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from User</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">colleation</span>=<span class="string">&quot;array&quot;</span> <span class="attr">open</span>=<span class="string">&quot;id in(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;) &quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-2-SQL片段抽取"><a href="#1-2-SQL片段抽取" class="headerlink" title="1.2 SQL片段抽取"></a>1.2 SQL片段抽取</h2><p><strong>sql中可将重复的sql 提取出来,使用时用include引用即可,最终达到sql重用的目的</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--抽取sql片段简化编写--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;selectUser&quot;</span> <span class="attr">select</span> * <span class="attr">from</span> <span class="attr">User</span>&lt;/<span class="attr">sql</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByld&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectUser&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span>where id=#(id) </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">&lt;selectid=&quot;findBylds&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectUser&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;array&quot;</span> <span class="attr">open</span>=<span class="string">&quot;id in(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            #(id)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2>1.3知识小结</h2><p><strong>MyBatis映射文件配置:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span>:查询</span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span>&gt;</span> :插入</span><br><span class="line">        <span class="tag">&lt;<span class="name">update</span>&gt;</span>:修改</span><br><span class="line">            <span class="tag">&lt;<span class="name">delete</span>&gt;</span>:删除</span><br><span class="line">                <span class="tag">&lt;<span class="name">where</span>&gt;</span>: where条件</span><br><span class="line">                    <span class="tag">&lt;<span class="name">if</span>&gt;</span>: if判断</span><br><span class="line">                        <span class="tag">&lt;<span class="name">foreach</span>&gt;</span>:循环</span><br><span class="line">                            <span class="tag">&lt;<span class="name">sql</span>&gt;</span>: sql片段抽取</span><br></pre></td></tr></table></figure><h1 id="1-MyBatis核心配置文件深入"><a href="#1-MyBatis核心配置文件深入" class="headerlink" title="1.MyBatis核心配置文件深入"></a>1.MyBatis核心配置文件深入</h1><h2 id="1-1-typeHandlers标签"><a href="#1-1-typeHandlers标签" class="headerlink" title="1.1 typeHandlers标签"></a>1.1 typeHandlers标签</h2><p><strong>无论是MyBatis在预处理语句(PreparedStatement)中设置一个参数时,还是从结果集中取出一个值时,都会用类型处理器将获取的值以合适的方式转换成Java类型。下表描述了一些默认的类型处理器(截取部分)。</strong></p><p><strong>类型处理器Java 类型JDBC 类型</strong></p><p><strong>BooleanTypeHandlerJava. lang. Boolean, boolean数据库兼容的BOOLEAN</strong></p><p><strong>ByteTypeHandler java. lang. Byte.byte数据库兼容的NUMERIC或BYTE</strong></p><p><strong>ShortTypeHandlerJava. lang.Short,short数据库兼容的NUMERIC 或 SHORT INTEGER</strong></p><p><strong>IntegerTypeHedlerjava.lang.integer,int数据库兼容的NUMERIC 或INTEGER</strong></p><p><strong>LongTypeHeerJava. lang. Long, long数据库兼容的NULERIC 或 LONG INTEGER</strong> </p><p><strong>你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。具体做法为:实现org.apache.ibatis.type.TypeHandler 接口,或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler, 然后可以选择性地将它映射到一个JDBC类型。例如需求:一个Java中的Date数据类型,我想将之存到数据库的时候存成一个1970年至今的毫秒数,取出来时转换成jäva的Date, 即java的Date与数据库的varchar毫秒值之间转换。</strong></p><p><strong>开发步骤:</strong></p><p><strong>①定义转换类继承类BaseTypeHandler<T></strong></p><p><strong>②覆盖4个未实现的方法,其中setNonNullParameter为java程序设置数据到数据库的回调方法, getNullableResult为查询时mysql的字符串类型转换成java的Type类型的方法</strong></p><p><strong>③在MyBatis核心配置文件中进行注册</strong></p><p><strong>④测试转换是否正确</strong></p><h2 id="1-2-plugins标签"><a href="#1-2-plugins标签" class="headerlink" title="1.2 plugins标签"></a>1.2 plugins标签</h2><p><strong>MyBatis可以使用第三方的插件来对功能进行扩展,分页助手PageHelper是将分页的复杂操作进行封装,使用简单的方式即可获得分页的相关数据</strong></p><p><strong>开发步骤:</strong></p><p><strong>①导入通用PageHelper的坐标</strong></p><p><strong>② 在mybatis核心配置文件中配置PageHelper插件</strong></p><p><strong>③测试分页数据获取</strong></p><h2 id="1-3知识小结-1"><a href="#1-3知识小结-1" class="headerlink" title="1.3知识小结"></a>1.3知识小结</h2><p><strong>MyBatis核心配置文件常用标签:</strong></p><p><strong>1.properties标签:该标签可以加载外部的properties文件</strong></p><p><strong>2.typeAliases标签:设置类型别名</strong></p><p><strong>3.environments标签:数据源环境配置标签</strong></p><p><strong>4.typeHandlers标签:配置自定义类型处理器</strong></p><p><strong>5.plugins标签:配置MyBatis的插件</strong> </p><h1 id="1-Mybatis多表查询"><a href="#1-Mybatis多表查询" class="headerlink" title="1.Mybatis多表查询"></a>1.Mybatis多表查询</h1><h2 id="1-1一对一查询"><a href="#1-1一对一查询" class="headerlink" title="1.1一对一查询"></a>1.1一对一查询</h2><p><strong>1.一对一查询的模型</strong></p><p><strong>用户表和订单表的关系为,一个用户有多个订单,一个订单只从属于一个用户一对一查询的需求:查询一个订单,与此同时查询出该订单所属的用户</strong></p><p><strong>ordersuser</strong></p><p><strong>id: int</strong></p><p><strong>ordertime: varchar(255)</strong></p><p> <strong>total: double</strong></p><p><strong>uid: int</strong></p><p><strong>id: int</strong></p><p><strong>user</strong></p><p><strong>username: varchar(50)</strong></p><p> <strong>password: varchar(50)</strong> </p><p><strong>birthday: varchar(50)</strong></p><h2 id="1-2一对多查询"><a href="#1-2一对多查询" class="headerlink" title="1.2一对多查询"></a>1.2一对多查询</h2><p><strong>1.一对多查询的模型</strong></p><p><strong>用户表和订单表的关系为,一个用户有多个订单,一个订单只从属于一个用户一对多查询的需求:查询一个用户,与此同时查询出该用户具有的订单</strong></p><h2 id="1-3多对多查询"><a href="#1-3多对多查询" class="headerlink" title="1.3多对多查询"></a>1.3多对多查询</h2><p><strong>1.多对多查询的模型</strong></p><p><strong>表和角色表的关系为,一个用户有多个角色,一个角色被多个用户使用多对多查询的需求:查询用户同时查询出该用户的所有角色</strong></p><p><strong>user</strong></p><p><strong>id: int</strong></p><p><strong>usermame: varchar(50)</strong> </p><p><strong>password: varchar(50)</strong></p><p><strong>birthday: varchar(50)</strong></p><p><strong>user_role</strong></p><p><strong>user_id: int</strong> </p><p><strong>role_id: int</strong></p><p><strong>role</strong></p><p><strong>id: int</strong></p><p><strong>rolename: varchar(255)</strong></p><h2 id="1-4知识小结"><a href="#1-4知识小结" class="headerlink" title="1.4知识小结"></a>1.4知识小结</h2><p><strong>MyBatis多表配置方式:</strong></p><p><strong>一对一配置:使用<resultMap>做配置</strong></p><p><strong>一对多配置:使用<resultMap>+<collection>做配置</strong></p><p><strong>多对多配置:使用<resultMap>+<collection>做配置</strong></p><h1 id="1-Mybatis的注解开发"><a href="#1-Mybatis的注解开发" class="headerlink" title="1.Mybatis的注解开发"></a>1.Mybatis的注解开发</h1><h2 id="1-1-MyBatis的常用注解"><a href="#1-1-MyBatis的常用注解" class="headerlink" title="1.1 MyBatis的常用注解"></a>1.1 MyBatis的常用注解</h2><p><strong>这几年来注解开发越来越流行, Mybatis也可以使用注解开发方式,这样我们就可以减少编写Mapper映射文件了。我们先围绕一些基本的CRUD来学习,再学习复杂映射多表操作。</strong></p><p><strong>@Insert:实现新增</strong></p><p><strong>@Update:实现更新</strong></p><p><strong>@Delete:实现删除</strong></p><p><strong>@Select:实现查询</strong></p><p><strong>@Result:实现结果集封装</strong></p><p><strong>@Results:可以与</strong></p><p><strong>@Result一起使用,封装多个结果集</strong></p><p><strong>@One:实现一对一结果集封装</strong></p><p><strong>@Many:实现一对多结果集封装</strong> </p><h2 id="1-2-MyBatis的增删改查"><a href="#1-2-MyBatis的增删改查" class="headerlink" title="1.2 MyBatis的增删改查"></a>1.2 MyBatis的增删改查</h2><p><strong>我们完成简单的user表的增删改查的操作</strong></p><p><strong>private UserMapper userMapper;</strong></p><p><strong>@Before</strong></p><p><strong>public void before () throws IOException{</strong></p><p><strong>Inputstream resourceAsStream &#x3D; Resources.getResourceAsStream(“SqlMapconfig.xml”);</strong></p><p><strong>SglsessionFactory sqlsessionFactory &#x3D; newSqlsessionFactoryBuilder (). build (resourceAsstream);</strong></p><p><strong>Sqlsession sqlsession &#x3D; sqlsessionFactory. opensession (true);</strong></p><p><strong>userMapper &#x3D; sqlSession. getMapper (UserMapper.class);</strong> </p><p>}</p><h2 id="1-3-MyBatis的注解实现复杂映射开发"><a href="#1-3-MyBatis的注解实现复杂映射开发" class="headerlink" title="1.3 MyBatis的注解实现复杂映射开发"></a>1.3 MyBatis的注解实现复杂映射开发</h2><p><strong>实现复杂关系映射之前我们可以在映射文件中通过配置<resultMap>来实现,使用注解开发后,我们可以使用@Results注解@Result注解, @One注解, @Many注解组合完成复杂关系的配置</strong></p><p><strong>注解说明</strong></p><p><strong>@Results(一对多)代替了<assocation>标签,是多表查询的关键,在注解中用来指定子查询返回单一对象。</strong></p><p>​<strong>@One注解属性介绍:</strong></p><p>​ <strong>select:指定用来多表查询的sqlmapper</strong></p><p>​<strong>使用格式: @Result(column&#x3D;’”.property&#x3D;”,one&#x3D;@One(select&#x3D;”“))</strong> </p><p><strong>@Many (多对一)代替了<collection>标签 是是多表查询的关键,在注解中用来指定子查询返回对象集合。</strong></p><p>​<strong>使用格式: @Result(property&#x3D;”.column&#x3D;””.many&#x3D;@Many(select&#x3D;”“))</strong> </p><h2 id="1-6多对多查询"><a href="#1-6多对多查询" class="headerlink" title="1.6多对多查询"></a>1.6多对多查询</h2><p><strong>1.多对多查询的模型</strong></p><p><strong>用户表和角色表的关系为,一个用户有多个角色,一个角色被多个用户使用多对多查询的需求:查询用户同时查询出该用户的所有角色</strong></p><p><strong>user</strong></p><p><strong>id: int</strong></p><p><strong>username: varchar(50)</strong></p><p><strong>password: varchar(50)</strong></p><p><strong>birthday: varchar(50)</strong></p><p><strong>user_role</strong></p><p><strong>user_id: int</strong></p><p> <strong>role_id: int</strong></p><p><strong>role</strong></p><p><strong>id: int</strong></p><p><strong>rolename: varchar(255)</strong> </p><h1 id="1-SSM框架整合"><a href="#1-SSM框架整合" class="headerlink" title="1.SSM框架整合"></a>1.SSM框架整合</h1><h2 id="1-1准备工作"><a href="#1-1准备工作" class="headerlink" title="1.1准备工作"></a>1.1准备工作</h2><p><strong>1.原始方式整合</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database ssm;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> account(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    name <span class="type">varchar</span> (<span class="number">100</span>),</span><br><span class="line">    money <span class="keyword">double</span> (<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line">); </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb</title>
      <link href="/2024/03/13/JavaWeb/"/>
      <url>/2024/03/13/JavaWeb/</url>
      
        <content type="html"><![CDATA[<h1 id="1-1Junit单元测试"><a href="#1-1Junit单元测试" class="headerlink" title="1.1Junit单元测试:"></a>1.1Junit单元测试:</h1><h2 id="测试分类"><a href="#测试分类" class="headerlink" title="测试分类:"></a><strong>测试分类:</strong></h2><p><strong>1.黑盒测试:不需要写代码,给输入值,看程序是否能够输出期望的值。</strong></p><p><strong>2.白盒测试:需要写代码的。关注程序具体的执行流程。</strong></p><p><strong>Junit使用:白盒测试</strong></p><h2 id="Junit使用-白盒测试"><a href="#Junit使用-白盒测试" class="headerlink" title="Junit使用:白盒测试"></a>Junit使用:白盒测试</h2><p><strong>步骤:</strong></p><p><strong>1.定义一个测试类(测试用例)</strong></p><p><strong>建议:</strong></p><p><strong>测试类名: 被测试的类名Test      calculatorTest</strong></p><p><strong>包名: xxx.xxx.xx.test               cn.itcast.test</strong></p><p><strong>2.定义测试方法:可以独立运行</strong></p><p><strong>建议:</strong></p><p><strong>方法名:test测试的方法名testAdd()</strong></p><p><strong>返回值: void</strong></p><p><strong>参数列表: 空参</strong></p><p><strong>3.给方法加@Test</strong></p><p><strong>4.导入junit依赖环境</strong></p><p><strong>判定结果:</strong></p><p><strong>红色:失败</strong></p><p><strong>绿色:成功</strong></p><p><strong>一般我们会使用断言操作来处理结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Assert.assertEquals(期望的结果,运算的结果);</span><br></pre></td></tr></table></figure><p><strong>补充:</strong></p><p> <strong>@Before:修饰的方法会在测试方法之前被自动执行</strong></p><p><strong>@After:修饰的方法会在测试方法执行之后自动被执行。</strong></p><h1 id="反射-框架设计的灵魂"><a href="#反射-框架设计的灵魂" class="headerlink" title="反射:框架设计的灵魂"></a>反射:框架设计的灵魂</h1><p><strong>框架:半成品软件。可以在框架的基础上进行软件开发,简化编码</strong></p><p><strong>反射:将类的各个组成部分封装为其他对象,这就是反射机制</strong></p><p><strong>好处:</strong></p><p><strong>1.可以在程序运行过程中,操作这些对象。</strong></p><p><strong>2.可以解耦,提高程序的可扩展性。</strong></p><h2 id="Java代码-在计算机中经历的阶段-三个阶段"><a href="#Java代码-在计算机中经历的阶段-三个阶段" class="headerlink" title="Java代码 在计算机中经历的阶段:三个阶段"></a><strong>Java代码 在计算机中经历的阶段:三个阶段</strong></h2><p><strong>源代码阶段  : javac 编译–字节码文件加载到内存：成员变量，构造方法，成员方法—</strong></p><p><strong>Class类对象阶段：类加载器  对象描述  class类对象：成员变量Field[ ]fields，构造方法constructor[ ]cons，成员方法Method[ ] methods</strong></p><p><strong>运行时阶段</strong></p><h2 id="获取Class对象的方式"><a href="#获取Class对象的方式" class="headerlink" title="获取Class对象的方式:"></a><strong>获取Class对象的方式:</strong></h2><p>**1.Class.forName(“全类名”); 将字节码文件加载进内存,返回class对象   **</p><p><strong>多用于配置文件  将类名定义在配置文件中。读取文件,加载类</strong></p><p>**2.类名.class: 通过类名的属性class获取 **</p><p><strong>多用于参数的传递</strong></p><p><strong>3.对象.getclass(): getclass()方法在object类中定义着。</strong></p><p><strong>多用于对象的获取字节码的方式</strong></p><p><strong>结论:同一个字节码文件(*.class)在一次程序运行过程中,只会被加载一次,不论通过哪一种方式获取的class对象都是同一个。</strong></p><h1 id="Class对象功能"><a href="#Class对象功能" class="headerlink" title="Class对象功能"></a>Class对象功能</h1><p><strong>获取功能:</strong></p><p>**1,获取成员变量们  **</p><p>**Field[] getFields()                      获取所有public修饰的成员变量    **</p><p><strong>Field getField(String name)       获取指定名称的bublic修饰的成员变量</strong></p><p><strong>Field[] getDeclaredFields()</strong></p><p><strong>Field getDeclaredField(String name)</strong></p><p><strong>2.获取构造方法们</strong></p><p><strong>Constructor&lt;?&gt;[] getConstructors()</strong></p><p><strong>Constructor<T> getconstructor(类&lt;?&gt;…. parameterTypes)</strong></p><p><strong>Constructdr<t> getDeclaredConstructor (类&lt;?&gt;… parameterTypes)</strong></p><p> <strong>Constructor&lt;?&gt;[] getDeclaredConstructors()</strong></p><p><strong>3.获取成员方法们</strong></p><p><strong>Method[] getMethods()</strong></p><p><strong>Method getMethod(String name, 类&lt;?&gt;… parameterTypes)</strong> </p><p><strong>Method[] getDeclaredMethods()</strong></p><p><strong>Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes)</strong> </p><p><strong>4.获取类名</strong></p><p><strong>string getName()</strong></p><p><strong>Field :成员变量</strong></p><p><strong>操作:</strong></p><p><strong>1.设置值</strong></p><p><strong>void set(Object obj, Object value)</strong></p><p><strong>2.获取值</strong></p><p><strong>get(object obj)</strong></p><p><strong>3.忽略访问权限修饰符的安全检擦</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setAccessible(<span class="literal">true</span>);<span class="comment">//暴力反射</span></span><br></pre></td></tr></table></figure><p><strong>Constructor:构造方法</strong></p><p><strong>创建对象:</strong></p><p><strong>T newInstance(Object…. initargs)</strong></p><p><strong>如果使用空参数构造方法创建对象,操作可以简化: class对象的newInstance方法</strong></p><p><strong>Method : 方法对象</strong></p><p><strong>执行方法:</strong></p><p><strong>Object invoke(Object obj, object… args)</strong></p><p><strong>获取方法名称:</strong></p><p> <strong>string getName</strong></p><p><strong>案例:</strong></p><p><strong>需求:</strong></p><p><strong>写一个”框架”,不能改变该类的任何代码的前提下,可以帮我们创建任意类的对象,并且执行其中任意方法</strong></p><p><strong>实现:</strong></p><p><strong>1.配置文件</strong></p><p><strong>2.反射</strong></p><p><strong>步骤:</strong></p><p><strong>1,将需要创建的对象的全类名和需要执行的方法定义在配置文件中</strong></p><p><strong>2,在程序中加载读取配置文件</strong></p><p><strong>3.使用反射技术来加载类文件进内存</strong></p><p><strong>4.创建对象</strong></p><p><strong>5.执行方法</strong></p><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p><strong>概念:说明程序的。给计算机看的</strong></p><p><strong>注释:用文字描述程序的。给程序员看的</strong></p><p><strong>定义:注解(Annotation),也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性,与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面,用来对这些元素进行说明,注释。</strong></p><p><strong>概念描述:</strong></p><p> <strong>JDK1.5之后的新特性</strong></p><p><strong>说明程序的</strong></p><p><strong>使用注解:@注解名称</strong></p><p><strong>作用分类:</strong></p><p><strong>@编写文档:通过代码里标识的注解生成文档【生成文档doc文档】</strong></p><p><strong>@代码分析:通过代码里标识的注解对代码进行分析【使用反射】</strong></p><p><strong>@编译检查:通过代码里标识的注解让编译器能够实现基本的编译检查【override】</strong></p><p><strong>JDK中预定义的一些注解</strong></p><p><strong>@override：检测被该注解标注的方法是否是继承自父类(接口)的</strong></p><p><strong>@Deprecated：将该注解标注的内容,已过时</strong></p><p> <strong>@Suppresswarnings：压制警告                  一般传递参数all@Suppresswarnings(“all”)</strong>   </p><p><strong>自定义注解</strong></p><p><strong>格式:</strong></p><p><strong>元注解</strong>  </p><p><strong>public @interface 注解名{</strong></p><p><strong>属性列表；</strong></p><p><strong>}</strong></p><p><strong>本质:注解本质上就是一个接口,该接口默认继承Annotation接口</strong></p><p> <strong>public interface MyAnno extends java.lang. annotation. Annotation{ }</strong></p><p><strong>属性:接口中的抽象方法</strong></p><p><strong>要求:</strong></p><p><strong>1.属性的返回值类型有下列取值</strong></p><p><strong>基本数据类型</strong></p><p><strong>string</strong></p><p><strong>枚举</strong></p><p><strong>注解</strong></p><p><strong>以上类型的数组</strong></p><p><strong>2.定义了属性,在使用时需要给属性赋值</strong></p><p><strong>2.1.如果定义属性时,使用default关键字给属性默认初始化值,则使用注解时,可以不进行属性的赋值。</strong></p><p><strong>2.2如果只有一个属性需要赋值,并且属性的名称是value,则value可以省略,直接定义值即可</strong></p><p><strong>2.3数组赋值时,值使用包裹。如果数组中只有一个值,则分省略</strong></p><p><strong>元注解:期于描述注解的注解</strong></p><p><strong>@Target :描述注解能够作用的位置</strong></p><p><strong>ElementType取值:</strong></p><p> <strong>TYPE:可以作用于类上</strong></p><p> <strong>METHOD :可以作用于方法上</strong></p><p><strong>FIELD:可以作用于成员变量上</strong></p><p><strong>@Retention :描述注解被保留的阶段</strong></p><p>​<strong>@Retention(RetentionPolicy.RUNTIME)：当前被描述的注解,会保留到class字节码文件中,并被JVM读取到</strong></p><p><strong>@Documented :描述注解是否被抽取到api文档中</strong></p><p><strong>@Inherited:描述注解是否被子类继承</strong></p><p><strong>在程序使用(解析)注解:获取注解中定义的属性值</strong></p><p><strong>1.获取注解定义的位置的对象 (class, Method, Field)</strong></p><p><strong>2.获取指定的注解</strong></p><p>*** getAnnotation(class)**</p><p><strong>其实就是在内存中生成了一个该注解接口的子类实现对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProImpl</span> implement Pro&#123;</span><br><span class="line">       String <span class="title function_">className</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;cn.itcast.annotation.Demo1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">        String <span class="title function_">methodName</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;show&quot;</span>;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.调用注解中的抽象方法获取配置的属性值</strong></p><p><strong>小结:</strong></p><p><strong>1.以后大多数时候,我们会使用注解,而不是自定义注解</strong></p><p><strong>2.注解给谁用?</strong></p><p><strong>1.编译器</strong></p><p><strong>2.给解析程序用</strong></p><p><strong>3.注解不是程序的一部分,问以理解为注解就是一个标签</strong></p><h1 id="javaweb"><a href="#javaweb" class="headerlink" title="javaweb"></a>javaweb</h1><h2 id="1-数据库"><a href="#1-数据库" class="headerlink" title="1.数据库"></a>1.数据库</h2><p><strong>什么数据库?</strong></p><p><strong>用于存储和管理数据的仓库。</strong></p><p><strong>数据库的特点:</strong></p><p><strong>1,持久化存储数据的。其实数据库就是一个文件系统</strong></p><p><strong>2.方便存储和管理数据</strong></p><p><strong>3.使用了统一的方式操作数据库。</strong></p><p><strong>1.什么是SQL?</strong></p><p><strong>Structured oWery Language : 结构化查询语</strong></p><p><strong>其实就是定义了操作所有关系型数据库的规则。</strong></p><p><strong>每一种数据库操作的方式存在不一样的地方,称为“方言”</strong></p><h2 id="3-SQL分类"><a href="#3-SQL分类" class="headerlink" title="3.SQL分类"></a>3.SQL分类</h2><p><strong>1.DDL(Data Definition Language)数据定义语言用来定义数据库对象:数据库,表,列等。关键字: create, drop,alter等</strong></p><p><strong>2.DML(Data Manipulation Language)数据操作语言用来对数据库中表的数据进行增删改。关键字:insert, delete, update等</strong></p><p><strong>3.DQL(Data Query Language)数据询语言用来查询数据库中表的记录(数据)。关键字: select, where等</strong></p><p><strong>4.DCL (Data Control Language)数据控制语言(了解)用来定义数据库的访问权限和安全级别,及创建用户。关键字: GRANT,REVOKE 等</strong></p><h2 id="1-操作数据库-CRUD"><a href="#1-操作数据库-CRUD" class="headerlink" title="1,操作数据库: CRUD"></a>1,操作数据库: CRUD</h2><p><strong>1.C(Create) :创建</strong></p><p><strong>创建db4数据库,判断是否存在,并制定字符集为gbk</strong></p><ul><li><strong>create database if not exists db4 character set gbk;</strong></li></ul><p><strong>2.R(Retrieve) :查询</strong></p><p>​<strong>查询所有数据库的名称: show databases;</strong>*</p><p>​<strong>查询某个数据库的字符集:查询某个数据库的创建语句</strong></p><p>​<strong>show create database 数据库名称;</strong></p><p><strong>3.U(Update) :修改</strong></p><p><strong>修改数据库的字符集</strong></p><ul><li><strong>alter database 据库名character set 字符集名称;</strong></li></ul><p><strong>4.D(Delete) :删除</strong></p><p><strong>修改数据库的字符集</strong></p><ul><li><p><strong>drop database 据库名</strong></p><p><strong>判断数据库存在,存在再删除</strong></p></li><li><p><strong>drop database if exists 数据库名称;</strong></p></li></ul><p><strong>5.使用数据库</strong></p><p><strong>查询当前正在使用的数据库名称</strong></p><ul><li><strong>select database();</strong></li></ul><p><strong>使用数据库</strong></p><p><strong>use 数据库名称;</strong></p><h2 id="2-操作表"><a href="#2-操作表" class="headerlink" title="2.操作表"></a>2.操作表</h2><p><strong>1.C(Create):创建</strong></p><p><strong>CREATE TABLE student( id int,…);</strong></p><p><strong>2.R(Retrieve) :查询</strong></p><p><strong>查询某个数据库中所有的表名称</strong></p><p>*** show tables;**</p><p><strong>查询表结构</strong></p><p>*<strong>desc表名;</strong></p><p><strong>3.U(Update) :修改</strong></p><p>*** update表名set 列名1 &#x3D;值1,列名2 &#x3D;值2,… [where条件];**</p><p><strong>4.D(Delete) :删除</strong></p><p><strong>delete from表名;</strong></p><p><strong>TRUNCATE TABLE 表名;</strong></p><h2 id="DQL-查询表中的记录"><a href="#DQL-查询表中的记录" class="headerlink" title="DQL:查询表中的记录"></a>DQL:查询表中的记录</h2><p><strong>select * from 表名;</strong></p><p><strong>1.语法:</strong></p><p><strong>select字段列表</strong></p><p><strong>from表名列表</strong></p><p><strong>where条件列表</strong></p><p><strong>group by分组字段</strong></p><p><strong>having分组之后的条件</strong></p><p><strong>order by排序</strong></p><p><strong>limit分页限定</strong></p><p><strong>基础查询</strong></p><p><strong>1,多个字段的查询</strong></p><p><strong>SELECT NAME, age FROM student;</strong> </p><p><strong>SELECT * FROM student;</strong> </p><p><strong>2.去除重复 distinct</strong></p><p><strong>SELECT DISTINCT address FROM student;</strong></p><p><strong>3.计算列</strong></p><p><strong>一般可以使用四则运算计算一些列的值。(一般只会进行数值型的计算)</strong></p><p><strong>SELECT NAME, math, english, math + english FROM student;</strong></p><p><strong>如果有null参与的一般可以使用四则运算计算一些列的值。(一般只会进行数值型的计算),计算结果都为null</strong></p><p><strong>SELECT NAME, math, english, math + IF NULL (english, 0) FROM student;</strong></p><p><strong>4.起别名 as可省略</strong></p><p><strong>SELECT NAME, math, english, math + IF NULL (english, 0) AS总分 FROM student;</strong></p><p><strong>SELECT NAME, math, english, math + IF NULL (english, 0)  总分 FROM student;</strong></p><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><ol><li><strong>where子句后跟条件</strong></li><li><strong>运算符  &gt;、&lt; 、&lt;&#x3D;  .&gt;&#x3D;. &#x3D; .&lt;&gt;</strong></li><li><ul><li><strong>BETWEEN…AND</strong></li><li><strong>IN(集合)</strong></li><li><strong>LIKE 模糊查询—–占位符:  _:单个任意字符    %:任意多字符</strong></li><li><strong>IS NULL</strong></li><li><strong>and 或&amp;&amp;</strong></li><li><strong>or 或||</strong></li><li><strong>not 或 !</strong></li></ul></li></ol><p><strong>1,修改表名</strong></p><p><strong>alter table 表名 rename to 新的表名;</strong></p><p><strong>2.修改表的字符集</strong></p><p><strong>alter table表名 character set 字符集名称;</strong></p><p><strong>3.添加一列</strong></p><p><strong>alter table 表名 add列名 数据类型;</strong></p><p><strong>4,修改列名称类型</strong></p><p><strong>alter table 表名 change 列名 新列  新数据类型;</strong></p><p><strong>alter table 表名 modify  列名 新数据类型;</strong></p><p><strong>5.删除列</strong></p><p><strong>alter table 表名 drop名;</strong></p><h2 id="DML-增删改表中数据"><a href="#DML-增删改表中数据" class="headerlink" title="DML:增删改表中数据"></a>DML:增删改表中数据</h2><p><strong>1.添加数据:语法:</strong></p><p><strong>insert into 表名(列名1,列名2,列名n) values(值1,值2,.值n);</strong></p><p><strong>除了数字类型,其他类型需要使用引号(单双都可以)引起来,</strong></p><p><strong>2.删除数据:</strong></p><p><strong>delete from 表名[where 条件]</strong></p><p><strong>TRUNCATE  TABLE  stu；——–删除表,然后再创建一个一模一样的空表</strong></p><p><strong>3.修改数据:</strong></p><p><strong>update 表名 set 列名1 &#x3D;值1,列名2 &#x3D; 值2,… [where条件];</strong></p><h2 id="DQL-查询语句"><a href="#DQL-查询语句" class="headerlink" title="DQL:查询语句"></a>DQL:查询语句</h2><p><strong>1.排序查询</strong></p><p><strong>按照数学成绩排名,如果数学成绩一样,则按照英语成绩排名</strong></p><p><strong>SELECT FROM student ORDER BY math ASC , english ASC;</strong></p><p><strong>语法: order by 子句</strong></p><p> <strong>order by 排序字段1排序方式1, 排序字段2排序方式2…·</strong></p><p><strong>排序方式:</strong></p><p> <strong>ASC:升序,默认的。</strong></p><p> <strong>DESC : 降序。</strong></p><p><strong>注意:如果有多个排序条件,则当前边的条件值一样时,才会判断第二条件。</strong></p><p><strong>2.聚合查询</strong></p><p><strong>1.count :计算不数</strong></p><p><strong>BELECT COUNT (If NULL (engliah, 01) FROM atudent;</strong></p><p><strong>2.max:计算最大值</strong></p><p><strong>SELECT MAX (math) FROM student;</strong></p><p><strong>SELECT MIN (math) FROM atudent;</strong></p><p><strong>3.min:计算最小值</strong></p><p><strong>4.sum :计算和</strong></p><p><strong>SELECT COUNT (id) PROM student;</strong></p><p><strong>5.avg:计算平均值</strong></p><p><strong>SELECT AVG (math) PROM student;</strong></p><p><strong>注意:聚合函数的计算,排除null值。</strong></p><p><strong>解决方案:</strong></p><p><strong>1.选择不包含非空的列进行计算</strong></p><p><strong>2. IFNULL函数</strong></p><p><strong>3.分组查询</strong></p><p><strong>group by分组字段;</strong></p><p><strong>按照性别分组,分别查询男、女同学的平均分</strong></p><p><strong>SELECT  sex,avg(math) FROM student GROUP BY sex:</strong></p><p><strong>按照性别分组,分别查询男、女同学的平均分,人数</strong></p><p><strong>SELECT  sex,avg(math),count(id) FROM student GROUP BY sex:</strong></p><p><strong>接照性别分超,分别查询男、文同学的平均分,人数要求:分数低于70分的人,不参与分组</strong></p><p><strong>SELECT sex,AVG (math).count (id) FROM student WHERE math &gt; 70 GROOP BY sex:</strong></p><p><strong>接照性别分超,分别查询男、文同学的平均分,人数要求:分数低于70分的人,不参与分组分组之后要大于2个人</strong></p><p><strong>SELECT sex,AVG (math).count (id) FROM student WHERE math &gt; 70 GROOP BY sex having count(id)&gt;2;</strong></p><p><strong>SELECT sex,AVG (math).count (id) 人数 FROM student WHERE math &gt; 70 GROOP BY sex having 人数&gt;2;</strong></p><p><strong>分组之后查询的字段:分组字段、聚合函数</strong></p><p><strong>where 和having 的区别?</strong></p><p><strong>1. where 在分组之前进行限定,如果不满足条件,则不参与分组。having在分组之后进行限定,如果不满足结果,则不会被查询出来、</strong></p><p><strong>2.where后不可以跟聚合函数, having可以进行聚合函数的判断。</strong></p><p><strong>4,分页查询</strong></p><p><strong>语法limit 开始的索引,每页查询的条数;</strong></p><p><strong>每页品示3条记录</strong></p><p><strong>SELECT * FROM student LIMIT 0，3；</strong></p><p>*<em>公式:开始的案引&#x3D;(当前的页码-1) <em>每页显示的条数</em></em></p><p><strong>limit操作是一个mysql的”方言”</strong></p><p><strong>约束概念:</strong></p><p><strong>对表中的数据进行限定,保证数据的正确性、有效性和完整性。</strong></p><p><strong>分类:</strong></p><ol><li><strong>主键约束: primary key</strong></li></ol><p><strong>1.1,含义:非空且唯一</strong></p><p><strong>1.2.一张表只能有一个字段为主键</strong></p><p><strong>删除主键</strong></p><p><strong>ALTER TABLE Btu DROP PRIMARY KEY;</strong></p><p><strong>自动增长:</strong></p><p><strong>概念:如果某一列是数值类型的,使用auto_increment可以来完成值得自动增长</strong></p><p><strong>INSERT INTO atu VALUES (null, ‘ccc’):</strong></p><p><strong>AITER TABLE stu MODIFY id INT auto_increment;</strong></p><p><strong>删除自动增长</strong></p><p><strong>AITER TABLE stu MODIFY id INT;</strong></p><p><strong>1.3.主键就是表中记录的唯一标识</strong></p><ol start="2"><li><strong>非空约束: not null</strong></li></ol><p><strong>-删除name的非空約東</strong></p><p><strong>ALTER TABLE atu MODIFY NAME VARCHAR (20) ;</strong></p><p><strong>–创建表完后,添加非空约束</strong></p><p><strong>ALTER TABLE stu MODIFY NAME VARCHAR (20) NOT NUll;</strong></p><p>3.<strong>唯一约束: unique</strong></p><p>​<strong>注意:唯一约束可以有NULL值,但是只能有一条记录为null</strong></p><p>​<strong>删除唯一约束</strong></p><p>​<strong>ALTER TABLE Stu DROP INDEX phone_number;</strong></p><p>4.<strong>外键约束: foreign key</strong></p><p><strong>1.在创建表时,可以添加外键</strong></p><ul><li><p><strong>语法:</strong></p><p><strong>create table 表名(</strong></p><p><strong>….</strong></p><p><strong>外键列</strong></p><p><strong>constraint 外键名称 foreign key （外键列名） references 主表名称(主表列名称)</strong></p><p><strong>);</strong></p></li></ul><p><strong>2.删除外键</strong></p><p><strong>ALTER TABLE 表名 DROP FOREIGN KEY 外键名称；</strong></p><p><strong>3.创建表之后,添加外键</strong></p><p><strong>TABLE 表名ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称)；</strong></p><p><strong>4.添加外键,设置级联更新</strong></p><p><strong>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称 (主表列名称) ON UPDATE CASCADE</strong></p><p><strong>–添加外键,设置级联更新,设置级联删除</strong></p><p><strong>ALTER TABLE employee ADD CONSTRAINT emp_dept_fk FOREIGN KEY(dep id) REFERENCES department (id) ON UPDATE CASCADE ON DELETE CASCADE</strong></p><p><strong>2.分类:</strong></p><p><strong>1,级联更新: ON UPDATE CASCADE</strong></p><p><strong>2.级联删除: ON DELETE CASCADE</strong></p><p><strong>数据库的设计</strong></p><p><strong>1,多表之间的关系</strong></p><p><strong>1.一对一(了解):</strong></p><p><strong>如:人和身份证</strong></p><p><strong>分析:一个人只有一个身份证,一个身份证只能对应一个人</strong></p><p><strong>2.一对多(多对一):</strong></p><p><strong>如:部门和员工</strong></p><p><strong>分析:一个部门有多个员工,一个员工只能对应一个部门</strong></p><p><strong>3,多对多:</strong></p><p><strong>如:学生和课程</strong></p><p><strong>分析:一个学生可以选择很多门课程,一个课程也可以被很多学生选择</strong></p><p><strong>2,实现关系:</strong></p><p><strong>1.一对多(多对一):</strong></p><p><strong>如:部门和员工</strong></p><p><strong>实现方式:在多的一方建立外键,指向一的一方的主键。</strong></p><p><strong>2.多对多关系</strong></p><p><strong>多对多关系实现需要借助第三张中间表。中间表至少包含两个字段,这两个字段作为第三张表的外健,分别指向两张表的主健</strong></p><p><strong>3.一对一(了解):</strong></p><p><strong>如:人和身份证</strong></p><p><strong>实现方式:一对一关系实现,可以在任意一方添加唯一外键指向另一方的主键。</strong></p><p><strong>数据库设计的范式</strong></p><p>*<strong>概念:设计数据库时,需要遵循的一些规范。</strong></p><p><strong>设计关系数据库时,遵从不同的规范要求,设计出合理的关系型数据库,这些不同的规范要求被称为不同的范式,各种范式呈递次规范,越高的范式数据库冗余越小。</strong></p><p><strong>目前关系数据库有六种范式:第一范式(1NF)、第二随式(2NF)、第三范式(3NF)、巴斯-科德范式(BCNF)、第四范式(4NF)和第五范式(5NF,又称完美范式)。</strong></p><p><strong>分类:</strong></p><p><strong>1.第一范式(1NF):每一列都是不可分割的原子数据项,</strong></p><p><strong>2.第二范式(2NF):在1NF的基础上,非码属性必须完全依赖于候选码(在1NF基础上消除非主属性对主码的部分函数依赖)</strong></p><p><strong>几个概念:</strong></p><p><strong>1.函数依赖:A–&gt;B,如果通过A属性(属性组)的值,可以确定唯一B属性的值。则称B依赖于A</strong></p><p><strong>例如:学号–&gt;姓名。(学号,课程名称) –&gt;分数</strong></p><p><strong>2.完全函数依赖:A–&gt;B,如果A是一个属性组,则B属性值得确定需要依赖于A属性组中所有的属性值。</strong></p><p><strong>例如:(学号,课程名称) –&gt;分数</strong></p><p><strong>3.部分函数依赖:A–&gt;B,如果A是一个属性组,则B属性值得确定只需要依赖于A属性组中某一些值即可。</strong></p><p><strong>例如:(学号,课程名称) –&gt;姓名</strong></p><p><strong>4.传递函数依赖:A–&gt;B, B –&gt;C.如果通过A属性(属性组)的值,可以确定唯一B属性的值,在通过B属性(属性组)的值可以确定唯一属性的值,则称C传递函数依赖于A</strong></p><p><strong>例如:学号–)系名,系名–&gt;系主任</strong></p><p><strong>5.码:如果在一张表中,一个属性或属性组,被其他所有属性所完全依赖,则称这个属性(属性组)为该表的码</strong></p><p><strong>例如:该表中码为:(学号,课程名称)</strong></p><p><strong>主属性:码属性组中的所有属性</strong></p><p><strong>非主属性:除过码属性组的属性,</strong></p><p><strong>3.第三范式(3NF):在2NF基础上,任何非主属性不依赖于其它非主属性(在2NF基础上消除传递依赖)</strong></p><p><strong>笛卡尔积:”有两个集合A,B,取这两个集合的所有组成情况。</strong></p><p><strong>要完成多表查询,需要消除无用的数据</strong></p><h2 id="多表查询的分类"><a href="#多表查询的分类" class="headerlink" title="多表查询的分类:"></a><strong>多表查询的分类:</strong></h2><p><strong>隐式内连接:使用where条件消除无用数据</strong></p><p><strong>1,内连接查询:</strong></p><p><strong>-查询所有员工信息和对应的部门信息</strong></p><p><strong>SELECT * FROM emp, dept WHERE emp. ‘dept_id’ &#x3D; dept. ‘id’</strong></p><p><strong>-查询员工表的名称,性别,部门表的名称SELECT emp. name, emp. gender, dept.name FRoM emp, dept wHERe emp. ‘dept id’ &#x3D; dept. ‘id’;</strong></p><p><strong>2.显式内连接:</strong></p><p><strong>语法:select 字段列表 from表名1 inner join表名2 on条件</strong></p><p><strong>SELECT * FROM emp INNER JOIN dept oN emp. ‘dept_id’&#x3D; dept. ‘id’;</strong></p><p><strong>2.外链接查询:</strong></p><p><strong>左外连接:</strong></p><p>*<strong>语法: select 字段列表from表1 left [outer] join 表2 on条件;</strong></p><p><strong>SELECT t1.*,t2. ‘name’ FROM emp t1 LEFT JOIN dept t2 ON t1. ‘dept_id’ &#x3D; t2. ‘id’;</strong></p><p><strong>查询的是左表所有数据以及其交集部分。</strong></p><p><strong>右外连接:</strong></p><p><strong>语法: select 字段列表from 表1 right [outer] join表2 on条件;</strong></p><p><strong>查询的是右表所有数据以及其交集部分。</strong></p><p><strong>3.子查询:</strong></p><p><strong>概念:查询中嵌套查询,称嵌套查询为子查询</strong></p><p><strong>SELECT * FROM omp WHERE emp. ‘salary’ &#x3D; (SELECT MAX (salary) FROM emp) ;</strong></p><p><strong>事务的基本介绍</strong></p><p><strong>1.概念:</strong></p><p>*<strong>如果一个包含多个步骤的业务操作,被事务管理,那么这些操作要么同时成功,要名同时失败。</strong></p><p><strong>2.操作:</strong></p><p><strong>1.1开启事务: start transaction;</strong></p><p><strong>2.1回滚: rollback;</strong></p><p><strong>3.1提交: commit;</strong></p><p><strong>4.1MySQL数据库中事务默认自动提交</strong></p><p><strong>事务提交的两种方式:</strong></p><p><strong>自动提交:</strong></p><p> <strong>mysq1就是自动提交的</strong></p><p><strong>一条DML(增删改)语句会自动提交一次事务。</strong></p><p><strong>手动提交:</strong></p><p> <strong>Oracle 数据库默认是手动提交事务</strong></p><p><strong>需要先开启事务,再提交</strong></p><p><strong>修改事务的默认提交方式:</strong></p><p><strong>查看事务的默认提交方式: SELECT @@autocommit;–1</strong></p><p><strong>代表自动提交 0代表手动提交</strong></p><p><strong>修改默认提交方式: set @@autocommit &#x3D; 0;</strong></p><p><strong>2.事务的四大特征</strong></p><p><strong>1.原子性:是不可分割的最小操作单位,要么同时成功,要么同时失败。</strong></p><p><strong>2.持久性:当事务提交或回滚后,数据库会持久化的保存数据。</strong></p><p><strong>3.隔离性:多个事务之间。相互独立。</strong></p><p><strong>4.一致性:事务操作前后,数据总量不变</strong></p><p><strong>3.事务的隔离级别(了解)</strong></p><p><strong>概念:多个事务之间隔离的,相互独立的。但是如果多个事务操作同一批数据,则会引发一些问题,设置不同的隔离级别就可以解决这些问题。</strong></p><p><strong>存在问题:</strong></p><p><strong>1.脏读:一个事务,读取到另一个事务中没有提交的数据</strong></p><p><strong>2,不可重复读(虚读):在同一个事务中,两次读取到的数据不一样。</strong></p><p><strong>3.幻读:一个事务操作(DML)数据表中所有记录,另一个事务添加了一条数据,则第一个事务查询不到自己的修改。</strong></p><p><strong>隔离级别:</strong></p><p><strong>1.read uncommitted :读未提交</strong></p><p><strong>产生的问题:脏读、不可重复读、幻读</strong></p><p><strong>2.pread committed :读已提交（oracle）</strong></p><p><strong>产生的问题:不可重复读、幻读</strong></p><p><strong>3.repeatable read : 可重复读(mysql默认)</strong></p><p><strong>产生的问题:幻读</strong></p><p><strong>4.serializable :串行化</strong></p><p><strong>可以解决所有的问题</strong></p><p><strong>注意:隔离级别从小到大安全性越来越高,但是效率越来越低</strong></p><p><strong>数据库查询隔离级别:</strong></p><p> <strong>select @@tx_isolation;</strong></p><p><strong>数据库设置隔离级别:</strong></p><p> <strong>set global transaction isolation level 级别字符串;</strong></p><h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><p>*<strong>概念: Java DataBase Connectivity Java数据库连接, Java语言操作数据库</strong></p><p><strong>JDBC:定义了一套操作所有关系型数据库的规则（接口）</strong></p><p><strong>JDBC本质:其实是官方(sun公司)定义的一套操作所有关系型数据库的规则,即接口。各个数据库厂商去实现这套接口,提供数据库驱动jar包。我们可以使用这套接口(JDBC)编程,真正执行的代码是驱动jar包中的实现类</strong></p><p><strong>2.快速入门:</strong></p><p>*<strong>步骤:</strong></p><p><strong>1.导入驱动jar包mysql-connector-java-5.1.37-bin.jar</strong></p><p><strong>1.1复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下</strong></p><p><strong>1.2.右键–&gt;Add As Liblary</strong></p><p><strong>2.注册驱动</strong></p><p><strong>3.获取数据库连接对象Connection</strong></p><p><strong>4,定义sql</strong></p><p><strong>5,获取执行sq1语句的对象Statement</strong></p><p><strong>6.执行sql,接受返回结果</strong></p><p><strong>7,处理结果</strong></p><p><strong>8.释放资源</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcDemo1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.导入驱动jar包</span></span><br><span class="line">        <span class="comment">//2.注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">//3.获取数据库连接对象</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection( url: <span class="string">&quot;jdbe:mysql://localhost:3306/db3&quot;</span>, <span class="string">&quot;root&quot;</span>,<span class="string">&quot;password&quot;</span>);</span><br><span class="line">       <span class="comment">//4.定义sql语句</span></span><br><span class="line">      String sql= <span class="string">&quot;update account set balance = 500 where id = 1&quot;</span>;</span><br><span class="line">      <span class="comment">//5.获取执行sql的对象Statement</span></span><br><span class="line">      <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement ();</span><br><span class="line">      <span class="comment">//6.执行sql</span></span><br><span class="line">      <span class="type">int</span> count= stmt.executeUpdate(sq1);</span><br><span class="line">      <span class="comment">//7.处理结果</span></span><br><span class="line">      System. out.println(count);</span><br><span class="line">      <span class="comment">//8.释放资源</span></span><br><span class="line">      stmt.close();</span><br><span class="line">      conn.close();</span><br><span class="line">                                                      </span><br><span class="line">    &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><h2 id="3-详解各个对象"><a href="#3-详解各个对象" class="headerlink" title="3,详解各个对象:"></a><strong>3,详解各个对象:</strong></h2><p><strong>1.DriverManager :驱动管理对象</strong></p><p><strong>功能:</strong></p><p><strong>1.注册驱动:告近程序该使用哪一个数据库驱动jar</strong></p><p><strong>static void registerpriver(Driver driver) :注册与给定的驱动程序 DriverManager.</strong></p><p><strong>写代码使用: class.forName(“com.mysql.jdbc.Driver);</strong></p><p><strong>通过查看源码发现:在com.mysql.jdbc.Driver类中存在静态代码块</strong></p><p><strong>注意:mysq15之后的驱动jar包可以省略注册驱动的步骤。</strong></p><p><strong>2,获取数据库连接</strong></p><p><strong>方法: static Connection getConnection(String url, String user, string password)</strong></p><p><strong>参数:</strong></p><p> <strong>url:指定连接的路径</strong></p><p><strong>语法: jdbc:mysql:&#x2F;&#x2F;ip地址(域名):端口号&#x2F;数据库名称</strong></p><p><strong>例子: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db3</strong></p><p><strong>细节:如果连接的是本机mysql服务器,并且mysql服务默认端口是3306,则url可以简写为:jdbc:mysql:&#x2F;&#x2F;gb1数据库名称</strong></p><p><strong>user :用户名</strong></p><p><strong>password :密码</strong></p><p><strong>2.connection :数据库连接对象</strong></p><p><strong>1,功能:</strong></p><p><strong>1,获取执行sql的对象</strong></p><p><strong>statement createstatement()</strong></p><p> <strong>Preparedstatement preparestatement (String sql)</strong></p><p><strong>2.管理事务:</strong></p><p><strong>开启事务: setAutoCommit (boolean autoCommit) :调用该方法设置参数为false,即开启事务</strong></p><p><strong>提交事务:commit()</strong></p><p><strong>回滚事务: rollback()</strong> </p><p><strong>3.Statement :执行sql的对象</strong></p><p><strong>执行sql</strong></p><p><strong>1.boolean execute(String sql) :可以执行任意的sql了解</strong></p><p><strong>2.int executeUpdate(String sql) :执行DML (insert, update, delete)、DDI(create, alter, drop)语句</strong></p><p><strong>返回值:影响的行数,可以通过这个影响的行数判断DML语句是否执行成功返回值&gt;0的则执行成功,反之,则失败。</strong></p><p><strong>3.Resultset executeQuery(String sqI) :执行DQL (select)语句</strong></p><p><strong>4.Resultset :结果集对象 封装查询结果</strong></p><p><strong>boolean next():游标向下移动一行,判断当前行是否是最后一行末尾(是否有数据）如果是,则返回false,如果不是则返回true</strong></p><p><strong>getxxx(参数):获取数据</strong></p><p><strong>Xxx:代表数据类型</strong> </p><p><strong>如: int getInt() , String getstring()</strong></p><p><strong>参数:</strong></p><p><strong>1.int :代表列的编号,从1开始 如: getstring(1)</strong></p><p>**2.String :代表列名称如: getDouble(“**balance”)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (rs.next())&#123;</span><br><span class="line">              <span class="comment">//循环判断游标是否是最后一行末尾。</span></span><br><span class="line">              <span class="comment">// 获取数据</span></span><br><span class="line">              <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="number">1</span>);</span><br><span class="line">             <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="type">double</span> <span class="variable">balance</span> <span class="operator">=</span> rs.getDouble(<span class="number">3</span>);</span><br><span class="line">            System.out.println(id+<span class="string">&quot;---&quot;</span>+name+<span class="string">&quot;---&quot;</span>+balance);</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><p><strong>5. Preparedstatement :执sql的对象</strong></p><p><strong>1. SQL注入问题:在拼接sql时,有一些sql的特殊关键字参与字符申的拼接。会造成安全性问题</strong></p><p><strong>1.输入用户随便,输入密码: a’ or ‘a’ &#x3D; ‘a</strong></p><p><strong>2. sql: select * from user where username&#x3D; ‘fhdsjkf’ and password &#x3D; ‘a’ or ‘a’ &#x3D; ‘a’</strong></p><p><strong>2.解决sql注入问题:使用Preparedstatement对象来解决</strong></p><p><strong>3.预编译的SQL:参数使用?作为占位符</strong></p><p><strong>4.步骤:</strong></p><p><strong>1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar</strong></p><p><strong>2.注册驱动</strong></p><p><strong>3.获取数据库连接对象Connection</strong></p><p><strong>4,定义sql</strong></p><p>*<strong>注意: sql的参数使用?作为占位符。如: select * from user where username &#x3D; ? and password &#x3D; ?;</strong></p><p><strong>5. 获取执行sq1语句的对象 Preparedstatement Connection.preparestatement (String sql)</strong></p><p><strong>6,给?赋值:</strong></p><p><strong>方法: setXxx(参数1,参数2)</strong></p><p><strong>参数1:?的位置编号 从1开始</strong></p><p><strong>参数2:?的值</strong></p><p><strong>7.执行sql,接受返回结果,不需要传递sql语句</strong></p><p><strong>8.处理结果</strong></p><p><strong>9,释放资源</strong></p><p><strong>5.注意:后期都会使用Preparedstatement来完成增删改查的所有操作</strong></p><p><strong>1.可以防止sQL注入</strong></p><p><strong>2.效率更高</strong></p><p><strong>抽取JDBC工具类: JDBCUtils</strong></p><p><strong>目的:简化书写分析:</strong></p><p><strong>1,注册驱动也抽取</strong></p><p><strong>2.抽取一个方法获取连接对象</strong></p><p><strong>需求:不想传递参数(麻烦),还得保证工具类的通用性。</strong></p><p><strong>解决:配置文件</strong></p><p><strong>jdbc.properties</strong></p><p><strong>url&#x3D;</strong></p><p><strong>user&#x3D;</strong></p><p><strong>password&#x3D;</strong></p><p><strong>抽取一个方法释放资源</strong></p><p><strong>JDBC控制事务:</strong></p><p><strong>1.事务:一个包含多个步骤的业务操作。如果这个业务操作被事务管理,则这多个步骤要么同时成功,要么同时失败。</strong></p><p><strong>2.操作:</strong></p><p><strong>1.开启事务</strong></p><p><strong>2.提交事务</strong></p><p><strong>3.回滚事务</strong></p><p><strong>3.使用Connection对象来管理事务</strong></p><p><strong>开启事务: setAltoCommit(boolean autoCommit) :调用该方法设置参数为false,即开后事务</strong></p><p><strong>在执行sql之前开启事务,</strong></p><p><strong>提交事务:commit()</strong></p><p><strong>当所有sql都执行完提交事务</strong></p><p><strong>回滚事务: rollback()</strong></p><p><strong>在catch中回滚事务</strong></p><h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><p><strong>概念:其实就是一个容器(集合),存放数据库连接的容器。</strong></p><p><strong>1当系统初始化好后,容器被创建,容器中会申请一些连接对象,当用户来访问数据库时,从容器中获取连接对象,用户访问完之后,会将连接对象归还给容器。</strong></p><p><strong>好处:</strong></p><p><strong>1.节约资源</strong></p><p><strong>2.用户访问高效</strong></p><p><strong>3.实现:</strong></p><p><strong>1.标准接口: DataSource  javax.sql包下的</strong></p><p><strong>1.方法:</strong></p><p> <strong>获取连接: getConnection()</strong></p><p><strong>归还连接:Connection.close()如果连接对象cdnnection是从连接池中获取的,那么调用Connection.close()方法,则不会再关闭连接了。而是归还连接</strong></p><p><strong>2.一般我们不去实现它,有数据库厂商来实现</strong></p><p><strong>1.C3PO :数据库连接池技术</strong></p><p><strong>2.Druid :数据库连接池实现技术，由阿里巴巴提供的</strong></p><h2 id="C3PO-数据库连接池技术"><a href="#C3PO-数据库连接池技术" class="headerlink" title="C3PO:数据库连接池技术"></a><strong>C3PO:数据库连接池技术</strong></h2><p><strong>步骤:1. 导入jar包(两个) c3pe-0.9.5.2.jar mchange-commons-java-0.2.12.jar</strong></p><p><strong>2,定义配置文件:</strong></p><p><strong>名称: c3p0.properties或者c3p0-config.xml</strong></p><p><strong>路径:直接将文件放在src目录下即可。</strong></p><p><strong>3.创建核心对象 数据库连接池对象ComboPooledDataSource</strong></p><p><strong>4.获取连接: getConnection</strong></p><p><strong>5.Druid :数据库连接池实现技术,由阿里巴巴提供的</strong></p><p><strong>步骤:</strong></p><p><strong>1.导入jar包 druid-1.0.9.jar</strong></p><p><strong>2.定义配置文件:</strong></p><p><strong>是properties形式的</strong></p><p><strong>可以叫任意名称,可以放在任意目录下</strong></p><p><strong>3,加载配置文件。Properties</strong></p><p><strong>4.获取数据库连接池对象:通过工厂来来获取 DruidDatasourceFactory</strong></p><p><strong>5.获取连接</strong></p><p><strong>2.定义工具类</strong></p><p><strong>1.定义一个类JDBcutils</strong></p><p><strong>2.提供静态代码块加载配置文件,初始化连接池对象</strong></p><p><strong>3.提供方法</strong></p><p><strong>1.获取连接方法:通过数据库连接池获取连接</strong></p><p><strong>2.释放资源</strong></p><p><strong>3.联取连接池的方法</strong></p><h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><p><strong>Spring框架对JDBC的简单封装 提供了一个JDBCTemplate对象简化JDBC的开发</strong></p><p><strong>步骤:</strong></p><p><strong>1.导入jar包</strong></p><p><strong>2.创建]dbcTemplate对象。依赖于数据源DataSource</strong></p><p> <strong>JdbcTemplate template &#x3D; new JdbcTemplate(ds);</strong></p><p><strong>3.调用JdbcTemplate的方法来完成CRUD的操作</strong></p><p><strong>1.1update():执行DML语句。增、删、改语句</strong></p><p>**1.2queryForMap():查询结果将结果集封装为map集合 **</p><p><strong>将列名作为key,将值作为value将这条记录封装为一个map集合</strong></p><p><strong>注意,这个方法查询的结果集长度只能是1</strong></p><p><strong>1.3queryForList():查询结果将结果集封装为list集合</strong></p><p><strong>将每一条记录封装为一个Map集合,再将Map集合装载到List集合中</strong></p><p><strong>1.4query():查询结果,将结果封装为JavaBean对象</strong></p><p><strong>query的参数: RowMapper</strong></p><p><strong>一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装</strong></p><p><strong>new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</strong></p><p><strong>1.5queryForobject :查询结果,将结果封装为对象</strong></p><p><strong>一般用于聚合函数的查询</strong></p><p><strong>junit单元测试可以让方法独立执行</strong></p><h1 id="web概念概述"><a href="#web概念概述" class="headerlink" title="web概念概述"></a>web概念概述</h1><p> <strong>Javaweb:使用Java语言开发基于互联网的项目软件架构:</strong></p><p><strong>1. C&#x2F;S: client&#x2F;Server 客户端&#x2F;服务器端</strong></p><p><strong>在用户本地有一个客户端程序,在远程有一个服务器端程序</strong></p><p><strong>如:QQ,迅雷.</strong></p><p><strong>优点:1.用户体验好</strong></p><p><strong>缺点:1.开发、安装,部署,维护麻烦</strong></p><p><strong>2.B&#x2F;S: Browser&#x2F;Server浏览器&#x2F;服务器端</strong></p><p><strong>只需要一个浏览器,用户通过不同的网址(URL),客户访问不同的服务器端程序</strong></p><p><strong>优点:</strong></p><p><strong>1.开发、安装,部署,维护简单</strong></p><p><strong>缺点:</strong></p><p><strong>1.如果应用过大,用户的体验可能会受到影响</strong></p><p><strong>2、对硬件要求过高</strong></p><p><strong>B&#x2F;S架构详解</strong></p><p><strong>资源分类:</strong></p><p><strong>1.静态资源:</strong></p><p><strong>使用静态网页开发技术发布的资源。</strong></p><p><strong>特点:</strong></p><p><strong>所有用户访问,得到的结果是一样的。</strong></p><p><strong>如:文本,图片,音频、视频, HTML,CSS, Javascript</strong></p><p><strong>如果用户请求的是静态资源,那么服务器会直接将静态资源发送给浏览器。</strong></p><p><strong>浏览器中内置了静态资源的解析引擎,可以展示静态资源</strong></p><p><strong>2.动态资源:</strong></p><p><strong>使用动态网页及时发布的资源。</strong></p><p><strong>特点:</strong></p><p><strong>所有用户访问,得到的结果可能不一样。</strong></p><p><strong>如: jsp&#x2F;servlet,php, asp…</strong></p><p><strong>如果用户请求的是动态资源,那么服务器会执行动态资源,转换为静态资源,再发送给浏览器</strong></p><h2 id="XML"><a href="#XML" class="headerlink" title="XML:"></a><strong>XML:</strong></h2><p><strong>1. 概念: Extensible Markup Language 可扩展标记语言</strong></p><p><strong>可扩展:标签都是自定义的。<user> <student></strong></p><p><strong>2,功能</strong></p><p><strong>存储数据1.配置文件2.在网络中传输</strong></p><p><strong>3.xml与tml的区别</strong></p><p><strong>properties</strong></p><p><strong>1.xml标签都是自定义的, html标签是预定义。</strong></p><p><strong>2.xml的语法严格, html语法松散</strong></p><p><strong>W3c:万维网联盟</strong></p><p><strong>2.语法:</strong></p><p><strong>基本语法:</strong></p><p><strong>1.xml文档的后缀名.xml</strong></p><p><strong>2.xml第一行必须定义为文档声明</strong></p><p><strong>3.xml文档中有且仅有一个根标签</strong></p><p><strong>4.属性值必须使用引号(单双都可)引起来</strong></p><p><strong>5.标签必须正确关闭</strong></p><p><strong>6.xml标签名称区分大小写</strong></p><p><strong>快速入门:</strong></p><p><strong>组成部分:</strong></p><p><strong>1.文档声明</strong></p><p><strong>1.1. 格式:<?xml 属性列表 ?></strong></p><p><strong>2.属性列表;</strong></p><ul><li><strong>version :版本号</strong></li><li><strong>encoding :编码方式  告知解析引擎当前文档使用的字符集,默认值: ISO-8859-1</strong> </li><li><strong>standalone :是否独立—-取值: yes :不依赖其他文件  no:依赖其他文件</strong></li></ul><p><strong>2.指令 结合css的</strong></p><p><strong><?xml-stylesheet type="text/css" href="a.css" ?></strong></p><p><strong>3标签  标签名称自定义的</strong></p><p><strong>名称可以包含字母、数字以及其他的字符</strong></p><p><strong>名称不能以数字或者标点符号开始</strong></p><p><strong>名称不能以字母xml(或者XML、Xml等等)开始</strong></p><p><strong>名称不能包含空格</strong></p><p><strong>4.属性</strong></p><p><strong>id属性值唯一</strong></p><p><strong>5.文本</strong></p><p><strong>CDATA区:在该区域中的数据会被原样展示</strong></p><![CDATA[数据]]><p><strong>谁编写xml?-用户,软件使用者</strong></p><p><strong>谁解析xml?-软件</strong></p><p><strong>约束</strong></p><p><strong>说明文档：规定xml文档的书写规则—约束文档</strong></p><p><strong>作为框架的使用者(程序员):</strong></p><p><strong>1.能够在xml中引入约東文档</strong></p><p><strong>2.能够简单的读懂约束文档</strong></p><p><strong>分类:</strong></p><p><strong>1.DTD:一种简单的约束技术</strong></p><p><strong>2.Schema:一种复杂的约束技术</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">students</span> (<span class="keyword">student</span>*) &gt;</span> </span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">student</span> (<span class="keyword">name</span>, <span class="keyword">age</span>, <span class="keyword">sex</span>)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">name</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">age</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">sex</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ATTLIST <span class="keyword">student</span> <span class="keyword">number</span> <span class="keyword">ID</span> <span class="keyword">#REQUIRED</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>DTD</strong></p><p><strong>引入dtd文档到xml文档中</strong></p><p><strong>内部dtd:将约束规则定义在xml文档中</strong></p><p><strong>外部dtd:将约束的规则定义在外部的dtd文件中</strong></p><p><strong>本地:<!DOCTYPE 根标签名SYSTEM "dtd文件的位置"></strong></p><p><strong>网络:<!DOCTYPE 根标签名PUBLIC "dtd文件名字" "dtd文件的位置URL"></strong></p><p><strong>1.填写xml文档的根元素</strong></p><p><strong>2.引入xsi前 xmlns:xsi&#x3D;”<a href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a>“</strong></p><p><strong>3.引入xsd文件命名空间.     xsi:schemaLocation&#x3D;”<a href="http://www.itcast.cn/xml">http://www.itcast.cn/xml</a> student.xsd”</strong></p><p><strong>4.为每一个xsd约束声明一个前级,作为标识 xmlns&#x3D;”<a href="http://www.itcast.cn/xml">http://www.itcast.cn/xml</a>“</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/xMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www. springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www. springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www. springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/mvchttp://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3.解析:操作xml文档,将文档中的数据读取到内存中</strong></p><p><strong>操作xml文档</strong></p><p><strong>1.解析(读取):将文档中的数据读取到内存中</strong></p><p><strong>2.写入:将内存中的数据保存到xml文档中。持久化的存储</strong></p><p><strong>解析xml的方式:</strong></p><p><strong>1.DOM:将标记语言文档一次性加载进内存,在内存中形成一颗dom树</strong></p><p><strong>优点:操作方便,可以对文档进行CRUD的所有操作</strong></p><p><strong>缺点:占内存</strong></p><p><strong>2.SAX:逐行读取,基于事件驱动的。</strong></p><p><strong>优点:不占内存。</strong></p><p><strong>缺点:只能读取,不能增删改</strong></p><p><strong>xml常见的解析器:</strong></p><p><strong>1.JAXP: sun公司提供的解析器,支持dom和sax两种思想</strong></p><p><strong>2.DOM4j:一款非常优秀的解析器</strong></p><p><strong>3.jsoup: jsoup是一款Java 的HTML解析器,可直接解析某个URL地址、”HTML文本内容。它提供了一套非常省力的API,可通过DOM, Css以及类似于jQuery的操作方法来取出和操作数据。</strong></p><p><strong>4.PÜLL : Android操作系统内置的解析器, sax方式的。</strong></p><p><strong>快速入门:</strong></p><p><strong>步骤:1. 导入jlar包</strong></p><p><strong>2,获取Document对象</strong></p><p><strong>3.获取对应的标签Element对象</strong></p><p><strong>4,获取数据</strong></p><p><strong>对象的使用:</strong></p><p><strong>1.Jsoup :工具类,可以解析html或xml文档,返回Document</strong></p><p><strong>parse :解析html或xml文档,返回Document</strong></p><p><strong>parse(File in, string charsetName) :解析xml或html文件的。</strong></p><p><strong>parse(String html):解析xml或html字符串</strong></p><p><strong>parse(URL url, int timeoutMillis) :通过网络路径获取指定的html或xml的文档对象</strong></p><p><strong>2.Document :文档对象。代表内存中的dom树</strong></p><p><strong>获取Element对象</strong></p><p><strong>getElementById(String id) :根据id属性值获取唯一的element对象</strong></p><p><strong>getElementsByTag(String tagName):根据标签名称获取元素对象集合</strong></p><p><strong>getElementsByAttribute(String key) :根据属性名称获取元素对象集合</strong></p><p><strong>getElementsByAttributeValue(String key, String value) :根据对应的属性名和属性值获取元素对象集合</strong></p><p><strong>3.Elements :元素Element对象的集合。可以当做ArrayList<Element>来使用</strong></p><p><strong>4.Element :元素对象</strong></p><p><strong>获取子元素对象</strong></p><p><strong>getElementById(stying id) :根据id属性值获取唯一的element对象</strong></p><p><strong>getElementsByTag(String tagName) :根据标签名称获取元素对象集合</strong></p><p><strong>getElementsByAttribute(String key):根据属性名称获取元素对象集合</strong></p><p><strong>getelementsByAttributevalue(String key, String value) :根据对应的属性名和属性值获取元素对象集合</strong></p><p><strong>2.获取属性值</strong></p><p> <strong>string attr(String key) :根据属性名称获取属性值</strong></p><p><strong>3.获取文本内容</strong></p><p><strong>string text() :获取文本内容</strong></p><p><strong>String html():获取标签体的所有内容(包括字标签的字符串内容)</strong></p><p><strong>5.Node :节点对象</strong></p><p><strong>是Document和Element的父类</strong></p><p><strong>快捷查询方式:</strong></p><p><strong>1.selector:选择器</strong></p><p><strong>使用的方法: Elementsselect(String cssQuery)</strong></p><p><strong>语法:参考selector类中定义的语法</strong></p><p><strong>2.XPath:XPath即为XML路径语言,它是一种用来确定XML(标准通用标记语言的子集)文档中某部分位置的语言</strong></p><p><strong>使用]soup的Xpath需要额外导入jar包。</strong></p><p><strong>查询w3cshool参考手册,使用xpath的语法完成查询</strong></p><p><strong>web相关概念回顾</strong></p><p><strong>1.软件架构</strong></p><p><strong>1.C&#x2F;S 客户端&#x2F;服务器端</strong> </p><p><strong>2.B&#x2F;S 浏览器&#x2F;服务器端</strong></p><p><strong>2.资源分类</strong></p><p><strong>1 ,静态资源 所有用户访问后,得到的结果都是一样的,称为静态资源,静态资源可以直接被浏览器解析</strong></p><p><strong>2,动态资源 每个用户访问相同资源后,得到的结果可能不一样。称为动态资源。动态资源被访问后,需要先转换为静态资源,在返回给浏览器</strong></p><p><strong>3.网络通信三要素</strong></p><p><strong>1.IP  电子设备(计算机)在网络中的唯一标识。</strong></p><p><strong>2.端口 应用程序在计算机中的唯一标识 0-65536</strong></p><p><strong>3.传输协议 ·规定了数据传输的规则</strong></p><p><strong>基础协议:</strong></p><p><strong>tcp:安全协议,三次握手。速度稍慢</strong></p><p><strong>udp:不安全协议。速度快</strong></p><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a><strong>Servlet</strong></h2><p> <strong>server applet</strong></p><p><strong>概念:运行在服务器端的小程序Servlet就是一个接口、定义了Java类被浏览器访问到(tomcat识别)的规则</strong></p><p><strong>将来我们自定义一个类,实现Servlet接口,复写方法</strong></p><p><strong>快速入门:</strong></p><p><strong>1.创建JavaEE项目</strong></p><p><strong>2.定义一个类,实现servlet接口</strong></p><p><strong>3.实现接口中的抽象方法</strong></p><p><strong>4.配置Servlet</strong></p><p><strong>在web.xml里面</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.itcast.web.servlet.ServletDemo1<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>执行原理:</strong></p><p><strong>1当服务器接受到客户端浏览器的请求后,会解析请求URL路径,获取访问的Servlet的资源路径</strong></p><p><strong>2.查找web,xml文件,是否有对应的<url-pattern>标签体内容。</strong></p><p><strong>3.如果有,则在找到对应的<servlet-class>全类名</strong></p><p><strong>4.tomcat会将字节码文件加载进内存,并且创建其对象</strong></p><p><strong>5.调用其方法</strong></p><p><strong>Servlet中的生命周期</strong></p><p><strong>1被创建 执行init方法,只执行一次</strong></p><p><strong>Servlet什么时候被创建?</strong></p><p><strong>默认情况下,第一次被访问时, Servlet被创建</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在<span class="tag">&lt;<span class="name">servlet</span>&gt;</span>标签下配置</span><br><span class="line">第一次被访问时创建</span><br><span class="line"> <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>的值为负值</span><br><span class="line">在服务器启动时创建</span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>的值为0或正数</span><br></pre></td></tr></table></figure><p><strong>servlet的init方法,只执行一次,说明一个Servlet在内存中只存在一个对象, Servlet是单例的</strong></p><p><strong>多个用户同时访问时,可能存在线程安全问题。</strong></p><p><strong>解决:尽量不要在Servlet中定义成员变量。即使定义了成员变量,也不要对修改值</strong></p><p><strong>2.提供服务 执行service方法,执行多次</strong></p><p><strong>每次访问Servlet时, Service方法都会被调一次。</strong></p><p><strong>3.被销毁 执行destroy方法,只执行一次</strong></p><p><strong>Servlet被销毁时执行。服务器关闭时, Servlet被销毁</strong></p><p><strong>只有服务器正常关闭时,才会执行destroy方法。</strong></p><p><strong>destroy方法在servlet被销毁之前执行,一般用于释放资源</strong></p><p><strong>servlet3.0:</strong></p><p><strong>好处:支持注解配置。可以不需要web.xml了。</strong></p><p><strong>步骤:</strong></p><p><strong>1.创建JavaEE项目,选择Servlet的版本3.0以上,可以不创建web.xml</strong></p><p><strong>2.定义一个类,实现Servlet接口</strong></p><p><strong>3.复写方法</strong></p><p><strong>4.在类上使用@Webservlet注解,进行配置</strong></p><p><strong>@WebServlet(“资源路径”)</strong></p><p><strong>IDEA与tomcat的相关配置</strong></p><p><strong>1. IDEA会为每一个tomcat部署的项目单独建立一份配置文件</strong></p><p><strong>查看控制台的log : Using CATALINA_BASE: “C: \UsersIfay). IntelliJIdea2018.1)system)tomcat_itcast”</strong></p><p><strong>2.工作空间项目 和tomcat部署的web项目</strong></p><p><strong>tomcat真正访问的是”tomcat部署的web预目”,”tomcat部署的web项目”对应着”工作空间项目”的web目录下的所有资源</strong></p><p><strong>WEB-INF目录下的资源不能被测览器直接访问。</strong></p><p><strong>3.断点调试:使用”小虫子”启动dubug启动</strong></p><p><strong>6. Servlet的体系结构</strong></p><p>**Servlet –接口 **</p><p>|</p><p><strong>GenericServlet –抽象类</strong></p><p>|</p><p><strong>HttpServlet  –抽象类</strong></p><p><strong>GenericServlet :将Servlet接口中其他的方法做了默认空实现,只将service()方法作为抽象</strong></p><p><strong>将来定义servlet类时,可以继承GedericServlet,实现service()方法即可</strong></p><p><strong>ettpServlet:对http协议的一种封装,简化操作</strong></p><p><strong>1,定义类继承Httpservlet</strong></p><p><strong>2.复写doGet&#x2F;doPost方法</strong></p><p><strong>7.Servlet相关配置</strong></p><p><strong>1.urlpartten: Servlet访问路径</strong></p><p><strong>一个servlet可以定义多个访问路径@WebServlet({“&#x2F;d4”,”&#x2F;dd4”,”&#x2F;ddd4”})</strong></p><p><strong>2.路径定义规则:</strong></p><p><strong>1. &#x2F;xxx</strong></p><p><strong>2. &#x2F;xxx&#x2F;xxx</strong></p><p>*<em>3. <em>.doi</em></em></p><p><strong>HTTP :</strong></p><p><strong>概念: Hyper Text Transfer Protocol超文本传输协议</strong></p><p><strong>传输协议:定义了,客户端和服务器端通信时,发送数据的格式</strong></p><p><strong>特点:</strong></p><p><strong>1.基于TCP&#x2F;IP的高级协议</strong></p><p><strong>2.默认端口号:80</strong></p><p><strong>3.基于请求&#x2F;响应模型的:一次请求对应一次响应</strong></p><p><strong>4.无状态的:每次请求之间相互独立</strong></p><p><strong>历史版本:</strong></p><p> <strong>1.0:每一次请求响应都会建立新的连接</strong></p><p><strong>1.1:复用连接</strong></p><p><strong>请求消息数据格式</strong></p><p><strong>1.请求行</strong></p><p><strong>请求方式 请求url请求协议&#x2F;版本</strong></p><p>**GET &#x2F;login.html HTTP&#x2F;1.1 **</p><p><strong>请求方式:HTTP协议有7中请求方式,常用的有2种</strong></p><p><strong>GET:</strong></p><p><strong>1.请求参数在请求行中,在url后。</strong></p><p><strong>2.请求的url长度有限制的</strong></p><p><strong>3.不太安全</strong></p><p><strong>POST:</strong></p><p><strong>1.请求参数在请求体中</strong></p><p><strong>2.请求的url长度没有限制的</strong></p><p><strong>3.相对安全</strong></p><p><strong>2.请求头 客户端浏览器告诉服务器一些信息</strong></p><p><strong>请求头名称:请求头值</strong></p><p><strong>常见的请求头:</strong></p><p><strong>1. User-Agent :浏览器告诉服务器,我访问你使用的浏览器版本信息</strong></p><p><strong>可以在服务器端获取该头的信息,解决浏览器的兼容性问题</strong></p><p><strong>2. Referer: <a href="http://localhost/login.html">http://localhost/login.html</a></strong></p><p><strong>告诉服务器,我(当前请求)从哪里来?</strong></p><p><strong>作用:1.防盗链:2.统计工作:</strong></p><p><strong>3.请求空行</strong></p><p><strong>空行 就是用于分割POST请求的请求头,和请求体的。</strong></p><p><strong>4,请求体（正文）</strong></p><p><strong>封装POST请求消息的请求参数的</strong></p><p><strong>字符串格式:</strong></p><p><strong>GET &#x2F;login.html HTTP&#x2F;1.1</strong></p><p><strong>Host: localhost</strong></p><p><strong>User-Agent: Moz[lla&#x2F;5.0 (windows NT 6.1; win64; x64; rv:60.0) Gecko&#x2F;20100101 Firefox&#x2F;60.0</strong></p><p>*<em>Accept: text&#x2F;html, application&#x2F;xhtml+xml, application&#x2F;xml;q&#x3D;0.9, <em>&#x2F;</em>;q&#x3D;0.8</em>*</p><p><strong>Accept-Language: zh-CN, zh; q&#x3D;0.8, zh-TW; q&#x3D;0.7, zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3, en;q&#x3D;0.2</strong></p><p><strong>Accept-Encoding: gzip, deflate</strong></p><p><strong>Connection: keep-alive</strong></p><p><strong>Upgrade-Insecure-Requests: 1</strong></p><p><strong>响应消息数据格式</strong></p><p><strong>Request</strong></p><p><strong>1.request对象和response对象的原理</strong></p><p><strong>1.2.request和response对象是由服务器创建的。我们来使用它们</strong></p><p><strong>1.3.request对象是来获取请求消息, response对象是来设置响应消息</strong></p><p><strong>2. request :获取请求消息</strong></p><p><strong>2.1request对象继承体系结构:</strong></p><p><strong>ServletRequest   -接口</strong> </p><p><strong>|    继承</strong></p><p><strong>HttpServletRequest  -接口</strong></p><p><strong>|    实现</strong></p><p><strong>org.apache.catalina.connector.RequestFacade 类（tomcat）</strong></p><p>**3. request 功能: **</p><p><strong>1.获取请求消息数据</strong></p><p>​<strong>1.获取请求行数据</strong></p><p>​<strong>GET &#x2F;day14&#x2F;demo1?name&#x3D;zhangsan HTTP&#x2F;1.1</strong></p><p>​<strong>方法:</strong></p><p>​<strong>1,获取请求方式:GET</strong></p><p>​<strong>String getMethod()</strong></p><p>​<strong>2.(*)获取虚拟目录:&#x2F;day14</strong></p><p>​<strong>String getContextPath()</strong></p><p>​<strong>3. 获取Servlet路径: &#x2F;demo1</strong></p><p>​<strong>string getServletPath()</strong></p><p>​<strong>4. 获取get方式请求参数: name&#x3D;zhangsan</strong></p><p>​<strong>String getQueryString()</strong></p><p>​<strong>5.(*)获取请求URI: &#x2F;day14&#x2F;demo1</strong></p><p>​<strong>string getRequestURI():&#x2F;day14&#x2F;demo1</strong></p><p>​<strong>stringBuffer getRequestURL() <a href="http://localhost/day14/demo1">http://localhost/day14/demo1</a></strong></p><p>​<strong>URL:统资源定位符:<a href="http://localhost/day14/demo1">http://localhost/day14/demo1</a>  中华人民某和国</strong></p><p>​<strong>URI统一资源标识符:&#x2F;day14&#x2F;demo1  共和国</strong></p><p>​<strong>6.获取协议及版本: HTTP&#x2F;1.1</strong></p><p>​<strong>string getProtocol()</strong></p><p>​<strong>7.获取客户机的IP地址:</strong></p><p>​<strong>string getRemoteAddr()</strong></p><p>​<strong>2.获取请求头数据</strong></p><p>​<strong>方法:</strong></p><p>​**String getHeader(String name):通过请求头的名称获取请求头的值**</p><p>​<strong>Enumeration<string>getHeaderNames():获取所有的请求头名称</strong></p><p><strong>3,获取请求体数据</strong></p><p>​<strong>请求体:只有POST请求方式,才有请求体,在请求体中封装了POST请求的请求参数</strong></p><p><strong>步骤:</strong></p><p><strong>1.获取流对象</strong></p><p><strong>BufferedReader getReader() 获取字符输入流,只能操作字符数据</strong></p><p><strong>ServletInputStream getInputStream() :获取字节输入流,可以操作所有类型数据</strong></p><p><strong>在文件上传知识点后讲解</strong></p><p><strong>2.再从流对象中拿数据</strong></p><p><strong>2.其他功能</strong></p><p><strong>1.获取请求参数通用方式 无论get还是post请求方式都可以使用下列方法来获取请求参数</strong></p><p><strong>1.1.String getParameter(String name) :根据参数名称获取参数值    username&#x3D;zs&amp;password&#x3D;123</strong></p><p><strong>1.2.String[ ] getParameterValues(String name) :根据参数名称获取参数值的数组 hobby&#x3D;xx&amp;hobby&#x3D;game</strong></p><p><strong>1.3.Enumeration<string> getParameterNames ():获取所有请求的参数名称</strong></p><p><strong>1.4.Map&lt;string, String[]&gt; getParameterMap():获取所有参数的map集合</strong></p><p><strong>中文乱码问题:</strong></p><p><strong>get方式: tomcat 8 已经将get方式乱码问题解决了</strong></p><p><strong>post方式会乱码</strong></p><p>*<strong>解决:在获取参数前,设置request的编码request.setCharacterEncoding(“utf-8”);</strong></p><p><strong>2.请求转发: 一种在服务器内部的资源跳转方式</strong></p><p><strong>1.步骤:</strong></p><p><strong>1.通过request对象获取请求转发器对象: RequestDispatcher getRequestDispatcher(String path)</strong></p><p><strong>2. 使用RequestDispatcher对象来进行转: forward(ServletRequest request, ServletResponse response)</strong></p><p><strong>2.特点:</strong></p><p><strong>1.浏览器地址栏路径不发生变化</strong></p><p><strong>2.只能转发到当前服务器内部资源中。</strong></p><p><strong>3.转发是一次请求</strong></p><p><strong>3.共享数据</strong></p><p><strong>域对象:一个有作用范围的对象,可以在范国内共享数据</strong></p><p><strong>request域:代表一次请求的范围,一股用于请求转发的多个资源中共享数据</strong></p><p><strong>方法:</strong></p><p><strong>1. void setAttribute(String name,object obj) :存储数据</strong></p><p><strong>2. object getattitude(String name) :通过健获取值</strong></p><p><strong>3. void removeAttribute(String name):通过键移除健值对</strong></p><p><strong>4.获取ServletContext</strong></p><p><strong>Servletcontext getservletContext()</strong></p><p><strong>1. tomcat服务器会根据请求url中的资源路径,创建对应的ServletDemol的对象。</strong></p><p><strong>2. tomcat服务器,会创建reguest和response对象, request对象中封装请求消息数据。</strong></p><p><strong>3. tomcat将reauest和response两个对象传递给service方法,并且调用service方法。</strong></p><p><strong>4,程序员(我们),可以通过request对象获取请求消息数据,通过通过,response对象设置响应消息数据</strong></p><p><strong>5,服务器在给浏览器做出响应之前,会从response对象中拿程序员设置的响应消息数据。</strong></p><p><strong>Beanutils工具类,简化数据封装</strong></p><p><strong>用于封装JavaBean的</strong></p><p><strong>1. JavaBean : 标准的Java类</strong></p><p><strong>1.要求:</strong></p><p><strong>1.类必须被public修饰</strong></p><p><strong>2.必须提供空参的构造器</strong></p><p><strong>3.成员变量必须使用private修饰</strong></p><p><strong>4.提供公共setter和getter方法</strong></p><p><strong>2.功能:封装数据</strong></p><p><strong>2.概念:</strong></p><p><strong>成员变量:</strong></p><p><strong>属性: setter和getter方法截取后的产物</strong></p><p><strong>例如: getusername() –&gt; Username–&gt; username</strong></p><p><strong>3.方法:</strong></p><p><strong>1. setProperty()</strong></p><p><strong>2. getproperty()</strong></p><p>**3. populate(object obj , Map map):将map集合的键值对信息,封装到对应的JavaBean对象中 **</p><p><strong>HTTP协议:</strong></p><p><strong>1.请求消息:客户端发送给服务器端的数据</strong></p><p><strong>数据格式:</strong></p><p><strong>1.请求行</strong></p><p><strong>2.请求头</strong></p><p><strong>3.请求空行</strong></p><p><strong>4.请求体</strong></p><p><strong>2,响应消息:服务器端发送给客户端的数据</strong></p><p><strong>数据格式:</strong></p><p><strong>1.响应行</strong></p><p>​<strong>1.组成:协议&#x2F;版本响应状态码 状态码描述</strong></p><p>​<strong>2.响应状态码:服务器告诉客户端浏览器本次请求和响应的一个状态。</strong></p><p>​<strong>1,状态码都是3位数字</strong></p><p>​<strong>2.分类:</strong></p><p>​<strong>1. 1xx：服务器就收客户端消息,但没有接受完成,等待一段时间后,发送1xx多状态码,</strong></p><p>​<strong>2. 2xxI：成功 代表: 200</strong></p><p>​<strong>3. 3xx:重定向。代表: 302(重定向) 304(访问缓存)</strong></p><p>​<strong>4. 4xx：客户端错误。</strong></p><p>​<strong>代表:</strong></p><p>​<strong>404(请求路径没有对应的资源)</strong></p><p>​<strong>405:请求方式没有对应的doxxx方法</strong></p><p>​<strong>5. 5xx:服务器端错误 服务器端错误。代表:500(服务器内部出现异常)。</strong></p><p><strong>2.响应头</strong></p><p><strong>1.格式:头名称:值</strong></p><p><strong>2.常见的响应头:</strong></p><p><strong>1. Content-Type:服务器告诉客户端本次响应体数据格式以及编码格式,</strong></p><p><strong>2.Content-disposition :服务器告诉客户端以什么格式打开响应体数据</strong></p><p><strong>值:</strong></p><p><strong>in-line:默认值,在当前页面内打开</strong></p><p><strong>attachment；filename&#x3D;xxx :以附件形式打开响应体 文件下载</strong></p><p><strong>3.响应空行</strong></p><p><strong>4.响应体</strong></p><p><strong>响应字符串格式</strong></p><p><strong>HTTP&#x2F;1.1 200 OK</strong></p><p><strong>Content-Type: text&#x2F;html; charset&#x3D;UTF-8</strong></p><p><strong>Content-Length: 101</strong></p><p><strong>Date: wed, 06 Jun 2018 07:08:42 GMT</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello World! respones<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Response对象</strong></p><p><strong>功能:设置响应消息</strong></p><p><strong>1,设置响应行</strong></p><p><strong>1. 格式: HTTP&#x2F;1.1 200 ok</strong></p><p><strong>2.设置状态码: setsifaltus(int sc)</strong></p><p><strong>2.设置响应头 setHeader(String name, String value)</strong></p><p><strong>3.设置响应体</strong></p><p><strong>使用步骤:</strong></p><p><strong>1.获取输出流</strong></p><p><strong>字符输出流: Printwriter getwriter()</strong></p><p><strong>字节输出流: ServletoutputStream getoutputStream()</strong></p><p><strong>2.使用输出流,将数据输出到客户端浏览器</strong></p><p><strong>案例:</strong></p><p><strong>1.完成重定向</strong></p><p><strong>重定向：资源跳转的方式</strong></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//访问responseDemo1自动跳转到Demo2资源</span></span><br><span class="line">        <span class="comment">//1.设置状态码为302</span></span><br><span class="line"><span class="comment">//        resp.setStatus(302);</span></span><br><span class="line">        <span class="comment">//2.设置响应头location</span></span><br><span class="line"><span class="comment">//        resp.setHeader(&quot;location&quot;,&quot;/day15/responseDemo2&quot;);</span></span><br><span class="line">        resp.sendRedirect(<span class="string">&quot;/day15/responseDemo2&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>重定向的特点  redirect</strong></p><p><strong>1,地址栏发生变化</strong></p><p><strong>2.重定向可以访问其他站点(服务器)的资源</strong></p><p><strong>3,重定向是两次请求</strong></p><p><strong>转发的特点:forward</strong></p><p><strong>1.转发地址栏路径不变</strong></p><p><strong>2.转发只能访问当前服务器下的资源</strong></p><p><strong>3.转发是一次请求 可以使用request对象来共享数据</strong></p><p><strong>forward和 redirect区别</strong></p><p><strong>路径写法:</strong></p><p><strong>1.路径分类</strong></p><p><strong>1.1,相对路径:通过相对路径不可以确定唯一资源</strong></p><p><strong>如:.&#x2F;index.html</strong></p><p><strong>不以&#x2F;开头,以,开头路径</strong></p><p><strong>规则:找到当前资源和目林资源之间的相对位置关系</strong></p><p><strong>.&#x2F;:当前目录</strong></p><p><strong>..&#x2F;:后退一级目录</strong></p><p><strong>1.2.绝对路径:通过绝对路径可以确定唯一资源</strong></p><p><strong>如: <a href="http://localhost/day15/responseDemo2">http://localhost/day15/responseDemo2</a>           &#x2F;day15&#x2F;responseDemo2</strong></p><p><strong>以&#x2F;开头的路径</strong></p><p><strong>规则:判断定义的路径是给谁用的?判断请求将来从哪儿发出</strong></p><p><strong>给客户端浏览器使用:需要加虚拟目录(项目的访问路径)</strong></p><p><strong>建议虚拟目录动态获取: request.getcontextPath()</strong></p><p><strong><a> , <form>重定向…</strong></p><p><strong>给服务器使用:不需要加虚拟目录</strong></p><p><strong>转发路径</strong></p><p><strong>2.服务器输出字符数据到浏览器</strong></p><p><strong>步骤:</strong></p><p><strong>1.获取字符输出流</strong></p><p><strong>2.输出数据</strong></p><p><strong>注意:</strong></p><p><strong>乱码问题:</strong></p><p><strong>1. Printwriter pw&#x3D; response.getwriter();获取的流的默认编码是IS0-8859-1</strong></p><p><strong>2.设置该流的默认编码</strong></p><p><strong>3.告诉浏览器响应体使用的编码</strong></p><p><strong>&#x2F;&#x2F;简单的形式,设置编码,是在获取流之前设置</strong></p><p><strong>response.setcontentType(“text&#x2F;html;charset&#x3D;utf-8”);</strong></p><p><strong>3.服务器输出字节数据到浏览器</strong></p><p><strong>步骤:</strong></p><p><strong>1.获取字节输出流</strong></p><p><strong>2.输出数据</strong></p><p><strong>4.验证码</strong></p><p><strong>1.本质:图片</strong></p><p><strong>2.目的:防止恶意表单注册</strong></p><p><strong>servletContext对象</strong></p><p><strong>1.概念:代表整个web应用,可以和程序的容器(服务器)来通信</strong></p><p><strong>2.获取:</strong></p><p><strong>1.通过request对象获取</strong></p><p><strong>request.getservletcontext();</strong></p><p><strong>2. 通过HttpServlet获取</strong></p><p><strong>this.getServletcontext();</strong></p><p><strong>3.功能:</strong></p><p><strong>1,获取MIME类型:</strong></p><p><strong>MIME类型:在互联网通信过程中定义的一种文件数据类型</strong></p><p><strong>格式:大类型&#x2F;小类型 text&#x2F;html        image&#x2F;jpeg</strong></p><p><strong>获取: String getMimeType(String file)</strong></p><p><strong>2.域对象:共享数据</strong></p><p><strong>1. setAttribute(String name, Object value)</strong></p><p><strong>2. getattribute(String name)</strong></p><p><strong>3. removeAttribute(string name)</strong></p><p><strong>Servletcontext对象范围:所有用户所有请求的数据</strong></p><p><strong>3.获取文件的真实(服务器)路径</strong></p><p><strong>1. 方法: string getRealPath(Strihg path)</strong></p><h1 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a><strong>会话技术</strong></h1><p><strong>1.会话:一次会话中包含多次请求和响应。</strong></p><p><strong>一次会话:浏览器第一次给服务器资源发送请求,会话建立,直到有一方断开为止</strong></p><p><strong>2.功能:在一次会话的范围内的多次请求间,共享数据</strong></p><p><strong>3.方式:</strong></p><p><strong>1,客户端会话技术:Cookie</strong></p><p><strong>2.服务器端会话技术: Sesslion</strong></p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie:"></a>Cookie:</h2><p><strong>1.概念:客户端会话技术,将数据保存到客户端</strong></p><p><strong>2.快速入门:</strong></p><p><strong>使用步骤:</strong></p><p><strong>1.创建cookie对象,绑定数据</strong></p><p><strong>new Cookie(String name, String value)</strong></p><p><strong>2.发送Cookie对象</strong></p><p><strong>response.addCookie(Cookie cookie)</strong></p><p><strong>3.获取Cookie,拿到数据</strong></p><p>**Cookie[ ] request.getcookies () **</p><p><strong>3.实现原理</strong></p><p><strong>基于响应头set-cookie和请求头cookie实现</strong></p><p><strong>4. cookie的细节</strong></p><p><strong>1.一次可不可以发送多个cookie?</strong></p><p><strong>可以</strong></p><p><strong>可以创建多个Cookie对象,使用response调用多次addcookie方法发送cookie即可。</strong></p><p><strong>2. cookie在浏览器中保存多长时间?</strong></p><p><strong>1.默认情况下,当浏览器关闭后, cookie数据被销毁</strong></p><p><strong>2.持久化存储:</strong></p><p><strong>setMaxAge (int seconds)</strong></p><p><strong>1,正数:将cookie数据写到硬盘的文件中。持久化存储。cookie存活时间。</strong></p><p><strong>2.负数:默认值</strong></p><p><strong>3.零:删除cookie信息</strong></p><p><strong>3. cookie能不能存中文?</strong></p><p><strong>在tomcat 8之前cookie中不能直接存储中文数据。</strong></p><p><strong>需要将中文数据转码–一般采用URL编码(%E3)</strong></p><p><strong>在tomcat 8之后,cookie支持中文数据。</strong></p><p><strong>4. cookie共享问题?</strong></p><p><strong>假设在一个tomcat服务器中,部署了多个web项目,那么在这些web项目中cookie能不能共享?</strong></p><p><strong>默认情况下cookie不能共享</strong></p><p><strong>setPath(String path):设置cookie的获取范围。默认情况下,设置当前的虚拟目录</strong></p><p><strong>如果要共享,则可以将path设置为”&#x2F;“</strong></p><p><strong>2.不同的tomcat服务器间cookie共享问题?</strong></p><p><strong>setDomain(String path):如果设置一级域名相同,那么多个服务器之间cookie可以共享</strong></p><p><strong>setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中cookie可以共享</strong></p><p><strong>5. cookie的特点和作用</strong></p><p><strong>1. cookie存储数据在客户端浏览器</strong></p><p><strong>2.浏览器对于单个cookie 的大小有限制(4kb)以及 对同一个域名下的总cookie数量也有限制(20个)</strong>*</p><p><strong>作用:</strong></p><p><strong>1. cookie一般用于存出少量的不太敏感的数据</strong></p><p><strong>2,在不登录的情况下,完成服务器对客户端的身份识别</strong></p><p><strong>6.案例:记住上一次访问时间</strong></p><p><strong>1.需求:</strong></p><p><strong>1.访问一个Servlet,如果是第一次访问,则提示:您好,欢迎您首次访问。</strong></p><p><strong>2.如果不是第一次访问,则提示:欢迎回来,您上次访问时间为:显示时间字符申</strong></p><p><strong>2.分析:</strong></p><p><strong>1,可以采用cookie来完成</strong></p><p><strong>2,在服务器中的Servlet判断是否有一个名为lastTime的cookie</strong></p><p><strong>1,有:不是第一次访问</strong></p><p><strong>1.响应数据:您好,欢迎您首次访问</strong></p><p><strong>2.写回cookie: lastTime&#x3D;2018年6月10日11:50:01</strong></p><p><strong>2,没有:是第一次访问,</strong></p><p><strong>1.响应数据:您好,欢迎您首次访问</strong></p><p><strong>2.写回cookie: lastTime&#x3D;2018年6月10日11:50:01</strong></p><h1 id="JSP-入门学习"><a href="#JSP-入门学习" class="headerlink" title="JSP:入门学习"></a><strong>JSP:入门学习</strong></h1><p><strong>1,概念:</strong></p><p><strong>Java Server Pages: java服务器端页面</strong></p><p><strong>可以理解为:一个特殊的页面,其中既可以指定定义html标签,又可以定义java代码</strong></p><p><strong>用于简化书写!!!</strong></p><p><strong>2.原理</strong></p><p><strong>JSP本质上就是一个Servlet</strong></p><p><strong>3. JSP的脚本: JSP定义Java代码的方式</strong></p><p><strong>1.&lt;% 代码 %&gt;:定义的java代码,在service方法中。service方法中可以定义什么,该脚本中就可以定义什么。</strong></p><p><strong>2.&lt;%!代码%&gt;:定义的java代码,在jsp转换后的java类的成员位置。</strong></p><p><strong>3.&lt;%&#x3D;代码 %&gt;:定义的java代码,会输出到页面上。输出语句中可以定义什么,该脚本中就可以定义什么。</strong></p><p><strong>4. JSP的内置对象</strong></p><p><strong>在jsp页面中不需要获取和创建,可以直接使用的对象</strong></p><p><strong>jsp一共有9个内置对象。</strong></p><p><strong>今天学习3个:</strong></p><p><strong>request</strong></p><p><strong>response</strong></p><p><strong>out :字符输出流对象。可以将数据输出到页面上。和response.getwriter()类似</strong></p><p><strong>response.getwriter)和out.write()的区别:</strong></p><h1 id="Session"><a href="#Session" class="headerlink" title="Session:"></a><strong>Session:</strong></h1><p><strong>1.概念:服务器端会话技术,在一次会话的多次请求间共享数据,将数据保存在服务器端的对象中。Httpsession</strong></p><p><strong>2.快速入门:</strong></p><p><strong>1.1获取Httpsession对象:</strong></p><p><strong>Httpsession session &#x3D; request.getSession();</strong></p><p><strong>1.2使用HttpSession对象:</strong></p><p><strong>Httpsession对象:object getattribute(String name)</strong></p><p><strong>void setAttribute(String name, object value)</strong></p><p><strong>void removeAttribute(String name)i</strong></p><p><strong>3.原理</strong></p><p><strong>Session的实现是依赖于cookie的。</strong></p><p><strong>4.细节:</strong></p><p><strong>1.当客户端关闭后,服务器不关闭,两次获取session是否为同一个?</strong></p><p><strong>默认情况下。不是。</strong></p><p><strong>如果需要相同,则可以创建cookie,键为JSESSIONID,设置最大存活时间,让cookie持久化保存。</strong></p><p><strong>Cookie c &#x3D; new Cookie(“JSESSIONID”, session.getId());</strong></p><p><strong>C.setMaxAge(60*60);</strong></p><p><strong>response.addCookie(c);</strong></p><p><strong>2.客户端不关闭,服务器关闭后,两次获取的session是同一个吗?</strong></p><p><strong>不是同一个但是要确保数据不丢失</strong></p><p><strong>session的顿化:</strong></p><p><strong>在服务器正常关闭之前,将session对象系列化到硬盘上</strong></p><p><strong>session的活化:</strong></p><p><strong>在服务器启动后,将session文件转化为内存中的session对象即可。</strong></p><p><strong>3. session的失效时间?</strong></p><p><strong>1,服务器关闭</strong></p><p><strong>2. session对象调用invalidate() .</strong></p><p><strong>3. session默认失效时间30分钟选择性配置修改</strong></p><p><strong><session-config></strong></p><p><strong><session-timeout>30</session-timeout></strong></p><p><strong></session-config></strong></p><p><strong>5. session的特点</strong></p><p><strong>1. session用于存储一次会话的多次请求的数据,存在服务器端</strong></p><p><strong>2. session可以存储任意类型,任意大小的数据</strong></p><p><strong>session与cookie的区别:</strong></p><p><strong>1. session存储数据在服务器端, Cookie在客户端</strong></p><p><strong>2. session没有数据大小限制, cookie有</strong></p><p><strong>3. session数据安全, cookie相对于不安全</strong></p><p><strong>JSP:</strong></p><p><strong>1.指令</strong></p><p><strong>作用:用于配置JSP页面,导入资源文件</strong></p><p><strong>格式:&lt;%@指令名称 属性名1&#x3D;属性值1属性名2&#x3D;属性值2 …%&gt;</strong></p><p><strong>分类:</strong></p><p><strong>1. page:配置JSP页面的</strong></p><p><strong>contentType :等同Fresponse.setContentType()</strong></p><p><strong>1.1设置响应体的mime类型以及字符集</strong></p><p><strong>1.2.设置当前jsp页面的编码(只能是高级的IDE才能生效,如果使用低级工具,则需要设置pageEncoding属性设置当前页面的字符集</strong></p><p><strong>import : 导包errorPage:当前页面发生异常后,会自动跳转到指定的错误页面</strong></p><p><strong>isErrorPage:标识当前也是是否是错误页面。</strong></p><p><strong>true :是,可以使用内置对象exception</strong></p><p><strong>false :否。默认值。不可以使用内置对象exception</strong></p><p><strong>2. include :页面包含的。导入页面的资源文件</strong></p><p><strong>&lt;%@include file&#x3D;”top.jsp”%&gt;</strong></p><p><strong>3. taglib : 导入资源</strong></p><p><strong>&lt;%@ taglib prefix&#x3D;”c” uri&#x3D;”<a href="http://java.sun.com/jsp/jstl/core">http://java.sun.com/jsp/jstl/core</a>“ %</strong></p><p><strong>prefix :前缀,自定义的</strong></p><p><strong>2.注释</strong></p><p><strong>1. html注释:<!-- -->:只能注释html代码片段</strong></p><p><strong>2. jsp注释:推荐使用&lt;%– –%&gt; :可以注释所有</strong></p><p><strong>3.内置对象</strong></p><p><strong>在jsp页面中不需要创建,直接使用的对象</strong></p><p><strong>一共有9个:</strong></p><p><strong>变量名真实类型</strong><strong>作用</strong></p><p><strong>pageContext</strong><strong>PageContext</strong><strong>当前页面共享数据</strong></p><p><strong>request</strong><strong>HttpservletRequest</strong><strong>一次请求访问的多个资源(转发)</strong></p><p><strong>session</strong><strong>Httpsession</strong><strong>一次会话的多个请求间</strong></p><p><strong>application</strong><strong>Servletcontext</strong><strong>所有用户间共享数据</strong></p><p><strong>response</strong><strong>HttpservletResponse</strong><strong>响应对象</strong></p><p><strong>page</strong><strong>object</strong><strong>当前页面(Servlet)的对象 this</strong></p><p><strong>out</strong><strong>jspwriter</strong><strong>输出对象,数据输出到页面上</strong></p><p>**config**<strong>Servletconfig</strong><strong>Servlet的配置对象</strong></p><p>**exception **<strong>Throwable</strong><strong>异常对象</strong></p><h1 id="MVC-开发模式"><a href="#MVC-开发模式" class="headerlink" title="MVC:开发模式"></a>MVC:开发模式</h1><p><strong>1. jsp演变历史</strong></p><p><strong>1.早期只有servlet,只能使用response输出标签数据,非常麻烦</strong></p><p><strong>2.后来又jsp,简化了Servlet的开发,如果过度使用jsp,在jsp中即写大量的java代码,有写html表,造成难于维护,难于分工协作</strong></p><p><strong>3.再后来, java的web开发,借鉴vc开发模式,使得程序的设计更加合理性</strong></p><p><strong>2. MVC:</strong></p><p><strong>1. M: Model, 模型 JavaBean</strong></p><p><strong>完成具体的业务操作,如:查询数据库,封装对象</strong></p><p><strong>2. v: View,视图 JSP</strong></p><p><strong>展示数据</strong></p><p><strong>3. C: Controller, 控制器 Servlet</strong></p><p><strong>获取用户的输入</strong></p><p><strong>调用模型</strong></p><p><strong>将数据交给视图进行展示</strong></p><p><strong>优缺点:</strong></p><p><strong>1,优点:</strong></p><p><strong>1.耦合性低,方便维护,可以利于分工协作</strong></p><p><strong>2.重用性高</strong></p><p><strong>2.缺点:</strong></p><p><strong>1.使得项目架构变得复杂,对开发人员要求高</strong></p><h1 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a><strong>EL表达式</strong></h1><p><strong>1.概念 Expression Language表达式语言</strong></p><p><strong>2.作用:替换和简化jsp页面中java代码的编写</strong></p><p><strong>3.语法:${表达式}</strong></p><p><strong>4.注意:</strong></p><p><strong>jsp默认支持el表达式的。如果要忽略el表达式</strong></p><p><strong>1.设置jspPpage指令中:isELIgnored&#x3D;”true”忽略当前jsp页面中所有的el表达式</strong></p><p><strong>2. ${表达式}:忽略当前这个el表达式</strong></p><p><strong>5.使用:</strong></p><p><strong>1.运算</strong></p><p><strong>运算符:</strong></p><p><strong>1. 算数运算符: + - * &#x2F; (div)  % (mod)</strong></p><p><strong>2.比较运算符:&gt;&lt;&gt;&#x3D; &lt;&#x3D; &#x3D;&#x3D;!&#x3D;</strong></p><p><strong>3. 逻辑运算符: &amp;&amp;(and) II(or)  !(not)</strong></p><p><strong>4,空运算符: empty</strong></p><p><strong>功能:用于判断字符串、集合、数组对象是否为null或者长度是否为0</strong></p><p><strong>${empty list}：判断字符申!集合、数组对象是否为null或者长度为0</strong></p><p><strong>${not empty str}:表示判断字符串、集合、数组对象是否不为null并目长度&gt;0</strong></p><p><strong>2.获取值</strong></p><p><strong>1. el表达式只能从域对象中获取值</strong></p><p><strong>2.语法:</strong></p><p><strong>1. ${域名称,键名}:从指定域中获取指定键的值</strong></p><p><strong>域名称:</strong></p><p><strong>1. pagescope–&gt; pageContext</strong></p><p><strong>2. requestscope–&gt; request</strong></p><p><strong>3. sessionScope –&gt; session</strong></p><p><strong>4. applicationScope –&gt; application (Servletcontext)</strong></p><p><strong>举例:在request域中存储了name&#x3D;张三</strong></p><p><strong>获取: ${requestscope. name}</strong></p><p><strong>2.${键名}:表示依次从最小的域中查找是否有该键对应的值,直到找到为止。</strong></p><p><strong>3.获取对象、List集合、Map集合的值</strong></p><p><strong>1.对象:${域名称,键名,属性名}</strong></p><p><strong>本质上会去调用对象的getter方法</strong></p><p><strong>2. List集合:</strong></p><p><strong>${域名称.键名[索引]}</strong></p><p><strong>3. Map集合:</strong></p><p><strong>${域名称.键名.key名称}</strong></p><p><strong>${域名称,键名[“key名称”]}</strong></p><p><strong>3.隐式对象:</strong></p><p><strong>el表达式中有11个隐式对象</strong></p><p><strong>pageContext:</strong></p><p><strong>获取jsp其他八个内置对象</strong></p><p><strong>${pageContext.request.contextPath}: 动态获取虚拟目录</strong></p><p><strong>JSTL</strong></p><p><strong>1.概念: JavaServer Pages Tag Library  JSP标准标签库</strong></p><p><strong>是由Apache组织提供的开源的免费的jsp标签    &lt;标签&gt;</strong></p><p><strong>2.作用:用于简化和替换jsp页面上的java代码</strong></p><p><strong>3.使用步骤:</strong></p><p><strong>1. 导入jstl相关jar包</strong></p><p><strong>2. 引入标签库: taglib指令: &lt;%@ taglib %&gt;</strong></p><p><strong>3.使用标签</strong></p><p><strong>4.常用的JSTL标签</strong></p><p><strong>1. if： 相当于java代码的if语句</strong></p><p><strong>1.属性:test必须属性,接受boolean表达式</strong></p><p><strong>如果表达式为true,则显示if标签体内容,如果为false,则不显示标签体内容</strong></p><p><strong>一般情况下, test属性值会结合el表达式一起使用</strong></p><p><strong>2.注意:c:if标签没有else情况,想要else情况,则可以在定义一个c:if标签</strong></p><p><strong>2. choose：相当于java代码的switch语句</strong></p><p><strong>1.使用choose标签声明相当于switch声明</strong></p><p><strong>2.使用when标签做判断相当于case</strong></p><p><strong>1.使用choose标签声明相当于switch声明</strong></p><p><strong>2.使用when标签做判断相当于case</strong></p><p><strong>3.使用otherwise标签做其他情况的声明相当于default</strong></p><p><strong>3.使用otherwise标签做其他情况的声明相当于default</strong></p><p><strong>3. foreach：相当于java代码的for语句</strong></p><p><strong>1,完成重复的操作</strong></p><p><strong>属性:</strong></p><p><strong>begin:开始值</strong></p><p><strong>end:结束值</strong></p><p><strong>var:临时变量</strong></p><p><strong>step:步长</strong></p><p><strong>varStatus:循环状态对象</strong></p><p><strong>index:容器中元素的索引,从0开始</strong></p><p><strong>count:循环次数,从1开始</strong></p><p><strong>2.遍历容器</strong></p><p><strong>List<User> list;</strong></p><p><strong>for(User user: list){}</strong></p><p><strong>属性:</strong></p><p><strong>items :容器对象</strong></p><p><strong>var:容器中元素的临时变量</strong></p><p><strong>三层架构:软件设计架构</strong></p><p><strong>1.界面层(表示层):用户看的得界面。用户可以通过界面上的组件和服务器进行交互,</strong></p><p><strong>2.业务逻辑层:处理业务逻辑的。</strong></p><p><strong>数据访问层:操作数据存储文件。</strong></p><p><img src="C:\Users\24861\Desktop\三层架构.JPG" alt="三层架构"></p><h2 id="Filter-过滤器"><a href="#Filter-过滤器" class="headerlink" title="Filter:过滤器"></a><strong>Filter:过滤器</strong></h2><p><strong>1.概念:生活中的过滤器:净水器,空气净化器,土匪、</strong></p><p><strong>web中的过滤器:当访问服务器的资源时,过滤器可以将请求拦截下来,完成一些特殊的功能。</strong></p><p><strong>过滤器的作用:</strong></p><p><strong>一般用于完成通用的操作。如:登录验证、统一编码处理、敏感字符过滤.</strong></p><p><strong>2.快速入门:</strong></p><p><strong>1,步骤:</strong></p><p><strong>1.定义一个类,实现接口Filter</strong></p><p><strong>2.复写方法</strong></p><p><strong>3.配置兰截路径</strong></p><p><strong>3.过滤器细节:</strong></p><p><strong>1.web.xml配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>cn.itcast.web.filer.FilterDemo1<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.过滤器执行流程</strong></p><p><strong>1.执行过滤器</strong></p><p><strong>2.执行放行后的资源</strong></p><p><strong>3、回来执行过滤器放行代码下边的代码,</strong></p><p><strong>3.过滤器生命周期方法</strong></p><p><strong>1. init:在服务器启动后,会创建Filter对象,然后调用init方法。只执行一次。用于加载资源</strong></p><p><strong>2. doFilter:每一次请求被拦截资源时,会执行。执行多次</strong></p><p><strong>3. destroy:在服务器关闭后, Filter对象被销段。如果服务器足正常关闭,只会执行destrov方法。只执行一次。用工释放资源。</strong></p><p><strong>4,过滤器配置详解</strong></p><p><strong>拦載路径配置:</strong></p><p><strong>1.具体资源路径: &#x2F;index.jsp 只有访问index.jsp资源时,过滤器才会被执行</strong></p><p><em><em>2.拦截目录:&#x2F;user&#x2F;</em>   访问&#x2F;user下的所有资源时,过滤器都会被执行拦截方式配置:</em>*</p><p>*<em>3.后缀名拦截: <em>.jsp 访问所有后缀名为jsp资源时,过滤器都会被执行</em></em></p><p><em><em>4,拦截所有资源:&#x2F;</em> 访问所有资源时,付滤器都会被执行</em>*</p><p><strong>5.过滤器链(配置多个过滤器)</strong></p><p><strong>拦截方式配置:资源被访问的方式</strong></p><p><strong>注解配置:设置dispatcherTypes属性</strong></p><p><strong>1. REQUEST :默认值。浏览器直接请求资源</strong></p><p><strong>2. FORWARD :转发访问资源</strong></p><p><strong>3. INCLUDE : 包含访问资源</strong></p><p><strong>4. ERROR:错误跳转资源</strong></p><p><strong>5. ASYNC :异步访问资源</strong></p><p><strong>web.xml配置</strong></p><p><strong>设置<dispatcher></dispatcher>标签即可</strong></p><p><strong>5.过滤器链(配置多个过滤器)</strong></p><p><strong>执行顺序:如果有两个过滤器:过滤器1和过滤器2</strong></p><p><strong>1.过滤器1</strong></p><p><strong>2.过滤器2</strong></p><p><strong>3.资源执行</strong></p><p><strong>4,过滤器2</strong></p><p><strong>5.过滤器1</strong></p><p><strong>过滤器先后顺序问题:</strong></p><p><strong>1.注解配置:按照类名的字符串比较规则比较,值小的先执行</strong></p><p><strong>如:AFilter 和BFilter, Afilter就先执行了。</strong></p><p><strong>2. web. xml配置:<filter-mapping>谁定义在上边,谁先执行</strong></p><p><strong>增强对象的功能:</strong></p><p><strong>设计模式:一些通用的解决固定问题的方式</strong></p><p><strong>1,装饰模式</strong></p><p><strong>2.代理模式</strong></p><p><strong>概念:</strong></p><p><strong>1,真实对象:被代理的对象</strong></p><p><strong>2.代理对象:</strong></p><p><strong>3.代理模式:代理对象代理真实对象,达到增强真实对象功能的目的</strong></p><p><strong>实现方式:</strong></p><p><strong>1.静态代理:有一个类文件描述代理模式</strong></p><p><strong>2,动态代理:在内存中形成代理类</strong></p><p><strong>实现步骤:</strong></p><p><strong>1.代理对象和真实对象实现相同的接口</strong></p><p><strong>2. 代理对象 &#x3D; Proxy.newInstance();</strong></p><p><strong>3.使用代理对象调用方法。</strong></p><p><strong>4,增强方法</strong></p><p><strong>增强方式:</strong></p><p><strong>1.增强参数列表</strong></p><p><strong>2.增强返回值类型</strong></p><p><strong>3.增强方法体执行逻辑</strong></p><p><strong>Listener :监听器</strong></p><p><strong>概念:web的三大組件之一。</strong></p><p><strong>事件监听机制</strong></p><p><strong>事件 :一件事情</strong></p><p><strong>事件源:事件发生的地方</strong></p><p><strong>监听器:一个对象</strong></p><p>**注册监听:将事件、事件源、监听器绑定在一起。当事件源上发生某个事件后,执行监听器代码 **</p><p><strong>ServletContextListener:监听servletcontext对象的创建和销毁</strong></p><p><strong>void contextDestroyed(ServletContextEvent sce):Servletcontext对象被销毁之前会调用该方法</strong></p><p><strong>void contextInitialized(ServletContextEvent sce):Servletcontext对象创建后会调用该方法</strong></p><p><strong>步骤:</strong></p><p><strong>1.定义一个类,实现ServletcontextListener接口</strong></p><p><strong>2.复写方法</strong></p><p><strong>3.配置</strong></p><p><strong>1. web.xml</strong></p><p><strong><listener></strong></p><p><strong><listener-class>cn.itcast.web.listener.ContextLoaderListener</listener-class></strong></p><p><strong></listener></strong></p><p><strong>2.注解:</strong></p><p><strong>指定初始化参数<context-param></strong></p><p><strong>@webListener</strong></p><h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX:"></a><strong>AJAX:</strong></h1><p><strong>1. 概念: ASynchronous JavaScript And XML 异的Javascript 和XML</strong></p><p><strong>1.异步和同步:客户端和服务器端相互通信的基础上</strong></p><p><strong>客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。</strong></p><p><strong>客户端不需要等待服务器端的响应。在服务器处理请求的过程中,客户端可以进行其他的操作。</strong></p><p><strong>Ajax是一种在无需重新加载整个网页的情况下,能够更新部分网页的技本</strong></p><p><strong>通过在后台与服务器进行少量数据交换,Ajax可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下,对网页的某部分进行更新。传统的网页(不使用Ajax)如果需要更新内容,必须重载整个网页页面。</strong></p><p><strong>2.实现方式:</strong></p><p><strong>1,原生的Js现方式</strong></p><p><strong>2. JQeury实现方式</strong></p><p><strong>1. $.ajax()</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">语法:S.ajax(&#123;键值对&#125;);</span><br><span class="line">//使用$.ajax()发送异步请求</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">url: &quot;ajaxServlet1111&quot; , // 请求路径</span><br><span class="line">type: &quot;POST&quot; , //请求方式</span><br><span class="line">//data: &quot;username=jack&amp;age=23&quot;,//请求参数</span><br><span class="line">data: &#123;&quot;username&quot;: &quot;jack&quot;, &quot;age&quot; :23&#125;,</span><br><span class="line">success: function (data) &#123;</span><br><span class="line">alert(data);</span><br><span class="line">&#125;,</span><br><span class="line">//响应成功后的回调函数</span><br><span class="line">error: function () &#123;</span><br><span class="line">alert(&quot;出错啦...&quot;)</span><br><span class="line">&#125;,//表示如果请求响应出现错误,会执行的回调函数</span><br><span class="line">datatype: &quot;text&quot;//设置接受到的响应数据的格式</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>2. $.get()发送get请求</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法: $.get(url, [data], [callback], [type])</span><br><span class="line">参数:* url :请求路径* data :请求参数*callback :回调函数*type:响应结果的类型</span><br></pre></td></tr></table></figure><p><strong>3. $.post()发送post请求</strong></p><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON:"></a>JSON:</h1><p><strong>1.概念: Javascript object NotationJavascript对象表示法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.<span class="title function_">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">p.<span class="title function_">setAge</span>(<span class="number">23</span>);</span><br><span class="line">p.<span class="title function_">setGender</span>(<span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> p = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;age&quot;</span>:<span class="number">23</span>, <span class="string">&quot;gender&quot;</span> :<span class="string">&quot;男&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>JSON : JavaScript 对象表示法( JavaScript Object Notation)</strong></p><p><strong>JSON 是存储和交换文本信息的语法。</strong></p><p><strong>类似XML,JSON 比 XML 更小、更快,更易解析。</strong></p><p><strong>2.语法:</strong></p><p><strong>1.基本规则</strong></p><p><strong>数据在名称&#x2F;值对中:json数据是由键值对构成的</strong></p><p><strong>键用引号(单双都行)引起来,也可以不使用引号</strong></p><p><strong>值得取值类型:</strong></p><p><strong>1.数字(整数或浮点数)</strong></p><p><strong>2.字符串(在双引号中)</strong></p><p><strong>3.逻辑值(true或false)</strong></p><p><strong>4,数组(在方括号中) {persons”:[{},{}]}</strong></p><p><strong>5&#x2F;对象(在花括号中) {“address”:{“province” :”陕西”….}}</strong></p><p><strong>null</strong></p><p><strong>数据由逗号分隔:多个键值对由逗号分隔</strong></p><p><strong>花括号保存对象:使用{}定义json格式</strong></p><p><strong>方括号保存数组[ ]</strong></p><p><strong>2.获取数据</strong></p><p><strong>1. json对象,键名</strong></p><p><strong>2. json对象[“键名”]</strong></p><p><strong>3.数组对象[索引]</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">      var person=&#123;&quot;name&quot;:&quot;张三&quot;,age:23,&#x27;gender&#x27;:true&#125;</span><br><span class="line"></span><br><span class="line">      var ps=[&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:true&#125;,&#123;&quot;name&quot;:&quot;张2&quot;,&quot;age&quot;:24,&quot;gender&quot;:true&#125;,&#123;&quot;name&quot;:&quot;张0&quot;,&quot;age&quot;:25,&quot;gender&quot;:false&#125;];</span><br><span class="line"></span><br><span class="line">      // for (var key in person)&#123;</span><br><span class="line">      //     alert(key+&quot;:&quot;+person[key]);</span><br><span class="line">      // &#125;</span><br><span class="line"></span><br><span class="line">      for (var i=0;i&lt;ps.length;i++)&#123;</span><br><span class="line">          var p=ps[i];</span><br><span class="line">          for (var key in p)&#123;</span><br><span class="line">              alert(key+&quot;:&quot;+p[key]);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>3. JSON数据和Java对象的相互转换</strong></p><p><strong>JSON解析器:</strong></p><p><strong>常见的解析器: Jsonlib, Gson, fastjson, jackson</strong></p><p><strong>1. JSON转为Java对象</strong></p><p><strong>2. Java对象转JSON</strong></p><p><strong>1.使用步骤:</strong></p><p><strong>1. 导入jackson的相关jar包</strong></p><p><strong>2.创建Jackson核心对象 objectMapper</strong></p><p><strong>3.调用objectMapper的相关方法进行转换</strong></p><p><strong>1. readvalue(ison字符串数据,class)</strong></p><p><strong>1.转换方法:</strong></p><p><strong>writevalue(参数1, obj):</strong></p><p><strong>参数1:</strong></p><p><strong>File :将obj对象转换为JSON字符串,并保存到指定的文件中</strong></p><p><strong>Writer :将obj对象转换为JSON字符串,并将json数据填充到字符输出流中</strong></p><p><strong>Outputstream :将obj对象转换为JSON字符串,并将json数据填充到字节输出流中</strong></p><p><strong>writeValueAsstring(obj):将对象转为json字符串</strong></p><p><strong>2.注解:</strong></p><p>**1. @Jsonignore :排除属性。 **</p><p><strong>2. @JsonHormat:属性值得格式化</strong></p><p><strong>@JsonFormat(pattern &#x3D; “yyyy-MM-dd”)</strong></p><p><strong>3.复杂java对象转换</strong></p><p><strong>1. List：数组</strong></p><p><strong>2. Map：对象格式一致</strong></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据可视化</title>
      <link href="/2024/03/13/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
      <url>/2024/03/13/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h1><h2 id="1-什么是数据可视化"><a href="#1-什么是数据可视化" class="headerlink" title="1.什么是数据可视化"></a>1.什么是数据可视化</h2><h3 id="1-1数据可视化"><a href="#1-1数据可视化" class="headerlink" title="1.1数据可视化"></a>1.1数据可视化</h3><p><strong>数据可视化主要目的:借助于图形化手段,清晰有效地传达与沟通信息。</strong></p><p><strong>数据可视化可以把数据从冰冷的数字转换成图形,揭示蕴含在数据中的规律和道理。</strong></p><h3 id="1-2数据可视化的场景"><a href="#1-2数据可视化的场景" class="headerlink" title="1.2数据可视化的场景"></a>1.2数据可视化的场景</h3><p><strong>目前互联网公司通常有这么几大类的可视化需求:</strong></p><p><strong>通用报表</strong></p><p><strong>移动端图表</strong></p><p><strong>大屏可视化</strong></p><p><strong>图编辑&amp;图分析</strong></p><p><strong>地理可视化</strong></p><h3 id="1-3常见的数据可视化库"><a href="#1-3常见的数据可视化库" class="headerlink" title="1.3常见的数据可视化库"></a>1.3常见的数据可视化库</h3><p><strong>D3.js 目前Web端评价最高的Javascript可视化工具库(入手难)</strong></p><p><strong><u>ECharts.js百度出品的一个开源Javascript数据可视化库</u></strong></p><p><strong><u>Highcharts.js国外的前端数据可视化库,非商用免费,被许多国外大公司所使用</u></strong></p><p><strong>AntV蚂蚁金服全新一代数据可视化解决方案</strong></p><p><strong>等等</strong></p><p><strong>Highcharts和 Echarts 就像是office和WPS的关系</strong></p><h2 id="2-数据可视化项目概述"><a href="#2-数据可视化项目概述" class="headerlink" title="2.数据可视化项目概述"></a>2.数据可视化项目概述</h2><p><strong>市场需求:</strong></p><p><strong>应对现在数据可视化的趋势,越来越多企业需要在很多场景(营销数据,生产数据,用户数据)下使用,可视化图表来展示体现数据,让数据更加直观,数据特点更加突出</strong></p><h3 id="2-3项目技术"><a href="#2-3项目技术" class="headerlink" title="2.3项目技术"></a>2.3项目技术</h3><p><strong>HTMLS+ CSs3布局</strong></p><p><strong>css3动画、渐变</strong></p><p><strong>jQuery+原生Javascript</strong></p><p><strong>flex布局和rem适配方案</strong></p><p><strong>图片边框border-image</strong></p><p><strong>ES6模板字符</strong></p><p><strong>ECharts可视化库等等</strong></p><h2 id="3-ECharts简介"><a href="#3-ECharts简介" class="headerlink" title="3.ECharts简介"></a>3.ECharts简介</h2><p><strong>ECharts是一个使用JavaScript实现的开源可视化库,可以流畅的运行在PC和移动设备上,兼容当前绝大部分浏览器(1E8&#x2F;9&#x2F;10&#x2F;11, Chrome, Firefox, Safari等) ,底层依赖矢量图形库ZRender,提供直观,交互丰富,可高度个性化定制的数据可视化图表。</strong></p><p><strong>官网地址:<a href="https://echarts.apache.org/zh/index.html">https://echarts.apache.org/zh/index.html</a></strong></p><p><strong>丰富的可视化类型</strong></p><p><strong>多种数据格式支持</strong></p><p><strong>流数据的支持</strong></p><p><strong>移动端优化</strong></p><p><strong>跨平台使用</strong></p><p><strong>绚丽的特效</strong></p><p><strong>详细的文档说明</strong></p><p><strong>ECharts能满足绝大多数可视化图表实现,使用方便,功能强大,是实现数据可视化的最优选择之一</strong></p><h2 id="4-ECharts的基本使用"><a href="#4-ECharts的基本使用" class="headerlink" title="4.ECharts的基本使用"></a>4.ECharts的基本使用</h2><h3 id="4-1-ECharts使用五步曲"><a href="#4-1-ECharts使用五步曲" class="headerlink" title="4.1 ECharts使用五步曲"></a>4.1 ECharts使用五步曲</h3><p><strong>步骤1:下载并引入echarts.js文件——————图表依赖这个js库</strong></p><p><strong>步骤2:准备一个具备大小的DOM容器———–生成的图表会放入这个容器内</strong></p><p><strong>步骤3 :初始化echarts实例对象——————–实例化echarts对象</strong></p><p><strong>步骤4:指定配置项和数据(option)—————–根据具体需求修改配置选项</strong></p><p><strong>步骤5:将配置项设置给echarts实例对象——–让echarts对象根据修改好的配置生效</strong></p><h3 id="4-3相关配置讲解"><a href="#4-3相关配置讲解" class="headerlink" title="4.3相关配置讲解"></a>4.3相关配置讲解</h3><p><strong>title :标题组件</strong></p><p><strong>tooltip :提示框组件</strong></p><p><strong>legend :图例组件</strong></p><p><strong>toolbox:工具栏</strong></p><p><strong>grid :直角坐标系内绘图网格</strong></p><p><strong>XAxis :直角坐标系grid中的x轴</strong></p><p><strong>yAxis :直角坐标系grid中的y轴</strong></p><p><strong>series:系列列表。每个系列通过type决定自己的图表类型(什么类型的图标)</strong></p><p><strong>color :调色盘颜色列表</strong></p><p><strong>series:系列列表</strong></p><p><strong>type:类型(什么类型的图表)比如line是折线bar柱形等</strong></p><p><strong>name:系列名称,用于tooltip的显示, legend的图例筛选变化</strong></p><p><strong>stack:数据堆叠。如果设置相同值,则会数据堆叠。</strong></p><p><strong>数据堆叠:</strong> </p><p><strong>第二个数据值&#x3D;第一个数据值+第二个数据值</strong></p><p><strong>第三个数据值&#x3D;第二个数据值+第三个数据值….依次叠加</strong></p><p><strong>如果给stack指定不同值或者去掉这个属性则不会发生数据堆叠</strong></p><h2 id="06-REM适配"><a href="#06-REM适配" class="headerlink" title="06-REM适配"></a>06-REM适配</h2><p><strong>设计稿是1920px</strong></p><p><strong>PC端适配:宽度在1024-1920之间页面元素宽高自适应</strong></p><p><strong>1.flexible.js把屏幕分为24等份.</strong></p><p><strong>2.cssrem插件的基准值是80px</strong> </p><p><strong>插件-配置按钮一配置扩展设置-Root Font Size里面设置</strong></p><p><strong>但是别忘记重启vscode软件保证生效</strong></p><p><strong>3,要把屏幕宽度约束在1024-1920之间有适配,实现代码:</strong></p><p><strong>&#x2F;&#x2F;实现rem适配</strong></p><p><strong>@media screen and (max-width: 1024px) {</strong></p><p><strong>html {</strong></p><p><strong>font-size: 42.66px !important;</strong></p><p><strong>}</strong></p><p><strong>}</strong></p><p><strong>@media screen and (min-width: 1920px) {</strong></p><p> <strong>html {</strong></p><p><strong>font-size: 80px limportant;</strong></p><p><strong>}</strong></p><p><strong>}</strong></p><p><strong>保存自动刷新浏览器插件</strong></p><p><strong>Preview on Web Server</strong></p><h3 id="2-2边框图片"><a href="#2-2边框图片" class="headerlink" title="2.2边框图片"></a>2.2边框图片</h3><p><strong>1,边框图片的使用场景</strong></p><p><strong>盒子大小不一,但是边框样式相同,此时就需要边框图片来完成</strong></p><p><strong>为了实现丰富多彩的边框效果,在CS3中,新增了border-image属性,这个新属性允许指定一幅图像作为元素的边框。</strong></p><p><strong>2.边框图片的切图原理</strong></p><p><strong>把四个角切出去(九宫格的由来) ,中间部分可以铺排、拉伸或者环绕。</strong></p><p><strong>按照上右下左顺序切割</strong></p><p><strong>3.边框图片语法规范</strong></p><p><strong>属性描述</strong></p><p><strong>border-image-source  用在边框的图片的路径。(那个图片? )</strong></p><p><strong>border-image-slice 图片边框向内偏移。(裁剪的尺寸,一定不加单位,上右下左顺序)</strong></p><p><strong>border-image-width  图片边框的宽度(需要加单位) (不是边框的宽度是边框图片的宽度</strong></p><p><strong>border-image-repeat 图像边框是否应平铺(repeat)、铺满(round)或拉伸(stretch)默认拉伸</strong></p><h3 id="2-4通过类名调用字体图标"><a href="#2-4通过类名调用字体图标" class="headerlink" title="2.4通过类名调用字体图标"></a>2.4通过类名调用字体图标</h3><p><strong>HTML页面引入字体图标中css文件。</strong></p><p><strong><link rel="stvlesheet" href="fonts/style.css"></strong></p><p><strong>2标签直接调用图标对应的类名即可。(类名在css文件中标注)</strong></p><p><strong><span class="icon-angellist"></span></strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue</title>
      <link href="/2024/03/13/Vue/"/>
      <url>/2024/03/13/Vue/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue基础"><a href="#Vue基础" class="headerlink" title="Vue基础"></a>Vue基础</h1><p><strong>webpack 的学习目标</strong></p><p><strong>①理解什么是前端工程化</strong></p><p><strong>转变对前端开发的认知</strong></p><p><strong>② 了解webpack的基本用法</strong></p><p><strong>为后面Vue和React课程的学习做技术储备</strong></p><p><strong>③不强制要求大家能手动配置webpack.</strong></p><p><strong>一定要知道webpack在项目中有什么作用</strong></p><p><strong>清楚webpack中的核心概念</strong></p><h1 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a><strong>前端工程化</strong></h1><p><strong>1.小白眼中的前端开发vs实际的前端开发小白眼中的前端开发:</strong></p><p><strong>会写HTML + CSS + JavaScript 就会前端开发</strong></p><p><strong>需要美化页面样式,就搜一个bootstrap过来</strong></p><p><strong>需要操作DOM 或发起Ajax请求,再搜一个jQuery过来</strong></p><p><strong>需要快速实现网页布局效果,就搜一个Layui过来</strong></p><p><strong>实际的前端开发:</strong></p><p><strong>模块化 (js的模块化、CSS的模块化、资源的模块化)</strong></p><p><strong>组件化 (复用现有的UI结构、样式、行为)</strong></p><p><strong>规范化 (目录结构的划分、编码规范化、接口规范化、文档规范化、Git分支管理)</strong></p><p><strong>自动化 (自动化构建、自动部署、自动化测试)</strong></p><h2 id="2-什么是前端工程化前端工程化指的是"><a href="#2-什么是前端工程化前端工程化指的是" class="headerlink" title="2.什么是前端工程化前端工程化指的是:"></a><strong>2.什么是前端工程化前端工程化指的是:</strong></h2><p><strong>在企业级的前端项目开发中,把前端开发所需的工具、技术、流程、经验等进行规范化、标准化。</strong></p><p><strong>企业中的Vue项目和React项目,都是基于工程化的方式进行开发的。</strong></p><p><strong>好处:前端开发自成体系,有一套标准的开发方案和流程。</strong></p><h2 id="3-前端工程化的解决方案"><a href="#3-前端工程化的解决方案" class="headerlink" title="3.前端工程化的解决方案"></a><strong>3.前端工程化的解决方案</strong></h2><p><strong>早期的前端工程化解决方案:</strong></p><p><strong>grunt ( <a href="https://www.gruntjs.net/">https://www.gruntjs.net/</a>)</strong></p><p><strong>gulp ( <a href="https://www.gulpjs.com.cn/">https://www.gulpjs.com.cn/</a>)</strong></p><p><strong>目前主流的前端工程化解决方案:</strong></p><p><strong>webpack ( <a href="https://www.webpackjs.com/">https://www.webpackjs.com/</a>)</strong></p><p><strong>parcel ( <a href="https://zh.parceljs.org/">https://zh.parceljs.org/</a>)</strong></p><h1 id="webpack-的基本使用"><a href="#webpack-的基本使用" class="headerlink" title="webpack 的基本使用"></a><strong>webpack 的基本使用</strong></h1><h2 id="1-什么是webpack"><a href="#1-什么是webpack" class="headerlink" title="1. 什么是webpack"></a><strong>1. 什么是webpack</strong></h2><p><strong>概念: webpack是前端项目工程化的具体解决方案。</strong></p><p><strong>主要功能:它提供了友好的前端模块化开发支持,以及代码压缩混滑、处理浏览器端JavaScript的兼容性、性能优化等强大的功能。</strong></p><p><strong>好处:让程序员把工作的重心放到具体功能的实现上,提高了前端开发效率和项目的可维护性。</strong></p><h2 id="2-创建列表隔行变色项目"><a href="#2-创建列表隔行变色项目" class="headerlink" title="2.创建列表隔行变色项目"></a><strong>2.创建列表隔行变色项目</strong></h2><p><strong>①新建项目空白目录,并运行npm init-y 命令,初始化包管理配置文件 package.json</strong></p><p><strong>②新建src源代码目录</strong></p><p><strong>③新建src-&gt; index.html 首页和src-&gt; index.js脚本交件</strong></p><p><strong>④初始化首页基本的结构5 运行 npm install jquery -S O令,安装 jQuery</strong></p><p><strong>6通过ES6模块化的方式导入jQuery,实现列表隔行变色效果</strong></p><h2 id="3-在项目中安装webpack"><a href="#3-在项目中安装webpack" class="headerlink" title="3.在项目中安装webpack"></a><strong>3.在项目中安装webpack</strong></h2><p><strong>在终端运行如下的命令,安装webpack相关的两个包:</strong></p><p><strong>npm install <a href="mailto:&#119;&#101;&#x62;&#x70;&#x61;&#x63;&#x6b;&#64;&#53;&#46;&#52;&#x32;&#x2e;&#x31;">&#119;&#101;&#x62;&#x70;&#x61;&#x63;&#x6b;&#64;&#53;&#46;&#52;&#x32;&#x2e;&#x31;</a> <a href="mailto:&#x77;&#101;&#98;&#112;&#97;&#x63;&#107;&#45;&#99;&#x6c;&#x69;&#x40;&#52;&#46;&#55;&#46;&#50;">&#x77;&#101;&#98;&#112;&#97;&#x63;&#107;&#45;&#99;&#x6c;&#x69;&#x40;&#52;&#46;&#55;&#46;&#50;</a> -D</strong></p><p><strong>-S是–save的简写</strong></p><p><strong>-D是–save-dev的简写</strong></p><p><strong>Install with npm:</strong></p><p><strong>npm install –save-dev webpack</strong></p><p><strong>Install with yarn:</strong></p><p><strong>yarn add webpack –dev</strong></p><h2 id="4-在项目中配置webpack"><a href="#4-在项目中配置webpack" class="headerlink" title="4.在项目中配置webpack"></a><strong>4.在项目中配置webpack</strong></h2><p><strong>① 在项目根目录中,创建名为webpack.config.js的webpack配置文件,并初始化如下的基本配置:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> =&#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span> <span class="comment">// mode用来指定构建模式,可选值有development和production</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>②在package.json 的scripts 节点下,新增dev脚本如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;webpack&quot;</span> <span class="comment">//script 节点下的脚本,可以通过 npm run执行,例如npm run dev</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>③在终端中运行npm run dev 命令,启动webpack进行项目的打包构建</strong></p><h3 id="4-3-webpack-中的默认约定"><a href="#4-3-webpack-中的默认约定" class="headerlink" title="4.3 webpack 中的默认约定"></a><strong>4.3 webpack 中的默认约定</strong></h3><p><strong>在webpack 4.x和5.的版本中,有如下的默认约定:</strong></p><p><strong>① 默认的打包入口文件为src -&gt; index.js</strong></p><p><strong>②默认的输出文件路径为 dist-&gt; main.js</strong></p><p><strong>注意:可以在webpack.config.js中修改打包的默认约定</strong></p><h3 id="4-4自定义打包的入口与出口"><a href="#4-4自定义打包的入口与出口" class="headerlink" title="4.4自定义打包的入口与出口"></a><strong>4.4自定义打包的入口与出口</strong></h3><p><strong>在webpack.config.js 配置文件中,通过entry节点指定打包的入口。通过output节点指定打包的出口。示例代码如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path= <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>) <span class="comment">// 导入 node.js 中专门操作路径的模块</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;./src/index.js&#x27;</span>), <span class="comment">// 打包入口文件的路径</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>:path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;./dist&#x27;</span>), <span class="comment">// 输出文件的存放路径。</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span> <span class="comment">//输出文件的名称</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>VSCode中智能提示node.js代码解决</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typings</span><br><span class="line">typings install dt~node --<span class="variable language_">global</span> --save</span><br></pre></td></tr></table></figure><h3 id="webpack-中的插件"><a href="#webpack-中的插件" class="headerlink" title="webpack 中的插件"></a><strong>webpack 中的插件</strong></h3><p><strong>1. webpack 插件的作用</strong></p><p><strong>通过安装和配置第三方的插件,可以拓展webpack的能力,从而让webpack用起来更方便。最常用的webpack 插件有如下两个:</strong></p><p><strong>①webpack-dev-server.</strong></p><p><strong>类似于node.js阶段用到的nodemon工具.</strong></p><p><strong>每当修改了源代码,webpack会自动进行项目的打包和构建</strong></p><p><strong>2.html-webpack-plugin</strong></p><p><strong>webpack 中的HTML 插件(类似于一个模板引擎插件)</strong></p><p><strong>可以通过此插件自定制index.html页面的内容</strong></p><h3 id="2-1-安装-webpack-dev-server"><a href="#2-1-安装-webpack-dev-server" class="headerlink" title="2.1 安装 webpack-dev-server"></a>2.1 安装 webpack-dev-server</h3><p><strong>运行如下的命令,即可在项目中安装此插件:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-server@<span class="number">3.11</span><span class="number">.2</span> -D</span><br></pre></td></tr></table></figure><h3 id="2-2-配置-webpack-dev-server"><a href="#2-2-配置-webpack-dev-server" class="headerlink" title="2.2 配置 webpack-dev-server"></a><strong>2.2 配置 webpack-dev-server</strong></h3><p><strong>①修改package.json-&gt;scripts 中的dev命令如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;webpack serve&quot;</span>, <span class="comment">// script 节点下的脚本,可以通过npm run执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>②再次运行npm run dev命令,重新进行项目的打包</strong></p><p><strong>③在浏览器中访问<a href="http://localhost:8080地址,查看自动打包效果">http://localhost:8080地址,查看自动打包效果</a></strong></p><p><strong>注意: webpack-dev-server 会启动一个实时打包的http服务器</strong></p><h3 id="3-1-安装-html-webpack-plugin"><a href="#3-1-安装-html-webpack-plugin" class="headerlink" title="3.1 安装 html-webpack-plugin"></a><strong>3.1 安装 html-webpack-plugin</strong></h3><p><strong>运行如下的命令,即可在项目中安装此插件:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-webpack-plugin@<span class="number">5.3</span><span class="number">.2</span> -D</span><br></pre></td></tr></table></figure><h3 id="3-2-配置-html-webpack-plugin"><a href="#3-2-配置-html-webpack-plugin" class="headerlink" title="3.2 配置 html-webpack-plugin"></a><strong>3.2 配置 html-webpack-plugin</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1,导入HTML播件,得到一个构造函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="comment">//2.创建HTML提件的实例对象</span></span><br><span class="line"><span class="keyword">const</span> htmlPlugin = <span class="keyword">new</span> <span class="title class_">HrmlPlugin</span>(&#123;</span><br><span class="line"><span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>, <span class="comment">//指定原文件的存放路径</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;./index.html&#x27;</span>,  <span class="comment">//指定生成的文件的存放路径</span></span><br><span class="line">&#125;)</span><br><span class="line">nodule.<span class="property">exports</span> =&#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    <span class="attr">plugins</span>: [htmlPlugin], <span class="comment">// 3.通过 plugins 点,使htmlPlugin播件生效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-devServer-节点"><a href="#4-devServer-节点" class="headerlink" title="4. devServer 节点"></a><strong>4. devServer 节点</strong></h2><p><strong>在webpack.config.js配置文件中,可以通过devServer节点对webpack-dev-server插件进行更多的配置,示例代码如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devServer</span>:&#123;</span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span>, <span class="comment">//初次打包完成后,自动打开浏览器</span></span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="comment">//实时打包所使用的主机地址</span></span><br><span class="line">    <span class="attr">port</span>: <span class="number">80</span>, <span class="comment">//实时打包所使用的端口号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:凡是修改了webpack.config.js配置文件,或修改了package.json配置文件,必须重启实时打包的服务器,否则最新的配置文件无法生效!</strong></p><h2 id="1-webpack-插件的作用"><a href="#1-webpack-插件的作用" class="headerlink" title="1. webpack 插件的作用"></a><strong>1. webpack 插件的作用</strong></h2><p><strong>通过安装和配置第三方的插件,可以拓展webpack的能力,从而让webpack用起来更方便。</strong></p><p><strong>最常用的webpack 插件有如下两个:</strong></p><p><strong>webpack-dev-server .</strong></p><p><strong>类似于node.js阶段用到的nodemon工具.每当修改了源代码, webpack会自动进行项目的打包和构建</strong></p><p><strong>html-webpaçk-plugin .</strong></p><p><strong>webpack 中的HTML插件(类似于一个模板引擎插件).可以通过此插件自定制index.html页面的内容</strong></p><h2 id="1-loader-概述"><a href="#1-loader-概述" class="headerlink" title="1. loader 概述"></a><strong>1. loader 概述</strong></h2><p><strong>在实际开发过程中,webpack默认只能打包处理以.js后缀名结尾的模块。其他非.js后缀名结尾的模块,webpack默认处理不了,需要调用loader加载器才可以正常打包,否则会报错!</strong></p><p><strong>loader加载器的作用:协助webpack打包处理特定的文件模块。比如:</strong></p><p><strong>css-loader 可以打包处理.CSS相关的文件.</strong></p><p><strong>less-loader 可以打包处理.less 相关的文件</strong></p><p><strong>babel-loader 可以打包处理webpack无法处理的高级JS语法</strong></p><p><strong>3.打包处理css文件</strong></p><p><strong>①运行npm i <a href="mailto:&#115;&#116;&#x79;&#108;&#x65;&#x2d;&#x6c;&#111;&#x61;&#100;&#101;&#x72;&#64;&#51;&#x2e;&#48;&#x2e;&#48;">&#115;&#116;&#x79;&#108;&#x65;&#x2d;&#x6c;&#111;&#x61;&#100;&#101;&#x72;&#64;&#51;&#x2e;&#48;&#x2e;&#48;</a> <a href="mailto:&#99;&#115;&#115;&#45;&#108;&#x6f;&#x61;&#x64;&#x65;&#x72;&#x40;&#53;&#x2e;&#x32;&#x2e;&#54;">&#99;&#115;&#115;&#45;&#108;&#x6f;&#x61;&#x64;&#x65;&#x72;&#x40;&#53;&#x2e;&#x32;&#x2e;&#54;</a> -D 命令, 安装处理 CSs 文件的 loader</strong></p><p><strong>② 在webpack.config.js 的module-&gt; rules 数组中,添加 loader规则如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123; <span class="comment">//所有第三方文件模块的匹配规则</span></span><br><span class="line"><span class="attr">rules</span>: [ <span class="comment">//文件后缀名的匹配规则</span></span><br><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,<span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span> , <span class="string">&#x27;css-loader &#x27;</span>] &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其中，test表示匹配的文件类型,use表示对应要调用的 loader</strong></p><p><strong>注意:use数组中指定的 loader顺序是固定的</strong></p><p><strong>多个loader的调用顺序是:从后往前调用</strong></p><p><strong>1. webpack默认只能打包处理.js结尾的文件，处理不了其它后缀的文件</strong></p><p><strong>2.由于代码中包含了index.css 这个文件，因此 webpack 默认处理不了</strong></p><p><strong>3.当webpack 发现某个文件处理不了的时候，会查找webpack.config.js 这个配置文件，module.rules数组中，是否配置了对应的loader 加载器。</strong></p><p><strong>4. webpack把index.css 这个文件，先转交给最后一个loader进行处理（先转交给css-loader) .<br>5.当css-loader处理完毕之后，会把处理的结果，转交给下一个loader(转交给style-loader)<br>6.当style-loader处理完毕之后，发现没有下一个loader了，于是就把处理的结果，转交给了webpack<br>7.webpack 把 style-loader处理的结果，合并到&#x2F;dist&#x2F;bundle.js[中，最终生成打包好的文件。</strong></p><h2 id="4-打包处理less文件"><a href="#4-打包处理less文件" class="headerlink" title="4.打包处理less文件"></a><strong>4.打包处理less文件</strong></h2><p><strong>运行 npm i <a href="mailto:&#x6c;&#101;&#115;&#115;&#45;&#x6c;&#111;&#97;&#100;&#101;&#x72;&#x40;&#x31;&#48;&#46;&#48;&#x2e;&#x31;">&#x6c;&#101;&#115;&#115;&#45;&#x6c;&#111;&#97;&#100;&#101;&#x72;&#x40;&#x31;&#48;&#46;&#48;&#x2e;&#x31;</a> <a href="mailto:&#x74;&#x65;&#x73;&#115;&#64;&#52;&#x2e;&#x31;&#x2e;&#x31;">&#x74;&#x65;&#x73;&#115;&#64;&#52;&#x2e;&#x31;&#x2e;&#x31;</a> -D命令</strong></p><p><strong>在webpack.config.js 的 module -&gt; rules数组中，添加loader 规则如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;<span class="comment">//所有第三方文忤模块的匹配规则</span></span><br><span class="line"><span class="attr">rules</span>: [ <span class="comment">//文件后缀名的匹配规则</span></span><br><span class="line">&#123;<span class="attr">test</span>:/\.<span class="property">less$</span>,<span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span> , <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader &#x27;</span>]&#125;,</span><br><span class="line">     ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-打包处理样式表中与url路径相关的文件"><a href="#5-打包处理样式表中与url路径相关的文件" class="headerlink" title="5.打包处理样式表中与url路径相关的文件"></a><strong>5.打包处理样式表中与url路径相关的文件</strong></h2><p><strong>运行npm i <a href="mailto:&#x75;&#x72;&#x6c;&#45;&#x6c;&#111;&#x61;&#100;&#x65;&#x72;&#x40;&#x34;&#46;&#49;&#46;&#x31;">&#x75;&#x72;&#x6c;&#45;&#x6c;&#111;&#x61;&#100;&#x65;&#x72;&#x40;&#x34;&#46;&#49;&#46;&#x31;</a> <a href="mailto:&#102;&#105;&#x6c;&#101;&#x2d;&#108;&#111;&#97;&#100;&#101;&#114;&#64;&#x36;&#x2e;&#50;&#x2e;&#x30;">&#102;&#105;&#x6c;&#101;&#x2d;&#108;&#111;&#97;&#100;&#101;&#114;&#64;&#x36;&#x2e;&#50;&#x2e;&#x30;</a> -D命令</strong><br><strong>在webpack.config.js 的 module -&gt; rules数组中，添加 loader 规则如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">madule</span>: &#123; <span class="comment">//所有第三方文件模块的匹配规则</span></span><br><span class="line"><span class="attr">rulcs</span>: [<span class="comment">//文件后缀名的匹配规则</span></span><br><span class="line">&#123; <span class="attr">test</span>: /\.<span class="property">jpg</span>|png|gif$l,<span class="attr">use</span>: <span class="string">&#x27;ur1-1oader?limit=22229&#x27;</span>&#125;,</span><br><span class="line"> </span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其中?之后的是loader的参数项:</strong></p><p><strong>limit 用来指定图片的大小，单位是字节( byte)</strong></p><p><strong>只有≤limit大小的图片，才会被转为base64格式的图片</strong></p><h2 id="6-打包处理js文件中的高级语法"><a href="#6-打包处理js文件中的高级语法" class="headerlink" title="6.打包处理js文件中的高级语法"></a><strong>6.打包处理js文件中的高级语法</strong></h2><p><strong>webpack 只能打包处理一部分高级的JavaScript 语法。对于那些webpack无法处理的高级js语法,需要借助于babel-loader进行打包处理。例如webpack无法处理下面的JavaScript代码:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.定义了名为info的装饰等</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">info</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="comment">//2.为目标添加静态属性info</span></span><br><span class="line">    target.<span class="property">info</span> = <span class="string">&#x27;Person info&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.为Person类应用info装饰器</span></span><br><span class="line">@info</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"><span class="comment">//4.打印Person的静高属性info</span></span><br><span class="line"><span class="variable language_">console</span>, <span class="title function_">log</span>( <span class="title class_">Person</span>, info)</span><br></pre></td></tr></table></figure><h3 id="6-1-安装-babel-loader-相关的包运行如下的命令安装对应的依赖包"><a href="#6-1-安装-babel-loader-相关的包运行如下的命令安装对应的依赖包" class="headerlink" title="6.1 安装 babel-loader 相关的包运行如下的命令安装对应的依赖包:"></a><strong>6.1 安装 babel-loader 相关的包运行如下的命令安装对应的依赖包:</strong></h3><p><strong>npm i <a href="mailto:&#x62;&#97;&#x62;&#x65;&#x6c;&#45;&#108;&#x6f;&#97;&#x64;&#x65;&#114;&#64;&#x38;&#x2e;&#x32;&#x2e;&#50;">&#x62;&#97;&#x62;&#x65;&#x6c;&#45;&#108;&#x6f;&#97;&#x64;&#x65;&#114;&#64;&#x38;&#x2e;&#x32;&#x2e;&#50;</a> @babel&#x2F;<a href="mailto:&#99;&#111;&#x72;&#101;&#64;&#55;&#x2e;&#x31;&#x34;&#x2e;&#54;">&#99;&#111;&#x72;&#101;&#64;&#55;&#x2e;&#x31;&#x34;&#x2e;&#54;</a> @babel&#x2F;<a href="mailto:&#112;&#108;&#117;&#103;&#x69;&#x6e;&#x2d;&#112;&#x72;&#x6f;&#x70;&#x6f;&#115;&#97;&#x6c;&#x2d;&#x64;&#x65;&#99;&#x6f;&#114;&#97;&#116;&#x6f;&#114;&#x73;&#x40;&#x37;&#x2e;&#x31;&#52;&#x2e;&#53;">&#112;&#108;&#117;&#103;&#x69;&#x6e;&#x2d;&#112;&#x72;&#x6f;&#x70;&#x6f;&#115;&#97;&#x6c;&#x2d;&#x64;&#x65;&#99;&#x6f;&#114;&#97;&#116;&#x6f;&#114;&#x73;&#x40;&#x37;&#x2e;&#x31;&#52;&#x2e;&#53;</a> -D</strong></p><p><strong>在webpack.config.js的module-&gt; rules数组中,添加 loader规则如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意:必须使用exclude指定推除项,因为node_modules 日录下的第三方包不需要被打包</span></span><br><span class="line">&#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">use</span>: <span class="string">&#x27;babel-loader&#x27;</span>, <span class="attr">exclude</span>: <span class="regexp">/nodc_modules/</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-配置babel-loader"><a href="#6-2-配置babel-loader" class="headerlink" title="6.2 配置babel-loader"></a><strong>6.2 配置babel-loader</strong></h3><p><strong>在项目根目录下,|创建名为babel.config.js的配置文件,定义Babel的配置项如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>. <span class="built_in">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//声明babel可用的插件</span></span><br><span class="line">    <span class="attr">plugins</span>: [[<span class="string">&#x27;@babel/plugin-proposal-decorators&#x27;</span>, &#123; <span class="attr">legacy</span>: <span class="literal">true</span> &#125;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-配置webpack的打包发布"><a href="#2-配置webpack的打包发布" class="headerlink" title="2.配置webpack的打包发布"></a><strong>2.配置webpack的打包发布</strong></h2><p><strong>在package.json文件的scripts节点下,新增build命令如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;webpack serve&quot;</span>, <span class="comment">//开发环境中,运行dev命令</span></span><br><span class="line">     <span class="string">&quot;build&quot;</span>: <span class="string">&quot;webpack --mode production&quot;</span> </span><br><span class="line">    <span class="comment">//项目发布时,运行build 命令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>–model 是一个参数项,用来指定webpack的运行模式。production代表生产环境,会对打包生成的文件进行代码压缩和性能优化。</strong></p><p><strong>注意:通过–model指定的参数项,会覆盖webpack.config.js 中的model 选项。</strong></p><h2 id="5-自动清理dist目录下的旧文件"><a href="#5-自动清理dist目录下的旧文件" class="headerlink" title="5.自动清理dist目录下的旧文件"></a><strong>5.自动清理dist目录下的旧文件</strong></h2><p><strong>为了在每次打包发布时自动清理掉dist目录中的旧文件,可以安装并配置clean-webpack-plugir插件:</strong></p><p><strong>安装插件npm install –save-dev clean-webpack-plugin</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.安装清理dist 目录的webpack播件</span></span><br><span class="line">npm install clean-webpack-plugin3<span class="number">.0</span><span class="number">.0</span> -D</span><br><span class="line"><span class="comment">//2.按需导入插件、得到插件的构造函数之后,创建播件的实例对象</span></span><br><span class="line"><span class="keyword">const</span> &#123;<span class="title class_">CleanwebpackPlugin</span>&#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> cleanPlugin = <span class="keyword">new</span> <span class="title class_">CleanlebpackPlugin</span>()</span><br><span class="line"><span class="comment">//3.把创建的cleanPlugin插件实例对象,挂载到plugins节点中</span></span><br><span class="line"><span class="attr">plugins</span>: [htmlPlugin, cleanPlugin], <span class="comment">//1 挂載插件</span></span><br></pre></td></tr></table></figure><h1 id="Source-Map"><a href="#Source-Map" class="headerlink" title="Source Map"></a><strong>Source Map</strong></h1><h2 id="2-什么是Source-Map"><a href="#2-什么是Source-Map" class="headerlink" title="2. 什么是Source Map"></a><strong>2. 什么是Source Map</strong></h2><p><strong>Source Map就是一个信息文件,里面储存着位置信息。也就是说,Source Map文件中存储着压缩混滑后的代码,所对应的转换前的位置。</strong></p><p><strong>有了它,出错的时候,除错工具将直接显示原始代码,而不是转换后的代码,能够极大的方便后期的调试。</strong></p><h2 id="3-1默认Source-Map-的问题"><a href="#3-1默认Source-Map-的问题" class="headerlink" title="3.1默认Source Map 的问题"></a><strong>3.1默认Source Map 的问题</strong></h2><p><strong>开发环境下默认生成的Source Map,|记录的是生成后的代码的位置。会导致运行时报错的行数与源代码的行数不一致的问题。</strong></p><p><strong>开发环境下,推荐在webpack.config.js中添加如下的配置,即可保证运行时报错的行数与源代码的行数保持一致:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports =&#123;</span><br><span class="line">mode: &#x27;development&#x27;，</span><br><span class="line">// eval-source-map仅限在&quot;开发模式&quot;下使用,不建议在&quot;生产模式&quot;下使用。</span><br><span class="line">//此选项生成的Source Map能够保证&quot;运行时报错的行数&quot;与&quot;源代码的行数&quot;保持一致</span><br><span class="line">devtool: &#x27;eval-source-nap&#x27;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-webpack-生产环境下的-Source-Map"><a href="#4-webpack-生产环境下的-Source-Map" class="headerlink" title="4. webpack 生产环境下的 Source Map"></a><strong>4. webpack 生产环境下的 Source Map</strong></h2><p><strong>在生产环境下,如果省略了devtool选项,则最终生成的文件中不包含Source Map。这能够防止原始代码通过Source Map的形式暴露给别有所图之人。</strong></p><h3 id="4-1只定位行数不暴露源码"><a href="#4-1只定位行数不暴露源码" class="headerlink" title="4.1只定位行数不暴露源码"></a><strong>4.1只定位行数不暴露源码</strong></h3><p><strong>在生产环境下|如果只想定位报错的具体行数,且不想暴露源码。此时可以将devtool的值设置为nosources-source-map。</strong></p><p><strong>4.2定位行数且暴露源码</strong></p><p><strong>在生产环境下,如果想在定位报错行数的同时,展示具体报错的源码。此时可以将devtool的值设置为source-map。不推荐使用</strong></p><p><strong>采用此选项后:你应该将你的服务器配置为,不允许普通用户访问source map文件!</strong></p><h2 id="5-Source-Map-的最佳实践"><a href="#5-Source-Map-的最佳实践" class="headerlink" title="5. Source Map 的最佳实践"></a><strong>5. Source Map 的最佳实践</strong></h2><p><strong>①开发环境下:</strong></p><p><strong>建议把 devtool 的值设置为 eval-source-map</strong></p><p><strong>好处:可以精准定位到具体的错误行</strong></p><p><strong>②生产环境下:</strong></p><p><strong>建议关闭 Source Map或将devtool 的值设置为nosources-source-map.</strong></p><p><strong>好处:防止源码泄露,提高网站的安全性</strong></p><p><strong>实际开发中需要自己配置webpack 吗?</strong></p><p><strong>答案:不需要!·</strong></p><p><strong>实际开发中会使命令行工具(俗称CLI)一键生成带有webpack的项目</strong></p><p><strong>·开箱即用,所有webpack配置项都是现成的!</strong></p><p><strong>.我们只需要知道webpack中的基本概念即可!</strong></p><h1 id="Vue简介"><a href="#Vue简介" class="headerlink" title="Vue简介"></a>Vue简介</h1><p><strong>1.什么是vue官方给出的概念:Vue (读音&#x2F;vju:&#x2F;,类似于view)是一套用于构建用户界面的前端框架</strong></p><p><strong>1.构建用户界面</strong></p><p><strong>。用vue 往html页面中填充数据,非常的方便</strong></p><p><strong>2.框架</strong></p><p><strong>。框架是一套现成的解决方案,程序员只能道守框架的规范,去编写自己的业务功能!</strong></p><p><strong>。要学习vue,就是在学习Vue框架中规定的用法!</strong></p><p><strong>。vue的指令、组件(是对UI结构的复用)、路由、Vuex</strong></p><h2 id="2-vue的特性vue框架的特性"><a href="#2-vue的特性vue框架的特性" class="headerlink" title="2. vue的特性vue框架的特性"></a><strong>2. vue的特性vue框架的特性</strong></h2><p><strong>主要体现在如下两方面:</strong></p><p><strong>1.数据驱动视图</strong></p><p>**数据的变化会驱动视图自动更新 **</p><p><strong>好处:程序员只管把数据维护好,那么页面结构会被vue自动演染出来!</strong></p><p><strong>2. 双向数据绑定</strong></p><p><strong>在网页中, form表单负责采集数据,Ajax负责提交数据。</strong></p><p><strong>js数据的变化,会被自动演染到页面上</strong></p><p><strong>页面上表单采集的数据发生变化的时候,会被vue 自动获取到,并更新到js数据中</strong></p><h3 id="2-1数据驱动视图"><a href="#2-1数据驱动视图" class="headerlink" title="2.1数据驱动视图"></a><strong>2.1数据驱动视图</strong></h3><p><strong>在使用了vue的页面中,vue会监听数据的变化,从而自动重新渲染页面的结构。示意图如下:</strong></p><p><strong>页面结构—-（自动渲染）—–vue监听数据变化—–（变化）——页面所依赖的数据</strong></p><p>​<strong>数据驱动视图</strong></p><p><strong>好处:当页面数据发生变化时,页面会自动重新渲染!</strong></p><p><strong>注意:数据驱动视图是单向的数据绑定。</strong></p><h2 id="2-2-双向数据绑定"><a href="#2-2-双向数据绑定" class="headerlink" title="2.2 双向数据绑定"></a><strong>2.2 双向数据绑定</strong></h2><p><strong>在填写表单时,双向数据绑定可以辅助开发者在不操作DOM的前提下,自动把用户填写的内容同步到数据源中。示意图如下:</strong></p><p><strong>页面结构—–（自动填充）——（值发送变化）——–vue——-（变化）——–（自动同步）——–（页面所依赖的数据）</strong></p><p><strong>①好处:开发者不再需要手动操作 DOM元素,来获取表单元素最新的值!</strong></p><h2 id="2-3-MVVM"><a href="#2-3-MVVM" class="headerlink" title="2.3 MVVM"></a><strong>2.3 MVVM</strong></h2><p><strong>MVVM 是vue 实现数据驱动视图和双向数据绑定的核心原理。MVVM指的是Model, View 和ViewModel,它把每个HTML页面都拆分成了这三个部分,如图所示:</strong></p><p><strong>在MVVM概念中:</strong></p><p><strong>Model 表示当前页面宣染时所依赖的数据源。</strong></p><p><strong>View 表示当前页面所宣染的DOM结构。</strong></p><p><strong>ViewModel 表示vue 的实例,它是MVVM的核心。</strong></p><h2 id="2-4-MVVM-的工作原理"><a href="#2-4-MVVM-的工作原理" class="headerlink" title="2.4 MVVM 的工作原理"></a><strong>2.4 MVVM 的工作原理</strong></h2><p><strong>ViewModel 作为MVVM 的核心,是它把当前页面的数据源(Model)和页面的结构(View)连接在了一起。</strong></p><p><strong>view—-（自动更新）———（监听dom变化）——-viewmodel———-（监听数据源变化）——–（自动同步）———-model</strong></p><p><strong>当数据源发生变化时,会被ViewModel监听到,VM会根据最新的数据源自动更新页面的结构</strong></p><p><strong>当表单元素的值发生变化时,也会被VM监听到,VM会把变化过后最新的值自动同步到Model数据源中</strong></p><p><strong>注意:数据驱动视图和双向数据绑定的底层原理是MVVM (Mode数据源、View视图、ViewModel就是vue的实例)</strong></p><h1 id="vue-的基本使用"><a href="#vue-的基本使用" class="headerlink" title="vue 的基本使用"></a><strong>vue 的基本使用</strong></h1><p><strong>1.基本使用步骤</strong></p><p><strong>1.导入vue.js 的script脚本文件</strong></p><p><strong>②在页面中声明一个将要被vue所控制的DOM区域</strong></p><p><strong>③创建vm实例对象(vue实例对象)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!--2.在页面中声明一个将要被vue所控制的DOM区域--&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&#123;&#123;username&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;!--1. 导入vue.js的script脚本文件--&gt;</span><br><span class="line">    &lt;script src=&quot;./lib/vue-2.6.12. js&quot;&lt;/script&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script&gt;</span><br><span class="line">//3.创建vm实例对象(vue实例对象)</span><br><span class="line">const vm = new Vue(&#123;</span><br><span class="line">//3.1指定当前vm实例要控制页面的哪个区域</span><br><span class="line">el: &#x27;#app&#x27;,</span><br><span class="line">// 3.2指定Model数据源</span><br><span class="line">data: &#123;</span><br><span class="line">username: &#x27;zs&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h2 id="vue-的指令与过滤器"><a href="#vue-的指令与过滤器" class="headerlink" title="vue 的指令与过滤器"></a><strong>vue 的指令与过滤器</strong></h2><p><strong>指令(Directives)是vue 为开发者提供的模板语法,用于辅助开发者宣染页面的基本结构。</strong></p><p><strong>vue中的指令按照不同的用途可以分为如下6大类:</strong></p><p><strong>① 内容宣染指令</strong></p><p><strong>② 属性绑定指令</strong></p><p><strong>③事件绑定指令</strong></p><p><strong>④ 双向绑定指令</strong></p><p><strong>⑤ 条件宣染指令</strong></p><p><strong>6.列表宣染指令</strong></p><p><strong>注意:指令是vue开发中最基础、最常用、最简单的知识点。</strong></p><h3 id="1-1内容宣染指令"><a href="#1-1内容宣染指令" class="headerlink" title="1.1内容宣染指令"></a><strong>1.1内容宣染指令</strong></h3><p><strong>内容宣染指令用来辅助开发者渲染DOM元素的文本内容。常用的内容宣染指令有如下3个:</strong></p><p><strong>.v-text———-会覆盖元素内部原有的内容!</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--把username对应的值,宣染到第一个p标签中--&gt;</span><br><span class="line">&lt;p v-text=&quot;username&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;!--把gender 对应的值,宣染到第二个p标签中--&gt;</span><br><span class="line">&lt;!--注意:第二个p标签中,默认的文本“性别”会被gender 的值覆盖掉--&gt;</span><br><span class="line">&lt;p v-text=&quot;gender&quot;&gt;性别&lt;/p&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#125;&#125;</span><br><span class="line">vue提供的[)语法,专门用来解决v-text会覆盖默认文本内容的问题。这种&#123;&#123;&#125;&#125;语法的专业名称是插值表达式(英文名为:Mustache)</span><br><span class="line">&lt;!--使用&#123;&#123;&#125;&#125;插值表达式,将对应的值渲染到元素的内容节点中,--&gt;</span><br><span class="line">&lt;!--同时保留元素自身的默认值--&gt;</span><br><span class="line">&lt;p&gt;姓名: &#123;&#123;username&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;性别: &#123;&#123;gender&#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#125;&#125;插值表达式:在实际开发中用的最多,只是内容的占位符,不会覆盖原有的内容!</span><br><span class="line"></span><br><span class="line">.v-html</span><br><span class="line">v-text指令和插值表达式只能渲染纯文本内容。如果要把包含HTML标签的字符串渲染为页面的HTML元素,则需要用到v-html这个指令:</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-html=&quot;info&quot;&gt;&lt;/div&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">        const vm = new Vue(&#123;</span><br><span class="line">                el: &#x27;#app&#x27;,</span><br><span class="line">                // el指向的选择器就是view视图区域</span><br><span class="line">                data: &#123;</span><br><span class="line">                    username: &#x27;zs&#x27;,</span><br><span class="line">                    // data指向的对象就是model数据源</span><br><span class="line">                    gender: &#x27;女&#x27;,</span><br><span class="line">                    info: &#x27;&lt;h4 style=&quot;color:red; font-weight:hold&quot;&gt;欢迎您学习vue&lt;/h4&gt;&#x27;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            //new vue()构造函数得到的vm实例对象就是viewmodel</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>v-html指令的作用:可以把带有标签的字符串,渲染成真正的HTML内容!</strong></p><h3 id="2-属性绑定指令"><a href="#2-属性绑定指令" class="headerlink" title="2.属性绑定指令"></a><strong>2.属性绑定指令</strong></h3><p><strong>注意:插值表达式只能用在元索的内容节点中,不能用在元索的属性节点中!</strong></p><h3 id="1-2属性绑定指令"><a href="#1-2属性绑定指令" class="headerlink" title="1.2属性绑定指令"></a><strong>1.2属性绑定指令</strong></h3><p><strong>如果需要为元素的属性动态绑定属性值,则需要用到v-bind属性绑定指令。用法示例如下:</strong></p><p><strong>在vue中,可以使用v-bind:指令,为元系的属性动态绑定值;</strong></p><p><strong>简写是英文的冒号</strong></p><h3 id="使用Javascript-表达式"><a href="#使用Javascript-表达式" class="headerlink" title="使用Javascript 表达式"></a><strong>使用Javascript 表达式</strong></h3><p><strong>在vue提供的模板宣染语法中,除了支持绑定简单的数据值之外,还支持Javascript表达式的运算,例如:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;number + 1&#125;&#125;</span><br><span class="line">&#123;&#123;ok ? &#x27;YES&#x27; : &#x27;NO&#x27;&#125;&#125;</span><br><span class="line">&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)&#125;&#125;</span><br><span class="line">&lt;div v-bind:id=&quot;&#x27;list-&#x27;+ id&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>在使用v-bind属性绑定期间,如果绑定内容需要进行动态拼接,则字符串的外面应该包裹单引号</strong></p><h2 id="1-3事件绑定指令"><a href="#1-3事件绑定指令" class="headerlink" title="1.3事件绑定指令"></a>1.3事件绑定指令</h2><p><strong>vue提供了v-on事件绑定指令,用来辅助程序员为DOM元素绑定事件监听。语法格式如下:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3&gt;count的值为: &#123;&#123;count&#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;!--语法格式为v-on:事件名称=&quot;事件处理函数的名称”.--&gt;</span><br><span class="line">&lt;button v-on:click=&quot;addCount&quot;&gt;+1&lt;/button&gt;</span><br></pre></td></tr></table></figure><p><strong>注意:原生DOM 对象有 onclick, oninput, onkeyup 等原生事件,替换为vue的事件绑定形式后,分别为:v-on:click, v-on:input, v-on:keyup</strong></p><p><strong>事件修饰符</strong></p><p><strong>在事件处理函数中调用 event.preventDefault() 或 event.stopPropagation()是非常常见的需求。因此,vue提供了事件修饰符的概念,来辅助程序员更方便的对事件的触发进行控制。常用的5个事件修饰符如下:</strong></p><p><strong>事件修饰符说明</strong></p><p><strong>.prevent阻止默认行为(例如:阻止a连接的跳转、阻止表单的提交等)</strong></p><p><strong>.stop  阻止事件冒泡</strong></p><p><strong>.capture                    以捕获模式触发当前的事件处理函数</strong></p><p><strong>.once  绑定的事件只触发1次</strong></p><p><strong>.self只有在event.target是当前元素自身时触发事件处理函数</strong></p><h2 id="3-事件绑定"><a href="#3-事件绑定" class="headerlink" title="3.事件绑定"></a><strong>3.事件绑定</strong></h2><p><strong>1. v-on:简写是@</strong></p><p><strong>2.语法格式为:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;add&quot;&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">add() &#123;</span><br><span class="line">//如果在方法中要修改data中的数据,可以通过this访问到</span><br><span class="line">this.count += 1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. Sevent的应用场景:如果默认的事件对象e被覆盖了,则可以手动传递一个$event.</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;add(3),$event&quot;&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">add(n,e) &#123;</span><br><span class="line">//如果在方法中要修改data中的数据,可以通过this访问到</span><br><span class="line">this.count += 1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-事件修饰符"><a href="#4-事件修饰符" class="headerlink" title="4.事件修饰符:"></a><strong>4.事件修饰符:</strong></h2><p><strong>.prevent</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>.stop</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>按键修饰符</strong></p><p><strong>在监听键盘事件时,我们经常需要判断详细的按键。此时,可以为键盘相关的事件添加按键修饰符,例如:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--只有在&quot;key&#x27;&#x27;Enter&#x27;时调用&quot;vm.submit()&#x27;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.enter</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">&lt;!-只有在&quot;key&quot;或‘Esc&#x27;时用&#x27;vm.clearinput()&#x27; --&gt;</span><br><span class="line"> <span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.esc</span>=<span class="string">&quot;clearinput&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-4双向绑定指令"><a href="#1-4双向绑定指令" class="headerlink" title="1.4双向绑定指令"></a><strong>1.4双向绑定指令</strong></h3><p><strong>vue 提供了 v-model 双向数据绑定指令,用来辅助开发者在不操作DOM的前提下,快速获取表单的数据。</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>用户名是: &#123;&#123;username&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">V-model</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>选中的省份是: &#123;&#123;province&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;province&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>请择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>河北<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span>黑龙江<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-v-model-指令"><a href="#4-v-model-指令" class="headerlink" title="4. v-model 指令"></a><strong>4. v-model 指令</strong></h2><p><strong>1. input 输入框</strong></p><p><strong>type&#x3D;”radio”</strong></p><p>**type&#x3D;”checkbox” **</p><p><strong>type&#x3D;”xxxx”</strong></p><p><strong>2. textarea</strong></p><p><strong>3. select</strong></p><h3 id="v-model指令的修饰符"><a href="#v-model指令的修饰符" class="headerlink" title="v-model指令的修饰符"></a><strong>v-model指令的修饰符</strong></h3><p><strong>为了方便对用户输入的内容进行处理, vue 为v-model指令提供了3个修饰符,分别是:</strong></p><p><strong>修饰符作用示例</strong></p><p><strong>.number 自动将用户的输入值转为数值类型<input v-model.number="age" /></strong></p><p><strong>.trim 自动过用户输入的首尾空白字符 <input v-model.trim="msg" /></strong></p><p><strong>.lazy 在”change”时而非 “input” 时更新 <input v-model.lazy="msg" /></strong></p><h3 id="1-5条件宣染指令"><a href="#1-5条件宣染指令" class="headerlink" title="1.5条件宣染指令"></a><strong>1.5条件宣染指令</strong></h3><p><strong>条件宣染指令用来辅助开发者按需控制DOM的显示与隐藏。条件宣染指令有如下两个,分别是:</strong></p><p><strong>•v-if</strong></p><p><strong>•v-show</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;networkState === 200&quot;</span>&gt;</span>请求成功被v-if控制<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>&quot;<span class="attr">networkState</span> === <span class="string">200</span>&quot;&gt;</span>请求成功被v-show控制<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>1. v-show 的原理是:动态为元素添加或移除display: none样式,来实现元素的显示和隐織</strong></p><p><strong>如果要频繁的切换元素的显示状态,用v-show性能会更好</strong></p><p><strong>2. v-if 的原理是:每次动态创建或移除元素,实现元素的显示和隐服</strong></p><p><strong>如果刚进入页面的时候,某些元素默认不需要被展示,而且后期这个元素很可能也不需要被展示出来,此时v-if性能更好</strong></p><p><strong>3.在实际开发中,绝大多数情况,不用考虑性能问题,直接使用v-if就好了</strong></p><p><strong>v-else</strong></p><p><strong>v-if可以单独使用,或配合v-else指令一起使用:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;Math.random() &gt; 0.5&quot;</span>&gt;</span></span><br><span class="line">   //随机数大于0.5</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">   随机数小于或等于0.5</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意:v-else指令必须配合v-if指令一起使用,否则它将不会被识别!</strong></p><h3 id="1-6列表宣染指令"><a href="#1-6列表宣染指令" class="headerlink" title="1.6列表宣染指令"></a><strong>1.6列表宣染指令</strong></h3><p><strong>vue提供了v-for列表演染指令,用来辅助开发者基于一个数组来循环渲染一个列表结构。v-for指令需要使用item in items形式的特殊语法,其中:</strong></p><p><strong>•items是待循环的数组</strong></p><p><strong>• item是被循环的每一项,</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data:&#123;</span><br><span class="line">list: [ //列表数据</span><br><span class="line">&#123;id: 1, name: &#x27;zs&#x27;&#125;,</span><br><span class="line">&#123;id: 2, name: &#x27;ls&#x27;&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span>&gt;</span>姓名是: &#123;&#123;item.name&#125;&#125;&lt;/1i&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>v-for中的索引</strong></p><p><strong>v-for指令还支持一个可选的第二个参数,即当前项的索引,语法格式为(item, index) in items,示例代码如下:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data:&#123;</span><br><span class="line">list: [//列表数据</span><br><span class="line">&#123;id: 1, name: &#x27;zs&#x27;&#125; ,</span><br><span class="line">&#123;id: 2, name: &#x27;1s&#x27;&#125;,</span><br><span class="line">//----------------------------------------------分割线</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in list&quot;</span>&gt;</span>索引是: &#123;&#123;index&#125;&#125;,姓名是: &#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意: v-for指令中的item项和index索引都是形参,可以根据需要进行重命名。例如(user, i) in userlist</strong></p><h3 id="key-的注意事项"><a href="#key-的注意事项" class="headerlink" title="key 的注意事项"></a><strong>key 的注意事项</strong></h3><p><strong>① key 的值只能是字符串或数字类型</strong></p><p><strong>② key的值必须具有唯一性(即:key的值不能重复)</strong></p><p><strong>③建议把数据项id属性的值作为key的值(因为id属性的值具有唯一性)</strong></p><p><strong>④ 使用index的值当作key的值没有任何意义(因为index的值不具有唯一性)</strong></p><p><strong>⑤建议使用v-for指令时一定要指定key的值(既提升性能、又防止列表状态素乱)</strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>①能够知道vue的基本使用步骤.</strong></p><p><strong>.导入vue.js文件</strong></p><p><strong>.new Vue()构造函数,得到vm实例对象</strong></p><p><strong>.声明el和data数据节点</strong></p><p><strong>.MVVM的对应关系</strong></p><p><strong>②掌握vue中常见指令的基本用法</strong></p><p><strong>插值表达式、v-bind, v-on,v-if和v-else</strong></p><p><strong>v-for 和:key, v-model</strong></p><p><strong>③掌握vue 中过滤器的基本用法</strong></p><h1 id="vue-的指令与过器"><a href="#vue-的指令与过器" class="headerlink" title="vue 的指令与过器"></a>vue 的指令与过器</h1><h2 id="2-过滤器"><a href="#2-过滤器" class="headerlink" title="2.过滤器"></a>2.过滤器</h2><p><strong>过滤器(Filters)是vue为开发者提供的功能,常用于文本的格式化。过滤器可以用在两个地方:插值表达式和v-bind属性绑定。</strong></p><p><strong>过滤器应该被添加在JavaScript表达式的尾部,由“管道符”进行调用,示例代码如下:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在双花括号中通过&quot;管道符&quot;调用capitalize 过速器,对message的值进行格式化--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;message | capitalize&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--在v-bind中通过“管道符&quot;调用formatId过滤器,对rawId的值进行格式化--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind</span>=<span class="string">&quot;rawId | formatId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><h3 id="过滤器的注意点"><a href="#过滤器的注意点" class="headerlink" title="过滤器的注意点"></a>过滤器的注意点</h3><p><strong>1.要定义到filters节点下,本质是一个函数</strong></p><p><strong>2.在过滤器函数中,一定要有return值</strong></p><p><strong>3.在过滤器的形参中,就可以获取到”管道符”前面待处理的那个值</strong></p><p><strong>4.如果全局过滤器和私有过滤器名字一致I此时按照”就近原则”,调用的是”私有过滤器”</strong></p><h2 id="watch-侦听器"><a href="#watch-侦听器" class="headerlink" title="watch 侦听器"></a>watch 侦听器</h2><h3 id="侦听器的格式"><a href="#侦听器的格式" class="headerlink" title="侦听器的格式"></a>侦听器的格式</h3><p><strong>1.方法格式的侦听器。</strong></p><p>​<strong>缺点:无法在刚进入页面的时候,自动触发!!!</strong></p><p>​<strong>缺点2:如果侦听的是一个对象,如果对象中的属性发生了变化,不会触发侦听器!!</strong></p><p><strong>2.对象格式的侦听器</strong></p><p>​<strong>好处:可以通过immediate选项,让侦听器自动触发!!</strong></p><p>​<strong>好处2:可以通过deep选项,让侦听器深度监听对象中每个属性的变化!!!</strong></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="2-2私有过滤器和全局过滤器"><a href="#2-2私有过滤器和全局过滤器" class="headerlink" title="2.2私有过滤器和全局过滤器"></a><strong>2.2私有过滤器和全局过滤器</strong></h2><p><strong>在filters节点下定义的过滤器,称为“私有过滤器”,因为它只能在当前vm实例所控制的el区域内使用。如果希望在多个vue实例之间共享过滤器,则可以按照如下的格式定义全局过滤器:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//全局过滤器-独立于每个vm实例之外</span><br><span class="line">// Vue.filter()方法接收两个参数:</span><br><span class="line">//第1个参数,是全局过滤器的&quot;名字&quot;</span><br><span class="line">//第2个参数,是全局过滤器的&quot;处理函数&quot;</span><br><span class="line">Vue. filter(&#x27;capitalize&#x27;, (str) =&gt;  &#123;</span><br><span class="line">return str.charAt(0).toUpperCase() + str.slice(1) + &#x27;~~&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="2-3连续调用多个过滤器"><a href="#2-3连续调用多个过滤器" class="headerlink" title="2.3连续调用多个过滤器"></a>2.3连续调用多个过滤器</h2><p><strong>过滤器可以串联地进行调用,例如:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--把message的值,交给filterA进行处理--&gt;</span><br><span class="line">&lt;!--把filterA处理的结果,再交给filterB进行处理--&gt;</span><br><span class="line">&lt;!--最终把filterB处理的结果,作为最终的值谊染到页面上--&gt;“</span><br><span class="line">&#123;&#123;message | filterA | filterB&#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>过滤器的本质是JavaScript函数,因此可以接收参数,格式如下:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- arg1 和arg2 是传递给filterA的参数--&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123; message | filterA(arg1, arg2)&#125;&#125; &lt;/p&gt;</span><br><span class="line">//过滤器处理函数的形参列表中:</span><br><span class="line">//第一个参数:永远都是&quot;管道符&quot;前面待处理的值</span><br><span class="line">// 从第二个参数开始,才是调用过滤器时传递过来的arg1和arg2参数</span><br><span class="line">Vue.filter(&#x27;filterA&#x27;, (msg, arg1, arg2) =&gt; &#123;</span><br><span class="line">//过滤器的代码逻辑....</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="2-5过滤器的兼容性"><a href="#2-5过滤器的兼容性" class="headerlink" title="2.5过滤器的兼容性"></a><strong>2.5过滤器的兼容性</strong></h2><p><strong>过滤器仅在vue 2.x和1.x中受支持,在vye 3.x的版本中剔除了过滤器相关的功能。</strong></p><p><strong>在企业级项目开发中:●如果使用的是2.x版本的vue,则依然可以使用过滤器相关的功能</strong></p><p><strong>·如果项目已经升级到了3.x版本的vue,官方建议使用计算属性或方法代替被剔除的过滤器功能</strong></p><h1 id="watch侦听器"><a href="#watch侦听器" class="headerlink" title="watch侦听器"></a>watch侦听器</h1><h2 id="1-什么是watch侦听器"><a href="#1-什么是watch侦听器" class="headerlink" title="1.什么是watch侦听器"></a>1.什么是watch侦听器</h2><p><strong>watch侦听器允许开发者监视数据的变化,从而针对数据的变化做特定的操作。语法格式如下:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const vm new Vue(&#123;</span><br><span class="line"> el: &#x27;#app&#x27;,</span><br><span class="line"> data: &#123; username:&#x27;&#x27;&#125;,</span><br><span class="line">watch:&#123;</span><br><span class="line">//监听username值的变化</span><br><span class="line">// newVal是&quot;变化后的新值&quot;, oldVal是&quot;变化之前的旧值”</span><br><span class="line">username(newval, oldVal)&#123;</span><br><span class="line">console.log(newVal, oldVal)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="2-使用watch检测用户名是否可用"><a href="#2-使用watch检测用户名是否可用" class="headerlink" title="2.使用watch检测用户名是否可用"></a><strong>2.使用watch检测用户名是否可用</strong></h2><p><strong>监听username值的变化,并使用axios发起Ajax请求,检测当前输入的用户名是否可用:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">//监听 username值的变化</span><br><span class="line">async username(newVal) &#123;</span><br><span class="line">if (newVal=== &#x27;&#x27;) return</span><br><span class="line">//使用axios发起请求,判断用户名是否可用</span><br><span class="line">const &#123; data: res &#125;= await axios.get(&#x27;https://www.escook.cn/api/finduser/&#x27; + newVal)</span><br><span class="line">console. log(res)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="watch侦听器-1"><a href="#watch侦听器-1" class="headerlink" title="watch侦听器"></a>watch侦听器</h2><h3 id="3-immediate-选项"><a href="#3-immediate-选项" class="headerlink" title="3.immediate 选项"></a>3.immediate 选项</h3><p><strong>默认情况下,组件在初次加载完毕后不会调用watdh侦听器。如果想让watch侦听器立即被调用,则需要使用immediate选项。示例代码如下:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">username:&#123;</span><br><span class="line">handle:async function(newVal) &#123;</span><br><span class="line">if (newVal=== &#x27;&#x27;) return</span><br><span class="line"></span><br><span class="line">const &#123; data: res &#125;= await axios.get(&#x27;https://www.escook.cn/api/finduser/&#x27; + newVal)</span><br><span class="line">console. log(res)</span><br><span class="line">&#125;,</span><br><span class="line">immediate:true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="watch侦听器-2"><a href="#watch侦听器-2" class="headerlink" title="watch侦听器"></a><strong>watch侦听器</strong></h2><h3 id="4-deep-选项"><a href="#4-deep-选项" class="headerlink" title="4.deep 选项"></a><strong>4.deep 选项</strong></h3><p><strong>如果watch侦听的是一个对象,如果对象中的属性值发生了变化,则无法被监听到。此时需要使用deep选项,代码示例如下:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const vm = new Vue(&#123;</span><br><span class="line">el: &#x27;#app&#x27;,</span><br><span class="line">data:&#123;</span><br><span class="line">info:&#123; username: &#x27;admin&#x27; &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch:&#123;</span><br><span class="line">info: &#123;</span><br><span class="line">handler(newVal)&#123;</span><br><span class="line">console.log(newVal.username)</span><br><span class="line">&#125;,</span><br><span class="line">deep: true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure><h2 id="5-监听对象单个属性的变化"><a href="#5-监听对象单个属性的变化" class="headerlink" title="5.监听对象单个属性的变化"></a>5.监听对象单个属性的变化</h2><p><strong>如果只想监听对象中单个属性的变化,则可以按照如下的方式定义watch侦听器:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const vm= new Vue&#123;</span><br><span class="line">el: &#x27;#app&#x27;,</span><br><span class="line">data:&#123;</span><br><span class="line">info:&#123;username: &#x27;admin&#x27;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123; </span><br><span class="line">&#x27;info.username&#x27;:&#123; </span><br><span class="line">handler(newVal)&#123;</span><br><span class="line">console.log(newWal)</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure><h2 id="侦听器的格式-1"><a href="#侦听器的格式-1" class="headerlink" title="侦听器的格式"></a>侦听器的格式</h2><p><strong>1.方法格式的侦听器。</strong></p><p><strong>缺点1:无法在刚进入页面的时候,自动触发!!!</strong></p><p><strong>缺点2:如果侦听的是一个对象,如果对象中的属性发生了变化,不会触发侦听器!!!</strong></p><p><strong>2.对象格式的侦听器。</strong></p><p><strong>好处1:可以通过immediate选项,让侦听器自动触发!!!。</strong></p><p><strong>好处2:可以通过deep选项,让侦听器深度监听对象中每个属性的变化!!!</strong></p><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a><strong>计算属性</strong></h2><h3 id="1-什么是计算属性"><a href="#1-什么是计算属性" class="headerlink" title="1.什么是计算属性"></a><strong>1.什么是计算属性</strong></h3><p><strong>计算属性指的是通过一系列运算之后,最终得到一个属性值。</strong></p><p><strong>这个动态计算出来的属性值可以被模板结构或methods方法使用。示例代码如下:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">el: &#x27;#app&#x27;,</span><br><span class="line">data:&#123;</span><br><span class="line">r: 0, g: 0, b: 0</span><br><span class="line">&#125;,</span><br><span class="line">computed:&#123;</span><br><span class="line">rgb() &#123;return &#x27;rgb($&#123;this.r&#125;, $&#123;this.g&#125;, $&#123;this.b&#125;)&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">show() &#123; </span><br><span class="line">console.log(this.rgb)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="计算属性特点"><a href="#计算属性特点" class="headerlink" title="计算属性特点:"></a>计算属性特点:</h3><p><strong>1.定义的时候,要被定义为“方法”</strong></p><p><strong>2.在使用计算属性的时候,当普通的属性使用即可</strong></p><p><strong>好处:</strong></p><p><strong>1.实现了代码的复用</strong></p><p><strong>2.只要计算属性中依赖的数据源变化了,则计算属性会自动重新求值!</strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodeJs</title>
      <link href="/2024/03/13/nodeJs/"/>
      <url>/2024/03/13/nodeJs/</url>
      
        <content type="html"><![CDATA[<h1 id="NODE-JS"><a href="#NODE-JS" class="headerlink" title="NODE.JS"></a>NODE.JS</h1><p><strong>1.初识Node.js</strong></p><p><strong>1.2 Node.js 简介</strong></p><p><strong>1. 什么是Node.js</strong></p><p><strong>Node.js@ is a JavaScript runtime built on Chrome’s V8 JavaScript engine.</strong></p><p><strong>Node.js 是一个基于Chrome V8 引擎的JavaScript 运行环境。</strong></p><p><strong>Node.js官网地址: <a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></strong></p><p><strong>2. Node.js 中的 JavaScript 运行环境</strong></p><p><strong>注意:</strong></p><p><strong>①浏览器是JavaScript的前端运行环境。</strong></p><p><strong>② Node.js 是 JavaScript的后端运行环境。</strong></p><p><strong>③ Node.js 中无法调用DOM和BOM等浏览器内置API。</strong></p><p><strong>3. Node.js 可以做什么</strong></p><p><strong>Node.js作为一个JavaScript的运行环境,仅仅提供了基础的功能和API。然而,基于Node.js提供的这些基础能,很多强大的工具和框架如雨后春笋,层出不穷,所以学会了Node.js,可以让前端程序员胜任更多的工作和岗位:</strong></p><p><strong>① 基于Express 框架(<a href="http://www.expressjs.com.cn/),%E5%8F%AF%E4%BB%A5%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BAWeb%E5%BA%94%E7%94%A8">http://www.expressjs.com.cn/),可以快速构建Web应用</a></strong></p><p><strong>② 基于Electron框架(<a href="https://electronjs.org/),%E5%8F%AF%E4%BB%A5%E6%9E%84%E5%BB%BA%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8">https://electronjs.org/),可以构建跨平台的桌面应用</a></strong></p><p><strong>③ 基于restify 框架(<a href="http://restify.com/),%E5%8F%AF%E4%BB%A5%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BAAPI%E6%8E%A5%E5%8F%A3%E9%A1%B9%E7%9B%AE">http://restify.com/),可以快速构建API接口项目</a></strong></p><p><strong>④读写和操作数据库、创建实用的命令行工具辅助前端开发、etc…</strong></p><p><strong>总之: Node.js是大前端时代的“大宝剑“,有了Node.js这个超级buff的加持,前端程序员的行业竞争力会越来越强!</strong></p><p><strong>Node.js 的学习路径:JavaScript 基础语法+ Node.js 内置API 模块(fs, path, http等) +第三方API 模块(express, mysql 等)</strong></p><h2 id="1-4在Node-js-环境中执行JavaScript代码"><a href="#1-4在Node-js-环境中执行JavaScript代码" class="headerlink" title="1.4在Node.js 环境中执行JavaScript代码"></a><strong>1.4在Node.js 环境中执行JavaScript代码</strong></h2><p><strong>1.终端中的快捷键</strong></p><p><strong>在Windows 的 powershell 或 cmd终端中,我们可以通过如下快捷键,来提高终端的操作效率:</strong></p><p><strong>①使用1键,可以快速定位到上一次执行的命令</strong></p><p><strong>②使用tab键,能够快速补全路径</strong></p><p><strong>③使用esc键,能够快速清空当前已输入的命令</strong></p><p><strong>④输入cls命令,可以清空终端</strong></p><p><strong>2. fs文件系统模块</strong></p><h2 id="2-1什么是fs文件系统模块"><a href="#2-1什么是fs文件系统模块" class="headerlink" title="2.1什么是fs文件系统模块"></a><strong>2.1什么是fs文件系统模块</strong></h2><p><strong>fs模块是Node.js官方提供的、用来操作文件的模块。它提供了一系列的方法和属性,用来满足用户对文件的操作需求。</strong></p><p><strong>例如:</strong></p><p><strong>fs.readFile0方法,用来读取指定文件中的内容.</strong></p><p><strong>fs.writeFile0方法,用来向指定的文件中写入内容</strong></p><p><strong>如果要在JavaScript代码中,使用fs模块来操作文件,则需要使用如下的方式先导入它:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs =<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="2-2读取指定文件中的内容"><a href="#2-2读取指定文件中的内容" class="headerlink" title="2.2读取指定文件中的内容"></a>2.2读取指定文件中的内容</h2><p><strong>1.fs.readFile()的语法格式</strong></p><p><strong>使用fs.readFile()方法,可以读取指定文件中的内容,语法格式如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(path[, options], callback)</span><br></pre></td></tr></table></figure><p><strong>参数解读:</strong></p><p><strong>参数1:必选参数,字符串,表示文件的路径。</strong></p><p><strong>参数2:可选参数,表示以什么编码格式来读取文件。</strong></p><p><strong>参数3:必选参数,文件读取完成后,通过回调函数拿到读取的结果。</strong></p><p><strong>2. fs.readFile()的示例代码以utf8的编码格式,读取指定文件的内容,并打印 err和dataStr的值:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/11.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, dataStr</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;----&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(dataStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>3.判断文件是否读取成功可以判断err对象是否为null,从而知晓文件读取的结果:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>) </span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/1.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;文件读取失!&#x27;</span>+ err.<span class="property">message</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;文件读取成功,内容是: &#x27;</span>+ result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="2-3向指定的文件中写入内容"><a href="#2-3向指定的文件中写入内容" class="headerlink" title="2.3向指定的文件中写入内容"></a><strong>2.3向指定的文件中写入内容</strong></h2><p><strong>1. fs.writeFile()的语法格式</strong></p><p><strong>使用fs.writeFile)方法,可以向指定的文件中写入内容,语法格式如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">writeFile</span>(file, data[, options], callback)</span><br></pre></td></tr></table></figure><p><strong>参数解读:</strong></p><p><strong>参数1:必选参数,需要指定一个文件路径的字符串,表示文件的存放路径。</strong></p><p><strong>参数2:必选参数,表示要写入的内容。</strong></p><p><strong>参数3:可选参数,表示以什么格式写入文件内容,默认值是utf8。</strong></p><p><strong>参数4:必选参数,文件写入完成后的回调函数。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;./files/2.txt&#x27;</span>, <span class="string">&#x27;Hello Node.js!&#x27;</span>, <span class="keyword">function</span>(<span class="params">err</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>3.判断文件是否写入成功</strong></p><p><strong>可以判断err对象是否为null,从而知晓文件写入的结果:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;F:/files/2.txt&#x27;</span>, <span class="string">&#x27;Hello Node.js!&#x27;</span>, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;文件写入失!&#x27;</span>+ err.<span class="property">message</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;文件写入成功! &#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="2-6-fs模块-路径动态拼接的问题"><a href="#2-6-fs模块-路径动态拼接的问题" class="headerlink" title="2.6 fs模块-路径动态拼接的问题"></a><strong>2.6 fs模块-路径动态拼接的问题</strong></h2><p><strong>在使用fs模块操作文件时,如果提供的操作路径是以&#x2F;或&#x2F;开头的相对路径时,很容易出现路径动态拼接错误的问题。</strong></p><p><strong>原因:代码在运行的时候,会以执行node命令时所处的目录,动态拼接出被操作文件的完整路径。</strong></p><p><strong>解决方案:在使用fs模块操作文件时,直接提供完整的路径,不要提供.&#x2F;或..&#x2F;开头的相对路径,从而防止路径动态拼接的问题。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(__dirname + <span class="string">&#x27;/files/1.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, datastr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取文件失败&#x27;</span> + err.<span class="property">message</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取文件成功&#x27;</span> + datastr);</span><br><span class="line">&#125;)fs.<span class="title function_">readFile</span>(__dirname + <span class="string">&#x27;/files/1.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, datastr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取文件失败&#x27;</span> + err.<span class="property">message</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取文件成功&#x27;</span> + datastr);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="3-path-路径模块"><a href="#3-path-路径模块" class="headerlink" title="3. path 路径模块"></a><strong>3. path 路径模块</strong></h1><h2 id="3-1什么是path-路径模块"><a href="#3-1什么是path-路径模块" class="headerlink" title="3.1什么是path 路径模块"></a><strong>3.1什么是path 路径模块</strong></h2><p><strong>path模块是 Node.js 官方提供的、用来处理路径的模块。它提供了一系列的方法和属性,用来满足用户对路径的处理需求。</strong></p><p><strong>例如:</strong></p><p>**path.join0方法,用来将多个路径片段拼接成一个完整的路径字符串. **</p><p><strong>path.basename0 方法,用来从路径字符串中,将文件名解析出来</strong></p><p><strong>如果要在JavaScript代码中,使用path模块来处理路径,则需要使用如下的方式先导入它:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="3-2-路径拼接"><a href="#3-2-路径拼接" class="headerlink" title="3.2 路径拼接"></a>3.2 路径拼接</h2><p><strong>1.path.join() 的语法格式</strong></p><p><strong>使用path.join0方法,可以把多个路径片段拼接为完整的路径字符串,语法格式如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.<span class="title function_">join</span>([...paths])</span><br></pre></td></tr></table></figure><p><strong>参数解读:</strong></p><p><strong>…paths<string> 路径片段的序列</strong></p><p><strong>返回值: <string></strong></p><p><strong>2. path.join()的代码示例</strong></p><p><strong>使用path.join0方法,可以把多个路径片段拼接为完整的路径字符串:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pathStr = path.<span class="title function_">join</span>(<span class="string">&#x27;/a&#x27;</span>, <span class="string">&#x27;/b/c&#x27;</span>, <span class="string">&#x27;../&#x27;</span>,<span class="string">&#x27;./d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pathStr) <span class="comment">// 输 \a\b\d\e</span></span><br><span class="line"><span class="keyword">const</span> pathStr2 path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;./files/1.txt&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pathStr2) <span class="comment">// 输出 当前文件所处目录\files\1.txt</span></span><br></pre></td></tr></table></figure><p><strong>注意:今后凡是涉及到路径拼接的操作,都要使用path.join0方法进行处理。不要直接使用+进行字符串的拼接。</strong></p><h2 id="3-3获取路径中的文件名"><a href="#3-3获取路径中的文件名" class="headerlink" title="3.3获取路径中的文件名"></a><strong>3.3获取路径中的文件名</strong></h2><p><strong>1. path.basename()的语法格式</strong></p><p><strong>使用 path.basename0方法,可以获取路径中的最后一部分,经常通过这个方法获取路径中的文件名,语法格式如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.<span class="title function_">basename</span>(path[, ext])</span><br></pre></td></tr></table></figure><p><strong>参数解读:</strong></p><p>**path <string> 必选参数,表示一个路径的字符串. **</p><p><strong>ext <string>可选参数,表示文件扩展名.</strong></p><p><strong>返回: <string>表示路径中的最后一部分</strong></p><p><strong>2. path.basename() 的代码示例</strong></p><p><strong>使用 path.basename0方法,可以从一个文件路径中,获取到文件的名称部分:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fpath = <span class="string">&#x27;/a/b/c/index.html&#x27;</span> <span class="comment">// 文件的存放路径</span></span><br><span class="line"><span class="keyword">var</span> fullName = path. <span class="title function_">basename</span>(path)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fullName) <span class="comment">// 输 index.html</span></span><br><span class="line"><span class="keyword">var</span> namewithoutExt = path.<span class="title function_">basename</span>(fpath, <span class="string">&#x27;.html&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(namewithoutExt) <span class="comment">// 输 index</span></span><br></pre></td></tr></table></figure><p><strong>3.4 获取路径中的文件扩展名</strong></p><p><strong>1. path.extname()的语法格式</strong></p><p><strong>使用path.extname()方法,可以获取路径中的扩展名部分,语法格式如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.<span class="title function_">extname</span>(path)</span><br></pre></td></tr></table></figure><p><strong>参数解读:</strong></p><p><strong>path <string>必选参数,表示一个路径的字符串.</strong></p><p><strong>返回: <string>返回得到的扩展名字符串</strong></p><p><strong>2. path.extname() 的代码示例</strong></p><p><strong>使用path.extname()方法,可以获取路径中的扩展名部分:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fpath = <span class="string">&#x27;/a/b/c/index.html&#x27;</span> <span class="comment">// 路径字符串</span></span><br><span class="line"><span class="keyword">const</span> fext = path.<span class="title function_">extname</span>(fpath)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fext) <span class="comment">// 输.html</span></span><br></pre></td></tr></table></figure><h2 id="3-5综合案例-时钟案例"><a href="#3-5综合案例-时钟案例" class="headerlink" title="3.5综合案例-时钟案例"></a><strong>3.5综合案例-时钟案例</strong></h2><p><strong>3.步骤1-导入需要的模块并创建正则表达式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.1 导入 fs文件系统模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="comment">//1.2导入 path路径处理模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="comment">//1.3匹配&lt;style&gt;&lt;/style&gt;标签的正则</span></span><br><span class="line"><span class="comment">//其中\s表示空白字符; \S表示非空白字符; *表示匹配任意次</span></span><br><span class="line"><span class="keyword">const</span> regStyle = <span class="regexp">/&lt;style&gt;[\s\S]*&lt;\/style&gt;/</span></span><br><span class="line"><span class="comment">//1.4 匹配&lt;script&gt;&lt;/script&gt;标签的正则</span></span><br><span class="line"><span class="keyword">const</span> regScript = <span class="regexp">/&lt;script&gt;[\s\S]*&lt;\/script&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3.步骤2-使用fs模块读取需要被处理的html文件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.1读取需要被处理的HTML文件</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;../素才/index.html&#x27;</span>), <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, dataStr</span>) =&gt;</span>&#123;</span><br><span class="line"> <span class="comment">//2.2 读取HTML文件失败</span></span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取HTML文件失!&#x27;</span> + err.<span class="property">message</span>)</span><br><span class="line"> <span class="comment">// 2.3 读取HTML文件成功后,调用对应的方法,拆解出css.js 和html文件</span></span><br><span class="line">    <span class="title function_">resolveCSS</span>(dataStr)</span><br><span class="line">    <span class="title function_">resolveJS</span>(dataStr)</span><br><span class="line">    <span class="title function_">resolveHTML</span>(dataStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>3.步骤3-自定义resolveCSS方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.1处理CSS样式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolveCSS</span>(<span class="params">htmlStr</span>)&#123;</span><br><span class="line"><span class="comment">//3.2使用正则提取页面中的&lt;style&gt;&lt;/style&gt;标签</span></span><br><span class="line"> <span class="keyword">const</span> r1 regStyle.<span class="title function_">exec</span>(htmlStr)</span><br><span class="line"><span class="comment">//3.3将提取出来的样式字符串,做进一步的处理</span></span><br><span class="line"> <span class="keyword">const</span> newCSS = r1[<span class="number">0</span>].<span class="title function_">replace</span>(<span class="string">&#x27;&lt;style&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>).<span class="title function_">replace</span>(<span class="string">&#x27;&lt;/style&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">// 3.4将提取出来的CSS样式,写入到index.css文件中</span></span><br><span class="line"> fs.<span class="title function_">writeFile</span>(path.<span class="title function_">join</span>(dirname, <span class="string">&#x27;./clock/index.css&#x27;</span>), newCSS, <span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (err) </span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入 CSS 样式失!&#x27;</span>+ err.<span class="property">message</span>)</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入CSS 样式成功!&#x27;</span>)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.步骤4-自定义resolveJS方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.1处理js脚本</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolveJS</span>(<span class="params">htmlStr</span>)&#123;</span><br><span class="line"><span class="comment">//4.2使用正则提取页面中的&lt;script&gt;&lt;/script&gt;标签</span></span><br><span class="line"> <span class="keyword">const</span> r2 =regScript.<span class="title function_">exec</span>(htmlStr)</span><br><span class="line"><span class="comment">//4.3将提取出来的脚本字符串,做进一步的处理</span></span><br><span class="line"> <span class="keyword">const</span> newJS = r2[<span class="number">0</span>].<span class="title function_">replace</span>(<span class="string">&#x27;&lt;script&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>).<span class="title function_">replace</span>(<span class="string">&#x27;&lt;/script&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">//4.4将提取出来的js脚本,写入到index.js文件中</span></span><br><span class="line"> fs.<span class="title function_">writeFile</span>(path.<span class="title function_">join</span>(_dirname, <span class="string">&#x27;./clock/index.js&#x27;</span>), newJS, <span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入 JavaScript脚本 失败!&#x27;</span>+ err.<span class="property">message</span>)</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;写入JS 脚本成功!&#x27;)</span></span><br><span class="line"><span class="string">                 &#125;)</span></span><br><span class="line"><span class="string"> &#125;</span></span><br></pre></td></tr></table></figure><p><strong>3.步骤5-自定义resolveHTML方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.处理html文件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolveHTML</span>(<span class="params">htmlStr</span>)&#123;</span><br><span class="line"><span class="comment">//5.1使用字符事的replace方法,把内嵌的&lt;style&gt;和&lt;script&gt;标签,替换为外联的&lt;link&gt;和&lt;script&gt;标签</span></span><br><span class="line"> <span class="keyword">const</span> newHTML htmlStr</span><br><span class="line"> .<span class="title function_">replace</span>(regStyle, <span class="string">&#x27;&lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;/&gt;&#x27;</span>)</span><br><span class="line">    .<span class="title function_">replace</span>(regScript, <span class="string">&#x27;&lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;&#x27;</span>)</span><br><span class="line"> <span class="comment">//5.2将替换完成之后的html代码,写入到index.html文件中</span></span><br><span class="line">  fs.<span class="title function_">writeFile</span>(path.<span class="title function_">join</span>(dirname, <span class="string">&#x27;./clock/index.html&#x27;</span>), newHTML, <span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入HTML文件失败!&#x27;</span>+ err.<span class="property">message</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入HTML页面成功! &#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.案例的两个注意点</strong></p><p><strong>① fs.writeFile0方法只能用来创建文件,不能用来创建路径</strong></p><p><strong>② 重复调用fs.writeFile0 写入同一个文件,新写入的内容会覆盖之前的旧内容</strong></p><h1 id="4-http模块"><a href="#4-http模块" class="headerlink" title="4. http模块"></a><strong>4. http模块</strong></h1><h2 id="4-1-什么是http模块"><a href="#4-1-什么是http模块" class="headerlink" title="4.1 什么是http模块"></a><strong>4.1 什么是http模块</strong></h2><p><strong>回顾:什么是客户端、什么是服务器?</strong></p><p><strong>在网络节点中,负责消费资源的电脑,叫做客户端;</strong></p><p><strong>负责对外提供网络资源的电脑,叫做服务器。</strong></p><p><strong>http 模块是Node.js官方提供的、用来创建web服务器的模块。通过http模块提供的http.createServer()方法,就能方便的把一台普通的电脑,变成一台Web服务器,从而对外提供Web资源服务。</strong></p><p><strong>如果要希望使用http模块创建Web服务器,则需要先导入它:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="4-2进一步理解http模块的作用"><a href="#4-2进一步理解http模块的作用" class="headerlink" title="4.2进一步理解http模块的作用"></a><strong>4.2进一步理解http模块的作用</strong></h2><p><strong>服务器和普通电脑的区别在于,服务器上安装了web服务器软件,例如: IIS,Apache等。通过安装这些服务器软件,就能把一台普通的电脑变成一台web服务器。</strong></p><p><strong>在Node.js 中,我们不需要使用IS, Apache等这些第三方web服务器软件。因为我们可以基于Node.js提供的http模块,通过几行简单的代码,“就能轻松的手写一个服务器软件,从而对外提供web服务。</strong></p><h2 id="4-3服务器相关的概念"><a href="#4-3服务器相关的概念" class="headerlink" title="4.3服务器相关的概念"></a><strong>4.3服务器相关的概念</strong></h2><p><strong>1. IP 地址IP地址就是互联网上每台计算机的唯一地址,因此IP地址具有唯一性。如果把“个人电脑”比作“一台电话”,那么”IP地址”就相当于“电话号码”,只有在知道对方IP地址的前提下,才能与对应的电脑之间进行数据通信。</strong></p><p><strong>IP地址的格式:通常用“点分十进制”表示成(a.b.c.d)的形式,其中,a,b,c,d都是0~255之间的十进制整数。例如:用点分十进表示的IP地址(192.168.1.1)</strong></p><p><strong>注意:</strong></p><p><strong>①互联网中每台Web服务器,都有自己的IP地址,例如:大家可以在Windows的终端中运行ping <a href="http://www.baidu.com命令,即可查看到百度服务器的ip地址./">www.baidu.com命令,即可查看到百度服务器的IP地址。</a></strong></p><p><strong>②在开发期间,自己的电脑既是一台服务器,也是一个客户端,为了方便测试,可以在自己的浏览器中输入127.0.0.1这个IP地址,就能把自己的电脑当做一台服务器进行访问了。</strong></p><p><strong>2.域名和域名服务器</strong></p><p><strong>尽管IP地址能够唯一地标记网络上的计算机,但IP地址是一长串数字,不直观,而且不便于记忆,于是人们又发明了另一套字符型的地址方案,即所谓的域名(Domain Name)地址。</strong></p><p><strong>IP地址和域名是–对应的关系,这份对应关系存放在一种叫做域名服务器(DNS, Domain name server)的电脑中。使用者只需通过好记的域名访问对应的服务器即可,对应的转换工作由域名服务器实现。因此,域名服务器就是提供IP地址和域名之间的转换服务的服务器。</strong></p><p><strong>注意:</strong></p><p><strong>①单纯使用IP地址,互联网中的电脑也能够正常工作。但是有了域名的加持,能让互联网的世界变得更加方便。</strong></p><p><strong>②在开发测试期间, 127.0.0.1 对应的域名是 localhost,它们都代表我们自己的这台电脑,在使用效果上没有任何区别。</strong></p><p><strong>3.端口号</strong></p><p><strong>计算机中的端口号,就好像是现实生活中的门牌号一样。通过门牌号,外卖小哥可以在整栋大楼众多的房间中,准确把外卖送到你的手中。</strong></p><p><strong>同样的道理,在一台电脑中,可以运行成百上干个web服务。每个web服务都对应一个唯一的端口号。客户端发送过来的网络请求,通过端口号,可以被准确地交给对应的web服务进行处理。</strong></p><p><strong>注意:</strong></p><p><strong>①每个端口号不能同时被多个web服务占用。</strong></p><p><strong>②在实际应用中,URL中的80端口可以被省略。</strong></p><p><strong>1.创建web服务器的基本步骤</strong></p><p><strong>① 导入http模块</strong></p><p><strong>②创建web服务器实例</strong></p><p><strong>③为服务器实例绑定request事件,监听客户端的请求</strong></p><p><strong>④启动服务器</strong></p><p><strong>4.4 创建最基本的web服务器</strong></p><p><strong>2.步骤3-为服务器实例绑定request事件</strong></p><p><strong>为服务器实例绑定request事件,即可监听客户端发送过来的网络请求</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//使用服务器实例的.on()方法,为服务器绑定一个request事件</span><br><span class="line"> server.on(&#x27;request&#x27;. (req. res) =&gt;&#123;</span><br><span class="line"> //只要有客户端来请求我们自己的服务器,就会触发request事件,从而调用这个事件处理函数</span><br><span class="line"> console.log(&#x27;Someone visit our web server&#x27;)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p><strong>2.步骤4-启动服务器</strong></p><p><strong>调用服务器实例的.listen0方法,即可启动当前的web服务器实例:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用 server.listen(端口号, cb回调)方法,即可启动web服务器</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">80</span>, <span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;http server running at http://127.0.0.1&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>3. req请求对象只要服务器接收到了客户端的请求,就会调用通过server.on0为服务器绑定的request事件处理函数。</strong></p><p><strong>如果想在事件处理函数中,访问与客户端相关的数据或属性,可以使用如下的方式:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>. (req) =&gt;&#123;</span><br><span class="line">    <span class="comment">//req 是请求对象,它包合了与客户端相关的数据和属性,例如:</span></span><br><span class="line">    <span class="comment">// req.url是客户端请求的URL地址</span></span><br><span class="line">    <span class="comment">// req.method是客户的method请求类型</span></span><br><span class="line">    <span class="keyword">const</span> str = <span class="string">&quot;Your request url is $(req.url), and request method is $&#123;req.method&#125;</span></span><br><span class="line"><span class="string">    console.log(str)</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure><p><strong>4. res 响应对象在服务器的request事件处理函数中,如果想访问与服务器相关的数据或属性,可以使用如下的方式:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span>&#123;</span><br><span class="line"> <span class="comment">// res 是响应对象,它包含了与服务器相关的数据和属性,例如:</span></span><br><span class="line"> <span class="comment">//要发送到客户端的字符串</span></span><br><span class="line">    <span class="keyword">const</span> str= <span class="string">&#x27;Your request url is $&#123;req.url&#125;, and request method is $&#123;req.method&#125;`</span></span><br><span class="line"><span class="string">    // res.end()方法的作用:</span></span><br><span class="line"><span class="string">    //向客户端发送指定的内容,并结束这次请求的处理过程</span></span><br><span class="line"><span class="string">    res.end(str)</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure><p><strong>5.解决中文乱码问题当调用res.end0方法,向客户端发送中文内容的时候,会出现乱码问题,此时,需要手动设置内容的编码格式:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//发送的内容包含中文</span></span><br><span class="line">    <span class="keyword">const</span> str=<span class="string">`您请求的ur1地址是<span class="subst">$&#123;req.url&#125;</span>,请求的method 类型是 <span class="subst">$&#123;req.method&#125;</span>`</span></span><br><span class="line">    <span class="comment">//为了防止中文显示乱码的问题,需要设置响应头Content-Type的值为text/html; charset=utf-8</span></span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html; charset=utf-8&#x27;</span>)</span><br><span class="line">    <span class="comment">//把包含中文的内容,响应给客户端</span></span><br><span class="line">    res.<span class="title function_">end</span>(str)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="4-5-根据不同的url响应不同的html内容"><a href="#4-5-根据不同的url响应不同的html内容" class="headerlink" title="4.5 根据不同的url响应不同的html内容"></a><strong>4.5 根据不同的url响应不同的html内容</strong></h2><p><strong>1.核心实现步骤</strong></p><p><strong>①获取请求的url地址</strong></p><p><strong>②设置默认的响应内容为404 Not found</strong></p><p><strong>③判断用户请求的是否为&#x2F;或&#x2F;index.html首页</strong></p><p><strong>④判断用户请求的是否为&#x2F;about.html关于页面</strong></p><p><strong>⑤设置Content-Type 响应头,防止中文乱码</strong></p><p><strong>6使用res.end()把内容响应给客户端</strong></p><p><strong>2.动态响应内容</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> url=req.<span class="property">url</span></span><br><span class="line">   <span class="comment">// 1.获取请求的url地址</span></span><br><span class="line">    <span class="keyword">let</span> content<span class="string">&#x27;&lt;h1&gt;404 Not found!&lt;/h1&gt;&#x27;</span></span><br><span class="line">    <span class="comment">// 2. 设置认的内容为404 Not found</span></span><br><span class="line">    <span class="keyword">if</span> (url ===<span class="string">&#x27;/&#x27;</span> || url ===<span class="string">&#x27;/index.html&#x27;</span>)&#123;</span><br><span class="line">      content =<span class="string">&#x27;&lt;h1&gt;首页&lt;/h1&gt;</span></span><br><span class="line"><span class="string">     //3.用户请求的是首页</span></span><br><span class="line"><span class="string">    &#125;else if (url ===&#x27;</span>/about.<span class="property">html</span><span class="string">&#x27;) &#123;</span></span><br><span class="line"><span class="string">        content = &#x27;</span>&lt;h1&gt;关于页&lt;/h1&gt;<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">   //4.用户请求的是关于页面</span></span><br><span class="line"><span class="string">    res.setHeader(&#x27;</span><span class="title class_">Content</span>-<span class="title class_">Type</span><span class="string">&#x27;, &#x27;</span>text/html; charset=utf-<span class="number">8</span><span class="string">&#x27;) </span></span><br><span class="line"><span class="string">    // 5. 设置Content-Type 响应头,防止中文乱研</span></span><br><span class="line"><span class="string">    res.end(content)</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">    //6.把内容发送给客户端</span></span><br></pre></td></tr></table></figure><p><strong>1.核心思路把文件的实际存放路径,作为每个资源的请求url地址。</strong></p><p><strong>2.实现步骤</strong></p><p><strong>① 导入需要的模块</strong></p><p><strong>②创建基本的web服务器</strong></p><p><strong>③将资源的请求url地址映射为文件的存放路径</strong></p><p><strong>④读取文件内容并响应给客户端</strong></p><p><strong>⑤优化资源的请求路径</strong></p><p><strong>3.步骤1-导入需要的模块</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.1 导入 http模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="comment">//1.2 导入 fs文件系统模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="comment">// 1.3 导入path路径处理模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>3.步骤2-创建基本的web服务器</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.1创建web服务器</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>()</span><br><span class="line"><span class="comment">// 2.2 监听web服务器的request事件</span></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;&#125;)</span><br><span class="line"><span class="comment">//2.3 启动web服务器</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">80</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server listen at http://127.0.0.1&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>3.步骤3-将资源的请求url地址映射为文件的存放路径</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.1获取到客户端请求的url地址</span></span><br><span class="line"><span class="keyword">const</span> url req.<span class="property">url</span></span><br><span class="line"><span class="comment">// 3.2把请求的url地址,映射为本地文件的存放路径</span></span><br><span class="line"><span class="keyword">const</span> fpath = path.<span class="title function_">join</span>(__dirname, url)</span><br></pre></td></tr></table></figure><p><strong>3.步骤4-读取文件的内容并响应给客户端</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.1根据“映射“过来的文件路径读取文件</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(fpath, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, dataStr</span>) =&gt;</span>&#123;</span><br><span class="line"> <span class="comment">// 4.2读取文件失败后,向客户端响应同定的“错误消息”</span></span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> res.<span class="title function_">end</span>(<span class="string">&#x27;404 Not fount. &#x27;</span>)</span><br><span class="line">  <span class="comment">// 4.3 读取文件成功后,将&quot;读取成功的内容”响应给客户端</span></span><br><span class="line">    res.<span class="title function_">end</span>(dataStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="1-模块化的基本概念"><a href="#1-模块化的基本概念" class="headerlink" title="1.模块化的基本概念"></a><strong>1.模块化的基本概念</strong></h2><h3 id="1-1什么是模块化"><a href="#1-1什么是模块化" class="headerlink" title="1.1什么是模块化"></a><strong>1.1什么是模块化</strong></h3><p><strong>模块化是指解决一个复杂问题时,自顶向下逐层把系统划分成若干模块的过程。对于整个系统来说,模块是可组合、分解和更换的单元。</strong></p><p><strong>2.编程领域中的模块化</strong></p><p><strong>编程领域中的模块化,就是遵守固定的规则,把一个大文件拆成独立并互相依赖的多个小模块。</strong></p><p><strong>把代码进行模块化拆分的好处:</strong></p><p><strong>①提高了代码的复用性</strong></p><p><strong>②提高了代码的可维护性</strong></p><p><strong>③可以实现按需加载</strong></p><p><strong>1.2模块化规范</strong></p><p><strong>模块化规范就是对代码进行模块化的拆分与组合时,需要遵守的那些规则。</strong></p><p><strong>例如:</strong></p><p><strong>使用什么样的语法格式来引用模块</strong></p><p><strong>在模块中使用什么样的语法格式向外暴露成员</strong></p><p><strong>模块化规范的好处:大家都遵守同样的模块化规范写代码,降低了沟通的成本,极大方便了各个模块之间的相互调用,利人利己。</strong></p><h2 id="2-Node-js中的模块化"><a href="#2-Node-js中的模块化" class="headerlink" title="2. Node.js中的模块化"></a><strong>2. Node.js中的模块化</strong></h2><h3 id="2-1-Node-js-中模块的分类"><a href="#2-1-Node-js-中模块的分类" class="headerlink" title="2.1 Node.js 中模块的分类"></a><strong>2.1 Node.js 中模块的分类</strong></h3><p><strong>Node.js中根据模块来源的不同,将模块分为了3大类,分别是:.</strong></p><p><strong>内置模块(内置模块是由Node.js官方提供的,例如fs, path, http等).</strong></p><p><strong>自定义模块(用户创建的每个.js文件,都是自定义模块)·</strong></p><p><strong>第三方模块(由第三方开发出来的模块,并非官方提供的内置模块,也不是用户创建的自定义模块,使用前需要先下载)</strong></p><h3 id="2-2加载模块"><a href="#2-2加载模块" class="headerlink" title="2.2加载模块"></a><strong>2.2加载模块</strong></h3><p><strong>使用强大的require0方法,可以加载需要的内置模块、用户自定义模块、第三方模块进行使用。例如:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.加载内置的fs模块</span></span><br><span class="line"><span class="keyword">const</span> fs = requireC<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="comment">// 2.加载用户的自定义模块</span></span><br><span class="line"><span class="keyword">const</span> custom = <span class="built_in">require</span>(<span class="string">&#x27;./custom.js&#x27;</span>)</span><br><span class="line"><span class="comment">// 3.加载第三方模块</span></span><br><span class="line"><span class="keyword">const</span> moment =<span class="built_in">require</span>(<span class="string">&#x27;moment&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>注意:使用requireO方法加载其它模块时,会执行被加载模块中的代码。</strong></p><h3 id="2-3-Node-js-中的模块作用域"><a href="#2-3-Node-js-中的模块作用域" class="headerlink" title="2.3 Node.js 中的模块作用域"></a><strong>2.3 Node.js 中的模块作用域</strong></h3><p><strong>1.什么是模块作用域和函数作用域类似,在自定义模块中定义的变量、方法等成员,只能在当前模块内被访问,这种模块级别的访问限制,叫做模块作用域。</strong></p><p><strong>2.模块作用域的好处</strong></p><p><strong>防止了全局变量污染的问题</strong></p><h3 id="2-4-向外共享模块作用域中的成员"><a href="#2-4-向外共享模块作用域中的成员" class="headerlink" title="2.4 向外共享模块作用域中的成员"></a><strong>2.4 向外共享模块作用域中的成员</strong></h3><p><strong>1. module 对象</strong></p><p><strong>在每个.js自定义模块中都有一个module对象,它里面存储了和当前模块有关的信息,打印如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Module</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;D:\\node&#x27;</span>,</span><br><span class="line">  <span class="attr">exports</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">filename</span>: <span class="string">&#x27;D:\\node\\17演示module对象.js&#x27;</span>,</span><br><span class="line">  <span class="attr">loaded</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">children</span>: [],</span><br><span class="line">  <span class="attr">paths</span>: [ <span class="string">&#x27;D:\\node\\node_modules&#x27;</span>, <span class="string">&#x27;D:\\node_modules&#x27;</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. module.exports 对象</strong></p><p><strong>在自定义模块中,可以使用module.exports对象,将模块内的成员共享出去,供外界使用。</strong></p><p><strong>外界用require0方法导入自定义模块时,得到的就是module.exports所指向的对象。</strong></p><p><strong>3.共享成员时的注意点</strong></p><p><strong>使用require0方法导入模块时,导入的结果,永远以module.exports指向的对象为准。</strong></p><p><strong>4.exports 对象</strong></p><p><strong>由于module.exports单词写起来比较复杂,为了简化向外共享成员的代码,Node提供了exports对象。默认情况下, exports 和module.exports指向同一个对象。最终共享的结果,还是以module.exports指向的对象为准。</strong></p><p><strong>4. exports 和 module.exports 的使用误区</strong></p><p><strong>时刻谨记, requireO模块时,得到的永远是module.exports指向的对象:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">username</span> =<span class="string">&#x27;zs&#x27;</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;<span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span>, <span class="attr">age</span>: <span class="number">22</span>&#125;  </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">username</span> = <span class="string">&#x27;zs&#x27;</span></span><br><span class="line"><span class="built_in">exports</span> = &#123;</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;<span class="attr">username</span>: <span class="string">&#x27;zs&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">username</span>= <span class="string">&#x27;zs&#x27;</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">gender</span> = <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#123; <span class="attr">username</span>: <span class="string">&#x27;zs&#x27;</span>, <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span> = &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="built_in">exports</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">age</span> = <span class="string">&#x27;22&#x27;</span></span><br><span class="line">&#123; <span class="attr">username</span>: <span class="string">&#x27;zs&#x27;</span>, <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span>, <span class="attr">age</span>: <span class="string">&#x27;22&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:为了防止混乱,建议大家不要在同一个模块中同时使用 exports 和module.exports</strong></p><h1 id="3-npm与包"><a href="#3-npm与包" class="headerlink" title="3. npm与包"></a><strong>3. npm与包</strong></h1><h2 id="3-1包"><a href="#3-1包" class="headerlink" title="3.1包"></a><strong>3.1包</strong></h2><p><strong>1.什么是包</strong></p><p><strong>Node.js中的第三方模块又叫做包。</strong></p><p><strong>就像电脑和计算机指的是相同的东西,第三方模块和包指的是同一个概念,只不过叫法不同。</strong></p><p><strong>2.包的来源</strong></p><p><strong>不同于Node.js中的内置模块与自定义模块,包是由第三方个人或团队开发出来的,免费供所有人使用。</strong></p><p><strong>注意: Node.js中的包都是免费且开源的,不需要付费即可免费下载使用。</strong></p><p><strong>3.为什么需要包</strong></p><p><strong>由于Node.js的内置模块仅提供了一些底层的API,导致在基于内置模块进行项目开发的时,效率很低。</strong></p><p><strong>包是基于内置模块封装出来的,提供了更高级、更方便的API,极大的提高了开发效率。</strong></p><p><strong>包和内置模块之间的关系,类似于jQuery和浏览器内置API之间的关系。</strong></p><p><strong>4.从哪里下载包</strong></p><p><strong>国外有一家IT公司,叫做npm, Inc.这家公司旗下有一个非常著名的网站: <a href="https://www.npmjs.com/,%E5%AE%83%E6%98%AF%E5%85%A8%E7%90%83%E6%9C%80%E5%A4%A7%E7%9A%84%E5%8C%85%E5%85%B1%E4%BA%AB%E5%B9%B3%E5%8F%B0,%E4%BD%A0%E5%8F%AF%E4%BB%A5%E4%BB%8E%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99%E4%B8%8A%E6%90%9C%E7%B4%A2%E5%88%B0%E4%BB%BB%E4%BD%95%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9A%84%E5%8C%85,%E5%8F%AA%E8%A6%81%E4%BD%A0%E6%9C%89%E8%B6%B3%E5%A4%9F%E7%9A%84%E8%80%90%E5%BF%83">https://www.npmjs.com/,它是全球最大的包共享平台,你可以从这个网站上搜索到任何你需要的包,只要你有足够的耐心</a>!</strong></p><p><strong>到目前位置,全球约1100 多万的开发人员,通过这个包共享平台,开发并共享了超过120多万个包 供我们使用。</strong></p><p><strong>npm, Inc. 公司提供了一个地址为hps:&#x2F;&#x2F;registry.npmjs.org&#x2F;的服务器,来对外共享所有的包,我们可以从这个服务器上下载自己所需要的包。</strong></p><p><strong>注意:</strong></p><p><strong>.从<a href="https://www.npmjs.com/%E7%BD%91%E7%AB%99%E4%B8%8A%E6%90%9C%E7%B4%A2%E8%87%AA%E5%B7%B1%E6%89%80%E9%9C%80%E8%A6%81%E7%9A%84%E5%8C%85">https://www.npmjs.com/网站上搜索自己所需要的包</a></strong></p><p><strong>.从<a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a> 服务器上下载自己需要的包</strong></p><p><strong>5.如何下载包</strong></p><p><strong>npm, Inc.公司提供了一个包管理工具,我们可以使用这个包管理T具,从<a href="https://registry.npmjs.org/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8A%8A%E9%9C%80%E8%A6%81%E7%9A%84%E5%8C%85%E4%B8%8B%E8%BD%BD%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BD%BF%E7%94%A8%E3%80%82">https://registry.npmjs.org/服务器把需要的包下载到本地使用。</a></strong></p><p><strong>这个包管理工具的名字叫做Node Package Manager(简称npm包管理工具),这个包管理T具随着Node.js的安装包一起被安装到了用户的电脑上。</strong></p><h2 id="3-2-npm-初体验"><a href="#3-2-npm-初体验" class="headerlink" title="3.2 npm 初体验"></a><strong>3.2 npm 初体验</strong></h2><p><strong>1.格式化时间的传统做法</strong></p><p><strong>①创建格式化时间的自定义模块</strong></p><p><strong>②定义格式化时间的方法</strong></p><p><strong>③创建补零函数</strong></p><p><strong>④从自定义模块中导出格式化时间的函数</strong></p><p><strong>⑤导入格式化时间的自定义模块</strong></p><p><strong>6调用格式化时间的函数</strong></p><p><strong>2.格式化时间的高级做法</strong></p><p><strong>①使用npm包管理T具,在项目中安装格式化时间的包moment</strong></p><p><strong>②使用requireO导入格式化时间的包</strong></p><p><strong>③参考moment的官方API文档对时间进行格式化</strong></p><p><strong>3.在项目中安装包的命令</strong></p><p><strong>如果想在项目中安装指定名称的包,需要运行如下的命令:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install 包的完整名称</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i 完整的包名称</span><br></pre></td></tr></table></figure><p><strong>4.初次装包后多了哪些文件</strong></p><p><strong>初次装包完成后,在项目文件夹下多一个叫做node_modules的文件夹和package-lock.json的配置文件。</strong></p><p><strong>其中:</strong></p><p><strong>node_modules文件夹用来存放所有已安装到项目中的包。 requireO导入第三方包时,就是从这个目录中查找并加载包。</strong></p><p><strong>package-lock.json配置文件用来记录 node_modules 目录下的每一个包的下载信息,例如包的名字、版本号、下载地址等。</strong></p><p><strong>注意:程序员不要手动修改node_modules 或 package-lock.json文件中的任何代码,npm包管理工具会自动维护它们。</strong></p><p><strong>5.安装指定版本的包默认情况下,使用npm install 命令安装包的时候,会自动安装最新版本的包。如果需要安装指定版本的包,可以在包名之后,通过@符号指定具体的版本,例如:</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i moment@<span class="number">2</span>.<span class="number">22</span>.<span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>6.包的语义化版本规范</strong></p><p><strong>包的版本号是以“点分十进制”形式进行定义的,总共有三位数字,例如2.24.0其中每一位数字所代表的的含义如下:</strong></p><p><strong>第1位数字:大版本</strong></p><p><strong>第2位数字:功能版本</strong></p><p><strong>第3位数字: Bug修复版本</strong></p><p><strong>版本号提升的规则:只要前面的版本号增长了,则后面的版本号归零。</strong></p><p><strong>3.3包管理配置文件</strong></p><p><strong>npm规定,在项目根目录中,必须提供一个叫做 package.json的包管理配置文件。用来记录与项目有关的一些配置信息。例如:</strong></p><p><strong>.项目的名称、版本号、描述等.</strong></p><p><strong>项目中都用到了哪些包.</strong></p><p><strong>哪些包只在开发期间会用到</strong></p><p><strong>.那些包在开发和部署时都需要用到</strong></p><p><strong>整个项目的体积是30.4M</strong></p><p><strong>第三方包的体积是 28.8M</strong></p><p><strong>项目源代码的体积1.6M</strong></p><p><strong>遇到的问题:第三方包的体积过大,不方便团队成员之间共享项目源代码。</strong></p><p><strong>解决方案:共享时剔除node_modules</strong></p><p><strong>2.如何记录项目中安装了哪些包</strong></p><p><strong>在项目根目录中,创建一个叫做package.json的配置文件,即可用来记录项目中安装了哪些包。从而方便剔除node_modules 目录之后,在团队成员之间共享项目的源代码。</strong></p><p><strong>注意:今后在项目开发中,一定要把node_modules文件夹,添加到.gitignore忽略文件中。</strong></p><p><strong>3. 快速创建 package.jsonnpm包管理工具提供了一个快捷命令,可以在执行命令时所处的目录中,快速创建 package.json这个包管理配置文件:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作用:在执行命令所处的目录中,快速新建package.json文件</span></span><br><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p><strong>注意:①上述命令只能在英文的目录下成功运行!所以,项目文件夹的名称一定要使用英文命名,不要使用中文,不能出现空格。</strong></p><p><strong>②运行npm install 命令安装包的时候, npm包管理工具会自动把包的名称和版本号,记录到package.json中。</strong></p><p><strong>4. dependencies 节点</strong></p><p><strong>package.json文件中,有一个 dependencies 节点,专门用来记录您使用npm install命令安装了哪些包。</strong></p><p><strong>5.一次性安装所有的包当我们拿到一个剔除了node_modules的项目之后,需要先把所有的包下载到项目中,才能将项目运行起来。否则会报类似于下面的错误:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于项目运行依赖于moment这个包,如果没有提前安装好这个包,就会报如下的错误:</span></span><br><span class="line"><span class="title class_">Error</span>: <span class="title class_">Cannot</span> find <span class="variable language_">module</span> <span class="string">&#x27;moment&quot;</span></span><br></pre></td></tr></table></figure><p><strong>5.一次性安装所有的包</strong></p><p><strong>可以运行npm install 命令(或 npm i)一次性安装所有的依赖包:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行npm install 命令时, npm包管理工具会先读取package.json 中的dependencies 节点</span></span><br><span class="line"><span class="comment">//读取到记录的所有依赖包名称和版本号之后,npm包管理工具会把这些包一次性下载到项目中</span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p><strong>6.卸载包</strong></p><p><strong>可以运行npm uninstall 命令,来卸载指定的包:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用npm uninstall 具体的包名 来卸载包</span></span><br><span class="line">npm uninstall moment</span><br></pre></td></tr></table></figure><p><strong>注意: npm uninstall 命令执行成功后,会把卸载的包,自动从package.json的dependencies中移除掉。</strong></p><p><strong>7. devDependencies 节点</strong></p><p><strong>如果某些包只在项目开发阶段会用到,在项目上线之后不会用到,则建议把这些包记录到devDependencies节点中。</strong></p><p><strong>与之对应的,如果某些包在开发和项目上线之后都需要用到,则建议把这些包记录到dependencies节点中。</strong></p><p><strong>您可以使用如下的命令,将包记录到devDependencies节点中:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安装指定的包,并记录到devDependencies 节点中</span></span><br><span class="line">npm i 包名 -D</span><br><span class="line"><span class="comment">//注意:上述命令是简写形式,等价于下面完整的写法:</span></span><br><span class="line">npm install 包名 --save-dev</span><br></pre></td></tr></table></figure><p><strong>3.4 解决下包速度慢的问题</strong></p><p><strong>1.为什么下包速度慢</strong></p><p><strong>在使用npm下包的时候,默认从国外的<a href="https://registry.npmjs.org/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E4%B8%8B%E8%BD%BD,%E6%AD%A4%E6%97%B6,%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BC%A0%E8%BE%93%E9%9C%80%E8%A6%81%E7%BB%8F%E8%BF%87%E6%BC%AB%E9%95%BF%E7%9A%84%E6%B5%B7%E5%BA%95%E5%85%89%E7%BC%86,%E5%9B%A0%E6%AD%A4%E4%B8%8B%E5%8C%85%E9%80%9F%E5%BA%A6%E4%BC%9A%E5%BE%88%E6%85%A2%E3%80%82">https://registry.npmjs.org/服务器进行下载,此时,网络数据的传输需要经过漫长的海底光缆,因此下包速度会很慢。</a></strong></p><p><strong>2.淘宝NPM 镜像服务器</strong></p><p><strong>淘宝在国内搭建了一个服务器,专门把国外官方服务器上的包同步到国内的服务器,然后在国内提供下包的服务。从而极大的提高了下包的速度。</strong></p><p><strong>扩展:镜像(Mirroring)是一种文件存储形式,一个磁盘上的数据在另一个磁盘上存在一个完全相同的副木即为镜像。</strong></p><p><strong>3.切换npm的下包镜像源</strong></p><p><strong>下包的镜像源,指的就是下包的服务器地址。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看当前的下包镜像源</span></span><br><span class="line">npm config get registry</span><br><span class="line"><span class="comment">//将下包的镜像源切换为淘宝镜像源</span></span><br><span class="line">npm config set registry=<span class="attr">https</span>:<span class="comment">//registry.npm.taobao.org/</span></span><br><span class="line"><span class="comment">//检查镜像源是否下载成功</span></span><br><span class="line">npm config get registry</span><br></pre></td></tr></table></figure><p><strong>4. nrm</strong></p><p><strong>为了更方便的切换下包的镜像源,我们可以安装nrm这个小工具,利用nrm提供的终端命令,可以快速查看和切换下包的镜像源。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过npm包管理器,将nrm安装为全局可用的工具</span></span><br><span class="line">npm i nrm -g</span><br><span class="line"><span class="comment">//查看所有可用的镜像源</span></span><br><span class="line">nrm 1s</span><br><span class="line"><span class="comment">//将下包的镜像源切换为taobao镜像</span></span><br><span class="line">nrm use taobao</span><br></pre></td></tr></table></figure><h3 id="3-5包的分类"><a href="#3-5包的分类" class="headerlink" title="3.5包的分类"></a><strong>3.5包的分类</strong></h3><p><strong>使用npm包管理工具下载的包,共分为两大类,分别是:·项目包.全局包</strong></p><p><strong>项目包又分为两类,分别是:.</strong></p><p><strong>开发依赖包(被记录到devDependencies节点中的包,只在开发期间会用到)</strong></p><p><strong>核心依赖包(被记录到dependencies节点中的包,在开发期间和项目上线之后都会用到)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i 包名 -D <span class="comment">//开发依赖包(会被记录到 devDependencies 节点下)&quot;</span></span><br><span class="line">npm i 包名   <span class="comment">//核心依赖包(会被记录到dependencies节点下)</span></span><br></pre></td></tr></table></figure><p><strong>2.全局包</strong></p><p><strong>在执行npm install 命令时,如果提供了-g参数,则会把包安装为全局包。</strong></p><p><strong>全局包会被安装到 C:Usersl用e目录AppDatalRoaming\npmlnode_modules 目录下。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i 包名 -g        <span class="comment">//全局安装指定的包</span></span><br><span class="line">npm uninstall 包名 -g <span class="comment">//载全局安装的包</span></span><br></pre></td></tr></table></figure><p><strong>①只有工具性质的包,才有全局安装的必要性。因为它们提供了好用的终端命令。</strong></p><p><strong>②判断某个包是否需要全局安装后才能使用,可以参考官方提供的使用说明即可。</strong></p><p><strong>3. i5ting_toc</strong></p><p><strong>iSting_toc 是一个可以把md文档转为html页面的小工具,使用步骤如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将i5ting_toc安装为全局包</span></span><br><span class="line">npm install -g i5ting_toc</span><br><span class="line"><span class="comment">//调用i5ting_toc,轻松实现md转html的功能</span></span><br><span class="line">i5ting_toc -f 要转换的md文件路径 -o</span><br></pre></td></tr></table></figure><p><strong>3.6规范的包结构</strong></p><p><strong>在清楚了包的概念、以及如何下载和使用包之后,接下来,我们深入了解一下包的内部结构。</strong></p><p><strong>一个规范的包,它的组成结构,必须符合以下3点要求:</strong></p><p><strong>①包必须以单独的目录而存在</strong></p><p><strong>②包的顶级目录下要必须包含package.json这个包管理配置文件</strong></p><p><strong>③ package.json 中必须包含name, version, main这三个属性,分别代表包的名字、版本号、包的入口。</strong></p><p><strong>注意:以上3点要求是一个规范的包结构必须遵守的格式,关于更多的约束,可以参考如下网址:</strong></p><p><strong><a href="https://yarnpkg.com/zh-Hans/docs/package-json">https://yarnpkg.com/zh-Hans/docs/package-json</a></strong></p><h3 id="3-7开发属于自己的包"><a href="#3-7开发属于自己的包" class="headerlink" title="3.7开发属于自己的包"></a><strong>3.7开发属于自己的包</strong></h3><p><strong>1.需要实现的功能格式化日期</strong></p><p><strong>①格式化日期</strong></p><p><strong>2.转义HTML中的特殊字符</strong></p><p><strong>③还原HTML中的特殊字符</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.导入自己的包</span></span><br><span class="line"><span class="keyword">const</span> itheima = <span class="built_in">require</span>(<span class="string">&#x27;itehima-utils&#x27;</span>)</span><br><span class="line"><span class="comment">//-功能1:格式化日期…</span></span><br><span class="line"><span class="keyword">const</span> dt = itheima.<span class="title function_">dateFormat</span>(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line"><span class="comment">//输出2020-01-20 10:09:45</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dt)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入自己的包</span></span><br><span class="line"><span class="keyword">const</span> itheima= <span class="built_in">require</span>(<span class="string">&#x27;itehima-utils&#x27;</span>)</span><br><span class="line"><span class="comment">//----功能2:转义HTML中的特殊字符</span></span><br><span class="line"><span class="keyword">const</span> htmlStr = <span class="string">&#x27;&lt;h1 style=&quot;color: red; &quot;&gt;你好! &amp;copy; &lt;span&gt;小黄! &lt;/span&gt;&lt;/h1&gt;&#x27;</span></span><br><span class="line"><span class="keyword">const</span> str= itheima.<span class="title function_">htmlEscape</span>(htmlStr)</span><br><span class="line"><span class="comment">// &amp;lt;h1 style=&amp;quot; color: red; &amp;quot;&amp;gt:你好! &amp;amp; copy: &amp;lt; span&amp;gt;小黄! &amp;lt;/span&amp;gt; &amp;lt;/h1&amp;gt;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入自己的包</span></span><br><span class="line"><span class="keyword">const</span> itheima = <span class="built_in">require</span>(<span class="string">&#x27;itehima-utils&#x27;</span>)</span><br><span class="line"><span class="comment">//功能3:还原HTML中的特殊字符</span></span><br><span class="line"><span class="keyword">const</span> rawHTML = itheima.<span class="title function_">htmlUnEscape</span>(str)</span><br><span class="line"><span class="comment">//输出&lt;h1 style=&quot;color: red; &quot;&gt;你好! &amp;copy;&lt;span&gt;小黄! &lt;/span&gt;&lt;/h1&gt;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rawHTML)</span><br></pre></td></tr></table></figure><h3 id="3-7-开发属于自己的包"><a href="#3-7-开发属于自己的包" class="headerlink" title="3.7 开发属于自己的包"></a><strong>3.7 开发属于自己的包</strong></h3><p><strong>2.初始化包的基本结构</strong></p><p><strong>①新建itheima-tools文件夹,作为包的根目录</strong></p><p><strong>②在itheima-tools文件夹中,新建如下三个文件:</strong></p><p><strong>package.json (包管理配置文件)</strong></p><p><strong>index.js (包的入口文件)</strong></p><p><strong>README.md (包的说明文档)</strong></p><p><strong>3. 初始化 package.json</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;itheima-tools&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;提供了格式化时间, HTMLEscape的功能&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;keywords&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;itheima&quot;</span><span class="punctuation">,</span> <span class="string">&quot;dateFormat&quot;</span><span class="punctuation">,</span> <span class="string">&quot;escape&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>关于更多license许可协议相关的内容,可参考<a href="https://www.jianshu.com/p/86251523e898">https://www.jianshu.com/p/86251523e898</a></strong></p><p><strong>4. 在index.js中定义格式化时间的方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式化时间的方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dateFormat</span> (dateStr) &#123; <span class="comment">/*省略其余代码*/</span> &#125;</span><br><span class="line"> <span class="comment">//补零的方法</span></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">padZero</span>(<span class="params">n</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> n &gt; <span class="number">9</span> ? n : <span class="string">&#x27;0&#x27;</span> +n</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="variable language_">module</span>.<span class="property">exports</span> =&#123;</span><br><span class="line">     dateFormat</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>5. 在index.js中定义转义HTML的方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">htmlEscape</span>(<span class="params">htmlStr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> htmlStr.<span class="title function_">replace</span>(<span class="regexp">/&lt;|&gt;|&quot;|&amp;/g</span>, <span class="function">(<span class="params">match</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (match) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&amp;lt;&#x27;</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&amp;gt;&#x27;</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&amp;quot;&#x27;</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&amp;amp;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6. 在index.js中定义还原HTML的方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">htmlUnEscape</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">replace</span>(<span class="regexp">/&amp;lt;|&amp;gt;|&amp;quot;|&amp;amp;/g</span>, <span class="function">(<span class="params">math</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (math) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&amp;lt;&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&amp;gt;&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&amp;quot;&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&amp;amp;&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&amp;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>7.将不同的功能进行模块化拆分</strong></p><p><strong>① 将格式化时间的功能,拆分到src-&gt;dateFormat.js中</strong></p><p><strong>②将处理HTML字符串的功能,拆分到src-&gt; htmlEscape.js中</strong></p><p><strong>③在index.js中,导入两个模块,得到需要向外共享的方法</strong></p><p><strong>④在index.js 中,使用module.exports把对应的方法共享出去</strong></p><p><strong>8.编写包的说明文档</strong></p><p><strong>包根目录中的README.md文件,是包的使用说明文档。通过它,我们可以事先把包的使用说明,以markdown的格式写出来,方便用户参考。</strong></p><p><strong>README文件中具体写什么内容,没有强制性的要求;只要能够清晰地把包的作用、用法、注意事项等描述清楚即可。</strong></p><p><strong>我们所创建的这个包的README.md文档中,会包含以下6项内容:安装方式、导入方式、格式化时间、转义HTML中的特殊字符、还原HTML中的特殊字符、开源协议</strong></p><h3 id="3-8-发布包"><a href="#3-8-发布包" class="headerlink" title="3.8 发布包"></a><strong>3.8 发布包</strong></h3><p><strong>1.注册npm账号</strong></p><p><strong>①访问<a href="https://www.npmjs.com/%E7%BD%91%E7%AB%99,%E7%82%B9%E5%87%BBsign">https://www.npmjs.com/网站,点击sign</a> up按钮,进入注册用户界面</strong></p><p><strong>②填写账号相关的信息: Full Name, Public Email, Username, Password</strong></p><p><strong>③点击Create an Account按钮,注册账号</strong></p><p><strong>2.登录npm账号</strong></p><p><strong>npm账号注册完成后,可以在终端中执行npm login命令,依次输入用户名、密码、邮箱后,即可登录成功。</strong></p><p><strong>3.把包发布到npm上</strong></p><p><strong>将终端切换到包的根目录之后,运行npm publish命令,即可将包发布到npm上(注意:包名不能雷同)。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">C</span>: <span class="title class_">Userslliulongbin</span>(<span class="title class_">Desktoplitheima</span>-utilsl)npm publish</span><br></pre></td></tr></table></figure><p><strong>4.删除已发布的包</strong></p><p><strong>运行npm unpublish 包名–force 命令,即可从npm删除已发布的包。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">C</span>:\<span class="title class_">Users</span>\liulongbin\<span class="title class_">Desktop</span>\itheima-utilsl&gt;npm unpublish itheima-utils --force</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><p><strong>① npm unpublish 命令只能删除72 小时以内发布的包</strong></p><p><strong>② npm unpublish 删除的包,在24 小时内不允许重复发布</strong></p><p><strong>③发布包的时候要慎重,尽量不要往npm上发布没有意义的包</strong></p><h1 id="4-模块的加载机制"><a href="#4-模块的加载机制" class="headerlink" title="4.模块的加载机制"></a><strong>4.模块的加载机制</strong></h1><h2 id="4-1优先从缓存中加载"><a href="#4-1优先从缓存中加载" class="headerlink" title="4.1优先从缓存中加载"></a><strong>4.1优先从缓存中加载</strong></h2><p><strong>模块在第一次加载后会被缓存。这也意味着多次调用require0不会导致模块的代码被执行多次。</strong></p><p><strong>注意:不论是内置模块、用户自定义模块、还是第三方模块,它们都会优先从缓存中加载,从而提高模块的加载效率。</strong></p><h2 id="4-2内置模块的加载机制"><a href="#4-2内置模块的加载机制" class="headerlink" title="4.2内置模块的加载机制"></a><strong>4.2内置模块的加载机制</strong></h2><p><strong>内置模块是由Node.js官方提供的模块,内置模块的加载优先级最高。</strong></p><p><strong>例如, require(‘fs’)始终返回内置的fs模块,即使在node_modules目录下有名字相同的包也叫做fs。</strong></p><h2 id="4-3-自定义模块的加载机制"><a href="#4-3-自定义模块的加载机制" class="headerlink" title="4.3 自定义模块的加载机制"></a><strong>4.3 自定义模块的加载机制</strong></h2><p><strong>使用require0加载自定义模块时,必须指定以.&#x2F;或..&#x2F;开头的路径标识符。在加载自定义模块时,如果没有指定&#x2F;或..&#x2F;这样的路径标识符,则node会把它当作内置模块或第三方模块进行加载。</strong></p><p><strong>同时,在使用requireO导入自定义模块时,如果省略了文件的扩展名,则Node.js会按顺序分别尝试加载以下的文件:</strong></p><p><strong>①按照确切的文件名进行加载</strong></p><p><strong>②补全.js扩展名进行加载</strong></p><p><strong>③补全.json扩展名进行加载</strong></p><p><strong>④补全.node扩展名进行加载</strong></p><p><strong>⑤加载失败,终端报错</strong></p><p><strong>4.4 第三方模块的加载机制</strong></p><p><strong>如果传递给require0的模块标识符不是一个内置模块,也没有以’&#x2F;‘或’.&#x2F;开头,则Node.js会从当前模块的父目录开始,尝试从&#x2F;node_modules文件夹中加载第三方模块。</strong></p><p><strong>例如,假设在’C:AUserslitheimalprojectlfoos’文件里调用了require(‘tools’),则Node.js会按以下顺序查找:</strong></p><p>**①CAUserslitheimalprojectlnode_modulesltgols **</p><p>**② CUserslitheimalnode_modules(tools **</p><p><strong>3.CUsersInode modules)tools</strong></p><p><strong>④C:Inode modulesltools</strong></p><p><strong>4.5目录作为模块</strong></p><p><strong>当把目录作为模块标识符,传递给requireO进行加载的时候,有三种加载方式:</strong></p><p><strong>①在被加载的目录下查找一个叫做package.json的文件,并寻找main属性,作为require0加载的入口</strong></p><p><strong>②如果目录里没有package.json文件,或者main入口不存在或无法解析,则Node.js将会试图加载目录下的index.js文件。</strong></p><p><strong>③如果以上两步都失败了,则Node.js 会在终端打印错误消息,报告模块的缺失: Error: Cannot find module ‘xxx’</strong></p><h1 id="1-初识Express"><a href="#1-初识Express" class="headerlink" title="1. 初识Express"></a><strong>1. 初识Express</strong></h1><h2 id="1-1-Express-简介"><a href="#1-1-Express-简介" class="headerlink" title="1.1 Express 简介"></a><strong>1.1 Express 简介</strong></h2><p><strong>1. 什么是Express</strong></p><p><strong>官方给出的概念:Express是基于Node.js平台,快速、开放、极简的Web开发框架。</strong></p><p><strong>通俗的理解: Express的作用和Node.js内置的http模块类似,是专门用来创建Web服务器的。</strong></p><p><strong>Express 的本质:就是一个npm上的第三方包,提供了快速创建Web服务器的便捷方法。</strong></p><p><strong>Express 中文官网: <a href="http://www.expressjs.com.cn/">http://www.expressjs.com.cn/</a></strong></p><p><strong>2. 进一步理解Express</strong></p><p><strong>思考:不使用Express能否创建Web服务器?</strong></p><p><strong>答案:能,使用Node.js提供的原生http模块即可。</strong></p><p><strong>思考:既生瑜何生亮(有了http内置模块,为什么还有用Express) ?</strong></p><p><strong>答案: http内置模块用起来很复杂,开发效率低:Express是基于内置的http模块进一步封装出来的,能够极大的提高开发效率。</strong></p><p><strong>思考: http内置模块与Express是什么关系?</strong></p><p><strong>答案:类似于浏览器中Web API和jQuery的关系。后者是基于前者进一步封装出来的。</strong></p><p><strong>3. Express 能做什么</strong></p><p><strong>对于前端程序员来说,最常见的两种服务器,分别是:</strong></p><p><strong>Web网站服务器:专门对外提供Web网页资源的服务器。</strong></p><p><strong>API接口服务器:专门对外提供API接口的服务器。</strong></p><p><strong>使用Express,我们可以方便、快速的创建Web网站的服务器或API接口的服务器。</strong></p><h2 id="1-2-Express-的基本使用"><a href="#1-2-Express-的基本使用" class="headerlink" title="1.2 Express 的基本使用"></a><strong>1.2 Express 的基本使用</strong></h2><p><strong>1.安装</strong></p><p><strong>在项目所处的目录中,运行如下的终端命令,即可将express安装到项目中使用:</strong></p><p><strong>npm i <a href="mailto:&#101;&#120;&#x70;&#114;&#x65;&#115;&#115;&#x40;&#x34;&#46;&#x31;&#x37;&#46;&#x31;">&#101;&#120;&#x70;&#114;&#x65;&#115;&#115;&#x40;&#x34;&#46;&#x31;&#x37;&#46;&#x31;</a></strong></p><p><strong>2.创建基本的Web服务器</strong></p><p><strong>1. 导入 express</strong></p><p><strong>const express &#x3D;”require(‘express’)</strong></p><p><strong>&#x2F;&#x2F; 2.创建web服务器</strong></p><p><strong>const app &#x3D; express()</strong></p><p><strong>&#x2F;&#x2F; 3.调用app.listen(端口号,启动成功后的回调函数),启动服务器</strong></p><p><strong>app.listen(80, () &#x3D;&gt; {</strong></p><p><strong>console.log(‘express server running at <a href="http://127.0.0.1/">http://127.0.0.1</a>‘)</strong></p><p><strong>})</strong></p><p><strong>3.监听GET请求</strong></p><p><strong>通过app.geto方法,可以监听客户端的GET请求,具体的语法格式如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数1:客户端请求的URL地址</span></span><br><span class="line"><span class="comment">//参数2:请求对应的处理函数</span></span><br><span class="line"><span class="comment">//req:请求对象(包含了与请求相关的属性与方法)</span></span><br><span class="line"><span class="comment">//res:响应对象(包含了与响应相关的属性与方法)</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;请求URL&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;<span class="comment">/*处理数*/</span> &#125;)</span><br></pre></td></tr></table></figure><p><strong>4.监听POST 请求</strong></p><p><strong>通过app.post0方法,可以监听客户端的POST请求,具体的语法格式如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数1:客户端请求的URL地址</span></span><br><span class="line"><span class="comment">//参数2:请求对应的处理函数</span></span><br><span class="line"><span class="comment">//req:请求对象(包含了与请求相关的属性与方法)</span></span><br><span class="line"><span class="comment">//res:响应对象(包含了与响应相关的属性与方法)</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;请求URL&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;<span class="comment">/*处理数*/</span> &#125;)</span><br></pre></td></tr></table></figure><p><strong>5.把内容响应给客户端</strong></p><p><strong>通过res.send(0)方法,可以把处理好的内容,发送给客户端:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/user&#x27;</span>. (req, res) =&gt; &#123;</span><br><span class="line"> <span class="comment">//向客户端发送JSON对象</span></span><br><span class="line">    res.<span class="title function_">send</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span>, <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span> &#125;)</span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/user&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">//向客户端发送文本内容</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;请求成功&#x27;)</span></span><br><span class="line"><span class="string">   &#125;)</span></span><br></pre></td></tr></table></figure><p><strong>6.获取URL中携带的查询参数</strong></p><p><strong>通过req.query对象,可以访问到客户端通过查询字符串的形式,发送到服务器的参数:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// req.query 默认是一个空对象</span></span><br><span class="line">   <span class="comment">// 客户端使用?name=zs&amp;age=20 这种查询字符串形式,发送到服务器的参数</span></span><br><span class="line">   <span class="comment">//可以通过req.query对象访问到,例如:</span></span><br><span class="line">   <span class="comment">//req.query.name req.query.age</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">query</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>7.获取URL中的动态参数</strong></p><p><strong>通过req.params对象,可以访问到URL中,通过:匹配到的动态参数:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// URL地址中,可以通过:参数名的形式,匹配动态参数值</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27; /user/:id&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// req.params 默认是一个空对象</span></span><br><span class="line">    <span class="comment">//里面存放着通过:动态匹配到的参数值</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">params</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="1-3托管静态资源"><a href="#1-3托管静态资源" class="headerlink" title="1.3托管静态资源"></a><strong>1.3托管静态资源</strong></h2><p><strong>1. express.static()</strong></p><p><strong>express提供了一个非常好用的函数,叫做express.static0,通过它,我们可以非常方便地创建一个静态资源服务器,</strong></p><p><strong>例如,通过如下代码就可以将public目录下的图片、CSS文件、JavaScript文件对外开放访问了:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;public&#x27;</span>))</span><br></pre></td></tr></table></figure><p><strong>现在,你就可以访问public目录中的所有文件了:</strong></p><p><strong><a href="http://localhost:3000/images/bg.jpg">http://localhost:3000/images/bg.jpg</a></strong></p><p><strong><a href="http://localhost:3000/css/style.css">http://localhost:3000/css/style.css</a></strong></p><p><strong><a href="http://localhost:3000/js/login.js">http://localhost:3000/js/login.js</a></strong></p><p><strong>注意: Express在指定的静态目录中查找文件,并对外提供资源的访问路径。因此,存放静态文件的目录名不会出现在URL中。</strong></p><p><strong>2.托管多个静态资源目录</strong></p><p><strong>如果要托管多个静态资源目录,请多次调用express.static0函数:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;public&#x27;</span>))</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;files&#x27;</span>))</span><br></pre></td></tr></table></figure><p><strong>访问静态资源文件时, express.static0函数会根据目录的添加顺序查找所需的文件。</strong></p><p><strong>3.挂载路径前缀</strong></p><p><strong>如果希望在托管的静态资源访问路径之前,挂载路径前缀,则可以使用如下的方式:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/public&#x27;</span>, express.<span class="title function_">static</span>(<span class="string">&#x27;public&#x27;</span>))</span><br></pre></td></tr></table></figure><p><strong>现在,你就可以通过带有&#x2F;public前缀地址来访问public目录中的文件了:</strong></p><p>**<a href="http://localhost:3000/public/images/kitten.jpg">http://localhost:3000/public/images/kitten.jpg</a> **</p><p><strong><a href="http://localhost:3000/public/css/style.css">http://localhost:3000/public/css/style.css</a></strong></p><p><strong><a href="http://localhost:3000/public/js/app.js">http://localhost:3000/public/js/app.js</a></strong></p><p><strong>1.4 nodemon</strong></p><p><strong>1.为什么要使用nodemon</strong></p><p><strong>在编写调试 Node.js项目的时候,如果修改了项目的代码,则需要频繁的手动close掉,然后再重新启动,非常繁琐。</strong></p><p><strong>现在,我们可以使用nodemon (<a href="https://www.npmjs.com/package/nodemon)%E8%BF%99%E4%B8%AA%E5%B7%A5%E5%85%B7,%E5%AE%83%E8%83%BD%E5%A4%9F%E7%9B%91%E5%90%AC%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8F%98%E5%8A%A8,%E5%BD%93%E4%BB%A3%E7%A0%81%E8%A2%AB%E4%BF%AE%E6%94%B9%E5%90%8E,nodemon%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%B8%AE%E6%88%91%E4%BB%AC%E9%87%8D%E5%90%AF%E9%A1%B9%E7%9B%AE,%E6%9E%81%E5%A4%A7%E6%96%B9%E4%BE%BF%E4%BA%86%E5%BC%80%E5%8F%91%E5%92%8C%E8%B0%83%E8%AF%95%E3%80%82">https://www.npmjs.com/package/nodemon)这个工具,它能够监听项目文件的变动,当代码被修改后,nodemon会自动帮我们重启项目,极大方便了开发和调试。</a></strong></p><p><strong>2. 安装 nodemon在终端中,运行如下命令,即可将nodemon安装为全局可用的工具:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g nodemon</span><br></pre></td></tr></table></figure><p> <strong>管理员power开启权限set-ExecutionPolicy RemoteSigned</strong></p><p><strong>3. 使用nodemon</strong></p><p><strong>当基于Node.js编写了一个网站应用的时候,传统的方式,是运行node app.js命令,来启动项目。这样做的坏处是:代码被修改之后,需要手动重启项目。</strong></p><p><strong>现在,我们可以将node命令替换为nodemon命令,使用nodemon app.js来启动项目。这样做的好处是:代码被修改之后,会被nodemon监听到,从而实现自动重启项目的效果。</strong></p><h1 id="2-Express-路由"><a href="#2-Express-路由" class="headerlink" title="2. Express 路由"></a><strong>2. Express 路由</strong></h1><h2 id="2-1路由的概念"><a href="#2-1路由的概念" class="headerlink" title="2.1路由的概念"></a><strong>2.1路由的概念</strong></h2><p><strong>2.现实生活中的路由</strong></p><p><strong>在这里,路由是按键与服务之间的映射关系</strong></p><p><strong>3. Express 中的路由</strong></p><p><strong>在Express中,路由指的是客户端的请求与服务器处理函数之间的映射关系。</strong></p><p><strong>Express中的路由分3部分组成,分别是请求的类型、请求的URL地址、处理函数,格式如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">METHOD</span>(<span class="variable constant_">PATH</span>, <span class="variable constant_">HANDLER</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4.</span> <span class="title class_">Express</span> 中的路由的例子</span><br><span class="line"><span class="comment">//匹配GET请求,且请求URL为/</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line"></span><br><span class="line"> res.<span class="title function_">send</span>( <span class="string">&#x27;Hello World!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配POST请求,且请求URL为/</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line"></span><br><span class="line"> res. <span class="title function_">send</span>(<span class="string">&#x27;Got a POST request&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>5.路由的匹配过程</strong></p><p><strong>每当一个请求到达服务器之后,需要先经过路由的匹配,只有匹配成功之后,才会调用对应的处理函数。</strong></p><p><strong>在匹配时,会按照路由的顺序进行匹配,如果请求类型和请求的URL同时匹配成功,则Express会将这次请求,转交给对应的function函数进行处理。</strong></p><p><strong>路由匹配的注意点:</strong></p><p><strong>①按照定义的先后顺序进行匹配</strong></p><p><strong>②请求类型和请求的URL同时匹配成功,才会调用对应的处理函数</strong></p><h2 id="2-2路由的使用"><a href="#2-2路由的使用" class="headerlink" title="2.2路由的使用"></a><strong>2.2路由的使用</strong></h2><p><strong>1.最简单的用法在Express中使用路由最简单的方式,就是把路由挂载到app上,示例代码如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="comment">//创建Web服务器,命名为app</span></span><br><span class="line"><span class="keyword">const</span> app=<span class="title function_">express</span>()</span><br><span class="line"><span class="comment">//挂载路由</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;res,<span class="title function_">send</span>(<span class="string">&#x27;Hello World. &#x27;</span>) &#125;) app.<span class="title function_">post</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span>&#123; res. <span class="title function_">send</span>( <span class="string">&#x27;Post Request. &#x27;</span>)&#125;)</span><br><span class="line"><span class="comment">//启动Web服务器</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>, <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server running at http://127.0.0.1&#x27;</span>) &#125;)</span><br></pre></td></tr></table></figure><p><strong>2.模块化路由</strong></p><p><strong>为了方便对路由进行模块化的管理, Express不建议将路由直接挂载到app上,而是推荐将路由抽离为单独的模块。将路由抽离为单独模块的步骤如下:</strong></p><p><strong>① 创建路由模块对应的.js文件</strong></p><p><strong>②调用express.Router()函数创建路由对象</strong></p><p><strong>③向路由对象上挂载具体的路由</strong></p><p><strong>④使用module.exports 向外共享路由对象</strong></p><p><strong>⑤使用app.use0函数注册路由模块</strong></p><h2 id="3-创建路由模块"><a href="#3-创建路由模块" class="headerlink" title="3.创建路由模块"></a><strong>3.创建路由模块</strong></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> router = express. <span class="title class_">Router</span>()</span><br><span class="line"><span class="comment">// 1. 导入 express</span></span><br><span class="line"><span class="comment">//2.创建路由对象</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/user/list&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line"> <span class="comment">//3,挂载获取用户列表的路由</span></span><br><span class="line">   res.<span class="title function_">send</span>(<span class="string">&#x27;Get user list.&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/user/add&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="comment">// 4.挂载添加用户的路由</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;Add new user.&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router  <span class="comment">//5.向外导出路由对象</span></span><br></pre></td></tr></table></figure><p><strong>4.注册路由模块</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入路由模块</span></span><br><span class="line"><span class="keyword">const</span> userRouter = <span class="built_in">require</span>(<span class="string">&#x27;./router/user.js&#x27;</span>)</span><br><span class="line"><span class="comment">//2.使用app.use()注册路由模块</span></span><br><span class="line">app.<span class="title function_">use</span>(userRouter)</span><br></pre></td></tr></table></figure><p><strong>5.为路由模块添加前缀类似于托管静态资源时,为静态资源统一挂载访问前缀一样,路由模块添加前缀的方式也非常简单:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入路由模块</span></span><br><span class="line"><span class="keyword">const</span> userRouter = <span class="built_in">require</span>(<span class="string">&#x27;./router/user.js&#x27;</span>)</span><br><span class="line"><span class="comment">// 2.使用app.use()注册路由模块,并添加统一的访问前缀/api</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/api&#x27;</span>, userRouter)</span><br></pre></td></tr></table></figure><h1 id="3-Express-中间件"><a href="#3-Express-中间件" class="headerlink" title="3. Express 中间件"></a><strong>3. Express 中间件</strong></h1><h2 id="3-1中间件的概念"><a href="#3-1中间件的概念" class="headerlink" title="3.1中间件的概念"></a><strong>3.1中间件的概念</strong></h2><p><strong>1.什么是中间件</strong></p><p><strong>中间件(Middleware),特指业务流程的中间处理环节。</strong></p><p><strong>2.现实生活中的例子</strong></p><p><strong>在处理污水的时候,一般都要经过三个处理环节,从而保证处理过后的废水,达到排放标准。</strong></p><p><strong>处理污水的这三个中间处理环节,就可以叫做中间件。</strong></p><p><strong>3. Express 中间件的调用流程当一个请求到达Express的服务器之后,可以连续调用多个中间件,从而对这次请求进行预处理。</strong></p><p><strong>4. Express 中间件的格式Express的中间件,本质上就是一个function处理函数, Express中间件的格式如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express= <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = <span class="title function_">express</span>();</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res, next</span>)&#123;</span><br><span class="line">   <span class="title function_">next</span>();</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p><strong>注意:中间件函数的形参列表中,必须包含next参数。而路由处理函数中只包含req和res。</strong></p><p><strong>5. next 函数的作用next函数是实现多个中间件连续调用的关键,它表示把流转关系转交给下一个中间件或路由。</strong></p><h2 id="3-2-Express-中间件的初体验"><a href="#3-2-Express-中间件的初体验" class="headerlink" title="3.2 Express 中间件的初体验"></a><strong>3.2 Express 中间件的初体验</strong></h2><p><strong>1.定义中间件函数</strong></p><p><strong>可以通过如下的方式,定义一个最简单的中间件函数:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量mw所指向的,就是一个中间件函数</span></span><br><span class="line"><span class="keyword">const</span> mw= <span class="keyword">function</span> (<span class="params">req, res, next</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是一个最简单的中间件&#x27;</span>)</span><br><span class="line"><span class="comment">//注意:在当前中间件的业务处理完毕后,必须调用next()函数</span></span><br><span class="line"> <span class="comment">//表示把流转关系转交给下一个中间件或路由</span></span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.全局生效的中间件</strong></p><p><strong>客户端发起的任何请求,到达服务器之后,都会触发的中间件,叫做全局生效的中间件。</strong></p><p><strong>通过调用app.use(中间件函数),即可定义一个全局生效的中间件,示例代码如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量mw所指向的,就是一个中间件函数</span></span><br><span class="line"><span class="keyword">const</span> mw= <span class="keyword">function</span> (<span class="params">reg, res, next</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是一个最简单的中间件函数&quot;</span>)</span><br><span class="line">    next ()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//全局生效的中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(mw)</span><br></pre></td></tr></table></figure><p><strong>3.定义全局中间件的简化形式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局生效的中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(furction (req, res, next)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是一个最简单的中间件函数&#x27;</span>)</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>4.中间件的作用</strong></p><p><strong>多个中间件之间,共享同一份req和res。基于这样的特性,我们可以在上游的中间件中,统一为req 或 res对象添加自定义的属性或方法,供下游的中间件或路由进行使用。</strong></p><p><strong>5.定义多个全局中间件</strong></p><p><strong>可以使用app.use()连续定义多个全局中间件。客户端请求到达服务器之后,会按照中间件定义的先后顺序依次进行调用,示例代码如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span>(<span class="params">req, res, next</span>) &#123;<span class="comment">// 第1个全局中间件</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;调用了第1个全局中间件&#x27;)</span></span><br><span class="line"><span class="string">    next()</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">app.use(function(req, res, next) &#123;</span></span><br><span class="line"><span class="string">    //1 第2个全局中间件</span></span><br><span class="line"><span class="string">    console.log(&quot;</span>调用了第<span class="number">2</span>个全局中间件<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">    next()</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">app.get(&#x27;</span>/user<span class="string">&#x27;, (req, res) =&gt;&#123;</span></span><br><span class="line"><span class="string">    //请求这个路由,会依次触发上述两个全局中间件</span></span><br><span class="line"><span class="string">    res.send(&#x27;</span><span class="title class_">Hone</span> page.<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure><p><strong>6.局部生效的中间件</strong></p><p><strong>不使用app.use0定义的中间件,叫做局部生效的中间件,示例代码如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义中间件图数mw</span></span><br><span class="line"><span class="keyword">const</span> mw1 <span class="keyword">function</span>(<span class="params">req, res, next</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是中间件函数&#x27;)</span></span><br><span class="line"><span class="string">     next()</span></span><br><span class="line"><span class="string">// mw1这个中间件只在&quot;</span>当前路由中生效”,这种用法属于<span class="string">&quot;局部生效的中间件&quot;</span></span><br><span class="line">  app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, mw1, <span class="keyword">function</span>(<span class="params">req, res</span>)&#123;</span><br><span class="line">      res.<span class="title function_">send</span>(<span class="string">&#x27;Home page.&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">// mw1这个中间件不会影响下面这个路由</span></span><br><span class="line">  app.<span class="title function_">get</span>(<span class="string">&#x27;/user&#x27;</span>, <span class="keyword">function</span>(<span class="params">req. res</span>) &#123;</span><br><span class="line">       res.<span class="title function_">send</span>( <span class="string">&#x27;User page. &#x27;</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p><strong>7.定义多个局部中间件</strong></p><p><strong>可以在路由中,通过如下两种等价的方式,使用多个局部中间件:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下两种写法是&quot;完全等价&quot;的,可根据自己的喜好,选择任意一种方式进行使用</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, mw1, <span class="title function_">mw2</span>(req, res) =&gt; &#123;</span><br><span class="line">    res.<span class="title function_">send</span>( <span class="string">&#x27;Home page. &#x27;</span>) &#125;)</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>. [mw1, mw2], <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;Home page.&#x27;</span>) &#125;)</span><br></pre></td></tr></table></figure><p><strong>8.了解中间件的5个使用注意事项</strong></p><p><strong>一定要在路由之前注册中间件</strong></p><p><strong>客户端发送过来的请求,可以连续调用多个中间件进行处理</strong></p><p><strong>执行完中间件的业务代码之后,不要忘记调用next()函数</strong></p><p><strong>为了防止代码逻辑混乱,调用next0函数后不要再写额外的代码</strong></p><p><strong>连续调用多个中间件时,多个中间件之间,共享req和res对象</strong></p><p><strong>3.3中间件的分类</strong></p><p><strong>为了方便大家理解和记忆中间件的使用,Expres把常见的中间件用法,分成了5大类,分别是:</strong></p><p><strong>①应用级别的中间件</strong></p><p><strong>2.路由级别的中间件</strong></p><p><strong>③错误级别的中间件</strong></p><p><strong>4.Express 内置的中间件</strong></p><p><strong>5.第三方的中间件</strong></p><h2 id="3-3中间件的分类"><a href="#3-3中间件的分类" class="headerlink" title="3.3中间件的分类"></a><strong>3.3中间件的分类</strong></h2><p><strong>1.应用级别的中间件</strong></p><p><strong>通过app.use()或 app.get()或 app.post().绑定到app实例上的中间件,叫做应用级别的中间件,代码示例如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//应用级别的中间件(全局中间件)</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">reg, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//应用级别的中间件(局部中间件)</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, mw, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;Home page.&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>2.路由级别的中间件</strong></p><p><strong>绑定到express.Router0实例上的中间件,叫做路由级别的中间件。它的用法和应用级别中间件没有任何区别。只不过,应用级别中间件是绑定到app实例上,路由级别中间件绑定到router实例上,代码示例如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app=<span class="title function_">express</span>()</span><br><span class="line"><span class="keyword">var</span> router =express.<span class="title class_">Router</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//路由级别的中间件</span></span><br><span class="line">router.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">req, res, next</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Time:&#x27;</span>, <span class="title class_">Date</span>.<span class="title function_">now</span>())</span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/&#x27;</span>, router)</span><br></pre></td></tr></table></figure><p><strong>3.错误级别的中间件</strong></p><p><strong>错误级别中间件的作用:专门用来捕获整个项目中发生的异常错误,从而防止项目异常崩溃的问题。</strong></p><p><strong>格式:错误级别中间件的function处理函数中,必须有4个形参,形参顺序从前到后,分别是(err, req, res, next)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 路由</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;服务器内部发生了错误! &#x27;</span>) <span class="comment">// 1.1抛出一个自定义的错误</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;Home Page. &#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">err, req, res, next</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.错误级别的中间件</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发生了错误:&#x27;</span>+ err.<span class="property">message</span>)<span class="comment">// 2.1 在服务器打印错误消息</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;Error! &#x27;</span>+ err.<span class="property">message</span>)<span class="comment">//2.2 向客户端响应错误相关的内容</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>注意:错误级别的中间件,必须注册在所有路由之后!</strong></p><p><strong>4. Express内置的中间件</strong></p><p><strong>自Express 4.16.0 版本开始, Express内置了3个常用的中间件,极大的提高了Express项目的开发效率和体验:</strong></p><p><strong>express.static快速托管静态资源的内置中间件,例如: HTML文件、图片、CSS样式等(无兼容性)</strong></p><p><strong>express.json 解析 JSON 格式的请求体数据(有兼容性,仅在4.16.0+版本中可用)</strong></p><p><strong>express.urlencoded 解析 URL-encoded 格式的请求体数据(有兼容性,仅在4.16.0+版本中可用)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置解析 application/json格式数据的内置中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>())</span><br><span class="line"><span class="comment">//配置解析 application/x-www-form-urlencoded格式数据的内置中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;))</span><br></pre></td></tr></table></figure><p><strong>5.第三方的中间件</strong></p><p><strong>非Express官方内置的,而是由第三方开发出来的中间件,叫做第三方中间件。在项目中,大家可以按需下载并配置第三方中间件,从而提高项目的开发效率。</strong></p><p><strong>例如:在<a href="mailto:&#101;&#120;&#x70;&#114;&#101;&#x73;&#115;&#x40;&#52;&#x2e;&#49;&#54;&#46;&#x30;">&#101;&#120;&#x70;&#114;&#101;&#x73;&#115;&#x40;&#52;&#x2e;&#49;&#54;&#46;&#x30;</a> 之前的版本中,经常使用body-parser这个第三方中间件,来解析请求体数据。使用步骤如下:</strong></p><p><strong>① 运行npm install body-parser安装中间件</strong></p><p><strong>②使用require导入中间件</strong></p><p><strong>③调用app.use()注册并使用中间件</strong></p><p><strong>注意: Express内置的express.urlencoded 中间件,就是基于body-parser这个第三方中间件进一步封装出来的。</strong></p><h2 id="3-4-自定义中间件"><a href="#3-4-自定义中间件" class="headerlink" title="3.4 自定义中间件"></a><strong>3.4 自定义中间件</strong></h2><p><strong>1.需求描述与实现步骤</strong></p><p><strong>自己手动模拟一个类似于express.urlencoded这样的中间件,来解析POST提交到服务器的表单数据。</strong></p><p><strong>实现步骤:</strong></p><p><strong>①定义中间件</strong></p><p><strong>②监听req 的data事件</strong></p><p><strong>3.监听 req的end 事件</strong></p><p><strong>④使用querystring模块解析请求体数据</strong></p><p><strong>5. 将解析出来的数据对象挂载为req.body</strong></p><p><strong>6将自定义中间件封装为模块</strong></p><p><strong>2.定义中间件</strong></p><p><strong>使用app.use()来定义全局生效的中间件,代码如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span>(<span class="params">req, res, next</span>)&#123;</span><br><span class="line">    <span class="comment">//中间件的业务逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>3.监听req 的data 事件</strong></p><p><strong>在中间件中,需要监听req对象的data事件,来获取客户端发送到服务器的数据。</strong></p><p><strong>如果数据量比较大,无法一次性发送完毕,则客户端会把数据切割后,分批发送到服务器。所以data事件可能会触发多次,每一次触发data事件时,获取到数据只是完整数据的一部分,需要手动对接收到的数据进行拼接。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义变量,用来存储客户端发送过来的请求体数据</span></span><br><span class="line"><span class="keyword">let</span> str =<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment">//监听req对象的data事件(客户端发送过来的新的请求体数据)</span></span><br><span class="line">req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//拼接请求体数据,险式转换为字符串</span></span><br><span class="line">    str+= chunk</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>4.监听 req 的end事件</strong></p><p><strong>当请求体数据接收完毕之后,会自动触发req的end事件。</strong></p><p><strong>因此,我们可以在req的end事件中,拿到并处理完整的请求体数据。示例代码如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//监听req对象的end事件(请求体发送完毕后自动触发)</span></span><br><span class="line">req.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//打印完整的请求体数据</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(str)</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>把字符串格式的请求体数据,解析成对象格式</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>5.使用querystring模块解析请求体数据</strong></p><p><strong>Node.js 内置了一个 querystring模块,专门用来处理查询字符甲。通过这个模块提供的parse()函数,可以轻松把查询字符串,解析成对象的格式。示例代码如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入处理 querystring的Node.js内置模块</span></span><br><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>)</span><br><span class="line"><span class="comment">//调用qs.parse()方法,把查询字符串解析为对象</span></span><br><span class="line"><span class="keyword">const</span> body = qs.<span class="title function_">parse</span>(str)</span><br></pre></td></tr></table></figure><p><strong>6.将解析出来的数据对象挂载为req.body</strong></p><p><strong>上游的中间件和下游的中间件及路由之间,共享同一份req 和res。因此,我们可以将解析出来的数据,挂载为req的自定义属性,命名为req.body,供下游使用。示例代码如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">req.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> body = qs.<span class="title function_">parse</span>(str) <span class="comment">//调用qs.parse()方法,把查询字符串解析为对象</span></span><br><span class="line">    req.<span class="property">body</span> = body  <span class="comment">//将解析出来的请求体对象,挂载为req.body属性</span></span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br><span class="line">    <span class="comment">//最后,一定要调用next()函数,执行后续的业务逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>7.将自定义中间件封装为模块</strong></p><p><strong>为了优化代码的结构,我们可以把自定义的中间件函数,封装为独立的模块,示例代码如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// custom-body-parser.js 模块中的代</span></span><br><span class="line"><span class="keyword">const</span> qs=<span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bodyParser</span>(<span class="params">req, res, next</span>) &#123;<span class="comment">/*其它代 *&#125;</span></span><br><span class="line"><span class="comment">module.exports= bodyParser // 向外导出解析请求体数据的中间件通数</span></span><br><span class="line"><span class="comment">-------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//1.导入自定义的中问件模块</span></span><br><span class="line"><span class="comment">const myBodyParser= require(&#x27;custom-body-parser&#x27;)</span></span><br><span class="line"><span class="comment">//2.注册自定义的中间件模块</span></span><br><span class="line"><span class="comment">app.use(myBodyParser)</span></span><br></pre></td></tr></table></figure><h1 id="4-使用Express写接口"><a href="#4-使用Express写接口" class="headerlink" title="4.使用Express写接口"></a><strong>4.使用Express写接口</strong></h1><h2 id="4-1创建基本的服务器"><a href="#4-1创建基本的服务器" class="headerlink" title="4.1创建基本的服务器"></a><strong>4.1创建基本的服务器</strong></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 express 模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="comment">//创建 express的服务器实例</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="comment">// write your code here...</span></span><br><span class="line"><span class="comment">//调用app.listen方法,指定端口号并启动web服务器</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Express server running at http://127.0.0.1&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="4-2-创建API-路由模块"><a href="#4-2-创建API-路由模块" class="headerlink" title="4.2 创建API 路由模块"></a><strong>4.2 创建API 路由模块</strong></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// apiRouter.js 【路由模块】</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> apiRouter= express.<span class="title class_">Router</span>()</span><br><span class="line"><span class="comment">// bind your router here...</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = apiRouter</span><br><span class="line">------------------------------------</span><br><span class="line"><span class="comment">// app.js 【导入并注册路由模块】</span></span><br><span class="line"><span class="keyword">const</span> apiRouter = <span class="built_in">require</span>(<span class="string">&#x27;./apiRouter.js&#x27;</span>)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/api&#x27;</span>, apiRouter)</span><br></pre></td></tr></table></figure><h2 id="4-3编写GET接口"><a href="#4-3编写GET接口" class="headerlink" title="4.3编写GET接口"></a><strong>4.3编写GET接口</strong></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiRouter.<span class="title function_">get</span>(<span class="string">&#x27;/get&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">//1.获取到客户端通过查询字符串,发送到服务器的数据</span></span><br><span class="line"><span class="keyword">const</span> query= req.<span class="property">query</span></span><br><span class="line"><span class="comment">// 2.调用res.send()方法,把数据响应给客户端</span></span><br><span class="line">res.<span class="title function_">send</span>(&#123;</span><br><span class="line">    <span class="attr">status</span>: <span class="number">0</span>, <span class="comment">//状态,0表示成功,1表示失败</span></span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;GET请求成功! &#x27;</span>, <span class="comment">//状态描述</span></span><br><span class="line">    <span class="attr">data</span>: query   <span class="comment">//需要响应给客户端的具体数据</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="4-4编写POST接口"><a href="#4-4编写POST接口" class="headerlink" title="4.4编写POST接口"></a><strong>4.4编写POST接口</strong></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiRouter.<span class="title function_">post</span>(<span class="string">&#x27;/post&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//1.获取客户端通过请求体,发送到服务器的URL-encoded数据</span></span><br><span class="line">    <span class="keyword">const</span> body = req.<span class="property">body</span></span><br><span class="line">    <span class="comment">// 2.调用res.send()方法,把数据响应给客户端</span></span><br><span class="line">    res.<span class="title function_">send</span>(&#123;</span><br><span class="line">        <span class="attr">status</span>: <span class="number">0</span>,            <span class="comment">//状态,0表示成功,1表示失败</span></span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;POST请求成功! &#x27;</span>, <span class="comment">//状态描述消息</span></span><br><span class="line">        <span class="attr">data</span>: body           <span class="comment">//需要响应给客户端的具体数据</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>注意:如果要获取URL-encoded 格式的请求体数据,必须配置中间件</strong></p><p><strong>app.use(express.urlencoded({ extended: false }))</strong></p><h2 id="4-5-CORS-跨域资源共享"><a href="#4-5-CORS-跨域资源共享" class="headerlink" title="4.5 CORS 跨域资源共享"></a><strong>4.5 CORS 跨域资源共享</strong></h2><p><strong>1.接口的跨域问题</strong></p><p><strong>刚才编写的GET和POST接口,存在一个很严重的问题:不支持跨域请求。</strong></p><p><strong>解决接口跨域问题的方案主要有两种:</strong></p><p><strong>CORS (主流的解决方案,推荐使用)</strong></p><p><strong>JSONP (有缺陷的解决方案:只支持GET请求)</strong></p><p><strong>2.使用cors中间件解决跨域问题</strong></p><p><strong>cors是Express的一个第三方中间件。通过安装和配置cors中间件,可以很方便地解决跨域问题。</strong></p><p><strong>使用步骤分为如下3步:</strong></p><p><strong>①运行npm install cors安装中间件</strong></p><p><strong>② 使用 const cors &#x3D; require(‘cors’) 导入中间件</strong></p><p><strong>③在路由之前调用app.use(cors0)配置中间件</strong></p><p><strong>3.什么是 CORS</strong></p><p><strong>CORS (Cross-Origin Resource Sharing,跨域资源共享)由一系列HTTP 响应头组成,这些HTTP响应头决定浏览器是否阻止前端JS代码跨域获取资源。</strong></p><p><strong>浏览器的同源安全策略默认会阻止网页“跨域”获取资源。但如果接口服务器配置了CORS相关的HTTP 响应头,就可以解除浏览器端的跨域访问限制。</strong></p><p><strong>4. CORS 的注意事项</strong></p><p><strong>① CORS主要在服务器端进行配置。客户端浏览器无须做任何额外的配置,即可请求开启了CORS的接口。</strong></p><p><strong>2.CORS在浏览器中有兼容性。只有支持XMLHttpRequest Level2的浏览器,才能正常访问开启了CORS的服务端接口(例如: IE10+、 Chrome4+, FireFox3.5+) .</strong></p><p><strong>5. CORS 响应头部 - Access-Control-Allow-Origin</strong></p><p><strong>响应头部中可以携带一个Access-Control-Allow-Origin字段,其语法如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: &lt;origin&gt; | *</span><br></pre></td></tr></table></figure><p><strong>其中,origin参数的值指定了允许访问该资源的外域URL</strong></p><p><strong>例如,下面的字段值将只允许来自<a href="http://itcast.cn的请求/">http://itcast.cn的请求</a>:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;http://itcast.cn&#x27;</span>)</span><br></pre></td></tr></table></figure><p><em><em>如果指定了Access-Control-Allow-Origin字段的值为通配符</em>,表示允许来自任何域的请求,示例代码如下:</em>*</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>6. CORS 响应头部 - Access-Control-Allow-Headers</strong></p><p><strong>默认情况下,CORS 仅支持客户端向服务器发送如下的9个请求头:</strong></p><p><strong>Accept, Accept-Language, Content-Language. DPR, Downlink, Save-Data, Viewport-Width, WidthContent-Type (限 text&#x2F;plain, multipart&#x2F;form-data, application&#x2F;x-www-form-urlencoded 三者之一)</strong></p><p><strong>如果客户端向服务器发送了额外的请求头信息,则需要在服务器端,通过Access-Control-Allow-Headers对额外的请求头进行声明,否则这次请求会失败!</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 允许客户端额外向服务器发送Content-Type 请求头和X-Custom-Header请求头</span></span><br><span class="line"><span class="comment">//注意:多个请求头之问使用英文的豆号进行分割</span></span><br><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;Content-Type, X-Custom-Header&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>7. CORS 响应头部 - Access-Control-Allow-Methods</strong></p><p><strong>默认情况下, CORS仅支持客户端发起GET, POST, HEAD请求。</strong></p><p><strong>如果客户端希望通过PUT、 DELETE等方式请求服务器的资源,则需要在服务器端,通过Access-Control-Alow-Methods来指明实际请求所允许使用的HTTP方法。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只允许POST, GET、 DELETE, HEAD 请求方法</span></span><br><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;POST, GET, DELETE, HEAD&#x27;</span>)</span><br><span class="line"><span class="comment">//允许所有的HTTP 请求方法</span></span><br><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;*&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>8. CORS请求的分类客户端在请求 CORS接口时,根据请求方式和请求头的不同,可以将CORS的请求分为两大类,分别是:</strong></p><p><strong>①简单请求</strong></p><p><strong>②预检请求</strong></p><p><strong>9.简单请求同时满足以下两大条件的请求,就属于简单请求:</strong></p><p><strong>1.请求方式: GET, POST, HEAD 三者之一</strong></p><p><strong>2.HTTP 头部信息不超过以下几种字段:无自定义头部字段、Accept. Accept-Language, Content-Language, DPR.Downlink, Save-Data, Viewport-Width, Width, Content-Type (只有三个值application&#x2F;x-www-formurlencoded, multipart&#x2F;form-data, text&#x2F;plain)</strong></p><p><strong>10.预检请求只要符合以下任何一个条件的请求,都需要进行预检请求:</strong></p><p><strong>①请求方式为GET, POST, HEAD 之外的请求Method类型</strong></p><p><strong>2.请求头中包含自定义头部字段</strong></p><p><strong>③向服务器发送了 application&#x2F;json格式的数据</strong></p><p><strong>在浏览器与服务器正式通信之前,浏览器会先发送OPTION请求进行预检,以获知服务器是否允许该实际请求,所以这一次的OPHON 请求称为“预检请求”。服务器成功响应预检请求后,才会发送真正的请求,并且携带真实数据。</strong></p><p><strong>11.简单请求和预检请求的区别</strong></p><p><strong>简单请求的特点:客户端与服务器之间只会发生一次请求。</strong></p><p><strong>预检请求的特点:客户端与服务器之间会发生两次请求, OPTION预检请求成功之后,才会发起真正的请求。</strong></p><h2 id="4-6-JSONP-接口"><a href="#4-6-JSONP-接口" class="headerlink" title="4.6 JSONP 接口"></a><strong>4.6 JSONP 接口</strong></h2><p><strong>1.回顾JSONP的概念与特点</strong></p><p><strong>概念:浏览器端通过<script>标签的src属性,请求服务器上的数据,同时,服务器返回一个函数的调用。这种请求数据的方式叫做JSONP。</strong></p><p><strong>特点:</strong></p><p><strong>① JSONP 不属于真正的Ajax请求,因为它没有使用XMLHttpRequest这个对象。</strong></p><p><strong>② JSONP仅支持GET请求,不支持POST, PUT, DELETE等请求。</strong></p><p><strong>2.创建JSONP接口的注意事项</strong></p><p><strong>如果项目中已经配置了CORS跨域资源共享,为了防止冲突,必须在配置CORS 中间件之前声明JSONP的接口。否则USONP接口会被处理成开启了 CORS的接口。示例代码如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优先创建JSONP接口【这个接口不会被处理成CORS接口】</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/api/jsonp&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">//再配置CORS中间件【后续的所有接口,都会被处理成CORS接口】</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cors</span>())</span><br><span class="line"><span class="comment">//这是一个开启了CORS的接口</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/api/get&#x27;</span>. (req, res) =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure><h2 id="4-6-JSONP-接口-1"><a href="#4-6-JSONP-接口-1" class="headerlink" title="4.6 JSONP 接口"></a><strong>4.6 JSONP 接口</strong></h2><p><strong>3.实现JSONP接口的步骤</strong></p><p><strong>①获取客户端发送过来的回调函数的名字</strong></p><p><strong>② 得到要通过JSONP形式发送给客户端的数据</strong></p><p><strong>③根据前两步得到的数据,拼接出一个函数调用的字符串</strong></p><p><strong>④把上一步拼接得到的字符串,响应给客户端的<script>标签进行解析执行</strong></p><p><strong>4.实现JSONP接口的具体代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/api/jsonp&#x27;</span>. (req, res) =&gt;&#123;</span><br><span class="line">   <span class="comment">//1.获取客户端发送过来的回调通数的名字</span></span><br><span class="line">    <span class="keyword">const</span> funcName = req.<span class="property">query</span>.<span class="property">callback</span></span><br><span class="line">   <span class="comment">//2.得到要通过JSONP形式发送给客户端的数据</span></span><br><span class="line">    <span class="keyword">const</span> data = &#123;<span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;</span><br><span class="line">   <span class="comment">//3.根据前两步得到的数据,拼接出一个函数调用的字符串</span></span><br><span class="line">    <span class="keyword">const</span> scriptStr = <span class="string">&#x27;$&#123;funcName&#125;($&#123;JSON.stringify(data)&#125;)&#x27;</span></span><br><span class="line">   <span class="comment">//4.把上一步拼接得到的字符串,响应给客户端的&lt;script&gt;标签进行解析执行</span></span><br><span class="line">    res.<span class="title function_">send</span>(scriptStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>5.在网页中使用jQuery发起JSONP 请求</strong></p><p><strong>调用$.ajax()函数,提供JSONP的配置选项,从而发起JSONP请求,示例代码如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#btnJSONP&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;http://127.0.0.1/api/jsonp&#x27;</span>,</span><br><span class="line">        <span class="attr">dataType</span>: <span class="string">&#x27;jsonp&#x27;</span>, <span class="comment">//表示要发起JSONP的请求</span></span><br><span class="line">        <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">res</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>4.在项目中操作MySQL</strong></p><p><strong>4.1在项目中操作数据库的步骤</strong></p><p><strong>① 安装操作MySQL数据库的第三方模块(mysql)</strong></p><p><strong>②通过mysql 模块连接到MySQL数据库</strong></p><p><strong>③通过mysql 模块执行SQL语句</strong></p><p><strong>1. 安装mysql 模块</strong></p><p><strong>mysql 模块是托管于npm上的第三方模块。它提供了在Node.js项目中连接和操作MySQL数据库的能力。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mysql</span><br></pre></td></tr></table></figure><p><strong>2.配置mysql 模块在使用mysql 模块操作MySQL数据库之前,必须先对mysql 模块进行必要的配置,主要的配置步骤如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入mysql模块</span></span><br><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql&#x27;</span>)</span><br><span class="line"><span class="comment">// 2.建立与MySQL数据库的连接</span></span><br><span class="line"><span class="keyword">const</span> db = mysql.<span class="title function_">createPool</span>(&#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="comment">//数据库的IP地址</span></span><br><span class="line">    <span class="attr">user</span>: <span class="string">&#x27;root&#x27;</span>,<span class="comment">//登录数据库的账号</span></span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;admin123&#x27;</span>, <span class="comment">// 登录数据库的密码</span></span><br><span class="line">    <span class="attr">database</span>: <span class="string">&#x27;my_db_01&#x27;</span> <span class="comment">//指定要操作哪个数据库</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>3.测试mysql 模块能否正常工作调用db.query0函数,指定要执行的SQL语句,通过回调函数拿到执行的结果:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测mysq1模块能否正常工作</span></span><br><span class="line">db.<span class="title function_">query</span>(<span class="string">&#x27;SELECT 1&#x27;</span>, <span class="function">(<span class="params">err, results</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">   <span class="comment">//只要能打印出[ RowDataPacket &#123;&#x27;1&#x27;: 1&#125; ]的结果,就证明数据库连接正常</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(results)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="4-在项目中操作MySQL"><a href="#4-在项目中操作MySQL" class="headerlink" title="4.在项目中操作MySQL"></a><strong>4.在项目中操作MySQL</strong></h1><h2 id="4-3-使用mysql-模块操作MySQL数据库"><a href="#4-3-使用mysql-模块操作MySQL数据库" class="headerlink" title="4.3 使用mysql 模块操作MySQL数据库"></a><strong>4.3 使用mysql 模块操作MySQL数据库</strong></h2><p><strong>1.查询数据</strong></p><p><strong>查询users表中所有的数据:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询users表中所有的用户数据</span></span><br><span class="line">db.<span class="title function_">query</span>(<span class="string">&#x27;SELECT * FROM users&#x27;</span>, <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">//查询失败</span></span><br><span class="line">   <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">  <span class="comment">//查询成功</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>2.插入数据</strong></p><p><strong>向users表中新增数据,其中username 为Spider-Man, ,password 为 pcc321,示例代码如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.要插入到users表中的数据对象</span></span><br><span class="line"><span class="keyword">const</span> user = &#123;<span class="attr">username</span>: <span class="string">&#x27;Spider-Man&#x27;</span>, <span class="attr">password</span>: <span class="string">&#x27;pcc321&#x27;</span> )</span><br><span class="line"><span class="comment">//2.待执行的SQL语句,其中英文的?表示占位符</span></span><br><span class="line"><span class="keyword">const</span> sqlStr = <span class="string">&#x27;INSERT INTO users (username, password) VALUES (?, ?)&#x27;</span></span><br><span class="line"><span class="comment">//3.使用数组的形式,依次为?占位符指定具体的值</span></span><br><span class="line">db.<span class="title function_">query</span>(sqlStr, [user.<span class="property">username</span>, user.<span class="property">password</span>], <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)<span class="comment">//1 失败</span></span><br><span class="line">   <span class="keyword">if</span>(results.<span class="property">affectedRows</span> === <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;插入数据成功&#x27;</span>)&#125;</span><br><span class="line">    <span class="comment">// 成功</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>3.插入数据的便捷方式向表中新增数据时,如果数据对象的每个属性和数据表的字段一-对应,则可以通过如下方式快速插入数据:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.要插入到users 表中的数据对象</span></span><br><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">username</span>: <span class="string">&#x27;Spider-Man2&#x27;</span>, <span class="attr">password</span>: <span class="string">&#x27;pcc4321&#x27;</span>&#125;</span><br><span class="line"><span class="comment">//2.待执行的SQL 语句,其中英文的?表示占位符</span></span><br><span class="line"><span class="keyword">const</span> sqlStr = <span class="string">&#x27;INSERT INTO users SET ?&#x27;</span></span><br><span class="line"><span class="comment">// 3.直接将数据对象当作占位符的值</span></span><br><span class="line">db.<span class="title function_">query</span>(sqlStr, user, <span class="function">(<span class="params">err, results</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>) <span class="comment">// 失败</span></span><br><span class="line">  <span class="keyword">if</span>(results.<span class="property">affectedRows</span>===<span class="number">1</span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;插入数据成功&quot;)&#125;//成功</span></span><br><span class="line"><span class="string"> &#125;)</span></span><br></pre></td></tr></table></figure><p><strong>4.更新数据可以通过如下方式,更新表中的数据:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.要更新的数据对象</span></span><br><span class="line"><span class="keyword">const</span> user = &#123;<span class="attr">id</span>: <span class="number">7</span>, <span class="attr">username</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">password</span>: <span class="string">&#x27;000&#x27;</span> &#125;</span><br><span class="line"><span class="comment">//2.要执行的SQL 语句</span></span><br><span class="line"><span class="keyword">const</span> sqlStr = <span class="string">&#x27;UPDATE users SET username=?, password=? WHERE id=?&quot;</span></span><br><span class="line"><span class="string">// 3.调用db.query()执行SQL语句的同时,使用数组依次为占位符指定具体的值</span></span><br><span class="line"><span class="string">db.query(sqlStr, [user.username, user.password, user.id], (err, results) =&gt; &#123;</span></span><br><span class="line"><span class="string">   if (err) return console.log(err.message) // 失败</span></span><br><span class="line"><span class="string">   if (results.affectedRows === 1) &#123;console.log(&#x27;</span>更新数据成功! <span class="string">&#x27;)&#125; //成功</span></span><br></pre></td></tr></table></figure><p><strong>5.更新数据的便捷方式</strong></p><p><strong>更新表数据时,如果数据对象的每个属性和数据表的字段--对应,则可以通过如下方式快速更新表数据:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.要更新的数据对象</span></span><br><span class="line"><span class="keyword">const</span> user = &#123;<span class="attr">id</span>: <span class="number">7</span>, <span class="attr">username</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">password</span>: <span class="string">&#x27;000&#x27;</span> &#125;</span><br><span class="line"><span class="comment">//2.要执行的SQL 语句</span></span><br><span class="line"><span class="keyword">const</span> sqlStr = <span class="string">&#x27;UPDATE users SET ? WHERE id=?&quot;</span></span><br><span class="line"><span class="string">// 3.调用db.query()执行SQL语句的同时,使用数组依次为占位符指定具体的值</span></span><br><span class="line"><span class="string">db.query(sqlStr, [user, user.id], (err, results) =&gt; &#123;</span></span><br><span class="line"><span class="string">   if (err) return console.log(err.message) // 失败</span></span><br><span class="line"><span class="string">   if (results.affectedRows === 1) &#123;console.log(&#x27;</span>更新数据成功! <span class="string">&#x27;)&#125; //成功</span></span><br></pre></td></tr></table></figure><p><strong>6.删除数据</strong></p><p><strong>在删除数据时,推荐根据id这样的唯一标识,来删除对应的数据。示例如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.要执行的SQL语句</span></span><br><span class="line"><span class="keyword">const</span> sqlStr = <span class="string">&#x27;DELETE FROM users WHERE id=?&#x27;</span></span><br><span class="line"><span class="comment">//2.调用db.query()执行SQL语句的同时,为占位符指定具体的值</span></span><br><span class="line"><span class="comment">//注意:如果SQL语句中有多个占位符,则必须使用数组为每个占位符指定具体的值</span></span><br><span class="line"><span class="comment">//如果SQL语句中只有一个占位符,则可以省略数组</span></span><br><span class="line">db.<span class="title function_">query</span>(sqlStr, <span class="number">7</span>, <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>) <span class="comment">// 失败</span></span><br><span class="line">    <span class="keyword">if</span> (results.<span class="property">affectedRows</span>=== <span class="number">1</span>)</span><br><span class="line">     <span class="variable language_">console</span>.1og(<span class="string">&#x27;删除数据成功!&#x27;</span>)&#125; <span class="comment">//成功</span></span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p><strong>7.标记删除</strong></p><p><strong>使用DELETE 语句,会把真正的把数据从表中删除掉。为了保险起见,推荐使用标记删除的形式,来模拟删除的动作。</strong></p><p><strong>所谓的标记删除,就是在表中设置类似于status这样的状态字段,来标记当前这条数据是否被删除。</strong></p><p><strong>当用户执行了删除的动作时,我们并没有执行DELETE 语句把数据删除掉,而是执行了UPDATE语句,将这条数据对应的status字段标记为删除即可。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标记删除:使用UPDATE 语句替代 DELETE 语句;只更新数据的状态,并没有真正删除</span></span><br><span class="line">db.<span class="title function_">query</span>(<span class="string">&#x27;UPDATE USERS SET status=1 WHERE id=?&#x27;</span>, <span class="number">6</span>, <span class="function">(<span class="params">err, results</span>) =&gt;</span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>) <span class="comment">// 失败</span></span><br><span class="line">    <span class="keyword">if</span> (results.<span class="property">affectedRows</span> === <span class="number">1</span>) &#123;<span class="variable language_">console</span>.1og(<span class="string">&#x27;删除数据成功!)&#125;</span></span><br><span class="line"><span class="string">  &#125;)</span></span><br></pre></td></tr></table></figure><h1 id="5-前后端的身份认证"><a href="#5-前后端的身份认证" class="headerlink" title="5.前后端的身份认证"></a><strong>5.前后端的身份认证</strong></h1><p><strong>5.1 Web 开发模式目前主流的Web开发模式有两种,分别是:</strong></p><p><strong>① 基于服务端演染的传统Web开发模式</strong></p><p><strong>②基于前后端分离的新型Web开发模式</strong></p><h2 id="5-1-Web-开发模式"><a href="#5-1-Web-开发模式" class="headerlink" title="5.1 Web 开发模式"></a><strong>5.1 Web 开发模式</strong></h2><p><strong>1.服务端宣染的Web开发模式</strong></p><p><strong>服务端演染的概念:服务器发送给客户端的HTML页面,是在服务器通过字符串的拼接,动态生成的。因此,客户端不需要使用Ajax这样的技术额外请求页面的数据。代码票例如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/index.html&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//1.要演染的数据</span></span><br><span class="line">    <span class="keyword">const</span> user=&#123;<span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> )</span><br><span class="line">    <span class="comment">// 2.服务器端通过字符申的拼接,动态生成HTML内容</span></span><br><span class="line">    <span class="keyword">const</span> html = <span class="string">&#x27;&lt;h1&gt;姓名: $&#123;user.name&#125;, 年龄:$&#123;user.age&#125;&lt;/h1&gt;`</span></span><br><span class="line"><span class="string">    //3.把生成好的页面内容响应给客户端。因此,客户端拿到的是带有真实数据的HTML页面</span></span><br><span class="line"><span class="string">  res.send(html)</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure><p><strong>2.服务端宣染的优缺点</strong></p><p><strong>优点:</strong></p><p><strong>前端耗时少。因为服务器端负责动态生成HTML内容,浏览器只需要直接渲染页面即可。尤其是移动端,更省电。</strong></p><p><strong>有利于SEO。因为服务器端响应的是完整的HTML页面内容,所以爬虫更容易爬取获得信息,更有利于SEO。</strong></p><p><strong>缺点:</strong></p><p><strong>①占用服务器端资源。即服务器端完成HTML页面内容的拼接,如果请求较多,会对服务器造成一定的访问压力。</strong></p><p><strong>②不利于前后端分离,开发效率低。使用服务器端演染,则无法进行分工合作,尤其对于前端复杂度高的项目,不利于项目高效开发。</strong></p><p><strong>3.前后端分离的Web开发模式</strong></p><p><strong>前后端分离的概念:前后端分离的开发模式,依赖于Ajax技术的广泛应用。简而言之,前后端分离的Web开发模式.就是后端只负责提供API接口,前端使用Ajax调用接口的开发模式。</strong></p><p><strong>4.前后端分离的优缺点优点:</strong></p><p><strong>①开发体验好。前端专注于UI页面的开发,后端专注于api的开发,且前端有更多的选择性。</strong></p><p><strong>用户体验好。Ajax技术的广泛应用,极大的提高了用户的体验,可以轻松实现页面的局部刷新。</strong></p><p><strong>减轻了服务器端的渲染压力。因为页面最终是在每个用户的浏览器中生成的。</strong></p><p><strong>缺点:</strong></p><p><strong>不利于SEO。因为完整的HTML页面需要在客户端动态拼接完成,所以爬虫对无法爬取页面的有效信息。(解决方案:利用Vue, React等前端框架的SSR (server side render)技术能够很好的解决SEO问题!)</strong></p><p><strong>5.如何选择Web开发模式</strong></p><p><strong>不谈业务场景而盲目选择使用何种开发模式都是耍流氓。</strong></p><p><strong>比如企业级网站,主要功能是展示而没有复杂的交互,并且需要良好的SEO,则这时我们就需要使用服务器端渲染:</strong></p><p><strong>而类似后台管理项目,交互性比较强,不需要考虑SEO,那么就可以使用前后端分离的开发模式。</strong></p><p><strong>另外,具体使用何种开发模式并不是绝对的,为了同时兼顾了首页的渲染速度和前后端分离的开发效率,一些网站采用了首屏服务器端谊染+其他页面前后端分离的开发模式。</strong></p><h2 id="5-2身份认证"><a href="#5-2身份认证" class="headerlink" title="5.2身份认证"></a><strong>5.2身份认证</strong></h2><p><strong>1.什么是身份认证</strong></p><p><strong>身份认证(Authentication)又称“身份验证”、“鉴权”,是指通过一定的手段,完成对用户身份的确认。</strong></p><p><strong>日常生活中的身份认证随处可见,例如:高铁的验票乘车,手机的密码或指纹解锁,支付宝或微信的支付密码等。</strong></p><p><strong>在Web开发中,也涉及到用户身份的认证,例如:各大网站的手机验证码登录、邮箱密码登录、二维码登录等。</strong></p><p><strong>2.为什么需要身份认证</strong></p><p><strong>身份认证的目的,是为了确认当前所声称为某种身份的用户,确实是所声称的用户。例如,你去找快递员取快递,你要怎么证明这份快递是你的。</strong></p><p><strong>在互联网项目开发中,如何对用户的身份进行认证,是一个值得深入探讨的问题。例如,如何才能保证网站不会错误的将“马云的存款数额”显示到“马化腾的账户”上。</strong></p><p><strong>3.不同开发模式下的身份认证</strong></p><p><strong>对于服务端渲染和前后端分离这两种开发模式来说,分别有着不同的身份认证方案:</strong></p><p><strong>①服务端演染推荐使用Session认证机制</strong></p><p><strong>2.前后端分离推荐使用JWT认证机制</strong></p><h2 id="5-3-Session-认证机制"><a href="#5-3-Session-认证机制" class="headerlink" title="5.3 Session 认证机制"></a><strong>5.3 Session 认证机制</strong></h2><p><strong>1. HTTP 协议的无状态性了解HTTP 协议的无状态性是进一步学习Session认证机制的必要前提。</strong></p><p><strong>HTTP 协议的无状态性,指的是客户端的每次HTTP 请求都是独立的,连续多个请求之间没有直接的关系,服务器不会主动保留每次HTTP 请求的状态。</strong></p><p><strong>2.如何突破HTTP无状态的限制</strong></p><p><strong>对于超市来说,为了方便收银员在进行结算时给VIP用户打折,超市可以为每个VIP用户发放会员卡。</strong></p><p><strong>注意:现实生活中的会员卡身份认证方式,在Web开发中的专业术语叫做Cookie.</strong></p><p><strong>3. 什么是CookieCookie 是存储在用户浏览器中的一段不超过4 KB 的字符串。它由一个名称(Name)、一个值(Value)和其它几个用于控制Cookie有效期、安全性、使用范围的可选属性组成。</strong></p><p><strong>不同域名下的Cookie各自独立,每当客户端发起请求时,会自动把当前域名下所有未过期的Cookie一同发送到服务器。</strong></p><p><strong>Cookie的几大特性:</strong></p><p><strong>① 自动发送</strong></p><p><strong>②域名独立</strong></p><p><strong>③过期时限</strong></p><p><strong>④ 4KB 限制</strong></p><p><strong>4. Cookie 在身份认证中的作用</strong></p><p><strong>客户端第一次请求服务器的时候,服务器通过响应头的形式,向客户端发送一个身份认证的Cookie,客户端会自动将Cookie保存在浏览器中。</strong></p><p><strong>随后,当客户端浏览器每次请求服务器的时候,浏览器会自动将身份认证相关的Cookie,通过请求头的形式发送给服务器,服务器即可验明客户端的身份。</strong></p><p><strong>5. Cookie 不具有安全性</strong></p><p><strong>由于Cookie是存储在浏览器中的,而且浏览器也提供了读写Cookie的API,因此Cookie很容易被伪造,不具有安全性。因此不建议服务器将重要的隐私数据,通过Cookie的形式发送给浏览器。</strong></p><p><strong>注意:干万不要使用Cookie存储重要且隐私的数据!比如用户的身份信息、密码等。</strong></p><p><strong>6.提高身份认证的安全性</strong></p><p><strong>为了防止客户伪造会员卡,收银员在拿到客户出示的会员卡之后,可以在收银机上进行刷卡认证。只有收银机确认存在的会员卡,才能被正常使用。</strong></p><p><strong>这种“会员卡+刷卡认证”的设计理念,就是Session认证机制的精髓。</strong></p><h2 id="5-4-在Express中使用Session认证"><a href="#5-4-在Express中使用Session认证" class="headerlink" title="5.4 在Express中使用Session认证"></a><strong>5.4 在Express中使用Session认证</strong></h2><p><strong>1. 安装 express-session 中间件</strong></p><p><strong>在Express 项目中,只需要安装 express-session中间件,即可在项目中使用Session认证:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express-session</span><br></pre></td></tr></table></figure><p><strong>2.配置 express-session 中间件express-session 中间件安装成功后,需要通过app.use()来注册 session中间件,示例代码如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 导入 session 中间件</span></span><br><span class="line"><span class="keyword">var</span> session = <span class="built_in">require</span>(<span class="string">&#x27;express-session&#x27;</span>)</span><br><span class="line"><span class="comment">// 2.配置Session中问件</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">session</span>(&#123;</span><br><span class="line">    <span class="attr">secret</span>: <span class="string">&#x27;keyboard cat&#x27;</span>, <span class="comment">// secret 属性的值可以为任意字符串</span></span><br><span class="line">    <span class="attr">resave</span>: <span class="literal">false</span>, <span class="comment">//固定写法</span></span><br><span class="line">    <span class="attr">saveUninitialized</span>: <span class="literal">true</span> <span class="comment">// 固定写法</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p><strong>3.向session中存数据</strong></p><p><strong>当express-session中间件配置成功后,即可通过req.session来访问和使用session对象,从而存储用户的关健信息:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/api/login&#x27;</span>, <span class="function">(<span class="params">req, res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//判断用户提交的登录信息是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (req.<span class="property">body</span>.<span class="property">username</span> !==<span class="string">&#x27;admin&#x27;</span> || req.<span class="property">body</span>.<span class="property">password</span> !== <span class="string">&#x27;000000&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">send</span>(&#123; <span class="attr">status</span>:<span class="number">1</span> <span class="attr">msg</span>: <span class="string">&#x27;登录失败&#x27;</span>&#125; )&#125;</span><br><span class="line">    req.<span class="property">session</span>.<span class="property">user</span>=req.<span class="property">body</span> <span class="comment">//将用户的信息,存储到 Session中</span></span><br><span class="line">    req.<span class="property">session</span>.<span class="property">islogin</span>=<span class="literal">true</span> <span class="comment">//将用户的登录状志,存储到Session中</span></span><br><span class="line">    res.<span class="title function_">send</span>(&#123; <span class="attr">status</span>: <span class="number">0</span>, <span class="attr">msg</span>: <span class="string">&#x27;登录成功&#x27;</span> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>4. 从 session中取数据</strong></p><p><strong>可以直接从req.session对象上获取之前存储的数据,示例代码如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取用户姓名的接口</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/api/username&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//判断用户是否登录</span></span><br><span class="line">    <span class="keyword">if</span> (!req.<span class="property">session</span>.<span class="property">islogin</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">send</span>(&#123;<span class="attr">status</span>: <span class="number">1</span>, <span class="attr">msg</span>: <span class="string">&#x27;fail&#x27;</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">send</span>(&#123; <span class="attr">status</span>: <span class="number">0</span>, <span class="attr">msg</span>: <span class="string">&#x27;success&#x27;</span>, <span class="attr">username</span>: req.<span class="property">session</span>.<span class="property">user</span>.<span class="property">username</span> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>5. 清空session</strong></p><p><strong>调用req.session.destroy()函数,即可清空服务器保存的session信息。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//退出登录的接口</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/api/logout&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//清空当前客户端对应的session信息</span></span><br><span class="line">    req.<span class="property">session</span>.<span class="title function_">destroy</span>() </span><br><span class="line">    res.<span class="title function_">send</span>(&#123;<span class="attr">status</span>: <span class="number">0</span>,<span class="attr">msg</span>: <span class="string">&#x27;退出登录成功&#x27;</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="5-5-JWT-认证机制"><a href="#5-5-JWT-认证机制" class="headerlink" title="5.5 JWT 认证机制"></a><strong>5.5 JWT 认证机制</strong></h2><p><strong>1.了解Session认证的局限性</strong></p><p><strong>Session认证机制需要配合 Cookie才能实现。由于Cookie默认不支持跨域访问,所以,当涉及到前端跨域请求后端接口的时候,需要做很多额外的配置,才能实现跨域Session认证。</strong></p><p><strong>注意:</strong></p><p><strong>当前端请求后端接口不存在跨域问题的时候,推荐使用Session身份认证机制。</strong></p><p><strong>当前端需要跨域请求后端接口的时候,不推荐使用Session身份认证机制,推荐使用JWT认证机制。</strong></p><p><strong>2. 什么是JWTJWT(英文全称: JSON Web Token)是目前最流行的跨域认证解决方案。</strong></p><p><strong>3. JWT 的工作原理</strong></p><p><strong>总结:用户的信息通过Token字符串的形式,保存在客户端浏览器中。服务器通过还原Token字符串的形式来认证用户的身份。</strong></p><p><strong>4. JWT 的组成部分</strong></p><p><strong>JWT通常由三部分组成,分别是Header (头部)、Payload (有效荷载)、Signature (签名)。</strong></p><p><strong>三者之间使用英文的“."分隔,格式如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Header</span>.<span class="property">Payload</span>.<span class="property">Signature</span></span><br></pre></td></tr></table></figure><p><strong>下面是JWT字符串的示例:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGcioiJIUZI1NiIsInR5cCI6IkpxVCJ9.<span class="property">yJpZCI6MSwidXN1cmShbwuioiJhzG1pbiIsInBhc3N3b3JkIjoiliwibmlja25hbWUi0iLms6X1t7T1t7QiLCJlbWFpbCI6Im5pYmFiYUBpdGNhc3QuY24iLCJ1c2VyX3BpYyI61iIsImlhdCI6MTU30DAZNJY4Miw1ZXhwIjoxNTC4MDcyNjgyfwq7GqCXJPK</span>-<span class="title class_">EA8LNrtMG</span>0411Kdz3359KBL3XeuBxuI</span><br></pre></td></tr></table></figure><p><strong>6. JWT 的三个部分各自代表的含义</strong></p><p><strong>JWT 的三个组成部分,从前到后分别是 Header, Payload, Signature.</strong></p><p><strong>其中:</strong></p><p><strong>Payload 部分才是真正的用户信息,它是用户信息经过加密之后生成的字符串。</strong></p><p><strong>Header 和Signature 是安全性相关的部分,只是为了保证Token的安全性。</strong></p><p><strong>7. JWT 的使用方式</strong></p><p><strong>客户端收到服务器返回的JWT 之后,通常会将它储存在localStorage 或 sessionStorage中。</strong></p><p><strong>此后,客户端每次与服务器通信,都要带上这个JWT的字符串,从而进行身份认证。推荐的做法是把JWT放在HTTP请求头的Authorization字段中,格式如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Authorization</span>: <span class="title class_">Bearer</span> &lt;token&gt;</span><br></pre></td></tr></table></figure><p><strong>5.6 在Express 中使用JWT</strong></p><p><strong>1.安装JWT相关的包运行如下命令,安装如下两个JWT相关的包:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install jsonwebtoken express-jwt</span><br></pre></td></tr></table></figure><p><strong>jsonwebtoken 用于生成 JWT 字符串</strong></p><p><strong>express-jwt 用于将 JWT 字符串解析还原成 JSON对象</strong></p><p><strong>2.导入JWT 相关的包</strong></p><p><strong>使用require()函数,分别导入JWT相关的两个包:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入用于生成JWT 字符串的包</span></span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>)</span><br><span class="line"><span class="comment">//2.导入用于将客户端发送过来的JWT字符串,解析还原成 JSON对象的包</span></span><br><span class="line"><span class="keyword">const</span> express_jwT = <span class="built_in">require</span>(<span class="string">&#x27;express-jwt&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>3.定义secret密钥</strong></p><p><strong>为了保证JWT字符串的安全性,防止JWT字符串在网络传输过程中被别人破解,我们需要专门定义一个用于加密和解密的secret密钥:</strong></p><p><strong>①当生成JWT字符串的时候,需要使用secret密钥对用户的信息进行加密,最终得到加密好的JWT字符串</strong></p><p><strong>②当把JWT字符串解析还原成JSON对象的时候,需要使用secret密钥进行解密</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. secret 密的本质:就是一个字符串</span></span><br><span class="line"><span class="keyword">const</span> secretKey = <span class="string">&#x27;itheima No1&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>4.在登录成功后生成 JWT字符串</strong></p><p><strong>调用jsonwebtoken包提供的sign()方法,将用户的信息加密成JWT字符串,响应给客户端:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//登录接口</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/api/login&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>)&#123;</span><br><span class="line"> <span class="comment">//...省略登录失败情况下的代码</span></span><br><span class="line">  <span class="comment">//用户登录成功之后,生成 JWT字符申,通过token属性响应给客户 </span></span><br><span class="line">  res.<span class="title function_">send</span>(&#123;<span class="attr">status</span>: <span class="number">200</span>,<span class="attr">message</span>: <span class="string">&#x27;登录成功!&#x27;</span>,</span><br><span class="line">  <span class="comment">//调用jwt,sign()生成JwT字符串,三个参数分别是:用户信息对象、加密密销、配置对象</span></span><br><span class="line">  <span class="attr">token</span>: jwt.<span class="title function_">sign</span>(&#123;<span class="attr">username</span>:userinfo.<span class="property">username</span>&#125;, secretKey, &#123; <span class="attr">expiresIn</span>: <span class="string">&#x27;30s&#x27;</span> &#125;)</span><br><span class="line">       &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>5.将JWT 字符串还原为JSON对象</strong></p><p><strong>客户端每次在访问那些有权限接口的时候,都需要主动通过请求头中的Authorization字段,将Token字符串发送到服务器进行身份认证。</strong></p><p><strong>此时,服务器可以通过express-jwt这个中间件,自动将客户端发送过来的Token解析还原成JSON对象:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用app.use()来注册中间件</span></span><br><span class="line"><span class="comment">// expressJWT(&#123;secret: secretKey &#125;)就是用来解析 Token 中件</span></span><br><span class="line"><span class="comment">// .unless(&#123;path: [/^\/api\//] &#125;)用来指定哪些接口不需要访问权限</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">expressJWT</span>(&#123; <span class="attr">secret</span>: secretKey,<span class="attr">algorithms</span>: [<span class="string">&#x27;HS256&#x27;</span>] &#125;).<span class="title function_">unless</span>(&#123; <span class="attr">path</span>: [<span class="regexp">/^\/api\//</span>]&#125;))</span><br></pre></td></tr></table></figure><p><strong>6.使用req.user获取用户信息</strong></p><p><strong>当express-jwt这个中间件配置成功之后,即可在那些有权限的接口中,使用req.user对象,来访问从JWT字符串中解析出来的用户信息了,示例代码如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个有权限的API接口</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/admin/getinfo&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">user</span>)</span><br><span class="line">    res.<span class="property">send</span> (&#123;</span><br><span class="line">        <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&#x27;获取用户信息成功!&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>: req.<span class="property">user</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>7.捕获解析JWT失败后产生的错误</strong></p><p><strong>当使用express-jwt 解析Token字符串时,如果客户端发送过来的Token字符串过期或不合法,会产生一个解析失败的错误,影响项目的正常运行。我们可以通过Express的错误中间件,捕获这个错误并进行相关的处理,示例代码如下:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">err, req, res, next</span>) =&gt;</span>&#123;</span><br><span class="line"> <span class="comment">// token 解析失败导致的错误</span></span><br><span class="line">  <span class="keyword">if</span>(err.<span class="property">name</span>=== <span class="string">&#x27;UnauthorizedError&#x27;</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> res.<span class="title function_">send</span>(&#123; <span class="attr">status</span>: <span class="number">401</span>, <span class="attr">message</span>: <span class="string">&#x27;无效的token&#x27;</span> &#125;)&#125;</span><br><span class="line">  <span class="comment">//其它原因导致的错误</span></span><br><span class="line">    res.<span class="title function_">send</span>(&#123; <span class="attr">status</span>: <span class="number">500</span>, <span class="attr">message</span>: <span class="string">&#x27;未知错误&#x27;</span> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodeJs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery</title>
      <link href="/2024/03/13/jquery/"/>
      <url>/2024/03/13/jquery/</url>
      
        <content type="html"><![CDATA[<h1 id="1-jQuery概述"><a href="#1-jQuery概述" class="headerlink" title="1.jQuery概述"></a>1.jQuery概述</h1><h2 id="1-1-JavaScript库"><a href="#1-1-JavaScript库" class="headerlink" title="1.1 JavaScript库"></a>1.1 JavaScript库</h2><p><strong>仓库:可以把很多东西放到这个仓库里面。找东西只需要到仓库里面查找到就可以了。</strong></p><p><strong>JavaScript库: 即library ,是一个封装好的特定的集合(方法和函数)。从封装一大堆函数的角度理解库,就是在这个库中,封装了很多预先定义好的函数在里面,比如动画animate, hide, show ,比如获取元素等。</strong></p><p><strong>简单理解:就是一个JS文件,里面对我们原生j代码进行了封装,存放到里面。这样我们可以快速高效的使用这些封装好的功能了。</strong></p><p><strong>比如jQuery,就是为了快速方便的操作DOM,里面基本都是函数(方法)。</strong></p><p><strong>常见的Javascript库</strong></p><p><strong>jQuery</strong></p><p><strong>Prototype</strong></p><p><strong>YUI</strong></p><p><strong>Dojo</strong></p><p><strong>Ext JS</strong></p><p><strong>移动端的zepto</strong></p><p><strong>这些库都是对原生JavaScript的封装,内部都是用JavaScript实现的,我们主要学习的是jQuery.</strong></p><h2 id="1-2-jQuery的概念"><a href="#1-2-jQuery的概念" class="headerlink" title="1.2 jQuery的概念"></a>1.2 jQuery的概念</h2><p><strong>jQuery是一个快速、简洁的JavaScript库,其设计的宗旨是”write Less , Do More” ,即倡导写更少的代码,做更多的事情。</strong></p><p><strong>j就是JavaScript; Query查询;意思就是查询js ,把js中的DOM操作做了封装,我们可以快速的查询使用里面的功能。</strong></p><p><strong>jQuery封装了JavaScript常用的功能代码,优化了DOM操作、事件处理、动画设计和Ajax交互。</strong></p><p><strong>jQuery出现的目的是加快前端人员的开发速度,我们可以非常方便的调用和使用它,从而提高开发效率。</strong></p><h2 id="1-2-jQuery的优点"><a href="#1-2-jQuery的优点" class="headerlink" title="1.2 jQuery的优点"></a>1.2 jQuery的优点</h2><p><strong>优点轻量级。核心文件才几+kb,不会影响页面加载速度</strong></p><p><strong>跨浏览器兼容。基本兼容了现在主流的浏览器</strong></p><p><strong>链式编程、隐式迭代</strong></p><p><strong>对事件、样式、动画支持,大大简化了DOM操作</strong></p><p><strong>支持插件扩展开发。有着丰富的第三方的插件,例如:树形菜单、日期控件、轮播图等</strong></p><p><strong>免费、开源</strong></p><h2 id="2-1-jQuery的下载"><a href="#2-1-jQuery的下载" class="headerlink" title="2.1 jQuery的下载"></a>2.1 jQuery的下载</h2><p><strong>官网地址: <a href="https://jquery.com/">https://jquery.com/</a></strong></p><p><strong>版本：</strong></p><p><strong>1x :兼容IE 678等低版本浏览器,官网不再更新</strong></p><p><strong>2x:不兼容1E678等低版本浏览器,官网不再更新</strong></p><p><strong>3x :不兼容IE 678等低版本浏览器,是官方主要更新维护的版本</strong></p><p><strong>各个版本的下载: <a href="https://code.jquery.com/">https://code.jquery.com/</a></strong></p><h1 id="2-jQuery的基本使用"><a href="#2-jQuery的基本使用" class="headerlink" title="2.jQuery的基本使用"></a>2.jQuery的基本使用</h1><h2 id="2-3-jQuery的入口函数"><a href="#2-3-jQuery的入口函数" class="headerlink" title="2.3 jQuery的入口函数"></a>2.3 jQuery的入口函数</h2><p><strong>$ (function () {</strong></p><p><strong>………&#x2F;&#x2F;此处是页面DOM加载完成的入口</strong></p><p> <strong>});</strong></p><p><strong>$ (document) .ready (function () {</strong></p><p><strong>..&#x2F;&#x2F;此处是页面DOM載完成的入口</strong></p><p><strong>});</strong></p><p><strong>1,等着DOM结构渲染完毕即可执行内部代码,不必等到所有外部资源加载完成, jQuery帮我们完成了封装。</strong></p><p><strong>2,相当于原生js中的DOMContentloaded,</strong></p><p><strong>3,不同于原生js中的load事件是等页面文档、外部的js文件、css文件、图片加载完毕才执行内部代码。</strong></p><p><strong>4,更推荐使用第一种方式</strong></p><h2 id="2-4-jQuery的顶级对象"><a href="#2-4-jQuery的顶级对象" class="headerlink" title="2.4 jQuery的顶级对象$"></a>2.4 jQuery的顶级对象$</h2><p><strong>1.$是jQuery的别称,在代码中可以使用jQuery代替$,但一般为了方便,通常都直接使用$。</strong></p><p><strong>2.$是jQuery的顶级对象,相当于原生JavaScript中的window,把元素利用包装成Query对象,就可以调用jQuery的方法。</strong></p><h2 id="2-5-jQuery对象和DOM对象"><a href="#2-5-jQuery对象和DOM对象" class="headerlink" title="2.5 jQuery对象和DOM对象"></a>2.5 jQuery对象和DOM对象</h2><p><strong>DOM对象: 用原生js获取过来的对象就是DOM对象</strong></p><p> <strong>jQuery对象: 用jquery方式获取过来的对象是iQuery对象。</strong></p><p><strong>本质:通过$把DOM元素进行了包装（伪数组形式存储)。</strong></p><p><strong>jquery对象只能使用jQuery方法, DOM对象则使用原生的Javascirpt属性和方法</strong></p><p><strong>DOM对象与jQuery对象之间是可以相互转换的。</strong></p><p><strong>因为原生js比jQuery更大,原生的一些属性和方法jQuery没有给我们封装.要想使用这些属性和方法需要把. jQuery对象转换为DOM对象才能使用。</strong></p><p><strong>1.DOM对象转换为jQuery对象: $(DOM对象)</strong></p><p><strong>$(‘div’)</strong></p><p><strong>2.jQuery对象转换为DOM对象(两种方式)</strong></p><p><strong>$(‘div’) [index]  index是索引号</strong></p><p><strong>$(‘div’).get(index) index是索引号</strong></p><h1 id="jQuery常用API"><a href="#jQuery常用API" class="headerlink" title="jQuery常用API"></a><strong>jQuery常用API</strong></h1><h2 id="1-jQuery选择器"><a href="#1-jQuery选择器" class="headerlink" title="1.jQuery选择器"></a>1.jQuery选择器</h2><h3 id="1-1-jQuery基础选择器"><a href="#1-1-jQuery基础选择器" class="headerlink" title="1.1 jQuery基础选择器"></a>1.1 jQuery基础选择器</h3><p><strong>原生j S获取元素方式很多,很杂,而且兼容性情况不一致,因此jQuery给我们做了封装,使获取元素统一标准。</strong></p><p><strong>$( “选择器” ) &#x2F;&#x2F;里面选择器直接写CSS选择器即可,但是要加引号</strong></p><p><strong>名称用法  描述</strong></p><p><strong>ID选择器$(“#id”)获取指定ID的元素</strong></p><p><strong>全选选择器$(*) 匹配所有元素</strong></p><p><strong>类选择器$(“.class”)获取同一类class的元素</strong></p><p><strong>标签选择器$(“div”)获取同一类标签的所有元素</strong></p><p><strong>并集选择器$(“div,p,li”)选取多个元素</strong></p><p><strong>交集选择器$(“li.current”)交集元素</strong></p><h2 id="1-2-jQuery层级选择器"><a href="#1-2-jQuery层级选择器" class="headerlink" title="1.2 jQuery层级选择器"></a>1.2 jQuery层级选择器</h2><p><strong>名称用法 描述</strong></p><p><strong>子代选择器$(“ul&gt;li”); 使用&gt;号,获取亲儿子层级的元素;注意,并不会获取孙子层级的元素</strong></p><p><strong>后代选择器 $(“ul li”); 使用空格,代表后代选择器,获取ul下的所有元素,包括孙子等</strong></p><h3 id="知识铺垫"><a href="#知识铺垫" class="headerlink" title="知识铺垫"></a>知识铺垫</h3><p><strong>jQuery设置样式</strong></p><p><strong>$(‘div’).css(‘属性’,’值’)</strong></p><h2 id="1-3隐式迭代-重要"><a href="#1-3隐式迭代-重要" class="headerlink" title="1.3隐式迭代(重要)"></a>1.3隐式迭代(重要)</h2><p><strong>遍历内部DOM元素(伪数组形式存储)的过程就叫做隐式迭代。</strong></p><p><strong>简单理解:给匹配到的所有元素进行循环遍历,执行相应的方法,而不用我们再进行循环,简化我们的操作,方便我们调用。</strong></p><h2 id="1-4-jQuery筛选选择器"><a href="#1-4-jQuery筛选选择器" class="headerlink" title="1.4 jQuery筛选选择器"></a>1.4 jQuery筛选选择器</h2><p><strong>语法用法描述</strong></p><p><strong>:first$(‘li:first’)获取第一个li元素</strong></p><p><strong>:last$(‘li:last’) 获取最后一个元素</strong></p><p><strong>:eq(index)   $(“li:eq(2)”)   获取到的li元素中,选择索引号为2的元素,索引号index从0开始。</strong></p><p><strong>:odd$(“li:odd”) 获取到的li元素中,选择索引号为奇数的元素</strong></p><p><strong>:even$(“li:even”)  获取到的li元素中,选择索引号为偶数的元素</strong></p><h2 id="1-5-jQuery-筛选方法-重点"><a href="#1-5-jQuery-筛选方法-重点" class="headerlink" title="1.5 jQuery 筛选方法( 重点)"></a>1.5 jQuery 筛选方法( 重点)</h2><p><strong>语法用法说明</strong></p><p><strong>parent()$(“li”).parent();查找父级</strong></p><p><strong>children(selector)  $(“ul”).children(“li”)相当于$(“ul&gt;li”),最近一级(亲儿子)</strong></p><p><strong>find(selector)  $(“ul”).find(“li”);相当于$(“ul li”),后代选择器</strong></p><p><strong>siblings(selector)   $(“.first”).siblings(“li”);查找兄弟节点,不包括自己本身</strong></p><p><strong>nextAll ([expr])$(“.first”).nextAll()查找当前元素之后所有的同辈元素</strong></p><p><strong>prevAll ([expr])$(“.last”).prevAll()查找当前元素之前所有的同辈元素</strong></p><p><strong>hasClass(class)$(‘div’).hasClass (“protected”)检查当前的元素是否含有某个特定的类,如果有,则返回true</strong></p><p><strong>eq(index)$(“li”).eq(2);相当于s(“li :eq (2)”), index从0开始</strong></p><p><u><strong>重点记住: parent() children() find() siblings() eq()</strong></u></p><h2 id="1-6-jQuery里面的排他思想"><a href="#1-6-jQuery里面的排他思想" class="headerlink" title="1.6 jQuery里面的排他思想"></a>1.6 jQuery里面的排他思想</h2><p><strong>想要多选一的效果,排他思想:当前元素设置样式,其余的兄弟元素清除样式。</strong></p><h2 id="1-5链式编程"><a href="#1-5链式编程" class="headerlink" title="1.5链式编程"></a>1.5链式编程</h2><p><strong>链式编程是为了节省代码量,看起来更优雅。</strong></p><p><strong>$(this).css(&#96;color’, ‘red’).sibling().css(‘color’, ‘ ‘);</strong> </p><p><strong>使用链式编程一定注意是哪个对象执行样式</strong></p><h2 id="2-1操作css方法"><a href="#2-1操作css方法" class="headerlink" title="2.1操作css方法"></a>2.1操作css方法</h2><p><strong>jQuery可以使用css方法来修改简单元素样式;也可以操作类,修改多个样式。</strong> </p><p><strong>1·参数只写属性名,则是返回属性值</strong></p><p><strong>$(this). css(“color”);</strong></p><p><strong>2,参数是属性名,属性值,逗号分隔,是设置一组样式,属性必须加引号,值如果是数字可以不用跟单位和引号</strong></p><p><strong>$(this).css(color”, “red”);</strong></p><p><strong>3,参数可以是对象形式,方便设置多组样式。属性名和属性值用冒号隔开,属性可以不用加引号,</strong></p><p><strong>$(this).css({color:”white”, “font-size”:”20px”});</strong></p><h2 id="2-2设置类样式方法"><a href="#2-2设置类样式方法" class="headerlink" title="2.2设置类样式方法"></a>2.2设置类样式方法</h2><p><strong>作用等同于以前的classlist, 可以操作类样式,注意操作类里面的参数不要加点。</strong></p><p><strong>1.添加类</strong></p><p><strong>$( “div” ).addClass(“current”);</strong></p><p><strong>2．移除类</strong></p><p><strong>$( “div” ).removeClass(“current”);</strong></p><p><strong>3.切换类</strong></p><p><strong>$( “div” ).toggleClass(“current”);</strong></p><h2 id="2-3类操作与className区别"><a href="#2-3类操作与className区别" class="headerlink" title="2.3类操作与className区别"></a>2.3类操作与className区别</h2><p><strong>原生IS 中className会覆盖元素原先里面的类名。</strong></p><p><strong>jQuery里面类操作只是对指定类进行操作,不影响原先的类名</strong>。</p><h1 id="3-jQuery效果"><a href="#3-jQuery效果" class="headerlink" title="3.jQuery效果"></a>3.jQuery效果</h1><p> <strong>jQuery给我们封装了很多动画效果,最为常见的如下:</strong></p><p><strong>显示隐藏</strong></p><p><strong>show()</strong></p><p><strong>hide()</strong></p><p><strong>toggle()</strong></p><p><strong>滑动</strong></p><p><strong>slideDown()</strong></p><p><strong>slideUpl()</strong></p><p><strong>slideToggle()</strong></p><p><strong>淡入淡出</strong></p><p><strong>fadeln()</strong></p><p><strong>fadeOut()</strong></p><p><strong>fadeToggle()</strong> </p><p><strong>fadeTo()</strong></p><p><strong>自定义动画</strong></p><p><strong>animate()</strong></p><h2 id="3-1显示隐藏效果"><a href="#3-1显示隐藏效果" class="headerlink" title="3.1显示隐藏效果"></a>3.1显示隐藏效果</h2><p><strong>1,显示语法规范</strong></p><p><strong>show ([speed, [easing] , [fn]]</strong></p><p><strong>hide ( [speed, [easing] , [fn]])</strong></p><p><strong>2.显示参数</strong></p><p><strong>(1)参数都可以省略,无动画直接显示。</strong></p><p><strong>(2) speed:三种预定速度之一的字符串( “slow”, “normal” ,or “fast” )或表示动画时长的毫秒数值(如: 1000)</strong></p><p><strong>(3) easing : (Optional)用来指定切换效果,默认是”swing” ,可用参数”inear”</strong></p><p><strong>(4) fn:回调函数,在动画完成时执行的函数,每个元素执行一次。</strong></p><h2 id="3-2滑动效果"><a href="#3-2滑动效果" class="headerlink" title="3.2滑动效果"></a>3.2滑动效果</h2><p><strong>1,下滑效果语法规范</strong></p><p><strong>slidepown ( [speed, [easing], [fn]])</strong></p><p><strong>2.上滑效果语法规范</strong></p><p><strong>slideup ( [speed, [easing], [fn]])</strong></p><p><strong>3滑动切换效果语法规范</strong></p><p><strong>slideToggle ( [speed, [easing), [fn]])</strong></p><p><strong>4,下滑上滑切换效果参数</strong></p><p><strong>(1)参数都可以省略。</strong></p><p><strong>(2) speed:三种预定速度之一的字符串(“slow”, “normal”,or “fast” )或表示动画时长的毫秒数值(如: 1000)</strong></p><p><strong>(3) easing:Optional)用来指定切换效果,默认是”swing” ,可用参数”linear</strong></p><p><strong>(4) fn:回调函数,在动画完成时执行的函数,每个元素执行一次。</strong></p><h2 id="3-3事件切换"><a href="#3-3事件切换" class="headerlink" title="3.3事件切换"></a>3.3事件切换</h2><p><strong>hoverl([over,]out)</strong></p><p><strong>(1) over:标移到元素上要触发的函数(相当mouseenter )</strong></p><p><strong>(2) out:鼠标移出元素要触发的函数(相当于mouseleave)</strong></p><h2 id="3-4动画队列及其停止排队方法"><a href="#3-4动画队列及其停止排队方法" class="headerlink" title="3.4动画队列及其停止排队方法"></a>3.4动画队列及其停止排队方法</h2><p><strong>1·动画或效果队列·</strong></p><p> <strong>动画或者效果一旦触发就会执行,如果多次触发,就造成多个动画或者效果排队执行。</strong></p><p><strong>2·停止排队stop()</strong></p><p><strong>(1) stop()方法用于停止动画或效果。</strong></p><p><strong>(2)注意: stop()写到动画或者效果的前面,相当于停止结束上一次的动画。</strong></p><h2 id="3-5淡入淡出效果"><a href="#3-5淡入淡出效果" class="headerlink" title="3.5淡入淡出效果"></a>3.5淡入淡出效果</h2><p><strong>1,淡入效果语法规范</strong></p><p><strong>fadeIn ([speed, [easing), [fn]])</strong></p><p><strong>1,淡出效果语法规范</strong></p><p><strong>fadeout ( [speed, [easing], [fn])</strong></p><p><strong>1,淡入淡出切换效果语法规范</strong></p><p><strong>fadeToggle ( Ispeed, [easing), (fn])</strong></p><p><strong>2·淡入效果参数</strong></p><p><strong>(1)参数都可以省略。</strong></p><p><strong>(2) speed:三种预定速度之一的字符串( “slow” , “normal” ,or “fast” )或表示动画时长的毫秒数值(如: 1000),</strong></p><p><strong>(3) easing : (Optional)用来指定切换效果,默认是”swing” ,可用参数”linear”</strong></p><p><strong>(4) fn:回调函数,在动画完成时执行的函数,每个元素执行一次。</strong></p><p><strong>1·渐进方式调整到指定的不透明度</strong></p><p><strong>fadeTo ( [ [speed], opacity, [easing] , [fn]])</strong></p><p><strong>2·效果参数</strong></p><p><strong>(1) opacity透明度必须写,取值0-1之间。</strong></p><p><strong>(2) speed :三种预定速度之一的字符串( “slow” , “normal” ,or “fast” )或表示动画时长的毫秒数值(如: 1000)。必须写</strong></p><p><strong>(3) easing : (Optional)用来指定切换效果,默认是”swing” ,可用参数”linear”</strong></p><p><strong>(4) fn:回调函数,在动画完成时执行的函数,每个元素执行一次。</strong></p><h2 id="3-6自定义动画animate"><a href="#3-6自定义动画animate" class="headerlink" title="3.6自定义动画animate"></a>3.6自定义动画animate</h2><p><strong>1.语法</strong></p><p><strong>animate (params, [speed] , [easing], [fn])</strong></p><p><strong>2.参数</strong></p><p><strong>(1) params:想要更改的样式属性,以对象形式传递,必须写。属性名可以不用带引号,如果是复合属性则需要采取驼峰命名法borderleft,其余参数都可以省略。</strong></p><p><strong>(2) speed:三种预定速度之一的字符串( “slow” , “normal” , or “fast”)或表示动画时长的毫秒数值(如:1000),</strong></p><p><strong>(3) easing : (Optional)用来指定切换效果,默认是”swing” ,可用参数”inear”</strong></p><p><strong>(4) fn:回调函数,在动画完成时执行的函数,每个元素执行一次。</strong></p><h2 id="5-jQuery属性操作"><a href="#5-jQuery属性操作" class="headerlink" title="5.jQuery属性操作"></a>5.jQuery属性操作</h2><h3 id="5-1设置或获取元素固有属性值prop"><a href="#5-1设置或获取元素固有属性值prop" class="headerlink" title="5.1设置或获取元素固有属性值prop()"></a>5.1设置或获取元素固有属性值prop()</h3><p><strong>所谓元素固有属性就是元素本身自带的属性,比如<a>元素里面的href ,比如<input>元素里面的type.</strong></p><p><strong>1,获取属性语法</strong></p><p><strong>prop(“属性”)</strong></p><p><strong>2、设置属性语法</strong></p><p><strong>prop(“属性”,”属性值”)</strong></p><h2 id="5-2设置或获取元素自定义属性值attr"><a href="#5-2设置或获取元素自定义属性值attr" class="headerlink" title="5.2设置或获取元素自定义属性值attr()"></a>5.2设置或获取元素自定义属性值attr()</h2><p><strong>用户自己给元素添加的属性,我们称为自定义属性。比如给div添加index &#x3D;”1”</strong></p><p><strong>1,获取属性语法</strong></p><p><strong>attr(“属性”) &#x2F;&#x2F;类似原生getAttribute()</strong></p><p><strong>2.设置属性语法</strong></p><p><strong>attr(“属性,”属性值”) &#x2F;&#x2F;类似原生setAttribute()</strong></p><p><strong>改方法也可以获取H5自定义属性</strong></p><h2 id="5-3数据缓存data"><a href="#5-3数据缓存data" class="headerlink" title="5.3数据缓存data()"></a>5.3数据缓存data()</h2><p><strong>data()方法可以在指定的元素上存取数据,并不会修改DOM元素结构。一旦页面刷新,之前存放的数据都将被移除</strong></p><h2 id="6-jQuery内容文本值"><a href="#6-jQuery内容文本值" class="headerlink" title="6.jQuery内容文本值"></a>6.jQuery内容文本值</h2><p><strong>主要针对元素的内容还有表单的值操作。</strong></p><p><strong>1.普通元素内容html() (相当原生inner HTML)</strong></p><p><strong>html()&#x2F;&#x2F;获取元素的内容</strong></p><p><strong>html(“内容”) &#x2F;&#x2F;获取设置元素文本内容</strong></p><p><strong>2,普通元素文本内容text() (相当与原生innerText)</strong></p><p><strong>text()&#x2F;&#x2F;获取元素的文本内容</strong></p><p><strong>text(“文本内容”) &#x2F;&#x2F;设置元素的文本内容</strong></p><p><strong>3,表单的值val() (相当于原生value)</strong></p><p><strong>val(“赋值”) &#x2F;&#x2F;设置表单的值</strong></p><p><strong>parents(“.p-num”) 返回指定的祖先元素</strong></p><p><strong>toFixed(2) 可以让我们保留2位小数</strong></p><h2 id="6-jQuery元素"><a href="#6-jQuery元素" class="headerlink" title="6.jQuery元素"></a>6.jQuery元素</h2><p><strong>操作主要是遍历、创建、添加、删除元素操作。</strong></p><h3 id="6-1遍历元素"><a href="#6-1遍历元素" class="headerlink" title="6.1遍历元素"></a>6.1遍历元素</h3><p><strong>jQuery隐式迭代是对同一类元素做了同样的操作。如果想要给同一类元素做不同操作,就需要用到遍历.</strong></p><p><strong>语法1：</strong></p><p><strong>$(“div”).each (function (index, domEle) (xxx; })</strong></p><p><strong>1, each0方法遍历匹配的每一个元素,主要用DOM处理, each每一个</strong></p><p><strong>2,里面的回调函数有2个参数: index是每个元素的索引号; demEle是每个DOM元素对象,不是jquery对象</strong></p><p><strong>语法2:</strong></p><p><strong>$.each (object, function (inde, element) { xxx; ))</strong></p><p><strong>1.$.each()方法可用于遍历任何对象。主要用于数据处理,比如数组,对象</strong></p><p><strong>2.里面的函数有2个参数: index是每个元素的索引号; element遍历内容</strong></p><h3 id="6-2创建元素"><a href="#6-2创建元素" class="headerlink" title="6.2创建元素"></a>6.2创建元素</h3><p><strong>语法</strong></p><p><strong>$(“(<li> </li>“);</strong></p><p><strong>动态的创建了一个<li></strong></p><h3 id="6-3添加元素"><a href="#6-3添加元素" class="headerlink" title="6.3添加元素"></a>6.3添加元素</h3><p><strong>1.内部添加</strong></p><p><strong>element.append(“内容”)</strong></p><p><strong>把内容放入匹配元素内部最后面,类似原生appendChild.</strong></p><p><strong>2.外部添加</strong></p><p><strong>element.after(内容”) &#x2F;&#x2F;把内容放入目标元素后面</strong></p><p><strong>element.before(“内容) &#x2F;&#x2F;把内容放入目标元素前面</strong></p><p><strong>内部添加元素，生成之后，它们是父子关系。</strong></p><p><strong>外部添加元素,生成之后,他们是兄弟关系。</strong></p><h3 id="6-4删除元素"><a href="#6-4删除元素" class="headerlink" title="6.4删除元素"></a><strong>6.4删除元素</strong></h3><p><strong>element.remove() &#x2F;&#x2F;删除匹配的元素(本身)</strong></p><p><strong>element.empty() &#x2F;&#x2F;删除匹配的元素集合中所有的子节点</strong></p><p><strong>element.html(“”) &#x2F;&#x2F;清空匹配的元素内容</strong></p><h2 id="7-jQuery尺寸、位置操作"><a href="#7-jQuery尺寸、位置操作" class="headerlink" title="7.jQuery尺寸、位置操作"></a>7.jQuery尺寸、位置操作</h2><h3 id="7-1-jQuery尺寸"><a href="#7-1-jQuery尺寸" class="headerlink" title="7.1 jQuery尺寸"></a>7.1 jQuery尺寸</h3><p><strong>语法用法</strong></p><p><strong>width() &#x2F; height()取得匹配元素宽度和高度值只算width &#x2F; height</strong></p><p><strong>innerWidth()&#x2F; innerHieght()取得匹配元素宽度和高度值包含padding</strong></p><p><strong>outerWidth() &#x2F; outerHeight()  取得匹配元素宽度和高度值包含padding, border</strong></p><p><strong>outerWidth(true) &#x2F; outerHeight(true).  取得匹配元素宽度和高度值包含padding、 borde, margin</strong></p><p><strong>以上参数为空,则是获取相应值,返回的是数字型</strong></p><p><strong>如果参数为数字,则是修改相应值。</strong></p><p><strong>参数可以不必写单位。</strong></p><h3 id="7-2-jQuery位置"><a href="#7-2-jQuery位置" class="headerlink" title="7.2 jQuery位置"></a>7.2 jQuery位置</h3><p><strong>位置主要有三个: offset(), position(). scrollTop()&#x2F;scrollLeft()</strong></p><p><strong>1.offset()设置或获取元素偏移</strong></p><p><strong>1.offset()方法设置或返回被选元素相对于文档的偏移坐标,跟父级没有关系。</strong></p><p><strong>2.该方法有2个属性left, top. offset().top用于获取距离文档顶部的距离, offset().left用于获取距离文档左侧的距离。</strong></p><p><strong>3.可以设置元素的偏移: offset(top: 10, left: 30));</strong></p><p><strong>2.position()获取元素偏移</strong></p><p><strong>1.position()方法用于返回被选元素相对于带有定位的父级偏移坐标,如果父级都没有定位,则以文档为准。</strong></p><p><strong>3.scrollTop()&#x2F;scrollLeft()置或获取元素被卷去的头部和左侧</strong></p><p><strong>1.scrollTop()方法设置或返回被选元素被卷去的头部。</strong></p><h2 id="1-jQuery-事件注册"><a href="#1-jQuery-事件注册" class="headerlink" title="1.jQuery 事件注册"></a>1.jQuery 事件注册</h2><h3 id="单个事件注册"><a href="#单个事件注册" class="headerlink" title="单个事件注册"></a>单个事件注册</h3><p><strong>语法:</strong></p><p><strong>element.事件(function () {}</strong></p><p><strong>$(“div”).click (function () {事件处理程序})</strong></p><p><strong>其他事件和原生基本一致。比如mouseover, mouseout, blur, focus. change. keydown, keyup, resize, scroll等</strong></p><h2 id="2-jQuery事件处理"><a href="#2-jQuery事件处理" class="headerlink" title="2.jQuery事件处理"></a>2.jQuery事件处理</h2><h2 id="2-1事件处理on-绑定事件"><a href="#2-1事件处理on-绑定事件" class="headerlink" title="2.1事件处理on()绑定事件"></a>2.1事件处理on()绑定事件</h2><p><strong>on()方法在匹配元素上绑定一个或多个事件的事件处理函数</strong></p><p><strong>语法:</strong></p><p><strong>element. on (events, [selector], fn)</strong></p><p><strong>1, events:一个或多个用空格分隔的事件类型,如”click”或keydown”.</strong></p><p><strong>2.selector:元素的子元素选择器。</strong></p><p><strong>3.fn:回调函数即绑定在元素身上的侦听函数。</strong></p><h3 id="on-方法优势1"><a href="#on-方法优势1" class="headerlink" title="on()方法优势1:"></a><strong>on()方法优势1:</strong></h3><p><strong>可以绑定多个事件,多个处理事件处理程序。</strong></p><p><strong>$(“div”).on ({</strong></p><p> <strong>mouseover: function(){},</strong></p><p> <strong>mouseout: function() {},</strong></p><p><strong>click: function() {}</strong></p><p><strong>})；</strong></p><p><strong>$(“div”) .on (“mouseover mouseout”, function() {</strong></p><p><strong>$ (this) .toggleclass (“current”);</strong></p><p><strong>});</strong></p><h3 id="on-方法优势2"><a href="#on-方法优势2" class="headerlink" title="on()方法优势2:"></a><strong>on()方法优势2</strong>:</h3><p><strong>可以事件委派操作。事件委派的定义就是,把原来加给子元素身上的事件绑定在父元素身上,就是把事件委派给父元素。</strong></p><p><strong>$ (‘ul’).on (‘click, ‘li’, function() {</strong></p><p> <strong>alert (‘hello world!);</strong></p><p><strong>})；</strong></p><p><strong>在此之前有bind(), live() delegate()等方法来处理事件绑定或者事件委派,最新版本的请用on替代他们。</strong></p><h3 id="on-方法优势3"><a href="#on-方法优势3" class="headerlink" title="on()方法优势3:"></a>on()方法优势3:</h3><p><strong>动态创建的元素, click()没有办法绑定事件, on()可以给动态生成的元素绑定事件</strong></p><h2 id="2-2事件处理off-解绑事件"><a href="#2-2事件处理off-解绑事件" class="headerlink" title="2.2事件处理off()解绑事件"></a>2.2事件处理off()解绑事件</h2><p><strong>off()方法可以移除通过on()方法添加的事件处理程序。</strong></p><p><strong>$(“p”) .off () &#x2F;&#x2F;解绑p元素所有事件处理程序</strong></p><p><strong>$(“p”off( “click”) &#x2F;&#x2F;解绑元素上面的点击事件后面的foo是侦听函数名</strong></p><p><strong>$(“ul”).off (“click”, “li”); &#x2F;&#x2F;解绑事件委托</strong></p><p><strong>如果有的事件只想触发一次,可以使用one()来绑定事件。</strong></p><h2 id="2-3自动触发事件trigger"><a href="#2-3自动触发事件trigger" class="headerlink" title="2.3自动触发事件trigger()"></a>2.3自动触发事件trigger()</h2><p><strong>有些事件希望自动触发,比如轮播图自动播放功能跟点击右侧,钮一致。</strong></p><p><strong>可以利用定时器自动触发右侧按钮点击事件,不必鼠标点击触发。</strong></p><p><strong>element.click() &#x2F;&#x2F;第一种简写形式</strong></p><p><strong>element.triqqer (“type”) &#x2F;&#x2F;第二种自动触发模式</strong></p><p><strong>element.triggerHandler (type) &#x2F;&#x2F;第三种自动触发模式</strong></p><h2 id="3-jQuery事件对象"><a href="#3-jQuery事件对象" class="headerlink" title="3.jQuery事件对象"></a>3.jQuery事件对象</h2><p><strong>事件被触发,就会有事件对象的产生。</strong></p><p><strong>element. on (events, [selector] , function (event) {})</strong></p><p><strong>阻止默认行为: event.preventDefault()或者return false</strong></p><p><strong>阻止冒泡: event.stopPropagation()</strong></p><h2 id="1-jQuery对象拷贝"><a href="#1-jQuery对象拷贝" class="headerlink" title="1.jQuery对象拷贝"></a>1.jQuery对象拷贝</h2><p><strong>如果想要把某个对象拷贝(合并)给另外一个对象使用,此时可以使用$.extend ()方法</strong></p><p><strong>语法：</strong></p><p><strong>$.extend ( [deep], target, object1, [objectN])</strong></p><p><strong>1.deep:如果设为true为深考贝,默认为false浅拷贝</strong></p><p><strong>2.target:要拷贝的目标对象</strong></p><p><strong>3.object1:待考贝到第一个对象的对象。</strong></p><p><strong>4.objectN.待拷贝到第N个对象的对象。</strong></p><p><strong>5.浅拷贝是把被拷贝的对象复杂数据类型中的地址拷贝给目标对象,修改目标对象会影响被拷贝对象。</strong></p><p><strong>6,深拷贝,前面加true ,完全克隆(拷贝的对象,而不是地址),修改目标对象不会影响被拷贝对象。</strong></p><h2 id="2-jQuery-多库共存"><a href="#2-jQuery-多库共存" class="headerlink" title="2.jQuery 多库共存"></a>2.jQuery 多库共存</h2><p><strong>问题概述</strong></p><p><strong>jQuery使用$作为标示符,随着jQuery的流行,其他js库也会用这$作为标识符,这样一起使用会引起冲突。</strong></p><p><strong>客观需求</strong></p><p><strong>需要一个解决方案,让Query和其他的js库不存在冲突,可以同时存在,这就叫做多库共存。</strong></p><p><strong>Query解决方案:</strong></p><p><strong>1·把里面的$符号统一改为jQuery.,比如jQuery(“ div’)</strong></p><p><strong>2.jQuery 变量规定新的名称: S.noConflictovar xx &#x3D; $.noConflict();</strong></p><h2 id="3-jQuery插件"><a href="#3-jQuery插件" class="headerlink" title="3.jQuery插件"></a>3.jQuery插件</h2><p><strong>jQuery功能比较有限,想要更复杂的特效效果,可以借助于jQuery插件完成。</strong></p><p><strong>注意:这些插件也是依赖于jQuery来完成的,所以必须要先引入jQuery文件,因此也称为jQuery插件。</strong></p><p><strong>jQuery插件常用的网站:</strong></p><p><strong>1.jQuery插件库<a href="http://www.jq22.com/">http://www.jq22.com/</a></strong></p><p><strong>2, jQuery之家<a href="http://www.htmleaf.com/">http://www.htmleaf.com/</a></strong></p><p><strong>Query 插件使用步骤:</strong></p><p><strong>1.引入相关文件. (jquery文件和插件文件)</strong></p><p><strong>2,复制相关html, css、 js 调用插件)。</strong></p><h2 id="jQuery插件演示"><a href="#jQuery插件演示" class="headerlink" title="jQuery插件演示:"></a><strong>jQuery插件演示:</strong></h2><p><strong>1瀑布流</strong></p><p><strong>2.图片懒加载(图片使用延迟加载在可提高网页下载速度。它也能帮助减轻服务器负载)当我们页面滑动到可视区域，再显示图片。</strong></p><p><strong>3.我们使用jquery插件库Easylazyload.注意,此时的js引入文件和js调用必须写到DOM元素(图片)最后面</strong></p><p><strong>3.全屏滚动(fullpage.js )</strong></p><p><strong>gitHub : <a href="https://github.com/alvarotrigo/fullPage.js">https://github.com/alvarotrigo/fullPage.js</a></strong></p><p><strong>中文翻译网站: <a href="http://www.dowebok.com/demo/2014/77/">http://www.dowebok.com/demo/2014/77/</a></strong></p><p><strong>bootstrap JS插件:</strong></p><p><strong>bootstrap框架也是依赖于jQuery开发的,因此里面的js插件使用,也必须引入jQuery文件。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript</title>
      <link href="/2024/03/13/js/"/>
      <url>/2024/03/13/js/</url>
      
        <content type="html"><![CDATA[<h1 id="1-4浏览器执行JS简介"><a href="#1-4浏览器执行JS简介" class="headerlink" title="1.4浏览器执行JS简介"></a>1.4浏览器执行JS简介</h1><p><strong>浏览器分成两部分:渲染引擎和JS引擎</strong></p><p><strong>渲染引擎:用来解析HTML与CSS ,俗称内核,比如chrome浏览器的blink ,老版本的webkit</strong></p><p><strong>Js引擎:也称为JS解释器。用来读取网页中的JavaScript代码,对其处理后运行,比如chrome浏览器的V8</strong></p><p><strong>浏览器本身并不会执行IS代码,而是通过内置JavaScript引擎(解释器)来执行JS代码。S引擎执行代码时逐行解释每一句源码(转换为机器语言) ,然后由计算机去执行,所以JavaScript语言归为脚本语言,会逐行解释执行。</strong></p><p>​<strong>JavaScript</strong></p><p><strong>ECMAScript   Javascript语法</strong></p><p><strong>DOM页面文档对象模型</strong></p><p><strong>BOM浏览器对象模型</strong></p><p><strong>可以将单行或少量JS代码写在HTML标签的事件属性中(以on开头的属性),如: onclick</strong></p><p><strong>注意单双引号的使用:在HTML中我们推荐使用双引号,JS中我们推荐使用单引号</strong></p><p><strong>可读性差,在html中编写IS大量代码时,不方便阅读;引号易错,</strong></p><p><strong>引号多层嵌套匹配时,非常容易弄混;</strong></p><p><strong>特殊情况下使用</strong></p><p><strong>单行注释ctrl +&#x2F;</strong></p><p><strong>多行注释 默认的快捷键shift + alt +a</strong></p><p><strong>多行注释 vscode中修改多行注释的快捷键: ctrl + shift +&#x2F;</strong></p><p><strong>方法说明归属</strong></p><p><strong>alert(msg)浏览器弹出警示框浏览器</strong></p><p><strong>console.log(msg)浏览器控制台打印输出信息   浏览器</strong></p><p><strong>prompt(info)浏览器弹出输入框,用户可以输入  浏览器</strong></p><h2 id="1-2变量的数据类型"><a href="#1-2变量的数据类型" class="headerlink" title="1.2变量的数据类型"></a>1.2变量的数据类型</h2><p><strong>变量是用来存储值的所在处,它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的内存中。 JavaScript是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型,在程序运行过程中,类型会被自动确定。</strong></p><p><strong>var age &#x3D; 10;&#x2F;&#x2F;这是一个数字型</strong></p><p><strong>var arexouok &#x3D;‘是的’; &#x2F;&#x2F;这是一个字符串</strong></p><p><strong>在代码运行时,变量的数据类型是由JS引擎根据&#x3D;右边变量值的数据类型来判断的,运行完毕之后,变量就确定了数据类型。</strong></p><p><strong>Javascript拥有动态类型,同时也意味着相同的变量可用作不同的型:</strong></p><p><strong>var x&#x3D;6;x为数字</strong></p><p><strong>var x&#x3D; “Bil”;x为字符串</strong> </p><h2 id="2-1简单数据类型-基本数据类型"><a href="#2-1简单数据类型-基本数据类型" class="headerlink" title="2.1简单数据类型(基本数据类型)"></a>2.1简单数据类型(基本数据类型)</h2><p><strong>JavaScript中的简单数据类型及其说明如下:</strong></p><p><strong>简单数据类型说明默认值</strong></p><p><strong>Number数字型,包含整型值和浮点型值,如21、0.21 0</strong></p><p><strong>Boolean布尔值类型,如true、false,等价于1和0false</strong></p><p><strong>string 字符串类型,如”张三”注意咱们js里面,字符串都带引号“”</strong></p><p><strong>Undefinedvar a;声明了变量a但是没有给值,此时a&#x3D; undefinedundefined</strong></p><p><strong>Nullvar a &#x3D;null;声明了变量a为空值null</strong> </p><p><strong>现阶段我们只需要记住,在JS中八进制前面加0,十六进制前面加Ox</strong> </p><p><strong>JavaScriptthf的最大和最小值</strong></p><p><strong>alert (Number.MAX_VALUE); &#x2F;&#x2F; 1.7976931348623157e+308</strong> </p><p><strong>alert (Number.MIN VALUE); &#x2F;&#x2F; 5e-324</strong></p><p><strong>数字型三个特殊值</strong></p><p><strong>alert(Infinity); &#x2F;&#x2F; Infinity</strong></p><p><strong>alert(nfinity) ; &#x2F;&#x2F;-Infinity</strong></p><p><strong>alert (NaN);NaN</strong></p><p><strong>Infinity ,代表无穷大,大于任何数值</strong></p><p><strong>-Infinity ,代表无穷小,小于任何数值</strong></p><p><strong>NaN , Not a number,代表一个非数值</strong></p><h2 id="4-isNaN"><a href="#4-isNaN" class="headerlink" title="4.isNaN()"></a>4.isNaN()</h2><p><strong>用来判断一个变量是否为非数字的类型,返回true或者falsex</strong></p><p><strong>x是数字,返回false</strong></p><p><strong>isNaN (x)</strong></p><p><strong>x不是数字,返回true</strong> </p><p><strong>x是一个非数字类型</strong></p><p><strong>1,字符串引号嵌套JS可以用单引号嵌套双引号,或者用双引号碳套单引号(外双内单,外单内双)</strong></p><h2 id="2-字符串转义符"><a href="#2-字符串转义符" class="headerlink" title="2.字符串转义符"></a>2.字符串转义符</h2><p><strong>类似HTML面的特殊字符,字符串中也有特殊字符,我们称之为转义符。</strong></p><p><strong>转义符都是\开头的,常用的转义符及其说明如下:</strong></p><p><strong>转义符解释说明</strong></p><p><strong>\n换行符,n是newline的意思</strong></p><p><strong>\\斜杠</strong></p><p><strong>\‘     单引号</strong></p><p><strong>\“双引号</strong></p><p><strong>\ttab缩进</strong></p><p><strong>\b空格,b是blank的意思</strong></p><p><strong>字符串是由若干字符组成的,这些字符的数量就是字符串的长度。通过字符串的length属性可以获取整个字符串的长度。</strong></p><p><strong>console. log(true +1); &#x2F;&#x2F; 2</strong></p><p><strong>console.log (false + 1); &#x2F;&#x2F; 1</strong></p><h2 id="4-2转换为字符串"><a href="#4-2转换为字符串" class="headerlink" title="4.2转换为字符串"></a>4.2转换为字符串</h2><p><strong>方式说明案例</strong></p><p><strong>toString()  转成字符串var num&#x3D; 1; alert(num.toString();</strong></p><p><strong>String()强制转换  转成字符串    var num &#x3D;1; alert(String(null);</strong></p><p><strong>加号拼接字符串   和字符串拼接的结果都是字符串var num &#x3D;1; alert(num+ “我是字符串”);</strong></p><p><strong>toString0和String0使用方式不一样。</strong></p><p><strong>三种转换方式,我们更喜欢用第三种加号拼接字符串转换方式,这一种方式也称之为隐式转换。</strong></p><h2 id="4-3转换为数字型-重点"><a href="#4-3转换为数字型-重点" class="headerlink" title="4.3转换为数字型(重点)"></a>4.3转换为数字型(重点)</h2><p><strong>方式 说明</strong><strong>案例</strong></p><p><strong>parselnt(string)函数将string类型转成整数数值型parselnt(78’)</strong></p><p><strong>parseFloat(string)函数   将string类型转成浮点数数值型parsefloat(‘78.21’)</strong></p><p><strong>Number()强制转换函数  将string类型转换为数值型Number(‘12’)</strong></p><p><strong>js隐式转换(- * &#x2F;)利用算术运算隐式转换为数值型案例‘12-0’</strong></p><h2 id="4-4转换为布尔型"><a href="#4-4转换为布尔型" class="headerlink" title="4.4转换为布尔型"></a>4.4转换为布尔型</h2><p><strong>方式说明案例</strong></p><p><strong>Boolean()函数其他类型转成布尔值Boolean(‘true’);</strong></p><p><strong>代表空、否定的值会被转换为false ,如 0,NaN, null, undefined</strong></p><p><strong>其余值都会被转换为true</strong></p><p><strong>tml标签marquee可以实现多种滚动效果，而且不仅可以移动文字，也可以移动图片，表格等。</strong><br><strong>语法：<marquee>…</marquee>；</strong><br><strong>说明：在标记之间添加要进行滚动的内容。</strong></p><p><strong>marquee常用到的两个事件：</strong><br><strong>onMouseOut&#x3D;“this.start()” 当鼠标移出该区域时</strong><br><strong>onMouseOver&#x3D;“this.stop()” 当鼠标移入该区域时</strong></p><p><strong>代码示例：</strong><br><strong><marquee onMouseOut="this.start()" onMouseOver="this.stop()">marquee常用到的两个事件</marquee></strong></p><p><strong>marquee的重要属性：</strong><br><strong>1.behavior设置滚动的方式；</strong><br><strong>scroll:循环滚动，默认效果；</strong><br><strong>slide:只滚动一次就停止；</strong><br><strong>alternate:来回交替进行滚动。</strong><br><strong>语法：<marquee behavior="滚动方式">…</marquee></strong></p><p><strong>2.direction设置滚动的方向；</strong><br><strong>可选值有 left, right, up and down。如果未指定值，默认值为 left。</strong><br><strong>语法：<marquee direction="滚动方向">…</marquee></strong><br><strong>3.scrollamount设置滚动的速度；</strong><br><strong>以像素为单位，默认值为 6。</strong><br><strong>语法：<marquee scrollamount="5">…</marquee></strong><br><strong>4.scrolldelay设置两次滚动的时间间隔；</strong><br><strong>以毫秒为单位，默认值为 85。 除非指定 truespeed 值，否则将忽略任何小于 60 的值，并改为使用 60。</strong><br><strong>5.loop设置 marquee 滚动的次数；</strong><br><strong>如果未指定值，默认值为 −1，表示 marquee 将连续滚动。</strong><br><strong>6.width、height设置滚动的范围；</strong><br><strong>7.hspace、vspace设置水平和垂直边距；</strong><br><strong>8.bgcolor设置滚动的背景颜色。</strong></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="3-4小结"><a href="#3-4小结" class="headerlink" title="3.4小结"></a>3.4小结</h3><p><strong>函数可以带參数也可以不带参数</strong></p><p><strong>声明函数的时候,函数名括号里面的是形参,形参的默认值为undefined</strong></p><p><strong>调用函数的时候,函数名括号里面的是实参</strong></p><p><strong>多个参数中间用逗号分隔</strong></p><p><strong>形参的个数可以和实参个数不配,但是结果不可预计,我们尽量要匹配</strong></p><h2 id="4-5-break-continue-return的区别"><a href="#4-5-break-continue-return的区别" class="headerlink" title="4.5 break,continue ,return的区别."></a>4.5 break,continue ,return的区别.</h2><p><strong>break :结束当前的循环体(如for, while )</strong></p><p><strong>continue :跳出本次循环,继续执行下次循环(如for, while )</strong></p><p><strong>return :不仅可以退出循环,还能够返回return语句中的值,同时还可以结束当前的函数体内的代码</strong></p><h2 id="5-arguments的使用"><a href="#5-arguments的使用" class="headerlink" title="5.arguments的使用"></a>5.arguments的使用</h2><p><strong>当我们不确定有多少个参数传递的时候,可以用arguments来获取。</strong></p><p><strong>在JavaScript中, arguments实际上它是当前函数的一个内置对象。</strong></p><p><strong>所有函数都内置了一个arguments对象, <u>arguments对象中存储了传递的所有实参。</u></strong></p><p><strong><u>arguments展示形式是一个伪数组</u>,因此可以进行遍历。伪数组具有以下特点:</strong></p><p><strong>具有length属性</strong></p><p><strong>按索引方式储存数据</strong></p><p><strong>不具有数组的push, pop等方法</strong></p><h2 id="Javascript作用域"><a href="#Javascript作用域" class="headerlink" title="Javascript作用域"></a>Javascript作用域</h2><p><strong>Javascript作用域: 就是代码名字在某个范围内起作用和效果</strong></p><p><strong>目的是为了提高程序的可靠性更重要的是减少命名冲突</strong></p><p><strong>js的作用域(es6)之前: 全局作用域 局部作用域</strong></p><p><u><strong>全局作用域: 整个script标签或者是一个单独的js文件</strong></u></p><p><strong><u>局部作用域(函数作用域)：在函数内部就是局部作用域这个代码的名字只在函数内部起效果和作用</u></strong></p><p><strong>注意：如果在函数内部没有声明直接赋值的变量也属于全局变量</strong></p><p><strong>注意: 函数的形参也可以看做是局部变量</strong></p><p><strong>3,从执行效率来看全局变量和局部变量</strong></p><p><strong>1全局变量只有浏览器关闭的时候才会销毁,比较占内存资源</strong></p><p><strong>2局部变量当我们程序执行完毕就会销毁 比较节约内存资源</strong></p><h3 id="2-2全局变量"><a href="#2-2全局变量" class="headerlink" title="2.2全局变量"></a>2.2全局变量</h3><p><strong>在全局作用域下声明的变量叫做全局变量(在函数外部定义的变量)</strong></p><p><strong>全局变量在代码的任何位置都可以使用</strong></p><p><strong>在全局作用域下var声明的变量是全局变量</strong></p><p><strong>特殊情况下,在函数内不使用var声明的变量也是全局变量(不建议使用)</strong></p><h3 id="2-2局部变量"><a href="#2-2局部变量" class="headerlink" title="2.2局部变量"></a>2.2局部变量</h3><p><strong>在局部作用域下声明的变量叫做局部变量(在函数内部定义的变量</strong></p><p><strong>局部变量只能在该函数内部使用</strong></p><p><strong>在函数内部var声明的变量是局部变量</strong></p><p><strong>函数的形参实际上就是局部变量</strong></p><h3 id="2-3全局变量和局部变量的区别"><a href="#2-3全局变量和局部变量的区别" class="headerlink" title="2.3全局变量和局部变量的区别"></a>2.3全局变量和局部变量的区别</h3><p><strong>全局变量:在任何一个地方都可以使用,只有在浏览器关闭时才会被销毁,因此比较占内存</strong></p><p><strong>局部变量:只在函数内部使用,当其所在的代码块被执行时,会被初始化;当代码块运行结束后,就会被·销毁,因此更节省内存空间</strong></p><p><strong>js中没有块级作用域 js的作用域: 全局作用域 局部作用域 现阶段我们js没有块级作用域</strong></p><p><strong>我们is也是在es6的时候新增的块级作用域</strong></p><p><strong>块级作用域 {} if{}  for {}</strong></p><h3 id="3作用域链：内部函数访问外部函数的变量-采取的是链式查找的方式来决定取那个值这种结构我们称为作用域链"><a href="#3作用域链：内部函数访问外部函数的变量-采取的是链式查找的方式来决定取那个值这种结构我们称为作用域链" class="headerlink" title="3作用域链：内部函数访问外部函数的变量,采取的是链式查找的方式来决定取那个值这种结构我们称为作用域链"></a>3作用域链：内部函数访问外部函数的变量,采取的是链式查找的方式来决定取那个值这种结构我们称为作用域链</h3><p><strong>只要是代码，就至少有一个作用域</strong></p><p><strong>写在函数内部的局部作用域</strong></p><p><strong>如果函数中还有函数,那么在这个作用域中就又可以诞生一个作用域</strong></p><p><strong>根据在内部函数可以访问外部函数变量的这种机制,用链式查找决定哪些数据能被内部函数访问,就称作作用域链</strong></p><p><strong>就近原则</strong></p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="1-1什么是对象"><a href="#1-1什么是对象" class="headerlink" title="1.1什么是对象?"></a>1.1什么是对象?</h3><p><strong>现实生活中:万物皆对象,对象一个具体的事物1看得见摸得着的实物。例如,一本书、-辆汽车、一个人可以是”对象” ,一个数据库、张网页、一写远程服务器的连接也可以是“对象”</strong></p><p><strong>在Javascript 中,对象是一组无序的相关属性和方法的集合,所有的事物都是对象,例如字符串、数值、数组、函数等。</strong></p><p><u><strong>对象是由属性和方法组成的。</strong></u></p><p><u><strong>属性:事物的特征,在对象中用属性来表示(常用名词)</strong></u></p><p><u><strong>方法：事物的行为,在对象中用方法来表示(常用动词)</strong></u></p><h3 id="1-2为什么需要对象"><a href="#1-2为什么需要对象" class="headerlink" title="1.2为什么需要对象"></a>1.2为什么需要对象</h3><p><strong>保存一个值时,可以使用变量,保存多个值(一组值)时,可以使用数组。如果要保存一个人的完整信息呢?</strong></p><p><strong>例如,将”张三疯”的个人的信息保存在数组中的方式为:</strong></p><p><strong>var arr &#x3D;[‘张三疯’,男’, 128,154];</strong></p><p><strong><u>JS中的对象表达结构更清晰,更强大。张三疯的个人信息在对象中的表达结构如下:</u></strong></p><p><strong>张三疯.姓名&#x3D; ‘’张三疯’;</strong></p><p><strong>张三疯.性别&#x3D;’男’;</strong></p><p><strong>张三疯.年龄&#x3D;129;</strong></p><p><strong>张三疯.身高&#x3D;154;</strong></p><p><strong>person. name &#x3D; ‘张三疯’;</strong></p><p><strong>person.sex&#x3D;男;</strong></p><p><strong>person.age &#x3D;128;</strong></p><p><strong>person.height &#x3D; 154;</strong></p><h2 id="2．创建对象的三种方式"><a href="#2．创建对象的三种方式" class="headerlink" title="2．创建对象的三种方式"></a>2．创建对象的三种方式</h2><p><strong>在Javascript中,现阶段我们可以采用三种方式创建对象(object) :</strong></p><p><strong>利用字面量创建对象</strong></p><p><strong>利用new Object创建对象</strong></p><p><strong>利用构造函数创建对象</strong></p><h3 id="2-1利用字面量创建对象"><a href="#2-1利用字面量创建对象" class="headerlink" title="2.1利用字面量创建对象"></a>2.1利用字面量创建对象</h3><p><strong>对象字面量:就是花括号()里面包含了表达这个具体事物(对象)的属性和方法。</strong></p><h4 id="对象的调用"><a href="#对象的调用" class="headerlink" title="对象的调用"></a>对象的调用</h4><p><strong>对象里面的属性调用:对象 属性名,这个小点.就理解为”的“</strong></p><p><strong>对象里面属性的另一种调用方式:对象[‘属性名‘ ],注意方括号里面的属性必须加引号,我们后面会用对象里面的方法调用:对象方法名(),注意这个方法名字后面一定加括号</strong></p><p><strong>console.log (star.name) &#x2F;&#x2F;调用名字属性</strong></p><p><strong>console.log (star [‘name’]) &#x2F;&#x2F;调用名字属性</strong></p><p><strong>star.sayHi(); &#x2F;&#x2F;调用sayHi方法,注意,一定不要忘记带后面的括号</strong></p><h3 id="变量、属性、函数、方法总结"><a href="#变量、属性、函数、方法总结" class="headerlink" title="变量、属性、函数、方法总结"></a>变量、属性、函数、方法总结</h3><p><strong>变量:单独声明赋值,单独存在</strong></p><p><strong>属性:对象里面的变量称为属性,不需要声明,用来描述该对象的特征</strong></p><p><strong>函数:单独存在的,通过”函数名()”的方式就可以调用</strong></p><p><strong>方法:对象里面的函数称为方法,方法不需要声明,使用“对象方法名()”的方式就可以调用,方法用来描述该对象的行为和功能。</strong></p><h2 id="2-3利用构造函数创建对象"><a href="#2-3利用构造函数创建对象" class="headerlink" title="2.3利用构造函数创建对象"></a>2.3利用构造函数创建对象</h2><p><strong>构造函数:是一种特殊的函数,主要用来初始化对象,即为对象成员变量赋初值,它总与new运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来,然后封装到这个函数里面。</strong></p><h2 id="2-4构造函数和对象"><a href="#2-4构造函数和对象" class="headerlink" title="2.4构造函数和对象"></a>2.4构造函数和对象</h2><p><strong>构造函数,如Stars() ,抽象了对象的公共部分,封装到了函数里面,它泛指某一大类(class)</strong></p><p><strong>创建对象,如new Stars(),特指某一个,通过new关键字创建对象的过程我们也称为对象实例化</strong></p><h3 id="new在执行时会做四件事情"><a href="#new在执行时会做四件事情" class="headerlink" title="new在执行时会做四件事情:"></a>new在执行时会做四件事情:</h3><p><strong>1,在内存中创建一个新的空对象。</strong></p><p><strong>2．让this指向这个新的对象。</strong></p><p><strong>3.执行构造函数里面的代码,给这个新对象添加属性和方法。</strong></p><p><strong>4.返回这个新对象(所以构造函数里面不需要return).</strong></p><h3 id="for-in-语句用于对数组或者对象的属性进行循环操作。"><a href="#for-in-语句用于对数组或者对象的属性进行循环操作。" class="headerlink" title="for in 语句用于对数组或者对象的属性进行循环操作。"></a>for in 语句用于对数组或者对象的属性进行循环操作。</h3><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>1.对象可以让代码结构更清晰</strong></p><p><strong>2,对象复杂数据类型object</strong></p><p><strong>3·本质:对象就是一组无序的相关属性和方法的集合</strong></p><p><strong>4.构造函数泛指某一大类,比如苹果,不管是红色苹果还是绿色苹果,都统称为苹果。</strong></p><p><strong>5.for..in 用于对对象的属性进行循环操作。</strong></p><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><p><strong>Javascript中的对象分为3种:自定义对象、内置对象、浏览器对象</strong></p><p><strong>前面两种对象是&#x2F;S基础内容,属于ECMAScript ;第三个浏览器对象属于我们Js独有的,我们JS APl讲解</strong></p><p><strong>内置对象就是指JS语言自带的一些对象,这些对象供开发者使用,并提供了一些常用的或是最基本而必要的功能(属性和方法)</strong></p><p><strong>内置对象最大的优点就是帮助我们快速开发</strong></p><p><strong>Javascript提供了多个内置对象: Math, Date、Array, string等</strong> </p><h2 id="查文档"><a href="#查文档" class="headerlink" title="查文档"></a>查文档</h2><h3 id="2-1-MDN学习一个内置对象的使用只要学会其常用成员的使用即可"><a href="#2-1-MDN学习一个内置对象的使用只要学会其常用成员的使用即可" class="headerlink" title="2.1 MDN学习一个内置对象的使用只要学会其常用成员的使用即可"></a>2.1 MDN学习一个内置对象的使用只要学会其常用成员的使用即可</h3><p><strong>我们可以通过查文档学习,可以通过MDN&#x2F;W3C来查询。</strong></p><p><strong>Mozilla开发者网络(MDN )提供了有关开放网络技术(Open Web )的信息,包括HTML, CSS和万维网及HTML5应用的API</strong></p><p><strong>MDN: <a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a></strong></p><h3 id="2-2如何学习对象中的方法"><a href="#2-2如何学习对象中的方法" class="headerlink" title="2.2如何学习对象中的方法"></a>2.2如何学习对象中的方法</h3><p><strong>1．查阅该方法的功能</strong></p><p><strong>2．查看里面参数的意义和类型</strong></p><p><strong>3.查看返回值的意义和类型</strong></p><p><strong>4.通过demo进行测试</strong></p><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p><strong>Math是一个内置对象,它具有数学常数和函数的属性和方法。不是一个函数对象。</strong></p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><strong>与其它全局对象不同的是, Math不是一个构造器 Math 的所有属性和方法都是静态的,你用到的常数p可以用Math.PI 表示用 x 作参数 Math.sin (x) 调sin函数 JavaScript中的常数,是以全精度的实数定义的</strong></p><h3 id="3-1-Math概述"><a href="#3-1-Math概述" class="headerlink" title="3.1 Math概述"></a>3.1 Math概述</h3><p><strong>Math对象不是构造函数,它具有数学常数和函数的属性和方法。跟数学相关的运算(求绝对值,取整、最大值等)可以使用Math中的成员。</strong></p><p><strong>Math.PI&#x2F;&#x2F;圆周率</strong></p><p><strong>Math.floor()&#x2F;&#x2F;向下取整</strong></p><p><strong>Math.ceil ()&#x2F;&#x2F;向上取整</strong></p><p><strong>Math.round()&#x2F;&#x2F;四舍五入  就近取整 注意-3.5 结果是-3</strong></p><p><strong>Math.abs ()&#x2F;&#x2F;绝对值</strong></p><p><strong>Math.max () &#x2F;Math.min() &#x2F;&#x2F;求最大和最小值</strong></p><h2 id="random-随机生成小数"><a href="#random-随机生成小数" class="headerlink" title="random()随机生成小数"></a>random()随机生成小数</h2><p><strong>随机生成整数</strong></p><p><strong>function getRandom(min, max) {</strong></p><p>​      <strong>return Math.floor(Math.random() * (max - min + 1)) + min;</strong></p><p>​    <strong>}</strong></p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><strong>new Date();</strong></p><p><strong>需要注意的是只能通过调用Date构這函 来实例化日期对象:以常规函数调用它, (即不加new操作符)将会返回一个字符串,而不是一个日期对象。另外,不像其他JavaScript类型, Date对象没有字面量格式。</strong></p><p><strong>如果没有输入 可容数,则Date的构造器会依据系统设置的当前时间来创建一个Date对象。</strong></p><p><strong>如果提供了至少两个参数,其余的参数均会默认设置为1 (如果没有提供day参数)或者0</strong></p><p><strong>&#x2F;&#x2F;参数常用写法 数字型参数 常用的写法数字型 2019, 10, 01或者是 字符型’2019-10-1 8:8:8’’</strong></p><p>​    <strong>var date1 &#x3D; new Date(2019, 10, 1);</strong></p><p>​    <strong>console.log(date1); &#x2F;&#x2F;返回的是11月不是10月</strong></p><p>​    <strong>var date2 &#x3D; new Date(‘2019-10-1 8:8:8’);</strong></p><p>​    <strong>console.log(date2); &#x2F;&#x2F;准确建议使用</strong></p><h2 id="4-1-Date概述"><a href="#4-1-Date概述" class="headerlink" title="4.1 Date概述"></a>4.1 Date概述</h2><p><strong>Date对象和Math对象不一样,他是一个构造函数,所以我们需要实例化后才能使用</strong></p><p><strong>Date实例用来处理日期和时间</strong></p><h2 id="4-2-Date-方法的使用"><a href="#4-2-Date-方法的使用" class="headerlink" title="4.2 Date()方法的使用"></a>4.2 Date()方法的使用</h2><p><strong>1,获取当前时间必须实例化</strong></p><p><strong>var now &#x3D; new Date ();</strong></p><p><strong>console.log (now);</strong></p><p><strong>2.Date)构造函数的参数</strong></p><p><strong>如果括号里面有时间,就返回参数里面的时间。例如日期格式字符串为‘2019-5-1’ ,可以写成new Date(2019-5-1)或者new Date(’2019&#x2F;5&#x2F;1‘)</strong></p><p><strong>4.3日期格式化</strong></p><p><strong>我们想要2019-8-88:8:8格式的日期,要怎么办?</strong></p><p><strong>需要获取日期指定的部分,所以我们要手动的得到这种格式。</strong></p><p><strong>方法名说明  代码</strong></p><p><strong>getFullYear()                          获取当年  dObj.getFullYear()</strong></p><p><strong>getMonth() 获取当月(0-11)   dobj.getMonth()</strong></p><p><strong>getDate()获取当天日期  dObi.getDate()</strong></p><p><strong>getDay() 获取星期几(周日0到周六6)dObj.getDay()</strong></p><p><strong>getHours() 获取当前小时  dobj.getHours()</strong></p><p><strong>getMinutes()  获取当前分钟dobj.getMinutes()</strong></p><p><strong>getSeconds()获取当前秒钟   dObj.getSeconds()</strong></p><p><strong>不需要参数</strong></p><h3 id="4-4获取日期的总的毫秒形式"><a href="#4-4获取日期的总的毫秒形式" class="headerlink" title="4.4获取日期的总的毫秒形式"></a>4.4获取日期的总的毫秒形式</h3><p><strong>Date对象是基于1970年1月1日(世界标准时间)起的毫秒数</strong></p><p><strong>为什么计算机起始时间从1970年开始?</strong></p><p><strong>我们经常利用总的毫秒数来计算时间,因为它更精确</strong></p><h2 id="4-日期对象"><a href="#4-日期对象" class="headerlink" title="4.日期对象"></a>4.日期对象</h2><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p><strong>倒计时算法</strong></p><p><strong>①核心算法:输入的时间减去现在的时间就是剩余的时间,即倒计时,但是不能拿着时分秒相减,比如05分减去25分,结果会是负数的。</strong></p><p><strong>用时间戳来做。用户输入时间总的毫秒数减去现在时间的总的毫秒数,得到的就是剩余时,间的毫秒数。</strong></p><p><strong>把剩余时间总的毫秒数转换为天、时、分、秒(时间戳转换为时分秒)</strong></p><p><strong>转换公式如下:</strong></p><p><strong>d &#x3D; parselnt(总秒数&#x2F;60&#x2F;60&#x2F;24); &#x2F;&#x2F;计算天数</strong></p><p><strong>h &#x3D; parselnt(总秒数&#x2F;60&#x2F;60%24) &#x2F;&#x2F;计算小时</strong></p><p><strong>m &#x3D; parselnt(总秒数&#x2F;60 %60); &#x2F;&#x2F;计算分数</strong></p><p><strong>s&#x3D; parselnt(总秒数%60); &#x2F;&#x2F;计算当前秒数</strong></p><h2 id="5-数组对象"><a href="#5-数组对象" class="headerlink" title="5.数组对象"></a>5.数组对象</h2><h3 id="instanceof和isArray"><a href="#instanceof和isArray" class="headerlink" title="instanceof和isArray"></a>instanceof和isArray</h3><p><strong>当检测Array实例时, Array.isArray优于instanceof,因为Array. isArray能检测iframes.</strong></p><h3 id="5-3添加删除数组元素的方法"><a href="#5-3添加删除数组元素的方法" class="headerlink" title="5.3添加删除数组元素的方法"></a>5.3添加删除数组元素的方法</h3><p><strong>方法名 说明                                返回值</strong></p><p><strong>push(参数1..) 末尾添加一个或多个元素,注意修改原数组                               并返回新的长度</strong></p><p><strong>pop()   删除数组最后一个元素,把教组长度减1无参数、修改原数组         返回它删除的元素的值</strong></p><p><strong>unshift(参数… ) 向数组的开头添加一个或更多元素,注意修改原数组   并返回新的长度</strong></p><p><strong>shift()                         删除数组的第一个元素,数组长度减1无参数、修改原数组 并返回第一个元素的值</strong></p><h3 id="5-4数组排序"><a href="#5-4数组排序" class="headerlink" title="5.4数组排序"></a>5.4数组排序</h3><p><strong>方法名 说明 是否修改原数组</strong></p><p><strong>reverse() 颠倒数组中元素的顺序,无参数该方法会改变原来的数组返回新数组</strong></p><p><strong>sort()对数组的元素进行排序该方法会改变原来的数组返回新数组</strong></p><h3 id="5-5数组索引方法"><a href="#5-5数组索引方法" class="headerlink" title="5.5数组索引方法"></a>5.5数组索引方法</h3><p><strong>方法名 说明返回值</strong>  </p><p><strong>indexOf()    数组中查找给定元素的第一个索引如果存在返回索引号如果不存在,则返回-1</strong></p><p><strong>lastindexOf() 在数组中的最后一个的索引,                   如果存在返回素引号如果不存在,则返回-1.</strong></p><p><strong>有一个数组[‘c’, ‘a’, ‘2’, ‘a’, ‘x’, ‘a’, ‘x’, ‘c’,’b’],要求去除数组中重复的元素。</strong></p><p><strong>核心算法:我们遍历日数组,然后拿着旧数组元素去查询新数组,如果该元素在新数组里面没有出现过,我们就添加,否则不添加。</strong></p><p><strong>我们怎么知道该元素没有存在?利用新数组.indexOf(数组元素)如果返回时-1就说明新数组里面没有改元素</strong></p><h3 id="5-6数组转换为字符串"><a href="#5-6数组转换为字符串" class="headerlink" title="5.6数组转换为字符串"></a>5.6数组转换为字符串</h3><p><strong>方法名   说明 返回值</strong></p><p><strong>toString()  把数组转换成字符串,逗号分隔每一项返回一个字符串</strong></p><p><strong>join(‘分隔符’)方法用于把数组中的所有元素转换为一个字符串。 返回一个字符串</strong></p><h3 id="5-7课下查询"><a href="#5-7课下查询" class="headerlink" title="5.7课下查询"></a>5.7课下查询</h3><p><strong>方法名 说明  返回值</strong></p><p><strong>concat()  连接两个或多个数组不影响原数组  返回一个新的数组</strong></p><p><strong>slice()  数组截取slice(begin, end) 返回被截取项目的新数组</strong></p><p><strong>splice()   数组删除splice(第几个开始,要删除个数) 返回被删除项目的新数组注意,这个会影响原数组</strong></p><p><strong>slice()和splice()目的基本相同,建议同学们重点看下splice()</strong></p><h3 id="6-1基本包装类型"><a href="#6-1基本包装类型" class="headerlink" title="6.1基本包装类型"></a>6.1基本包装类型</h3><p><strong>为了方便操作基本数据类型, Javascript还提供了三个特殊的引用类型: String, Number和Boolean.</strong></p><p><strong>基本包装类型就是把简单数据类型包装成为复杂数据类型,这样基本数据类型就有了属性和方法</strong></p><h3 id="6-2字符串的不可变"><a href="#6-2字符串的不可变" class="headerlink" title="6.2字符串的不可变"></a>6.2字符串的不可变</h3><p><strong>指的是里面的值不可变,虽然看上去可以改变内容,但其实是地址变了,内存中新开辟了一个内存空间。</strong></p><h3 id="6-3根据字符返回位置"><a href="#6-3根据字符返回位置" class="headerlink" title="6.3根据字符返回位置"></a>6.3根据字符返回位置</h3><p><strong>字符串所有的方法,都不会修改字符串本身字符串是不可变的,操作完成会返回一个新的字符串。</strong></p><p><strong>方法名  说明</strong></p><p><strong>indexof(要查找的字符,开始的位置)返回指定内容在元字符串中的位置,如果找不到就返回-1,开始的位置是index索引号</strong></p><p><strong>lastlindexof() 从后往前找,只找第一个匹配的</strong></p><h3 id="6-4根据位置返回字符-重点"><a href="#6-4根据位置返回字符-重点" class="headerlink" title="6.4根据位置返回字符(重点)"></a>6.4根据位置返回字符(重点)</h3><p><strong>方法名说明 使用</strong></p><p><strong>charAt(index)   返回指定位置的字符(index字符串的索引号) str.charAt(0)</strong></p><p><strong>charCodeAt(index)      获取指定位置处字符的ASCI1码(index素引号)  str.charCodeAt(0)</strong></p><p><strong>charAt(index)获取指定位置处字符HTML5, IE8+支持和charAt()等效</strong></p><h3 id="6-5字符串操作方法-重点"><a href="#6-5字符串操作方法-重点" class="headerlink" title="6.5字符串操作方法(重点)"></a>6.5字符串操作方法(重点)</h3><p><strong>方法名  说明</strong></p><p><strong>concat(str1,str2,str3…. concat()方法用于连接两个或多个字符串。拼接字符串,等效于+, +更常用</strong></p><p><strong>substr(start,length)  从start位置开始(索引号) , length取的个数重点记住这个</strong></p><p><strong>slice(start, end)从start位置开始,截取到end位置, end取不到(他们俩都是索引号)</strong></p><p><strong>substring(start, end)  从start位置开始,截取到end位置, end取不到基本和slice相同但是不接受负值</strong></p><h3 id="6-8课下查阅"><a href="#6-8课下查阅" class="headerlink" title="6.8课下查阅"></a>6.8课下查阅</h3><p><strong>toUpperCase()&#x2F;&#x2F;转换大写</strong></p><p><strong>tolowerCase() &#x2F;&#x2F;转换小写</strong></p><h1 id="1-简单类型与复杂类型"><a href="#1-简单类型与复杂类型" class="headerlink" title="1.简单类型与复杂类型"></a>1.简单类型与复杂类型</h1><p><strong>简单类型又叫做基本数据类型或者 值类型,复杂类型又叫做 引用类型。·</strong></p><p><strong>值类型:简单数据类型基本数据类型,在存储时变量中存储的是值本身,因此 做值类型</strong></p><p><strong>string , number, boolean , undefined, null</strong></p><p><strong>引用类型:复杂数据类型,在存储时变量中存储的仅仅是地址(引用) ,因此叫做引用数据类型</strong></p><p><strong>通过new关键字创建的对象(系统对象、自定义对象) ,如Object,Array. Date等</strong></p><h2 id="2-堆和栈"><a href="#2-堆和栈" class="headerlink" title="2.堆和栈"></a>2.堆和栈</h2><p><strong>堆栈空间分配区别：</strong></p><p><strong>1、栈(操作系统) :由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈;</strong></p><p><strong>简单数据类型存放到栈里面</strong></p><p><strong>2、堆(操作系统) :存储复杂类型对象,一般由程序员分配释放,若程序员不释放,由垃圾回收机制回收。</strong></p><p><strong>复杂数据类型存放到堆里面</strong></p><p><strong>注意: JavaScriot中没有堆栈的概念,通过堆栈的方式,可以让大家更容易理解代码的一些执行方式,便于将来学习其他语言</strong></p><h2 id="3-简单类型的内存分配"><a href="#3-简单类型的内存分配" class="headerlink" title="3.简单类型的内存分配"></a>3.简单类型的内存分配</h2><p><strong>值类型(简单数据类型) : string , number , boolean , undefined , null</strong></p><p><strong>值类型变量的数据直接存放在变量(栈空间)中</strong></p><h2 id="6-复杂类型传参"><a href="#6-复杂类型传参" class="headerlink" title="6.复杂类型传参"></a>6.复杂类型传参</h2><p><strong>函数的形参也可以看做是一个变量,当我们把一个值类型变量作为参数传给函数的形参时,其实是把变量在栈空间里的值复制了一份给形参,那么在方法内部对形参做任何修改,都不会影响到的外部变量。</strong></p><p><strong>函数的形参也可以看做是一个变量,当我们把引用类型变量传给形参时,其实是把变量在栈空间里保存的堆地址复制给了形参,形参和实参其实葆存的是同一个堆地址,所以操作的是同一个对象。</strong></p><h1 id="Web-APIs介绍"><a href="#Web-APIs介绍" class="headerlink" title="Web APIs介绍"></a>Web APIs介绍</h1><h2 id="1-1-JS的组成"><a href="#1-1-JS的组成" class="headerlink" title="1.1 JS的组成"></a>1.1 JS的组成</h2><p><img src="C:\Users\24861\Desktop\笔记图\js组成.JPG" alt="js组成"></p><h2 id="1-2JS基础阶段以及Web-APIs阶段"><a href="#1-2JS基础阶段以及Web-APIs阶段" class="headerlink" title="1.2JS基础阶段以及Web APIs阶段"></a>1.2JS基础阶段以及Web APIs阶段</h2><p><strong>JS基础阶段</strong></p><p><strong>我们学习的是ECMAScript标准规定的基本语法</strong></p><p><strong>要求同学们掌握Js基础语法</strong></p><p><strong>只学习基本语法,做不了常用的网页交互效果</strong></p><p><strong>目的是为了Js后面的课程打基础、做铺垫</strong></p><p><strong>Web APis阶段Web APIs是w3c组织的标准</strong></p><p><strong>Web APIs a Doм和BOM</strong></p><p><strong>Web APIs是我们Js所独有的部分</strong></p><p><strong>我们主要学习页面交互功能</strong></p><p><strong>需要使用Js基础的课程内容做基础</strong></p><p><strong>Js基础学习ECMAScript基础语法为后面作铺垫, web APIs是Js的应用,大量使用Js基础语法做交互效果</strong></p><h2 id="2-1-API"><a href="#2-1-API" class="headerlink" title="2.1 API"></a>2.1 API</h2><p><strong>API (Application Programming Interface,应用程序编程接口)是一些预先定义的函数,目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力,而又无需访问源码,或理解内部工作机制的细节。</strong></p><p><strong>简单理解: API是给程序员提供的一种工具,以便能更轻松的实现想要完成的功能。</strong></p><h2 id="2-2-Web-API"><a href="#2-2-Web-API" class="headerlink" title="2.2 Web API"></a>2.2 Web API</h2><p><strong>Web API是浏览器提供的一套操作浏览器功能和页面元素的API (BOM和DOM).</strong></p><p><strong>现阶段我们主要针对于浏览器讲解常用的API,主要针对浏览器做交互效果。</strong></p><p><strong>比如我们想要浏览器弹出一个警示框,直接使用alert( 弹出 )</strong></p><p><strong>MDN详细API : <a href="https://developer.mozilla.org/zh-CN/docs/Web/API">https://developer.mozilla.org/zh-CN/docs/Web/API</a></strong></p><p><strong>因为Web API很多,所以我们将这个阶段称为Web APls</strong></p><h2 id="2-3-API和Web-API总结"><a href="#2-3-API和Web-API总结" class="headerlink" title="2.3 API和Web API总结"></a>2.3 API和Web API总结</h2><p><strong>1.API是为我们程序员提供的一个接口,帮助我们实现某种功能,我们会使用就可以了,不必纠结内部如何实现</strong></p><p><strong>2.Web API主要是针对于浏览器提供的接口,主要针对于浏览器做交互效果。</strong></p><p><strong>3.Web API一般都有输入和输出(函数的传参和返回值) , WebAPI很多都是方法(函数)</strong></p><p><strong>4.学习Web APl可以结合前面学习内置对象方法的思路学习</strong></p><h2 id="DOM-重点"><a href="#DOM-重点" class="headerlink" title="DOM(重点)"></a>DOM(重点)</h2><h3 id="1-1什么是DOM"><a href="#1-1什么是DOM" class="headerlink" title="1.1什么是DOM"></a>1.1什么是DOM</h3><p><strong>文档对象模型( Document Object Model ,简称DOM ) ,是W3C组织推荐的处理可扩展标记语言(HTML或者XML )的标准编程接口。</strong></p><p> <strong>W3C已经定义了一系列的DOM接口,通过这些DOM接口可以改变网页的内容、结构和样式。</strong></p><h3 id="1-2-DOM树"><a href="#1-2-DOM树" class="headerlink" title="1.2 DOM树"></a>1.2 DOM树</h3><p><img src="C:\Users\24861\Desktop\笔记图\dom树.JPG" alt="dom树"></p><p><strong>文档:一个页面就是一个文档, DOM中使用document表示</strong></p><p><strong>元素:页面中的所有标签都是元素, DOM中使用element表示</strong></p><p><strong>节点:网页中的所有内容都是节点(标签、属性、文本、注释等) , DOM中使用node表示</strong></p><p><strong>DOM把以上内容都看做是对象</strong></p><h3 id="2-1如何获取页面元素"><a href="#2-1如何获取页面元素" class="headerlink" title="2.1如何获取页面元素"></a>2.1如何获取页面元素</h3><p><strong>DOM在我们实际开发中主要用来操作元素。</strong></p><p><strong>我们如何来获取页面中的元素呢?</strong></p><p><strong>获取页面中的元素可以使用以下几种方式:</strong></p><p><strong>根据ID获取</strong></p><p><strong>根据标签名获取</strong></p><p><strong>通过HTML5新增的方法获取</strong></p><p><strong>特殊元素获取</strong></p><h3 id="2-2根据ID获取"><a href="#2-2根据ID获取" class="headerlink" title="2.2根据ID获取"></a>2.2根据ID获取</h3><p><strong>使用getElementByld()方法可以获取带有ID的元素对象。</strong></p><p><strong>Document的方法getElementByld())返回一个匹配特定1D的元素由于元素的ID在大部分情况下要求是独一无二的,这个方法自然而然地成为了一个高效查找特库元素的方法。</strong></p><p><strong>element是一个Element对象。如果当前文档中拥有特定ID的元素不存在则返回null</strong></p><p><strong>id是写的字,代表了所要查找的元素的唯一ID.</strong></p><p><strong>返回一个匹配到ID的DOM ElementE,若在当前Document下没有找到,则返回null</strong></p><h3 id="2-3根据标签名获取"><a href="#2-3根据标签名获取" class="headerlink" title="2.3根据标签名获取"></a>2.3根据标签名获取</h3><p><strong>使用getElementsByTagName()方法可以返回带有指定标签名的对象的集合。</strong></p><p><strong>还可以获取某个元素(3元素)内部所有指定标签名的子元素.</strong></p><p><strong>element.getElementsByTagName (‘标签名‘);</strong></p><p><strong>注意:父元素必须是单个对象(必须指明是哪一个元素对象).获取的时候不包括元素自己。</strong></p><h3 id="2-4通过HTML5新增的方法获取i9以上浏览器可以使用"><a href="#2-4通过HTML5新增的方法获取i9以上浏览器可以使用" class="headerlink" title="2.4通过HTML5新增的方法获取i9以上浏览器可以使用"></a>2.4通过HTML5新增的方法获取i9以上浏览器可以使用</h3><p><strong>1.document.getElementsByClassName (类名’) ; &#x2F;&#x2F;根据类名返回元素对象集合</strong></p><p><strong>2.document.querySelector (‘选择器’);  &#x2F;&#x2F;根据指定选择器返回第一个元素对象</strong></p><p><strong>3.document.querySelelctorAll (,選择器’);&#x2F;&#x2F;根据指定选择器返回</strong></p><h3 id="2-5获取特殊元素-body-html"><a href="#2-5获取特殊元素-body-html" class="headerlink" title="2.5获取特殊元素( body , html )"></a>2.5获取特殊元素( body , html )</h3><p><strong>获取body元素</strong></p><p><strong>doucumnet.body &#x2F;&#x2F;返回body元素对象</strong></p><p><strong>获取html元素</strong></p><p><strong>document-documentElement &#x2F;&#x2F;返回html元素对象</strong></p><h2 id="3-事件基础"><a href="#3-事件基础" class="headerlink" title="3.事件基础"></a>3.事件基础</h2><h3 id="3-1事件概述"><a href="#3-1事件概述" class="headerlink" title="3.1事件概述"></a>3.1事件概述</h3><p><strong>JavaScript使我们有能力创建动态页面,而事件是可以被Javascript侦测到的行为</strong>。</p><p><strong>简单理解:触发–响应机制。</strong></p><p><strong>网页中的每个元素都可以产生某些可以触发JavaScript的事件,例如,我们可以在用户点击某按钮时产生一个事件,然后去执行某些操作。</strong></p><h3 id="3-3执行事件的步骤"><a href="#3-3执行事件的步骤" class="headerlink" title="3.3执行事件的步骤"></a>3.3执行事件的步骤</h3><p><strong>1.获取事件源</strong></p><p><strong>2注册事件（绑定事件)</strong></p><p><strong>3.添事件处理程序(采取函数赋值形式)</strong></p><h3 id="3-3常见的鼠标事件"><a href="#3-3常见的鼠标事件" class="headerlink" title="3.3常见的鼠标事件"></a>3.3常见的鼠标事件</h3><p><strong>鼠标事件 触发条件</strong></p><p><strong>onclick   鼠标点击左键触发</strong></p><p><strong>onmouseover  鼠标经过触</strong></p><p><strong>onmouseout鼠标离开触发</strong></p><p><strong>onfocus    获得鼠标焦点触发</strong></p><p><strong>onblur  失去鼠标焦点触发</strong></p><p><strong>onmousemove     鼠标移动触发</strong></p><p><strong>onmouseup      鼠标弹起触发</strong></p><p><strong>onmousedown    鼠标按下触发</strong></p><h2 id="4·操作元素"><a href="#4·操作元素" class="headerlink" title="4·操作元素"></a>4·操作元素</h2><p><strong>JavaScript的DOM操作可以改变网页内容、结构和样式,我们可以利用DOM操作元素来改变元素里面的内容、属性等。注意以下都是属性</strong></p><h3 id="4-1改变元素内容"><a href="#4-1改变元素内容" class="headerlink" title="4.1改变元素内容"></a>4.1改变元素内容</h3><p><strong>element. innerText</strong></p><p><strong>从起始位置到终止位置的内容,但它去除html标签,同时空格和换行也会去掉</strong></p><p><strong>element. innerHTML</strong></p><p><strong>起始位置到终止位置的全部内容,包括html标签,同时保留空格和换行</strong></p><h3 id="4-2常用元素的属性操作"><a href="#4-2常用元素的属性操作" class="headerlink" title="4.2常用元素的属性操作"></a>4.2常用元素的属性操作</h3><p><strong>1.innerText. innerHTMI改变元素内容</strong></p><p><strong>2.src, href</strong></p><p><strong>3.id, alt, title</strong></p><h3 id="4-3表单元素的属性操作"><a href="#4-3表单元素的属性操作" class="headerlink" title="4.3表单元素的属性操作"></a>4.3表单元素的属性操作</h3><p><strong>利用DOM可以操作如下表单元素的属性:</strong></p><p><strong>type, value, checked, selected, disabled</strong></p><h3 id="4-4样式属性操作"><a href="#4-4样式属性操作" class="headerlink" title="4.4样式属性操作"></a>4.4样式属性操作</h3><p><strong>我们可以通过IS修改元素的大小、颜色、位置等样式。</strong></p><ol><li><strong>element.style 行内样式操作——-用行内样式覆盖了</strong>  </li><li><strong>element.className类名样式操作——-样式很多用</strong></li></ol><p><strong>注意:</strong></p><p><strong>1.Js里面的样式采取驼峰命名法比如fontSize, backgroundColor</strong></p><p><strong>2.Js修改style样式操作,产生的是行内样式, css权重比较高</strong></p><p><strong>注意：</strong></p><p><strong>1,如果样式修改较多,可以采取操作类名方式更改元素样式。</strong></p><p><strong>2.class因为是个保留字,因此使用className来操作元素类名属性</strong></p><p><strong>3.className会直接更改元素的类名,会覆盖原先的类名。</strong></p><p><strong>可以利用for循环设置一组元素的精灵图背景</strong></p><p><strong>首先精灵图图片排列有规律的核心思路:</strong></p><p><strong>利用for循环修改精灵图片的背景位置background-position</strong></p><p><strong>剩下的就是考验你的数学功底了</strong></p><p><strong>i循环里面的i索引号*44就是每个图片的y坐标</strong></p><p><strong>首先表单需要2个新事件,获得焦点onfocus失去焦点onblur</strong></p><p><strong>如果获得焦点,判断表单里面内容是否为默认文字,如果是默认文字,就清空表单内容</strong></p><p><strong>如果失去焦点,判断表单内容是否为空,如果为空,则表单内容改为默认文字</strong></p><h2 id="4·操作元素总结"><a href="#4·操作元素总结" class="headerlink" title="4·操作元素总结"></a>4·操作元素总结</h2><p><strong>操作元素是DOM核心内容</strong></p><p><img src="C:\Users\24861\Desktop\笔记图\操作元素总结.JPG" alt="操作元素总结"></p><h3 id="4-6自定义属性的操作"><a href="#4-6自定义属性的操作" class="headerlink" title="4.6自定义属性的操作"></a>4.6自定义属性的操作</h3><p><strong>1·获取属性值</strong></p><p><strong>element.属性 获取属性值</strong></p><p><strong>element.getAttribute (属性);</strong></p><p><strong>区别:</strong></p><p><strong>element.属性 获取内置属性值(元素本身自带的属性)</strong></p><p><strong>element .getattribute ( ‘属性’);主要获得自定义的属性(标准)我们程序员自定义的属性</strong></p><p><strong>2,设置属性值</strong></p><p><strong>element.属性&#x3D; ‘值’ 设置内置属性值。</strong> </p><p><strong>element .setAttribute (‘属性’,‘值’);</strong></p><p><strong>3.移除属性</strong></p><p><strong>element. removeAttribute (‘’属性”);</strong></p><h3 id="4-7-H5自定义属性"><a href="#4-7-H5自定义属性" class="headerlink" title="4.7 H5自定义属性"></a>4.7 H5自定义属性</h3><p><strong>自定义属性目的:是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。</strong></p><p><strong>自定义属性获取是通过getAttribute (属性”)获取。但是有些自定义属性很容易引起歧义,不容易判断是元素的内 属性还是自定义属性。</strong></p><p><strong>H5给我们新增了自定义属性:</strong></p><p><strong>1·设置H5自定义属性H5规定自定义属性data开头做为属性名并且赋值</strong></p><p><strong>比如<div data-inde= "1" ></div></strong></p><p><strong>或者使用JS设置</strong></p><p><strong>element.setAttribute( ‘data-index’ ,2)</strong></p><p><strong>2,获取H5自定义属性</strong></p><p><strong>1,兼容性获取element.getAttribute( ‘data-index ‘)</strong></p><p><strong>H5新增element.dataset.index或者element.dataset ’index’ ] ie 11才开始支持</strong></p><h2 id="5．节点操作"><a href="#5．节点操作" class="headerlink" title="5．节点操作"></a>5．节点操作</h2><h3 id="5-1为什么学节点操作"><a href="#5-1为什么学节点操作" class="headerlink" title="5.1为什么学节点操作"></a>5.1为什么学节点操作</h3><h4 id="1-利用DOM提供的方法获取元素"><a href="#1-利用DOM提供的方法获取元素" class="headerlink" title="1,利用DOM提供的方法获取元素"></a><strong>1,利用DOM提供的方法获取元素</strong></h4><p><strong>document.getElementByld(）</strong></p><p><strong>document.getElementsByTagName()</strong></p><p><strong>document.querySelector等</strong></p><p><strong>逻辑性不强、繁琐</strong></p><h4 id="2·利用节点层级关系获取元素"><a href="#2·利用节点层级关系获取元素" class="headerlink" title="2·利用节点层级关系获取元素"></a>2·利用节点层级关系获取元素</h4><p><strong>利用父子兄节点关系获取元素</strong></p><p><strong>逻辑性强,但是兼容性稍差</strong></p><p><strong>这两种方式都可以获取元素节点,我们后面都会使用,但是节点操作更简单</strong></p><h3 id="5-2节点概述"><a href="#5-2节点概述" class="headerlink" title="5.2节点概述"></a>5.2节点概述</h3><p><strong>网页中的所有内容都是节点(标签、属性、文本、注程等) ,在DOM中,节点使用node来表示。HTMILDOM树中的所有节点均可通过Javascript进行访问,所有HTML元素(节点)均可被修改,也可以创建或删除。</strong></p><p><strong>一般地,节点至少拥有nodeType (节点类型)、nodeName (节点名称)和nodeValue (节点值)这三个基本属性。</strong></p><p><strong>元素节点nodeType为1</strong></p><p><strong>属性节点nodeType为2</strong></p><p><strong>文本节点nodelype为3 (文本节点包含文字、空恪、换行等)</strong></p><p><strong>我们在实际开发中,节点操作主要操作的是元素节点</strong></p><h3 id="5-3节点层级"><a href="#5-3节点层级" class="headerlink" title="5.3节点层级"></a>5.3节点层级</h3><p><strong>利用DOM树可以把节点划分为不同的层级关系,常见的是父子兄层级关系。</strong></p><p><strong>1,父级节点 node.parentNode</strong></p><p><strong>parentNode属性可返回某节点的父节点,注意是最近的一个父节点</strong></p><p><strong>如果指定的节点没有父节点则返回null</strong></p><p><strong>2.子节点</strong></p><p><strong>1. parentNode. childNodes (标准）</strong></p><p><strong>parentNode. childNodes返回包含指定节点的子节点的集合,该集合为即时更新的集合。</strong></p><p><strong>注意：返回值里面包含了所有的子节点,包括元素节点,文本节点等。如果只想要获得里面的元素节点,则需要专门处理。所以我们一般不提倡使用childNodes</strong></p><p><strong>var ul &#x3D; document. queryselector (‘ul’);</strong></p><p><strong>for(var i&#x3D; 0; i &lt; ul.childNodes.length;i++) {</strong></p><p><strong>if (ul.childNodes [i].nodeType&#x3D;&#x3D;1) {</strong></p><p><strong>&#x2F;&#x2F; ul.childNodes [i]是元素节点</strong></p><p><strong>console. log (ul.childNodes [i]);</strong></p><p><strong>}</strong></p><p><strong>}</strong></p><p><strong>children获取所有的子元素节点</strong></p><p><strong>2.parentNode. children (非标准)</strong></p><p><strong>firstChild返回第一个子节点,找不到则返回null,同样,也是包含所有的节点。</strong></p><p><strong>3.parentNode.firstChild</strong></p><p><strong>lastchild返回第一个子节点,找不到则返回null,同样,也是包含所有的节点。</strong></p><p><strong>4.parentNode.lastchild</strong></p><p><strong>5.parentNode .firstElementChild</strong></p><p><strong>firstElementchild返回第一个子元素节点,找不到则返回null</strong></p><p><strong>6.parent Node  .lastElementChild</strong></p><p><strong>lastElenentchild返回最后一个子元素节点,找不到则返回null</strong></p><p><strong>注意:这两个方法有兼容性问题, IE9以上才支持。</strong></p><p><strong>实际开发中, firstChild和lastchild包含其他节点,操作不方便,而firstElementchild和lastElementchila又有兼容性问题,那么我们如何获取第一个子元素节点或最后一个子元素节点呢?</strong></p><h3 id="3-兄弟节点"><a href="#3-兄弟节点" class="headerlink" title="3.兄弟节点"></a><strong>3.兄弟节点</strong></h3><p><strong>1.node.nextsibling</strong></p><p><strong>nextsibling返回当前元素的下一个兄弟节点,找不到则返回nu11。同样,也是包含所有的节点。</strong></p><p><strong>2.node.previoussibling</strong></p><p><strong>previoussibling返回当前元素上一个兄弟节点,找不到则返回nu11。同样,也是包含所有的节点</strong></p><p><strong>3.node.nextElementsibling</strong></p><p><strong>nextElementsibling返回当前元素下一个兄弟元素节点,找不到则返回null.</strong></p><p><strong>4.node.previousElementsibling</strong></p><p><strong>previousElementsibling返回当前元素上一个兄弟节点,找不到则返回null.</strong></p><p><strong>主意:这两个方法有兼容性问题, 1E9以上才支持。</strong></p><p><strong>如何解决兼容性问题?</strong></p><p><strong>自己封装一个兼容性的函数</strong></p><p><strong>function getNextElementsibling (element) {</strong></p><p><strong>var el &#x3D; element;</strong></p><p><strong>while (el &#x3D; el.nextsibling) {</strong></p><p><strong>if (el.nodeType &#x3D;&#x3D;1) {</strong> </p><p><strong>return el;</strong></p><p><strong>}</strong></p><p><strong>}</strong></p><p><strong>return null;</strong></p><p><strong>}</strong></p><h3 id="5-4创建节点"><a href="#5-4创建节点" class="headerlink" title="5.4创建节点"></a>5.4创建节点</h3><p><strong>document. createElement (“tagName ‘)document. createlement ()</strong></p><p><strong>方法创建由tagName指定的HTML元素。因为这些元素原先不存在,是根据我们的需求动态生成的,所以我们也称为动态创建元素节点。</strong></p><h3 id="5-5添加节点"><a href="#5-5添加节点" class="headerlink" title="5.5添加节点"></a>5.5添加节点</h3><p><strong>1.node.appendchild (child)</strong> </p><p><strong>node. appendchild()方法将一个节点添加到指定父节点的子节点列表未尾。类似于css里面的after伪元素。</strong></p><p><strong>2.node.insertBefore (child,指定元素)</strong></p><p><strong>node. insert Be fore ()方法将一个节点添加到父节点的指定子节点前面。类似于css里面的before伪元素。</strong></p><h3 id="5-5删除节点"><a href="#5-5删除节点" class="headerlink" title="5.5删除节点"></a>5.5删除节点</h3><p><strong>node. removechild (child)</strong></p><p><strong>node.removechild()方法从DoM中删除一个子节点,返回删除的节点</strong></p><h3 id="5-6复制节点-克隆节点"><a href="#5-6复制节点-克隆节点" class="headerlink" title="5.6复制节点(克隆节点)"></a>5.6复制节点(克隆节点)</h3><p><strong>node.cloneNode ()node.cloneNode (1)方法返回调用该方法的节点的一个副本。也称为克隆节点&#x2F;拷贝节点</strong></p><p><strong>注意：</strong></p><p><strong>1,如果括号参数为空或者为false ,则是浅拷贝,即只克隆复制节点本身,不克隆里面的子节点。</strong></p><p><strong>2,如果括号参数为true,则是深度拷贝,会复制节点本身以及里面所有的子节点。</strong></p><h3 id="5-8三种动态创建元素区别"><a href="#5-8三种动态创建元素区别" class="headerlink" title="5.8三种动态创建元素区别"></a>5.8三种动态创建元素区别</h3><p><strong>document.write ()</strong></p><p><strong>element .innerHTML</strong></p><p><strong>document. creeateElement ().</strong></p><p><strong>区别.</strong></p><p><strong>1. document.write是直接将内容写入页面的内容流,但是文档流执行完毕,则它会导致页面全部重绘</strong></p><p><strong>2.innerHTML是将内容写入某个DoM节点,不会导致页面全部重绘</strong></p><p><strong>3.innerHTML创建多个元素效率更高(不要拼接字符串,采取数组形式拼接) ,结构稍微复杂</strong></p><p><strong>4.createElement ()创建多个元素效率稍低一点点,但是结构更清材</strong></p><p><strong>总结:不同浏览器下, innerHTM效率要比creatElement高</strong></p><h2 id="6-DOM重点核心"><a href="#6-DOM重点核心" class="headerlink" title="6.DOM重点核心"></a>6.DOM重点核心</h2><p><strong>文档对象模型( Document Object Model,简称DOM ) ,是W3C组织推荐的处理可扩展标记语言(HTML或者XML )的标准编程接口</strong></p><p><strong>W3C已经定义了一系列的DOM接口,通过这些DOM接口可以改变网页的内容、结构和样式</strong></p><p><strong>1,对于JavaScript,为了能够使lavaScript操作HTML , JavaScript就有了一套自己的dom编程接口。</strong></p><p><strong>2,对于HTMIL, dom使得html形成一棵dom树,包含文档、元素、节点</strong></p><p><strong>我们获取过来的DOM元素是一个对象(object) , 所以称为文档对象模型</strong></p><p><strong>关于dom操作,我们主要针对于元素的操作。主要有创建、增、删、改、查、属性操作、事件操作。</strong></p><h3 id="6-1创建"><a href="#6-1创建" class="headerlink" title="6.1创建"></a>6.1创建</h3><ol><li><strong>document.write</strong></li><li><strong>innerHTML</strong></li><li><strong>createElement</strong></li></ol><h3 id="6-2增"><a href="#6-2增" class="headerlink" title="6.2增"></a>6.2增</h3><ol><li><strong>appendChild</strong></li><li><strong>insertBefore</strong></li></ol><h3 id="6-3删"><a href="#6-3删" class="headerlink" title="6.3删"></a><strong>6.3删</strong></h3><ol><li><strong>removeChild</strong></li></ol><h3 id="6-4改"><a href="#6-4改" class="headerlink" title="6.4改"></a>6.4改</h3><p><strong>主要修改dom的元素属性, dom元素的内容、属性,表单的值等</strong></p><p><strong>1.修改元素属性: src, href, titte等</strong></p><p><strong>2,修改普通元素内容: innerHTML, innerText</strong></p><p><strong>3,修改表单元素: value, type, disabled等</strong></p><p><strong>4.修改元素样式: style, className</strong></p><h3 id="6-5查"><a href="#6-5查" class="headerlink" title="6.5查"></a>6.5查</h3><p><strong>主要获取查询dom的元素</strong></p><ol><li><p><strong>DOM提供的API方法: getElementByld, getElementsByTagName  古老用法不太推荐</strong></p></li><li><p><strong>H5提供的新方法: querySelector, querySelectorAll提倡</strong></p></li><li><p><strong>“利用节点操作获取元素:父(parentNode),子(children),</strong></p><p><strong>兄(previousElementSibling \ nextElementSibling )提倡</strong></p></li></ol><h3 id="6-6属性操作"><a href="#6-6属性操作" class="headerlink" title="6.6属性操作"></a>6.6属性操作</h3><p><strong>主要针对于自定义属性。</strong></p><ol><li><strong>setAttribute :设置dom的属性值</strong></li><li><strong>getAttribute :得到dom的属性值</strong></li><li><strong>removeAttribute移除属性</strong></li></ol><h3 id="6-7-事件操作"><a href="#6-7-事件操作" class="headerlink" title="6.7 事件操作"></a>6.7 事件操作</h3><p><strong>给元素注册事件,采取事件源事件类型&#x3D;事件处理程序</strong></p><img src="C:\Users\24861\Desktop\笔记图\操作事件.JPG" alt="操作事件" style="zoom:100%;" /><h2 id="1-注册事件-绑定事件"><a href="#1-注册事件-绑定事件" class="headerlink" title="1.注册事件(绑定事件)"></a>1.注册事件(绑定事件)</h2><p><strong>1.1注册事件概述给元素添加事件,称为注册事件或者绑定事件。</strong></p><p><strong>注册事件有两种方式:传统方式和方法监听注册方式</strong></p><p><strong>传统注册方式</strong></p><p><strong>利用on开头的事件onclick</strong></p><p><button onclick= "alert(hi~)" ></button></p><p><strong>btn.onclick &#x3D; function(){}</strong></p><p><strong>特点：注册事件的唯一性,</strong></p><p><strong>同一个元素同一个事件只能设置一个处理函数,最后注册的处理函数将会覆盖前面注册的处理函数</strong></p><p><strong>方法监听注册方式</strong></p><p><strong>w3c标准推荐方式</strong></p><p><strong>addEventListener()它是一个方法</strong></p><p><strong>IE9之前的IE不变持此方法,可使用attachEvent()代替</strong></p><p><strong>特点:同一个元素同一个事件可以注册多个监听器</strong></p><p><strong>按注册顺序依次执行</strong></p><h3 id="1-2-addEventListener事件监听方式"><a href="#1-2-addEventListener事件监听方式" class="headerlink" title="1.2 addEventListener事件监听方式"></a>1.2 addEventListener事件监听方式</h3><p><strong>eventTarget.addEventListener (type, listener [, usecapture]).</strong></p><p><strong>eventTarget.addEventListener ()方法将指定的监听器注册到eventTarget (目标对象)上,当该对象触发指定的事件时,就会执行事件处理函数。</strong></p><p><strong>该方法接收三个参数:</strong></p><p><strong>type:事件类型字符串,比如click, mouseover ,注意这里不要带on</strong></p><p><strong>listener:事件处理函数,事件发生时,会调用该监听函数</strong></p><p><strong>useCapture:可选参数,是一个布尔值,默认是false,学完DOM事件流后,我们再进步学习</strong></p><h3 id="1-3-attachEvent事件监听方式"><a href="#1-3-attachEvent事件监听方式" class="headerlink" title="1.3 attachEvent事件监听方式"></a>1.3 attachEvent事件监听方式</h3><p><strong>eventrarget. attachEvent (eventNamewithOn, callback).</strong></p><p><strong>eventTarget. attachEvent ()方法将指定的监听器注册到eventTarget (目标对象)上,当该对象触发指定的事件时,指定的回调函数就会被执行。</strong></p><p><strong>该方法接收两个参数:</strong></p><p><strong>eventNameWithOn :事件类型字符串,比如onclick, onmouseover ,这里要带on</strong></p><p><strong>callback :事件处理函数,当目标触发事件时回调函数被调用</strong></p><h3 id="1-4注册事件兼容性解决方案"><a href="#1-4注册事件兼容性解决方案" class="headerlink" title="1.4注册事件兼容性解决方案"></a>1.4注册事件兼容性解决方案</h3><p><strong>function addEventzistener (element, eventName, fn) {</strong></p><p><strong>&#x2F;&#x2F;判断当前浏览器是否支持addEventListener方法</strong></p><p><strong>if (element. addEventListener) {</strong></p><p><strong>element.addiventListener (eventName, fn); &#x2F;&#x2F;第三个参数默认是false</strong></p><p><strong>} else if (element.attachEvent) {</strong></p><p><strong>element. attachEvent (‘on’ + eventName, fn);</strong></p><p><strong>} else{</strong></p><p><strong>&#x2F;&#x2F;相当于element.onclick&#x3D;fn;</strong></p><p><strong>element[‘on’ + eventName] &#x3D; fn;</strong></p><p><strong>}</strong></p><p><strong>兼容性处理的原则:首先照顾大多数浏览器,再处理特殊浏览器</strong></p><h2 id="2-删除事件（解绑事件"><a href="#2-删除事件（解绑事件" class="headerlink" title="2.删除事件（解绑事件)."></a>2.删除事件（解绑事件).</h2><h3 id="2-1删除事件的方式"><a href="#2-1删除事件的方式" class="headerlink" title="2.1删除事件的方式"></a>2.1删除事件的方式</h3><p><strong>1.传统注册方式</strong></p><p><strong>eventTarget.onclick &#x3D; null;</strong></p><p><strong>2.方法监听注册方式.</strong></p><p><strong>eventTarget. removeEventListener (type, listenerl, useCapturel);</strong></p><p><strong>ventrarget. detachEvent (eventNamewithon, callback);</strong></p><h3 id="2-2删除事件兼容性解决方案"><a href="#2-2删除事件兼容性解决方案" class="headerlink" title="2.2删除事件兼容性解决方案"></a>2.2删除事件兼容性解决方案</h3><p><strong>functiont removeEventListener (element, eventName, fn)</strong></p><p> <strong>&#x2F;&#x2F;判断当前浏览器是否支持removeEventistener方法</strong></p><p><strong>if (element. removeEventListener) {</strong></p><p><strong>element.removeEventListener (eventName, fn); &#x2F;&#x2F;第三个参数默认是false</strong></p><p><strong>} else if (element.detaEvent) {</strong></p><p><strong>element. detachEvent (‘on’ + eventName, fn);</strong></p><p><strong>} else {</strong></p><p><strong>element[‘on’ + eventName] &#x3D; null;</strong></p><p><strong>}</strong></p><h2 id="3-DOM事件流"><a href="#3-DOM事件流" class="headerlink" title="3.DOM事件流"></a>3.DOM事件流</h2><p><strong>事件流描述的是从页面中接收事件的顺序。</strong></p><p><strong>事件发生时会在元素节点之间按照特定的顺字传播,这个传播过程即DOM事件流。</strong></p><p><img src="C:\Users\24861\Desktop\笔记图\Dom事件流.JPG" alt="Dom事件流"></p><p><strong>事件冒泡: IE最早提出,事件开始时由最具体的元素接收,然后逐级向上传播到到DOM最顶层节点的过程。</strong></p><p><strong>事件捕获:网景最早提出,由DOM最顶层节点开始,然后逐级向下传播到到最具体的元素接收的过程。</strong></p><p><strong>我们向水里面扔一块石头,首先它会有一个下降的过程,这个过程就可以理解为从最顶层向事件发生的最具体元素(目标点)的捕获过程;之后会产生泡泡,会在最低点(最具体元素)之后漂浮到水面上,这个过程相当于事件冒泡。</strong></p><p><img src="C:\Users\24861\Desktop\笔记图\事件流2.JPG" alt="事件流2"></p><p><strong>事件发生时会在元素节点之间按照特定的顺序传播,这个传播过程即DoM事件流。</strong></p><p><strong>注意.</strong></p><p><strong>1. Js代码中只能执行捕获或者冒泡其中的一个阶段。</strong></p><p><strong>2.onclick和attachEvent只能得到冒泡阶段</strong></p><p><strong>3.addEventListener (type, listenert, usecapture] )</strong></p><p><strong>第三个参数如果是true ,表示在事件捕获阶段调用事件处理程序;</strong></p><p><strong>如果是false (不写默认就是false ) ,表示在事件冒泡阶段调用事件处理程序。</strong></p><p><strong>4,实际开发中我们很少使用事件捕获,我们更关注事件冒泡。</strong></p><p><strong>5,有些事件是没有冒泡的,比如onblur, onfocus, onmouseenter, onmouseleave</strong></p><p><strong>6·事件冒泡有时候会带来麻烦,有时候又会帮助很巧妙的做某些事件,我们后面讲解。</strong></p><h3 id="4-1什么是事件对象"><a href="#4-1什么是事件对象" class="headerlink" title="4.1什么是事件对象"></a>4.1什么是事件对象</h3><p><strong>eventTarget. onclick &#x3D; function (event) {}</strong></p><p><strong>&#x2F;&#x2F;这个event就是事件对象,我们还喜欢的写成e或者evt</strong></p><p><strong>eventTarget.addEventListener (‘click’, function (event) {})</strong></p><p><strong>&#x2F;&#x2F;这个event就是事件对象,我们还喜欢的写成e或者evt</strong></p><p><strong>官方解释: event对象代表事件的状态 比如键盘按键的状态鼠标的位置、鼠标按钮的状态。</strong></p><p><strong>简单理解:事件发生后,跟事件相关的一系列信息数据的集合都放到这个对象里面,这个对象就是事件对象event,它有很多属性和方法。</strong></p><p><strong>比如：</strong></p><p><strong>1谁绑定了这个事件。</strong></p><p><strong>2鼠标触发事件的话,会得到鼠标的相关信息,如鼠标位置。</strong></p><p><strong>3键盘触发事件的话,会得到腱盘的相关信息,如按了哪个键。</strong></p><p><strong>这个event是个形参,系统帮我们设定为事件对象,不需要传递实参过去。</strong></p><p><strong>当我们注册事件时, event对象就会被系统自动创建,并依次传递给事件监听器(事件处理函数)。</strong></p><h3 id="4-3事件对象的兼容性方案"><a href="#4-3事件对象的兼容性方案" class="headerlink" title="4.3事件对象的兼容性方案"></a>4.3事件对象的兼容性方案</h3><p><strong>事件对象本身的获取存在兼容问题:</strong></p><p><strong>1,标准浏览器中是浏览器给方法传递的参数,只需要定义形参e就可以获取到。</strong></p><p><strong>2.在1E6-8中,浏览器不会给方法传递参数,如果需要的话,需要到window.event中获取查找。</strong></p><p><strong>解决:e &#x3D;e Il window.event</strong></p><h3 id="4-4事件对象的常见属性和方法"><a href="#4-4事件对象的常见属性和方法" class="headerlink" title="4.4事件对象的常见属性和方法"></a>4.4事件对象的常见属性和方法</h3><p><strong>事件对象属性方法说明</strong></p><p><strong>e.target 返回触发事件的对象标准</strong></p><p><strong>e.srcElement返回触发事件的对象非标准1e6-8使用</strong></p><p><strong>e.type返回事件的类型比如click mouseover不带on</strong></p><p><strong>e.cancelBubble该属性阻止冒泡非标准ie6-8使用</strong></p><p><strong>e.returnValue该属性阻止默认事件(默认行为)非标准ie6-8使用比如不让链接跳转</strong></p><p><strong>e.preventDefault()该方法阻止默认事件(默认行为)标准比如不让链接跳转</strong></p><p><strong>e.stopPropagation()阻止冒泡标准</strong></p><h3 id="5-1阻止事件冒泡的两种方式"><a href="#5-1阻止事件冒泡的两种方式" class="headerlink" title="5.1阻止事件冒泡的两种方式"></a>5.1阻止事件冒泡的两种方式</h3><p><strong>事件冒泡:开始时由最具体的元素接收,然后逐级向上传播到到DOM最页层节点。</strong></p><p><strong>事件冒泡本身的特性,会带来的坏处,也会带来的好处,需要我们灵活掌握。</strong></p><p><strong>阻止事件冒泡标准写法:</strong></p><p><strong>利用事件对象里面的stopPropagation()方法</strong>  <strong>&#x2F;&#x2F;stop停止 Propagation 传播</strong></p><p><strong>e.cancelBubble &#x3D; true;&#x2F;&#x2F;cancel 取消bubble泡泡</strong> </p><h3 id="5-2阻止事件冒泡的兼容性解决方案"><a href="#5-2阻止事件冒泡的兼容性解决方案" class="headerlink" title="5.2阻止事件冒泡的兼容性解决方案"></a>5.2阻止事件冒泡的兼容性解决方案</h3><p><strong>if (e &amp;&amp; e.stopPropagation) {</strong></p><p><strong>e.stopPropagation();</strong></p><p><strong>}else{</strong></p><p><strong>window.event.cancelBubble &#x3D; true;</strong></p><p><strong>}</strong></p><h2 id="6．事件委托（代理、委派"><a href="#6．事件委托（代理、委派" class="headerlink" title="6．事件委托（代理、委派)"></a>6．事件委托（代理、委派)</h2><p><strong>事件冒泡本身的特性,会带来的坏处,也会带来的好处,需要我们灵活掌握,生活中有如下场景:</strong></p><p><strong>咱们班有100个学生,快递员有100个快递,如果一个个的送花费时间较长。同时每个学生领取的时候,也需要排队领取，也花费时间较长,何如?</strong></p><p><strong>解决方案:快递员把100个快递,委托给班主任,班主任把这些快递放到办公室,同学们下课自行领取即可。</strong></p><p><strong>优势:快递员省事,委托给班主任就可以走了。同学们领取也方便,因为相信班主任。</strong></p><p>事件冒泡本身的特性,会带来的坏处,也会带来的好处,需要我们灵活掌握。程序中也有如此场景:</p><p>1.<ul></p><li>知否知否,应该有弹框在手</li><li>知否知否,应该有弹框在手</li><li>知否知否,应该有弹框在手</li><li>知否知否,应该有弹框在手</li><li>知否知否,应该有弹框在手</li><p>1.<ul></p><p><strong>点击每个li都会弹出对话框,以前需要给每个 注册事件,是非常辛苦的,而且访问DOM的次数越多,这就会延长整个页面的交互就绪时间。</strong></p><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p><strong>事件委托也称为事件代理,在jQuery里面称为事件委派。</strong></p><h3 id="事件委托的原理"><a href="#事件委托的原理" class="headerlink" title="事件委托的原理"></a>事件委托的原理</h3><p><u><strong>(重要)不是每个子节点单独设置事件监听器,而是事件监听器设置在其父节点上,然后利用冒泡原理影响设置每个子节点。</strong></u></p><p><strong>以上案例:给ul注册点击事件,然后利用事件对象的target来找到当前点击的l1,因为点击li,事件会冒泡到ul上,ul有注册事件,就会触发事件监听器。</strong></p><h3 id="事件委托的作用"><a href="#事件委托的作用" class="headerlink" title="事件委托的作用"></a><strong>事件委托的作用</strong></h3><p><strong>我们只操作了一次DOM,提高了程序的性能。</strong></p><h2 id="7．常用的鼠标事件"><a href="#7．常用的鼠标事件" class="headerlink" title="7．常用的鼠标事件"></a>7．常用的鼠标事件</h2><h3 id="7-1常用的鼠标事件"><a href="#7-1常用的鼠标事件" class="headerlink" title="7.1常用的鼠标事件"></a>7.1常用的鼠标事件</h3><p><strong>1.禁止鼠标右键菜单</strong></p><p><strong>contextmenu主要控制应该何时显示上下文菜单,主要用于程序员取消默认的上下文某单document.addEventListener (‘contextmenu’, function(e) {</strong></p><p><strong>e.preventDefault ();</strong></p><p><strong>})</strong></p><p><strong>2.禁止鼠标选中( selectstart开始选中)</strong></p><p><strong>document.addEventListener (‘selectstart’, function(e) {</strong></p><p><strong>e.preventDefault ();</strong></p><p><strong>})</strong></p><h3 id="7-2鼠标事件对象"><a href="#7-2鼠标事件对象" class="headerlink" title="7.2鼠标事件对象"></a>7.2鼠标事件对象</h3><p><strong>event对象代表事件的状态,跟事件相关的一系列信息的集合。现阶段我们主要是用鼠标事件对象</strong></p><p><strong>MouseEvent和键盘事件对象KeyboardEvent.</strong></p><p><strong>鼠标事件对象说明</strong></p><p><strong>e.clientx返回鼠标相对于浏览器窗口可视区的×坐标</strong></p><p><strong>e.clientY返回鼠标相对于浏览器窗口可视区的Y坐标</strong></p><p><strong>e.pagex返回鼠标相对于文档页面的x坐标1E9+支持</strong></p><p><strong>e.pageY返回鼠标相对于文档页面的Y坐标1E9+支持</strong></p><p><strong>e.screenX返回鼠标相对于电脑屏幕的x坐标</strong></p><p><strong>e.screenY返回鼠标相对于电脑屏幕的Y坐标</strong></p><h3 id="8-1常用键盘事件"><a href="#8-1常用键盘事件" class="headerlink" title="8.1常用键盘事件"></a>8.1常用键盘事件</h3><p><strong>事件除了使用鼠标触发,还可以使用鍵盘触发。</strong></p><p><strong>键盘事件触发条件</strong></p><p><strong>onkeyup某个键盘按键被松开时触发</strong></p><p><strong>onkeydown 某个鍵盘按键被按下时触发</strong></p><p><strong>onkeypress某个键盘按键被按下时触发 但是它不识别功能键比如ctrl shift箭头等</strong></p><p><strong>注意:</strong></p><p><strong>1,如果使用addEventListener不需要加on</strong></p><p><strong>2.onkeypress和前面2个的区别是,它不识别功能键,比如左右箭头, shift等。</strong></p><p><strong>3.三个事件的执行顺序是: keydown–keypress —keyup</strong></p><h3 id="8-2键盘事件对象"><a href="#8-2键盘事件对象" class="headerlink" title="8.2键盘事件对象"></a>8.2键盘事件对象</h3><p><strong>键盘事件对象属性    说明</strong></p><p><strong>keyCode返回该键的ASCII值</strong></p><p><strong>注意: onkeydown和onkeyup不区分字母大与, onkeypress区分字母大小写.</strong></p><p><strong>在我们实际开发中,我们更多的使用keydown和keyup ,它能识别所有的键(包括功能键)</strong></p><p><strong>Keypress不识别功能键,但是keyCode属性能区分大小写,返回不同的ASCI值</strong></p><p><img src="C:\Users\24861\Desktop\笔记图\ACSII.JPG" alt="ACSII"></p><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><p><strong>1.1什么是BOMBOM (Browser Object Model )即浏览器对象模型,它提供了独立于内容而与浏览器窗口进行交互的对象,其核心对象是window.</strong></p><p><strong>BOM由一系列相关的对象构成,并且每个对象都提供了很多方法与属性。BOM缺乏标准, Javascript语法的标准化组织是ECMA, DOM的标准化组织是W3C, BOM最初是Netscape浏览器标准的一部分。</strong></p><p><strong>DOM</strong></p><p><strong>文档对象模型</strong></p><p><strong>DOM就是把「文档」当做一个「对象」来看待</strong></p><p><strong>DOM的顶级对象是document</strong></p><p><strong>DOM主要学习的是操作页面元素</strong></p><p><strong>DOM是W3C标准规范</strong></p><p><strong>BOM</strong></p><p><strong>浏览器对象模型</strong></p><p><strong>把「浏览器」当做一个「对象」来看待</strong></p><p><strong>BOM的顶级对象是window</strong></p><p><strong>BOM学习的是浏览器窗口交互的一些对象</strong></p><p><strong>BOM是浏览器厂商在各自浏览器上定义的,兼容性较差</strong></p><p><strong>вом比DOM更大,包含DOM.</strong></p><h2 id="1-2-BоM的构成"><a href="#1-2-BоM的构成" class="headerlink" title="1.2 BоM的构成"></a>1.2 BоM的构成</h2><p><img src="E:\桌面\笔记图\bom.JPG" alt="bom"></p><p><strong>window对象是浏览器的顶级对象,它具有双重角色。</strong></p><p><strong>1,它是JS访问浏览器窗口的一个接口。</strong></p><p><strong>2,它是一个全局对象。定义在全局作用域中的变量、函数都会变成window对象的属性和方法。在调用的时候可以省略window ,前面学习的对话框都属于window对象方法,如alert(), prompt()等。</strong></p><p><strong>注意： window下的一个特殊属性window.name</strong></p><h2 id="2-1窗口加载事件"><a href="#2-1窗口加载事件" class="headerlink" title="2.1窗口加载事件"></a>2.1窗口加载事件</h2><p><strong>window.onload &#x3D; function (){}</strong></p><p><strong>或者window.addEventListener (“load”, function () {});</strong></p><p><strong>window.onload是窗口(页面)加载事件,当文档内容完全加载完成会触发该事件(包括图像、脚本文件、CSs文件等),就调用的处理函数。</strong></p><p><strong>注意:</strong></p><p><strong>1,有了window.onload就可以把JS代码写到页面元素的上方,因为onload是等页面内容全部加载完毕,再去执行处理函数。</strong></p><p><strong>2. window.onload传统注册事件方式只能写一次,如果有多个,会以最后一个window.onload为准。</strong></p><p><strong>3,如果使用addEventnistener则没有限制</strong></p><p><strong>document.addEventListener (‘DOMContentLoaded’, function(){})</strong></p><p><strong>DOMContentLoaded事件触发时,仅当DOM加载完成,不包括样式表,图片, flash等等。le9以上才支持</strong></p><p><strong>如果页面的图片很多的话,从用户访问到onload触发可能需要较长的时间,交互效果就不能实现,必然影响用户的体验,此时用DOMContentloaded事件比较合适。</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>load等页面内容全部加载完毕,包含页面dom元素图片flash css等等DOMContentLoaded是DOM加载完毕,不包含图片falsh css等就可以执行加载速度比load更快一些</strong></p><h2 id="2-2调整窗口大小事件"><a href="#2-2调整窗口大小事件" class="headerlink" title="2.2调整窗口大小事件"></a>2.2调整窗口大小事件</h2><p><strong>window.onresize &#x3D; function(){}</strong></p><p><strong>window.addEventListener(“resize”, function(){});</strong></p><p><strong>window.onresize是调整窗口大小加载事件,当触发时就调用的处理函数。注意:</strong></p><p><strong>1,只要窗口大小发生像素变化,就会触发这个事件。</strong></p><p><strong>2,我们经常利用这个事件完成响应式布局.window.innerWidth当前屏幕的宽度</strong></p><h2 id="3-1两种定时器"><a href="#3-1两种定时器" class="headerlink" title="3.1两种定时器"></a><strong>3.1两种定时器</strong></h2><p><strong>window对象给我们提供了2个非常好用的方法-定时器。</strong></p><p><strong>setTimeout()</strong></p><p><strong>setlnterval()</strong></p><h2 id="3-2-setTimeout-定时器"><a href="#3-2-setTimeout-定时器" class="headerlink" title="3.2 setTimeout()定时器"></a>3.2 setTimeout()定时器</h2><p><strong>window.setTimeout (调用函数, [延迟的毫秒数]);</strong></p><p><strong>setTimeout()方法用于设置一个定时器,该定时器在定时器到期后执行调用函数。</strong></p><p><strong>这个window在调用的时候可以省略</strong></p><p><strong>这个延时时间单位是毫秒但是可以省略,如果省略默认的是0</strong></p><p><strong>这个调用函数可以直接写函数还可以写函数名</strong></p><p><strong>还有一个写法,’函数名()’ &#x2F;&#x2F;我们不提倡这个写法</strong></p><p><strong>页面中可能有很多的定时器,我们经常给定时器加标识符(名字)</strong></p><p><strong>setTimeout()这个调用函数我们也称为回调函数callback</strong></p><p><strong>普通函数是按照代码顺序直接调用。</strong></p><p><strong>而这个函数,需要等待时间,时间到了才去调用这个函数,因此称为回调函数。</strong></p><p><strong>简单理解:回调,就是回头调用的意思。上一件事干完,再回头再调用这个函数。</strong></p><p><strong>以前我们讲的element.onclick&#x3D;functiono(){}或者element.addeventistener(“clik”, fn);里面的函数也是回调函数。</strong></p><h2 id="3-3停止setTimeout-定时器（只调用一次）"><a href="#3-3停止setTimeout-定时器（只调用一次）" class="headerlink" title="3.3停止setTimeout()定时器（只调用一次）"></a>3.3停止setTimeout()定时器（只调用一次）</h2><p><strong>window.clearTimeout (timeoutID)—(定时器名字)</strong></p><p><strong>clearTimeout (1)方法取消了先前通过调用setTimeout ()建立的定时器。</strong></p><p><strong>注意：1. window可以省略。</strong></p><h2 id="3-4-setInterval-定时器（重复调用）"><a href="#3-4-setInterval-定时器（重复调用）" class="headerlink" title="3.4 setInterval()定时器（重复调用）"></a>3.4 setInterval()定时器（重复调用）</h2><p><strong>window.set Interval (回 函数, [间隔的毫秒数] );</strong></p><p><strong>setinterval()方法重复调用一个函数,每隔这个时间,就去调用一次回调函数。</strong></p><p><strong>注意：</strong></p><ol><li><strong>window可以省略</strong></li><li><strong>这个调用函数可以直接写函数,或者写函数名或者采取字符串函数名0三种形式。</strong></li><li><strong>间隔的毫秒数省略默认是0,如果写,必须是毫秒,表示每隔多少毫秒就自动调用这个函数。</strong></li><li><strong>因为定时器可能有很多,所以我们经常给定时器赋值一个标识符。</strong></li></ol><h2 id="3-5停止setInterval-定时器"><a href="#3-5停止setInterval-定时器" class="headerlink" title="3.5停止setInterval()定时器"></a>3.5停止setInterval()定时器</h2><p><strong>window. clearInterval (intervalID);</strong></p><p><strong>clearInterval ()方法取消了先前通过调用setInterval ()建立的定时器。</strong></p><p><strong>注意:</strong></p><p><strong>1.window可以省略。</strong></p><p><strong>2.里面的参数就是定时器的标识符。</strong></p><h2 id="3-6-this"><a href="#3-6-this" class="headerlink" title="3.6 this"></a>3.6 this</h2><p><strong>this的指向在函数定义的时候是确定不了的,只有函数执行的时候才能确定</strong></p><p><strong>this到底指向谁,一般情况下this的最终指向的是那个调用它的对象</strong></p><p><strong>现阶段,我们先了解一下几个this指向</strong></p><p><strong>1,全局作用域或者普通函数中this指向全局对象window (注意定时器里面的this指向window )</strong></p><h2 id="4-JS执行机制"><a href="#4-JS执行机制" class="headerlink" title="4.JS执行机制"></a>4.JS执行机制</h2><h2 id="4-1JS单线程"><a href="#4-1JS单线程" class="headerlink" title="4.1JS单线程"></a>4.1JS单线程</h2><p><strong>JavaScript语言的一大特点就是单线程,也就是说,同一个时间只能做一件事。这是因为Javascript这门脚本语言诞生的使命所致-JavaScript是为处理页面中用户的交互,以及操作DOM而诞生的。比如我们对某个DOM元素进行添加和删除操作,不能同时进行。应该先进行添加,之后再删除。</strong></p><p><strong>单线程就意味着,所有任务需要排队,前一个任务结束,才会执行后一个任务。这样所导致的问题是:如果JS执行的时间过长,这样就会造成页面的渲染不连贯,导致页面渲染加载阻塞的感觉。</strong></p><h2 id="4-3同步和异步"><a href="#4-3同步和异步" class="headerlink" title="4.3同步和异步"></a>4.3同步和异步</h2><p><strong>为了解决这个问题,利用多核CPU的计算能力, HTML5提出Web Worker标准,允许JavaScript脚本创建多个线程。于是，JS中出现了同步和异步。</strong></p><p><strong>同步</strong></p><p><strong>前一个任务结束后再执行后一个任务,程序的执行顺字与任务的排列顺序是一致的、同步的。比如做饭的同步做法:我们要烧水煮饭,等水开了(10分钟之后) ,再去切菜,炒菜。</strong></p><p><strong>异步</strong></p><p><strong>你在做一件事情时,因为这件事情会花费很长时间,在做这件事的同时,你还可以去处理其他事情。比如做饭的异步做法,我们在烧水的同时,利用这10分钟,去切菜,炒菜。</strong></p><p><strong>他们的本质区别：这条流水线上各个流程的执行顺序不同。</strong></p><p><strong>同步任务</strong></p><p><strong>同步任务都在主线程上执行,形成一个执行栈。</strong></p><p><strong>异步任务</strong></p><p><strong>JS的异步是通过回调函数实现的。</strong></p><p><strong>一般而言,异步任务有以下三种类型</strong></p><p><strong>1、普通事件,如click, resize等</strong></p><p><strong>2、资源加载,如load, error等</strong></p><p><strong>3、定时器,包括setInterval, setTimeout等</strong></p><p><strong>异步任务相关回调函数添加到任务队列中(任务队列也称为消息队列)。</strong></p><h2 id="4-4-JS执行机制"><a href="#4-4-JS执行机制" class="headerlink" title="4.4 JS执行机制"></a>4.4 JS执行机制</h2><p><strong>1.先执行执行栈中的同步任务。</strong></p><p><strong>2异步任务(回调函数)放入任务队列中。</strong></p><p><strong>3,一旦执行栈中的所有同步任务执行完毕,系统就会按次序读取任务队列中的异步任务,于是被读取的异步任务结束等待状态,进入执行栈，开始执行。</strong></p><p><strong>由于主线程不断的重复获得任务、执行任务、再获取任务、再执行,所以这种机制被称为事件循环( event loop).</strong></p><h2 id="5-location对象"><a href="#5-location对象" class="headerlink" title="5.location对象"></a>5.location对象</h2><h3 id="5-1什么是location对象"><a href="#5-1什么是location对象" class="headerlink" title="5.1什么是location对象"></a>5.1什么是location对象</h3><p><strong>window对象给我们提供了一个location属性用于获取或设置窗体的URL ,并且可以用于解析URL。</strong></p><p><strong>因为这个属性返回的是一个对象,所以我们将这个属性也称为location对象。</strong></p><h3 id="5-2-URL"><a href="#5-2-URL" class="headerlink" title="5.2 URL"></a>5.2 URL</h3><p><strong>统一资源定位符(Uniform Resource Locator, URL)是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL,它包含的信息指出文件的位置以及浏览器应该怎么处理它</strong></p><p><strong>URL的一股语法格式为:</strong></p><p><strong>protocol:&#x2F;&#x2F;host [:port]&#x2F;path&#x2F; [?query]#fragment</strong></p><p><strong><a href="http://www.itcast.cn/index.html">http://www.itcast.cn/index.html</a> ?name-andysage&#x3D;18#link</strong></p><p><strong>组成说明</strong></p><p><strong>protocol 通信协议常用的http,ftp,maito等</strong></p><p><strong>host主机(域名) <a href="http://www.itheima.com/">www.itheima.com</a></strong></p><p><strong>port端口号可选,省略时使用方案的默认端口如http的默认端口为80</strong></p><p><strong>path路径由零或多个&#x2F;符号隔开的字符串,一般用来表示主机上的一个目录或文件地址</strong></p><p><strong>query 参数以键值对的形式,通过&amp;符号分隔开来</strong></p><p><strong>fragment  片段#后面内容常见于链接锚点</strong></p><h2 id="5-3-location对象的属性"><a href="#5-3-location对象的属性" class="headerlink" title="5.3 location对象的属性"></a><strong>5.3 location对象的属性</strong></h2><p><strong>location对象属性返回值</strong></p><p><strong>location.href获取或者设置整个URL</strong></p><p><strong>location. host返回主机(域名) <a href="http://www.itheima.com/">www.itheima.com</a></strong></p><p> <strong>location.port返回端口号如果未写返回空字符串</strong></p><p> <strong>location.pathname  返回路径</strong></p><p> <strong>location. search返回参数</strong></p><p> <strong>location. hash返回片段#后面内容常见于链接锚点</strong></p><p><strong>重点记住: href和search</strong></p><h2 id="5-4-location对象的方法"><a href="#5-4-location对象的方法" class="headerlink" title="5.4 location对象的方法"></a>5.4 location对象的方法</h2><p><strong>location对象方法返回值</strong></p><p><strong>location.assign()跟href一样,可以跳转页面(也称为重定向页面)</strong></p><p><strong>location.replace()替换当前页面,因为不记录历史,所以不能后退页面</strong></p><p><strong>location.reload() 重新加载页面,相当于刷新按钮或者f5如果参数为true强制刷新ctrl+5</strong></p><h2 id="6-navigator对象"><a href="#6-navigator对象" class="headerlink" title="6.navigator对象"></a>6.navigator对象</h2><p><strong>navigator对象包含有关浏览器的信息,它有很多属性,我们最常用的是userAgent ,该属性可以返回由客户机发送服务器的user-agent头部的值。</strong></p><p><strong>下面前端代码可以判断用户那个终端打开页面,实现跳转</strong></p><p><strong>if ( (navigator. userAgent. match (&#x2F; (phone lpadl podl iPhone lipodl ios l iPad I Androidl tMobile IBlackBerryl IEMobi le IMOOBrowserl JuC I Fennec IwOSBrowser I BrowserNG| WebosI Symbian Iwindows Phone)&#x2F;i))) {</strong></p><p><strong>window.location.href&#x3D;””;&#x2F;&#x2F;手机</strong></p><p><strong>} else {</strong></p><p><strong>window. location.href &#x3D;””;&#x2F;&#x2F;电脑</strong></p><p><strong>}</strong></p><h2 id="7-history对象"><a href="#7-history对象" class="headerlink" title="7.history对象"></a>7.history对象</h2><p><strong>window对象给我们提供了一个history对象,与浏览器历史记录进行交互。该对象包含用户(在浏览器窗口中)访问过的URL</strong></p><p><strong>history对象方法作用</strong></p><p><strong>back()可以后退功能</strong></p><p><strong>forward()前进功能</strong></p><p><strong>go(参数)前进后退功能参数如果是1前进1个页面如果是-1后退1个页面</strong></p><h2 id="1·元素偏移量offset系列"><a href="#1·元素偏移量offset系列" class="headerlink" title="1·元素偏移量offset系列"></a>1·元素偏移量offset系列</h2><h3 id="1-1-offset概述"><a href="#1-1-offset概述" class="headerlink" title="1.1 offset概述"></a>1.1 offset概述</h3><p><strong>offset 翻译过来就是偏移量,我们使用offset系列相关属性可以动态的得到该元素的位置(偏移)、大小等。</strong></p><p><strong>获得元素距离带有定位父元素的位置</strong></p><p><strong>获得元素自身的大小(宽度高度)</strong></p><p><strong>注意:返回的数值都不带单位</strong></p><p><strong>offset系列常用属性:</strong></p><p><strong>offset系列属性作用</strong></p><p><strong>element.offsetParent返回作为该元素带有定位的父级元素如果父级都没有定位则返回body</strong></p><p><strong>element.offsetTop 返回元素相对带有定位父元素上方的偏移</strong></p><p><strong>element.offsetLeft返回元素相对带有定位父元素左边框的偏移</strong></p><p><strong>element.offsetWidth返回自身包括padding、边框、内容区的宽度,返回数值不带单位</strong></p><p><strong>element.offsetHeight 返回自身包括padding、边框、内容区的高度,返回数值不带单位</strong></p><h2 id="1-2-offset与style区别"><a href="#1-2-offset与style区别" class="headerlink" title="1.2 offset与style区别"></a>1.2 offset与style区别</h2><p><strong>offset</strong></p><p><strong>offset可以得到任意样式表中的样式值</strong></p><p><strong>offset系列获得的数值是没有单位的</strong></p><p><strong>offsetwidth 包含padding+border+width</strong></p><p><strong>offsetidth等属性是只读属性,只能获取不能赋值</strong></p><p><strong>所以,我们想要获取元素大小位置,用offset更合适</strong></p><p><strong>style</strong></p><p><strong>style只能得到行内样式表中的样式值</strong></p><p><strong>style.width获得的是带有单位的字符串</strong></p><p><strong>style.width获得不包含padding和border 的值</strong></p><p><strong>style.width是可读写属性,可以获取也可以赋值</strong></p><p><strong>所以,我们想要给元素更改值,则需要用style改变</strong></p><h2 id="2-元素可视区client系列"><a href="#2-元素可视区client系列" class="headerlink" title="2,元素可视区client系列"></a>2,元素可视区client系列</h2><p><strong>client翻译过来就是客户端,我们使用clent系列的相关属性来获取元素可视区的相关信息。通过client系列的相关属性可以动态的得到该元素的边框大小、元素大小等。</strong></p><p><strong>elient系列属性   作用</strong></p><p><strong>element.clientTop返回元素上边框的大小</strong></p><p><strong>element.clientLeft返回元素左边框的大小</strong></p><p><strong>element.clientWidth返回自身包括padding、内容区的宽度,不含边框返回数值不带单位</strong></p><p><strong>element.clientHeight 返回自身包括padding、内容区的高度,不含边框,返回数值不带单位</strong></p><h2 id="3-立即执行函数"><a href="#3-立即执行函数" class="headerlink" title="3.立即执行函数"></a>3.立即执行函数</h2><p><strong>立即执行函数</strong></p><p><strong>(functiono(){})()</strong></p><p><strong>或者</strong></p><p><strong>(function(){}())</strong></p><p><strong>主要作用:创建一个独立的作用域。避免了命名冲突问题</strong></p><h2 id="案例：淘宝flexible-js源码分析"><a href="#案例：淘宝flexible-js源码分析" class="headerlink" title="案例：淘宝flexible.js源码分析"></a><strong>案例：淘宝flexible.js源码分析</strong></h2><p><strong>下面三种情况都会刷新页面都会触发load事件。</strong></p><p><strong>1.a标签的超链接</strong></p><p><strong>2.F5或者刷新按钮(强制刷断)</strong></p><p><strong>3.前进后退按钮</strong></p><p><strong>但是火狐中,有个特点,有个”往返缓存” ,这个缓存中不仅保存着页面数据,还保存了DOM和JavaScript的状态;实际上是将整个页面都保存在了内存里。</strong></p><p><strong>所以此时后退按钮不能刷新页面。</strong></p><p><strong>此时可以使用pageshow事件来触发。,这个事件在页面显示时触发,无论页面是否来自缓存。在重新加载页面中, pageshow会在load或件触发后触发;根据事件对象中的persisted来判断是否是缓存中的页面触发的pageshow事件,注意这个事件给window添加。</strong></p><h2 id="3-1元素scroll系列属性"><a href="#3-1元素scroll系列属性" class="headerlink" title="3.1元素scroll系列属性"></a>3.1元素scroll系列属性</h2><p><strong>scroll翻译过来就是滚动的,我们使用scroll系列的相关属性可以动态的得到该元素的大小、滚动距离等。</strong></p><p><strong>scroll系列属性    作用</strong></p><p><strong>element.scrollTop返回被卷去的上侧距离,返回数值不带单位</strong></p><p><strong>element.scrollLeft返回被卷去的左侧距离,返回数值不带单位</strong></p><p><strong>element.scrollWidth返回自身实际的宽度,不含边框,返回数值不带单位</strong></p><p><strong>element.scrollHeight  返回自身实际的高度,不含边框,返回数值不带单位</strong></p><p><strong>内容的实际大小</strong></p><h2 id="3-2页面被卷去的头部"><a href="#3-2页面被卷去的头部" class="headerlink" title="3.2页面被卷去的头部"></a>3.2页面被卷去的头部</h2><p><strong>如果浏览器的高(或宽)度不足以显示整个页面时,会自动出现滚动条。当滚动条向下滚动时,页面上面被隐藏掉的高度,我们就称为页面被卷去的头部。滚动条在滚动时会触发onscroll事件。</strong></p><p><strong>需要用到页面滚动事件scroll因为是页面滚动,所以事件源是document</strong></p><p><strong>②滚动到某个位置,就是判断页面被卷去的上部值。</strong></p><p><strong>3页面被卷去的头部:可以通过window.pageYoffset获得 如果是被卷去的左侧window.pagexoffset</strong></p><p><strong>④注意,元素被卷去的头部是element.scolTop,如果是页面被卷去的头部则是window.pageYofset</strong></p><p><strong>3,新方法window.pageroffset和window. pagexoffset , IE9开始支持</strong></p><p><strong>function getscroll() {</strong></p><p><strong>return {</strong></p><p><strong>left: window.pagexoffset I I document.documentElement.scrollleft II document.body.scrollleft I I0, top: window.pageYoffset II document.documentElement.scrollTop II document.body.scrollTop II0};</strong></p><p><strong>}</strong></p><p><strong>使用的时候getScroll ().left</strong></p><h2 id="三大系列总结"><a href="#三大系列总结" class="headerlink" title="三大系列总结"></a>三大系列总结</h2><p><strong>三大系列大小对比作用</strong></p><p><strong>element.offsetWidth 返回自身包括padding.(边框)内容区的宽度,返回数值不带单位</strong></p><p><strong>element.clientWidth 返回自身包括padding、内容区的宽度,不含边框,返回数值不带单位</strong></p><p><strong>element.scrollWidth 返回自身实际的宽度,不含边框,返回数值不带单位</strong></p><p><strong>他们主要用法:</strong></p><p><strong>1.offst系列经常用于获得元素位置offsetLeft offsetTop</strong></p><p><strong>2.client经常用于获取元素大小clientwidth clientHeight</strong></p><p><strong>3, scroll经常用于获取滚动距离scrollTop scrolleft</strong></p><p><strong>4,注意页面滚动的距离通过window.pagexoffset获得</strong></p><h2 id="mouseenter和mouseover的区别"><a href="#mouseenter和mouseover的区别" class="headerlink" title="mouseenter和mouseover的区别"></a>mouseenter和mouseover的区别</h2><h3 id="mouseenter鼠标事件"><a href="#mouseenter鼠标事件" class="headerlink" title="mouseenter鼠标事件"></a>mouseenter鼠标事件</h3><p><strong>当鼠标移动到元素上时就会触发mouseenter事件</strong></p><p><strong>类似mouseover,它们两者之间的差别是</strong></p><p><strong>mouseover鼠标经过自身盒子会触发,经过子盒子还会触发。mouseenter只会经过自身盒子触发</strong></p><p><strong>之所以这样,就是因为mouseenter不会冒泡</strong></p><p><strong>跟mouseenter搭配鼠标离开mouseleave同样不会冒泡</strong></p><h2 id="4．动画函数封装"><a href="#4．动画函数封装" class="headerlink" title="4．动画函数封装"></a>4．动画函数封装</h2><h3 id="4-1动画实现原理"><a href="#4-1动画实现原理" class="headerlink" title="4.1动画实现原理"></a>4.1动画实现原理</h3><p><strong>核心原理:通过定时器setinterval()不断移动盒子位置。</strong></p><p><strong>实现步骤：</strong></p><p><strong>1获得盒子当前位置</strong></p><p><strong>2.让盒子在当前位置加上1个移动距离</strong></p><p><strong>3,利用定时器不断重复这个操作</strong></p><p><strong>4.加一个结束定时器的条件</strong></p><p><strong>5,注意此元素需要添加定位,才能使用element.style.left</strong></p><h3 id="4-2动画函数简单封装"><a href="#4-2动画函数简单封装" class="headerlink" title="4.2动画函数简单封装"></a>4.2动画函数简单封装</h3><p><strong>注意函数需要传递2个参数，动画对象和移动到的距离。</strong></p><h3 id="4-4缓动效果原理"><a href="#4-4缓动效果原理" class="headerlink" title="4.4缓动效果原理,"></a>4.4缓动效果原理,</h3><p><strong>缓动动画就是让元素运动速度有所变化,最常见的是让速度慢慢停下来</strong></p><p><strong>思路:1,让盒子每次移动的距离慢慢变小,速度就会慢慢落下来。</strong></p><p><strong>核心算法: (目标值·现在的位置) &#x2F; 10做为每次移动的距离步长</strong></p><p><strong>停止的条件是:让当前盒子位置等于目标位置就停止定时器</strong></p><h2 id="5．常见网页特效案例"><a href="#5．常见网页特效案例" class="headerlink" title="5．常见网页特效案例"></a>5．常见网页特效案例</h2><h3 id="5-1节流阀"><a href="#5-1节流阀" class="headerlink" title="5.1节流阀"></a>5.1节流阀</h3><p><strong>防止轮播图按纽连续点击造成播放过快.</strong></p><p><strong>节流阀目的:当上一个函数动画内容执行完毕,再去执行下一个函鼓动画,让事件无法连续身发。</strong></p><p><strong>核心实现思路:利用回调函数,添加一个变量来控制,锁住函数和解锁函数</strong></p><p><strong>开始设置一个变量 var flag&#x3D; true;</strong></p><p><strong>If(flag) (flag &#x3D; false; do somethng) 闭水龙头</strong></p><p><strong>利用回调函数动画执行完毕, flag&#x3D;true打开水龙头</strong></p><h1 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h1><h2 id="1-触屏事件"><a href="#1-触屏事件" class="headerlink" title="1.触屏事件"></a>1.触屏事件</h2><h3 id="1-1触屏事件概述"><a href="#1-1触屏事件概述" class="headerlink" title="1.1触屏事件概述"></a>1.1触屏事件概述</h3><p><strong>移动端浏览器兼容性较好,我们不需要考虑以前JS的兼容性问题,可以放心的使用原生JS书写效果,但是移动端也有自己独特的地方。比如触屏事件touch (也称触摸事件) , Android和IOS都有。</strong> </p><p><strong>touch对象代表一个触摸点。触摸点可能是一根手指,也可能是一根触摸笔。触屏事件可响应用户手指(或触空笔）对屏幕或者触控板操作。</strong></p><p><strong>触屏touch事件说明</strong></p><p><strong>touchstart  手指触摸到一个DOM元素时触发</strong></p><p><strong>touchmove手指在一个DOM元素上滑动时触发</strong></p><p><strong>touchend手指从一个DOM元素上移开时触发</strong></p><h3 id="1-2触摸事件对象-TouchEvent"><a href="#1-2触摸事件对象-TouchEvent" class="headerlink" title="1.2触摸事件对象(TouchEvent )"></a>1.2触摸事件对象(TouchEvent )</h3><p><strong>TouchEvent是一类描述手指在触莫平面(触摸屏、触莫板等)的状态变化的事件。这类事件用于描述一个或多个触点,使开发者可以检测触点的移动,触点的增加和减少,等等</strong></p><p><strong>touchstart, touchmove, touchend三个事件都会各自有事件对象。</strong></p><p><strong>触摸列表说明</strong></p><p><strong>touches正在触摸屏幕的所有手指的一个列表</strong></p><p><strong>targetTouches正在触摸当前DOM元素上的手指的一个列表</strong></p><p><strong>changedTouches手指状态发生了改变的列表,从无到有,从有到无变化</strong></p><p><strong>因为平时我们都是给元素注册触摸事件,所以重点记住targetTocuhes</strong></p><h3 id="1-3移动端拖动元素"><a href="#1-3移动端拖动元素" class="headerlink" title="1.3移动端拖动元素"></a>1.3移动端拖动元素</h3><p><strong>1.touchstart, touchmove, touchend可以实现拖动元素</strong></p><p><strong>2,但是拖动元素需要当前手指的坐标值我们可以使用targetTouches[0]里面的pagex和pageY</strong></p><p><strong>3,移动端拖动的原理: 手指移动中,计算出手指移动的距离。然后用盒子原来的位置+手指移动的距离</strong></p><p><strong>4,手指移动的距离:手指滑动中的位置减去手指刚开始触摸的位置</strong></p><p><strong>拖动元素三步曲:</strong></p><p><strong>(1)触摸元素touchstart :获取手指初始坐标,同时获得盒子原来的位置</strong></p><p><strong>(2)移动手指touchmove :计算手指的滑动距离,并且移动盒子</strong></p><p><strong>(3)离开手指touchend:</strong></p><p><strong>注意:手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动e.preventDefault();</strong></p><h2 id="2-移动端常见特效"><a href="#2-移动端常见特效" class="headerlink" title="2.移动端常见特效"></a>2.移动端常见特效</h2><p><strong>classList属性</strong></p><p><strong>classlist属性是HTML5新增的一个属性,返回元素的类名。但是ie10以上版本支持。</strong></p><p><strong>该属性用于在元素中添加,移除及切换CSS类。</strong></p><p><strong>有以下方法</strong></p><p><strong>添加类：</strong></p><p><strong>element.classlist.add ( 类名” ) ;</strong></p><p><strong>移除类:</strong></p><p><strong>element.classlist.remove (‘类名’ );</strong></p><p><strong>切换类</strong></p><p><strong>element.classlist.toggle (‘类名’ ) ;</strong></p><h3 id="2-2-click延时解决方案"><a href="#2-2-click延时解决方案" class="headerlink" title="2.2 click延时解决方案"></a>2.2 click延时解决方案</h3><p><strong>移动端click事件会有300ms的延时,原因是移动端屏幕双击会缩放(double tapto zoom)页面。</strong></p><p><strong>解决方案:1,禁用缩放。浏览器禁用默认的双击缩放行为并且去掉300ms的点击延迟。</strong></p><p><strong>1.<meta name="viewport" content="user-scalable=no"></strong></p><p><strong>2.利用touch事件自己封装这个事件解决300ms延迟。</strong></p><p><strong>原理就是:</strong></p><p><strong>1,当我们手指触摸屏幕,记录当前触摸时间</strong></p><p><strong>2,当我们手指离开屏幕,用离开的时间减去触莫的时间</strong></p><p><strong>3.如果时间小于150ms ,并且没有滑动过屏幕,那么我们就定义为点击</strong></p><p><strong>&#x2F;&#x2F;封装tap,解决click 300ms延时</strong></p><p><strong>function tap (obj, callback) {</strong></p><p><strong>var isMove &#x3D; false;</strong></p><p><strong>var startTime &#x3D;0; &#x2F;&#x2F;记录触摸时候的时间变量</strong></p><p><strong>obj.addeventListener (‘touchstart’, function (e){</strong></p><p><strong>startrime &#x3D; Date.now(); &#x2F;&#x2F;记录触摸时间</strong></p><p><strong>});</strong></p><p><strong>obj.addEventListener (‘touchmove’, function (e) {</strong></p><p><strong>isMove &#x3D;true; &#x2F;&#x2F;看看是否有滑动,有滑动算拖拽,不算点击</strong></p><p><strong>});</strong></p><p><strong>obj.addeventListener (‘touchend’, function (e) {</strong></p><p><strong>if (isMove &amp;&amp; (Date.now() -startTime) &lt; 150) { &#x2F;&#x2F;如果手指触摸和离开时间小于150ms算点击</strong></p><p><strong>callback &amp;&amp; callback(); &#x2F;&#x2F;执行回调函数</strong></p><p><strong>}isMove &#x3D; false; &#x2F;&#x2F; 取反重置</strong></p><p><strong>startTime &#x3D; 0;</strong></p><p><strong>});</strong></p><p><strong>&#x2F;&#x2F;调用</strong></p><p><strong>tap(div, function(){ &#x2F;&#x2F;执行代码});</strong></p><h2 id="3-移动端常用开发插件"><a href="#3-移动端常用开发插件" class="headerlink" title="3.移动端常用开发插件"></a>3.移动端常用开发插件</h2><h3 id="3-1什么是插件"><a href="#3-1什么是插件" class="headerlink" title="3.1什么是插件"></a>3.1什么是插件</h3><p><strong>移动端要求的是快速开发,所以我们经常会借助于一些插件来帮我完成操作,那么什么是插件呢?</strong></p><p><strong>Js插件是js文件,它遵循一定规范编写,方便程序展示效果,拥有特定功能目方便调用。如轮播图和瀑布流插件。</strong></p><p><strong>特点:它一般是为了解决某个问题而专门存在,其功能单一,并且比较小。</strong></p><p><strong>我们以前写的animatejs也算一个最简单的插件</strong></p><p><strong>fastclick插件解决300ms延迟。使用延时</strong></p><p><strong>GitHub官网地址: <a href="https://github.com/ftlabs/fastclick">https://github.com/ftlabs/fastclick</a></strong></p><h3 id="3-3-Swiper插件的使用"><a href="#3-3-Swiper插件的使用" class="headerlink" title="3.3 Swiper插件的使用"></a>3.3 Swiper插件的使用</h3><p><strong>中文官网地址: <a href="https://www.swiper.com.cn/1">https://www.swiper.com.cn/1</a>.</strong></p><p><strong>引入插件相关文件</strong></p><p><strong>按照规定语法使用</strong></p><h3 id="3-4其他移动端常见插件"><a href="#3-4其他移动端常见插件" class="headerlink" title="3.4其他移动端常见插件"></a>3.4其他移动端常见插件</h3><p><strong>superslide : <a href="http://www.superslide2.com/">http://www.superslide2.com/</a></strong> </p><p><strong>iscroll: <a href="https://github.com/cubiq/iscroll">https://github.com/cubiq/iscroll</a></strong></p><h3 id="3-5插件的使用总结"><a href="#3-5插件的使用总结" class="headerlink" title="3.5插件的使用总结"></a>3.5插件的使用总结</h3><p><strong>1,确认插件实现的功能</strong> </p><p><strong>2,去官网查看使用说明</strong></p><p><strong>3.下载插件</strong></p><p><strong>4,打开demo实例文件,查看需要引入的相关文件,并且引入</strong></p><p><strong>5.复制demo实例文件中的结构html,样式ss以及s代码</strong></p><h3 id="3-6练习移动端视频插件zy-media-js"><a href="#3-6练习移动端视频插件zy-media-js" class="headerlink" title="3.6练习移动端视频插件zy.media.js"></a>3.6练习移动端视频插件zy.media.js</h3><p><strong>H5给我们提供了video标签,但是浏览器的支持情况不同。</strong></p><p><strong>不同的视频格式文件,我们可以通过source解决。</strong></p><p><strong>但是外观样式,还有暂停,播放,全屏等功能我们只能自己写代码解决。</strong></p><p><strong>这个时候我们可以使用插件方式来制作。</strong></p><h2 id="4-移动端常用开发框架"><a href="#4-移动端常用开发框架" class="headerlink" title="4.移动端常用开发框架"></a>4.移动端常用开发框架</h2><h3 id="4-1框架概述框架"><a href="#4-1框架概述框架" class="headerlink" title="4.1框架概述框架,"></a>4.1框架概述框架,</h3><p><strong>顾名思义就是一套架构,它会基于自身的特点向用户提供一套较为完整的解决方案。框架的控制权在框架本身,使用者要按照框架所规定的某种规范进行开发。</strong></p><p><strong>插件一般是为了解决某个问题而专门存在,其功能单一,并且比较小。</strong></p><p><strong>前端常用的框架有Bootstrap, Vue, Angular, React等。既能开发PC端,也能开发移动端</strong></p><p><strong>前端常用的移动端插件有swiper, superslide, iscrol等</strong></p><p><strong>框架:大而全,一整套解决方案</strong></p><p><strong>插件：小而专一,某个功能的解决方案</strong></p><h3 id="4-2-BootstrapBootstrap"><a href="#4-2-BootstrapBootstrap" class="headerlink" title="4.2 BootstrapBootstrap"></a>4.2 BootstrapBootstrap</h3><p><strong>是一个简洁、直观、强悍的前端开发框架,它让web开发更迅速、简单。它能开发PC端,也能开发移动端</strong></p><p><strong>Bootstrap JS插件使用步骤:</strong></p><p><strong>1,引入相关js文件</strong></p><p><strong>2.复制HTML结构</strong></p><p><strong>3,修改对应样式</strong></p><p><strong>4,修改相应JS参数</strong></p><h1 id="1-本地存储"><a href="#1-本地存储" class="headerlink" title="1.本地存储"></a>1.本地存储</h1><p><strong>随着互联网的快速发展,基于网页的应用越来越普遍,同时也变的越来越复杂,为了满足各种各样的需求,会常性在本地存储大量的数据, HTMI5规范提出了相关解决方案</strong></p><p><strong>本地存储特性</strong></p><p><strong>1、数据存储在用户浏览器中</strong></p><p><strong>2、设置、读取方便、甚至页面刷新不丢失数据</strong></p><p><strong>3、容量较大, sessionStorage约5M, localstorage约20M</strong></p><p><strong>4、只能存储字符串,可以将对象JSON.stringifyo编码后存储</strong></p><h3 id="2-window-sessionStorage"><a href="#2-window-sessionStorage" class="headerlink" title="2.window.sessionStorage"></a>2.window.sessionStorage</h3><p> <strong>1.生命周期为关闭浏览器窗口</strong></p><p><strong>2.在同一个窗口(页面)下数据可以共享</strong></p><p><strong>3,以键值对的形式存储使用</strong></p><p><strong>存储数据：</strong></p><p><strong>sessionStorage.setltem(key, value)</strong></p><p><strong>获取数据:</strong></p><p><strong>sessionStorage.getitem(key)</strong></p><p><strong>删除数据:</strong></p><p><strong>sessionStorage.removeltem(key)</strong></p><p><strong>删除所有数据:</strong></p><p><strong>sessionStorage.clear()</strong></p><h2 id="3-window-localStorage"><a href="#3-window-localStorage" class="headerlink" title="3.window.localStorage."></a>3.window.localStorage.</h2><p><strong>1、生命周期永久生效,除非手动删除否则关闭页面也会存在</strong></p><p><strong>2、可以多窗口(页面)共享(同一浏览器可以共享)</strong></p><p><strong>3,以键值对的形式存储使用</strong></p><p><strong>存储数据:</strong></p><p><strong>localStorage.setitem(key, value)</strong></p><p><strong>获取数据:</strong></p><p><strong>localStorage.getltem(key)</strong></p><p><strong>删除数据:</strong></p><p><strong>localStorage.removeltem(key)</strong></p><p><strong>删除所有数据:</strong></p><p><strong>localStorage.clear()</strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thinkphp_sql</title>
      <link href="/2024/03/13/thinkphp-sql/"/>
      <url>/2024/03/13/thinkphp-sql/</url>
      
        <content type="html"><![CDATA[<h1 id="1-thinkphp之SQL查询语句"><a href="#1-thinkphp之SQL查询语句" class="headerlink" title="1.thinkphp之SQL查询语句"></a>1.thinkphp之SQL查询语句</h1><h2 id="一：字符串条件查询"><a href="#一：字符串条件查询" class="headerlink" title="一：字符串条件查询"></a>一：字符串条件查询</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接实例化Model</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$user</span>=<span class="title function_ invoke__">M</span>(<span class="string">&#x27;user1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">where</span> (<span class="string">&#x27;id=1 OR age=55&#x27;</span>)-&gt;<span class="title function_ invoke__">select</span>());</span><br></pre></td></tr></table></figure><p>最终生成的sql语句为：SELECT * FROM <code>user1</code> WHERE ( id&#x3D;1 OR age&#x3D;55 )</p><p>PS:where 查询方法里面只要包含条件即可，多个条件加上 AND 等连接符即可</p><h2 id="二：使用索引数组作为查询条件"><a href="#二：使用索引数组作为查询条件" class="headerlink" title="二：使用索引数组作为查询条件"></a>二：使用索引数组作为查询条件</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$user</span>=<span class="title function_ invoke__">M</span>(<span class="string">&#x27;user1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$condition</span>[<span class="string">&#x27;age&#x27;</span>]=<span class="string">&#x27;55&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$condition</span>[<span class="string">&#x27;name&#x27;</span>]=<span class="string">&#x27;zs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引数组查询的默认逻辑关系是 AND，如果想改变为 OR，可以使用_logic 定义查询逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$condition</span>[<span class="string">&#x27;_logic&#x27;</span>] = <span class="string">&#x27;OR&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="variable">$condition</span>)-&gt;<span class="title function_ invoke__">select</span>());</span><br></pre></td></tr></table></figure><p>最终生成的sql语句为：SELECT * FROM <code>user1</code> WHERE <code>id</code> &#x3D; ‘1’ AND <code>name</code> &#x3D; ‘zs’</p><h2 id="三：使用对象方式查询"><a href="#三：使用对象方式查询" class="headerlink" title="三：使用对象方式查询"></a>三：使用对象方式查询</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">Home</span>\<span class="title class_">Controller</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Think</span>\<span class="title">Controller</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Think</span>\<span class="title">stdClass</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EleController</span> <span class="keyword">extends</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$user</span>=<span class="title function_ invoke__">M</span>(<span class="string">&#x27;user1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$condition</span>=<span class="keyword">new</span> \<span class="built_in">stdClass</span>;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$condition</span>-&gt;id = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="variable">$condition</span>)-&gt;<span class="title function_ invoke__">select</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终生成的sql语句为：SELECT * FROM <code>user1</code> WHERE <code>id</code> &#x3D; ‘1’</p><h2 id="四：表达式查询"><a href="#四：表达式查询" class="headerlink" title="四：表达式查询"></a>四：表达式查询</h2><p>查询表达式格式：$map[‘字段名’] &#x3D; array(‘表达式’,’查询条件’);</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d90237578dc93ffdeff7470b75ae5e5a.png" alt="img"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$user</span>=<span class="title function_ invoke__">M</span>(<span class="string">&#x27;user1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$map</span>[<span class="string">&#x27;age&#x27;</span>] = <span class="keyword">array</span>(<span class="string">&#x27;eq&#x27;</span>, <span class="number">55</span>); <span class="comment">//where 为 age=55</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="variable">$map</span>)-&gt;<span class="title function_ invoke__">select</span>());  </span><br></pre></td></tr></table></figure><h2 id="五：快捷查询"><a href="#五：快捷查询" class="headerlink" title="五：快捷查询"></a>五：快捷查询</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用相同查询条件</span></span><br><span class="line"></span><br><span class="line">  <span class="variable">$user</span> = <span class="title function_ invoke__">M</span>(<span class="string">&#x27;user1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable">$map</span>[<span class="string">&#x27;name|email&#x27;</span>] = <span class="string">&#x27;a&#x27;</span>; <span class="comment">//&#x27;|&#x27;换成&#x27;&amp;&#x27;变成AND</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="variable">$map</span>)-&gt;<span class="title function_ invoke__">select</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不同字段不同查询条件</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用不同查询条件</span></span><br><span class="line"></span><br><span class="line">  <span class="variable">$user</span> = <span class="title function_ invoke__">M</span>(<span class="string">&#x27;user1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable">$map</span>[<span class="string">&#x27;name&amp;email&#x27;</span>] =<span class="keyword">array</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;test@qq.com&#x27;</span>,<span class="string">&#x27;_multi&#x27;</span>=&gt;<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="variable">$map</span>)-&gt;<span class="title function_ invoke__">select</span>());    </span><br></pre></td></tr></table></figure><p>第一条查询的结果：SELECT * FROM <code>user1</code> WHERE ( <code>name</code> &#x3D; ‘a’ OR <code>email</code> &#x3D; ‘a’ ) </p><p>第二条查询的结果：SELECT * FROM <code>user1</code> WHERE ( (<code>name</code> &#x3D; ‘a’) AND (<code>email</code> &#x3D; ‘<a href="mailto:&#x74;&#x65;&#115;&#116;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#x6d;">&#x74;&#x65;&#115;&#116;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#x6d;</a>‘) )</p><h2 id="六：区间查询"><a href="#六：区间查询" class="headerlink" title="六：区间查询"></a>六：区间查询</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间查询</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$user</span> = <span class="title function_ invoke__">M</span>(<span class="string">&#x27;user1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$map</span>[<span class="string">&#x27;id&#x27;</span>] = <span class="keyword">array</span>(<span class="keyword">array</span>(<span class="string">&#x27;gt&#x27;</span>, <span class="number">1</span>), <span class="keyword">array</span>(<span class="string">&#x27;lt&#x27;</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="variable">$map</span>)-&gt;<span class="title function_ invoke__">select</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三个参数设置逻辑OR</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$user</span> = <span class="title function_ invoke__">M</span>(<span class="string">&#x27;User1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$map</span>[<span class="string">&#x27;id&#x27;</span>] = <span class="keyword">array</span>(<span class="keyword">array</span>(<span class="string">&#x27;gt&#x27;</span>, <span class="number">1</span>), <span class="keyword">array</span>(<span class="string">&#x27;lt&#x27;</span>, <span class="number">4</span>), <span class="string">&#x27;OR&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="variable">$map</span>)-&gt;<span class="title function_ invoke__">select</span>()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七：组合查询"><a href="#七：组合查询" class="headerlink" title="七：组合查询"></a>七：组合查询</h2><p>组合查询是基于索引数组查询方式的一个扩展性查询，添加了字符串查询(_string)、复合查询(_complex)、请求字符串查询(_query)，由于采用的是索引数组，重复的会被覆盖。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串查询(_string)</span></span><br><span class="line"></span><br><span class="line">      <span class="variable">$user</span> = <span class="title function_ invoke__">M</span>(<span class="string">&#x27;user1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="variable">$map</span>[<span class="string">&#x27;name&#x27;</span>] = <span class="keyword">array</span>(<span class="string">&#x27;eq&#x27;</span>, <span class="string">&#x27;zs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="variable">$map</span>[<span class="string">&#x27;_string&#x27;</span>] =<span class="string">&#x27;age=&quot;30&quot; AND email=&quot;zs@qq.com&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="variable">$map</span>)-&gt;<span class="title function_ invoke__">select</span>());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//请求字符串查询(_query)</span></span><br><span class="line"></span><br><span class="line">      <span class="variable">$user</span> = <span class="title function_ invoke__">M</span>(<span class="string">&#x27;user1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="variable">$map</span>[<span class="string">&#x27;id&#x27;</span>] = <span class="keyword">array</span>(<span class="string">&#x27;eq&#x27;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="variable">$map</span>[<span class="string">&#x27;_query&#x27;</span>] =<span class="string">&#x27;name=zs&amp;email=zs@qq.com&amp;_logic=OR&#x27;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="variable">$map</span>)-&gt;<span class="title function_ invoke__">select</span>());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//复合查询(_complex)</span></span><br><span class="line"></span><br><span class="line">      <span class="variable">$user</span> = <span class="title function_ invoke__">M</span>(<span class="string">&#x27;user1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="variable">$where</span>[<span class="string">&#x27;name&#x27;</span>] = <span class="keyword">array</span>(<span class="string">&#x27;like&#x27;</span>, <span class="string">&#x27;z&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="variable">$where</span>[<span class="string">&#x27;id&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="variable">$where</span>[<span class="string">&#x27;_logic&#x27;</span>] = <span class="string">&#x27;OR&#x27;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="variable">$map</span>[<span class="string">&#x27;_complex&#x27;</span>] = <span class="variable">$where</span>;</span><br><span class="line"></span><br><span class="line">      <span class="variable">$map</span>[<span class="string">&#x27;id&#x27;</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">      <span class="variable">$map</span>[<span class="string">&#x27;_logic&#x27;</span>] = <span class="string">&#x27;OR&#x27;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="variable">$map</span>)-&gt;<span class="title function_ invoke__">select</span>());</span><br></pre></td></tr></table></figure><p>第一条查询语句：SELECT * FROM <code>user1</code> WHERE <code>name</code> &#x3D; ‘zs’ AND ( age&#x3D;”30” AND email&#x3D;”<a href="mailto:&#x7a;&#115;&#x40;&#113;&#113;&#46;&#99;&#x6f;&#109;">&#x7a;&#115;&#x40;&#113;&#113;&#46;&#99;&#x6f;&#109;</a>“ )</p><p>第二条查询语句：SELECT * FROM <code>user1</code> WHERE <code>name</code> &#x3D; ‘zs’ AND ( age&#x3D;”30” AND email&#x3D;”<a href="mailto:&#122;&#115;&#64;&#113;&#x71;&#x2e;&#99;&#x6f;&#109;">&#122;&#115;&#64;&#113;&#x71;&#x2e;&#99;&#x6f;&#109;</a>“ ) AND ( <code>name</code> &#x3D; ‘zs’ OR <code>email</code> &#x3D; ‘<a href="mailto:&#122;&#115;&#64;&#113;&#x71;&#x2e;&#x63;&#111;&#109;">&#122;&#115;&#64;&#113;&#x71;&#x2e;&#x63;&#111;&#109;</a>‘ )</p><p>第三条查询语句：SELECT * FROM <code>user1</code> WHERE <code>name</code> &#x3D; ‘zs’ OR ( age&#x3D;”30” AND email&#x3D;”<a href="mailto:&#122;&#x73;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#x6d;">&#122;&#x73;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#x6d;</a>“ ) OR ( <code>name</code> &#x3D; ‘zs’ OR <code>email</code> &#x3D; ‘<a href="mailto:&#x7a;&#115;&#x40;&#113;&#113;&#46;&#x63;&#x6f;&#109;">&#x7a;&#115;&#x40;&#113;&#113;&#46;&#x63;&#x6f;&#109;</a>‘ ) OR ( <code>name</code> LIKE ‘z’ OR <code>id</code> &#x3D; 1 ) </p><h2 id="八：统计查询"><a href="#八：统计查询" class="headerlink" title="八：统计查询"></a>八：统计查询</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据总条数</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//SHOW COLUMNS FROM `user1`</span></span><br><span class="line"></span><br><span class="line">       <span class="variable">$user</span> = <span class="title function_ invoke__">M</span>(<span class="string">&#x27;user1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">count</span>());</span><br><span class="line"></span><br><span class="line">       <span class="comment">//字段总条数，遇到NULL不统计</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//SELECT COUNT(*) AS tp_count FROM `user1` LIMIT 1</span></span><br><span class="line"></span><br><span class="line">       <span class="variable">$user</span> = <span class="title function_ invoke__">M</span>(<span class="string">&#x27;user1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">count</span>(<span class="string">&#x27;email&#x27;</span>));</span><br><span class="line"></span><br><span class="line">       <span class="comment">//最大值</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//SELECT MAX(id) AS tp_max FROM `user1` LIMIT 1 </span></span><br><span class="line"></span><br><span class="line">       <span class="variable">$user</span> = <span class="title function_ invoke__">M</span>(<span class="string">&#x27;user1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">max</span>(<span class="string">&#x27;id&#x27;</span>));</span><br><span class="line"></span><br><span class="line">       <span class="comment">//最小值</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//SELECT MIN(id) AS tp_min FROM `user1` LIMIT 1</span></span><br><span class="line"></span><br><span class="line">       <span class="variable">$user</span> = <span class="title function_ invoke__">M</span>(<span class="string">&#x27;user1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">min</span>(<span class="string">&#x27;id&#x27;</span>));</span><br><span class="line"></span><br><span class="line">       <span class="comment">//平均值</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//SELECT AVG(id) AS tp_avg FROM `user1` LIMIT 1 </span></span><br><span class="line"></span><br><span class="line">       <span class="variable">$user</span> = <span class="title function_ invoke__">M</span>(<span class="string">&#x27;user1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">avg</span>(<span class="string">&#x27;id&#x27;</span>));</span><br><span class="line"></span><br><span class="line">       <span class="comment">//求总和</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//SELECT SUM(id) AS tp_sum FROM `user1` LIMIT 1</span></span><br><span class="line"></span><br><span class="line">       <span class="variable">$user</span> = <span class="title function_ invoke__">M</span>(<span class="string">&#x27;user1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">sum</span>(<span class="string">&#x27;id&#x27;</span>));</span><br></pre></td></tr></table></figure><h2 id="九：动态查询"><a href="#九：动态查询" class="headerlink" title="九：动态查询"></a>九：动态查询</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.getBy 动态查询</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//查找email=xiaoin@163.com的数据</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//SELECT * FROM `user1` LIMIT 1 </span></span><br><span class="line"></span><br><span class="line">   <span class="variable">$user</span> = <span class="title function_ invoke__">M</span>(<span class="string">&#x27;user1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">getByemail</span>(<span class="string">&#x27;zs@qq.com&#x27;</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.getFieldBy 动态查询</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//通过user得到相对应id值</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//SELECT `id` FROM `user1` LIMIT 1</span></span><br><span class="line"></span><br><span class="line">   <span class="variable">$user</span> = <span class="title function_ invoke__">M</span>(<span class="string">&#x27;user1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">getFieldByUser</span>(<span class="string">&#x27;ls&#x27;</span>, <span class="string">&#x27;id&#x27;</span>));</span><br></pre></td></tr></table></figure><h2 id="十：SQL查询"><a href="#十：SQL查询" class="headerlink" title="十：SQL查询"></a>十：SQL查询</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">　　　　</span><br><span class="line">　    <span class="comment">// 1.query 读取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查询结果集，如果采用分布式读写分离，则始终在读服务器执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SELECT * FROM user1</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$user</span> = <span class="title function_ invoke__">M</span>(<span class="string">&#x27;user1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&#x27;SELECT * FROM user1&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.execute写入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//更新和写入，如果采用分布式读写分离，则始终在写服务器执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//UPDATE user1 set name=&quot;xuexi&quot; WHERE id=&quot;1&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$user</span> = <span class="title function_ invoke__">M</span>(<span class="string">&#x27;user1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">execute</span>(<span class="string">&#x27;UPDATE user1 set name=&quot;xuexi&quot; WHERE</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> id=&quot;1&quot;;&#x27;</span>));</span><br></pre></td></tr></table></figure><h2 id="十一：连贯查询"><a href="#十一：连贯查询" class="headerlink" title="十一：连贯查询"></a>十一：连贯查询</h2><p> 通过连贯操作可以有效的提供数据存取的代码清晰度和开发效率，并且支持所有的 CURD 操作</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连贯操作</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//PS：这里的 where、order 和 limit 方法都是连贯操作方法，所以它们都能返回$user本身，可以互换位置。而 select 方法不是连贯方法，需要放在最后，用以显示数据集。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//SELECT * FROM `user1` WHERE ( id in (1,2,3,4) ) LIMIT 2 </span></span><br><span class="line"></span><br><span class="line">        <span class="variable">$user</span>=<span class="title function_ invoke__">M</span>(<span class="string">&#x27;user1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;id in (1,2,3,4)&#x27;</span>)-&gt;<span class="title function_ invoke__">limit</span>(<span class="number">2</span>)-&gt;<span class="title function_ invoke__">select</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数组操作</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//SELECT * FROM `user1` WHERE id in (1,2,3,4) LIMIT 2 </span></span><br><span class="line"></span><br><span class="line">        <span class="variable">$user</span> = <span class="title function_ invoke__">M</span>(<span class="string">&#x27;user1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">select</span>(<span class="keyword">array</span>(<span class="string">&#x27;where&#x27;</span>=&gt;<span class="string">&#x27;id in (1,2,3,4)&#x27;</span>, <span class="string">&#x27;limit&#x27;</span>=&gt;<span class="string">&#x27;2&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        )));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CURD处理</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// SELECT * FROM `user1` WHERE ( id=1 ) LIMIT 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// DELETE FROM `user1` WHERE ( id=2 )</span></span><br><span class="line"></span><br><span class="line">        <span class="variable">$user</span> = <span class="title function_ invoke__">M</span>(<span class="string">&#x27;user1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;id=1&#x27;</span>)-&gt;<span class="title function_ invoke__">find</span>());</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;id=2&#x27;</span>)-&gt;<span class="title function_ invoke__">delete</span>());</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/39ba8bdbcabe4531408900bd3c672fcc.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/aab7c9d757290f0f8a8e1d2ecbb47266.png" alt="img"></p><h3 id="1-where-支持字符串条件、数组条件（推荐用法）和多次调用。"><a href="#1-where-支持字符串条件、数组条件（推荐用法）和多次调用。" class="headerlink" title="1.where(支持字符串条件、数组条件（推荐用法）和多次调用。)"></a>1.where(支持字符串条件、数组条件（推荐用法）和多次调用。)</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串方式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//SELECT * FROM `user1` WHERE ( id=6 )</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;id=6&#x27;</span>)-&gt;<span class="title function_ invoke__">select</span>());</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        <span class="comment">//索引数组方式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// SELECT * FROM `user1` WHERE `id` = 6</span></span><br><span class="line"></span><br><span class="line">        <span class="variable">$map</span>[<span class="string">&#x27;id&#x27;</span>]=<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="variable">$map</span>)-&gt;<span class="title function_ invoke__">select</span>());</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        <span class="comment">//多次调用方式</span></span><br><span class="line"></span><br><span class="line">        SELECT * FROM `user1` WHERE `id` = <span class="number">6</span> <span class="title function_ invoke__">AND</span> ( name=<span class="string">&quot;test&quot;</span> ) </span><br><span class="line"></span><br><span class="line">        <span class="variable">$map</span>[<span class="string">&#x27;id&#x27;</span>]=<span class="keyword">array</span>(<span class="string">&#x27;eq&#x27;</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="variable">$map</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;name=&quot;test&quot;&#x27;</span>)-&gt;<span class="title function_ invoke__">select</span>());</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-order-用于对结果集排序"><a href="#2-order-用于对结果集排序" class="headerlink" title="2.order 用于对结果集排序"></a>2.order 用于对结果集排序</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 倒序</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// SELECT * FROM `user1` ORDER BY id desc</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">order</span>(<span class="string">&#x27;id desc&#x27;</span>)-&gt;<span class="title function_ invoke__">select</span>());</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二排序</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// SELECT * FROM `user1` ORDER BY id desc,age desc</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">order</span>(<span class="string">&#x27;id desc,age desc&#x27;</span>)-&gt;<span class="title function_ invoke__">select</span>());</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        <span class="comment">//数组形式，防止字段和mysql关键字冲突</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// SELECT * FROM `user1` ORDER BY `id` DESC,`email` DESC</span></span><br><span class="line"></span><br><span class="line">        <span class="variable">$map</span>[<span class="string">&#x27;id&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">order</span>(<span class="keyword">array</span>(<span class="string">&#x27;id&#x27;</span>=&gt;<span class="string">&#x27;DESC&#x27;</span>,<span class="string">&#x27;email&#x27;</span>=&gt;<span class="string">&#x27;DESC&#x27;</span>))-&gt;<span class="title function_ invoke__">select</span>());</span><br></pre></td></tr></table></figure><h3 id="3-feild（feild-方法可以返回或操作字段，可以用于查询和写入操作。）"><a href="#3-feild（feild-方法可以返回或操作字段，可以用于查询和写入操作。）" class="headerlink" title="3.feild（feild 方法可以返回或操作字段，可以用于查询和写入操作。）"></a>3.feild（feild 方法可以返回或操作字段，可以用于查询和写入操作。）</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">　　　　</span><br><span class="line"><span class="comment">// 只显示id和name两个字段</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// SELECT `id`,`name` FROM `user1` </span></span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">field</span>(<span class="string">&#x27;id,name&#x27;</span>)-&gt;<span class="title function_ invoke__">select</span>());</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">      <span class="comment">//使用SQL函数和别名</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// SELECT SUM(id) as count,`name` FROM `user1`</span></span><br><span class="line"></span><br><span class="line">      <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">field</span>(<span class="string">&#x27;SUM(id) as count,name&#x27;</span>)-&gt;<span class="title function_ invoke__">select</span>());</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 使用数组参数结合SQL函数</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// SELECT `id`,LEFT(name,1) AS `left_user` FROM `user1`</span></span><br><span class="line"></span><br><span class="line">      <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">field</span>(<span class="keyword">array</span>(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;LEFT(name,1)&#x27;</span>=&gt;<span class="string">&#x27;left_user&#x27;</span>))-&gt;<span class="title function_ invoke__">select</span>());</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">      <span class="comment">//获取所有字段</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// SELECT * FROM `user1` </span></span><br><span class="line"></span><br><span class="line">      <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">field</span>()-&gt;<span class="title function_ invoke__">select</span>());</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">      <span class="comment">//用于写入</span></span><br><span class="line"></span><br><span class="line">      <span class="variable">$user</span>-&gt;<span class="title function_ invoke__">field</span>(<span class="string">&#x27;name,email&#x27;</span>)-&gt;<span class="title function_ invoke__">create</span>();</span><br></pre></td></tr></table></figure><h3 id="4-limit（主要用于指定查询和操作的数量）"><a href="#4-limit（主要用于指定查询和操作的数量）" class="headerlink" title="4.limit（主要用于指定查询和操作的数量）"></a>4.limit（主要用于指定查询和操作的数量）</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//限制结果集数量</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// SELECT * FROM `user1` LIMIT 2</span></span><br><span class="line"></span><br><span class="line">     <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">limit</span>(<span class="number">2</span>)-&gt;<span class="title function_ invoke__">select</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">//分页查询</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// SELECT * FROM `user1` LIMIT 1,2 </span></span><br><span class="line"></span><br><span class="line">     <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">limit</span>(<span class="number">1</span>,<span class="number">2</span>)-&gt;<span class="title function_ invoke__">select</span>());</span><br></pre></td></tr></table></figure><h3 id="5-page（page-方法完全用于分页查询）"><a href="#5-page（page-方法完全用于分页查询）" class="headerlink" title="5.page（page 方法完全用于分页查询）"></a>5.page（page 方法完全用于分页查询）</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//page分页</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// SELECT * FROM `user1` LIMIT 3,3</span></span><br><span class="line"></span><br><span class="line">     <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">page</span>(<span class="number">2</span>,<span class="number">3</span>)-&gt;<span class="title function_ invoke__">select</span>());</span><br></pre></td></tr></table></figure><h3 id="6-table（用于数据表操作，主要是切换数据表或多表操作）"><a href="#6-table（用于数据表操作，主要是切换数据表或多表操作）" class="headerlink" title="6.table（用于数据表操作，主要是切换数据表或多表操作）"></a>6.table（用于数据表操作，主要是切换数据表或多表操作）</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//切换数据表</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// SELECT * FROM `test_user`</span></span><br><span class="line"></span><br><span class="line">      <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">table</span>(<span class="string">&#x27;test_user&#x27;</span>)-&gt;<span class="title function_ invoke__">select</span>());</span><br></pre></td></tr></table></figure><h3 id="7-alias-（用于设置数据表别名）"><a href="#7-alias-（用于设置数据表别名）" class="headerlink" title="7.alias （用于设置数据表别名）"></a>7.alias （用于设置数据表别名）</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置别名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// SELECT * FROM user1 a </span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">alias</span>(<span class="string">&#x27;a&#x27;</span>)-&gt;<span class="title function_ invoke__">select</span>());</span><br></pre></td></tr></table></figure><h3 id="8-group（用于对结合函数统计的结果集分组）"><a href="#8-group（用于对结合函数统计的结果集分组）" class="headerlink" title="8.group（用于对结合函数统计的结果集分组）"></a>8.group（用于对结合函数统计的结果集分组）</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　<span class="comment">// 分组统计</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SELECT `name`,max(id) FROM `user1` GROUP BY id</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">field</span>(<span class="string">&#x27;name,max(id)&#x27;</span>)-&gt;<span class="title function_ invoke__">group</span>(<span class="string">&#x27;id&#x27;</span>)-&gt;<span class="title function_ invoke__">select</span>());</span><br></pre></td></tr></table></figure><h3 id="9-having（用于配合-group-方法完成从分组的结果中再筛选数据）"><a href="#9-having（用于配合-group-方法完成从分组的结果中再筛选数据）" class="headerlink" title="9.having（用于配合 group 方法完成从分组的结果中再筛选数据）"></a>9.having（用于配合 group 方法完成从分组的结果中再筛选数据）</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分组统计结合having</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// SELECT `user`,max(id) FROM `user1` GROUP BY id HAVING id&gt;2 </span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">field</span>(<span class="string">&#x27;user,max(id)&#x27;</span>)-&gt;<span class="title function_ invoke__">group</span>(<span class="string">&#x27;id&#x27;</span>)-&gt;<span class="title function_ invoke__">having</span>(<span class="string">&#x27;id&gt;2&#x27;</span>)-&gt;<span class="title function_ invoke__">select</span>());</span><br></pre></td></tr></table></figure><h3 id="10-comment-（用于对-SQL-语句进行注释）"><a href="#10-comment-（用于对-SQL-语句进行注释）" class="headerlink" title="10.comment （用于对 SQL 语句进行注释）"></a>10.comment （用于对 SQL 语句进行注释）</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SQL注释</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// SELECT * FROM `user1` /* test */</span></span><br><span class="line"></span><br><span class="line">      <span class="title function_ invoke__">var_dump</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">comment</span>(<span class="string">&#x27;test&#x27;</span>)-&gt;<span class="title function_ invoke__">select</span>());</span><br></pre></td></tr></table></figure><h1 id="2-ThinkPHP-数据的增删改查"><a href="#2-ThinkPHP-数据的增删改查" class="headerlink" title="2.ThinkPHP 数据的增删改查"></a>2.ThinkPHP 数据的增删改查</h1><h2 id="1、增"><a href="#1、增" class="headerlink" title="1、增"></a>1、增</h2><p>ThinkPHP 内置的 add 方法用于向数据表添加数据，相当于 SQL 中的 INSERT INTO 行为。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Type:text/html; charset=utf-8&quot;</span>);</span><br><span class="line"> <span class="number">3</span>     <span class="variable">$Dao</span> = <span class="title function_ invoke__">M</span>(<span class="string">&quot;User&quot;</span>);    <span class="comment">// 实例化模型类</span></span><br><span class="line"> <span class="number">4</span> </span><br><span class="line"> <span class="number">5</span>     <span class="comment">// 构建写入的数据数组</span></span><br><span class="line"> <span class="number">6</span>     <span class="variable">$data</span>[<span class="string">&quot;username&quot;</span>] = <span class="string">&quot;小王&quot;</span>;</span><br><span class="line"> <span class="number">7</span>     <span class="variable">$data</span>[<span class="string">&quot;password&quot;</span>] = <span class="title function_ invoke__">md5</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"> <span class="number">8</span>     <span class="variable">$data</span>[<span class="string">&quot;email&quot;</span>] = <span class="string">&quot;12345@163.com&quot;</span>;    </span><br><span class="line"> <span class="number">9</span>     <span class="variable">$data</span>[<span class="string">&quot;regdate&quot;</span>] = <span class="title function_ invoke__">time</span>();</span><br><span class="line"><span class="number">10</span> </span><br><span class="line"><span class="number">11</span>     <span class="comment">// 写入数据</span></span><br><span class="line"><span class="number">12</span>     <span class="variable">$insertM</span> = <span class="variable">$Dao</span>-&gt;<span class="title function_ invoke__">add</span>(<span class="variable">$data</span>)；</span><br><span class="line"><span class="number">13</span> &#125;</span><br></pre></td></tr></table></figure><p>等同于SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span>(username,password,email,regdate) <span class="keyword">VALUES</span> (<span class="string">&#x27;小王&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;12345@163.com&#x27;</span>,<span class="number">1486974334</span>);</span><br></pre></td></tr></table></figure><h2 id="2、删"><a href="#2、删" class="headerlink" title="2、删"></a>2、删</h2><p>delete() 方法执行成功返回操作影响（删除）的记录数。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">del</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="number">2</span>     <span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Type:text/html; charset=utf-8&quot;</span>);</span><br><span class="line"><span class="number">3</span>     <span class="variable">$Dao</span> = <span class="title function_ invoke__">M</span>(<span class="string">&quot;User&quot;</span>);</span><br><span class="line"><span class="number">4</span>     <span class="comment">// 删除 uid=5 的数据记录</span></span><br><span class="line"><span class="number">5</span>     <span class="variable">$result</span> = <span class="variable">$Dao</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;uid = 5&#x27;</span>)-&gt;<span class="title function_ invoke__">delete</span>();</span><br><span class="line"><span class="number">6</span> &#125;</span><br></pre></td></tr></table></figure><p>等同于SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> uid <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h2 id="3、改"><a href="#3、改" class="headerlink" title="3、改"></a>3、改</h2><p>ThinkPHP 内置的 save() 方法用于向数据表更新数据，相当于 SQL 中的 UPDATE 行为。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Type:text/html; charset=utf-8&quot;</span>);</span><br><span class="line"> <span class="number">3</span>     <span class="variable">$Dao</span> = <span class="title function_ invoke__">M</span>(<span class="string">&quot;User&quot;</span>);</span><br><span class="line"> <span class="number">4</span> </span><br><span class="line"> <span class="number">5</span>     <span class="comment">// 需要更新的数据</span></span><br><span class="line"> <span class="number">6</span>     <span class="variable">$data</span>[<span class="string">&#x27;email&#x27;</span>] = <span class="string">&#x27;Jack@163.com&#x27;</span>;</span><br><span class="line"> <span class="number">7</span>     <span class="comment">// 更新的条件</span></span><br><span class="line"> <span class="number">8</span>     <span class="variable">$condition</span>[<span class="string">&#x27;username&#x27;</span>] = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line"> <span class="number">9</span>     <span class="variable">$result</span> = <span class="variable">$Dao</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="variable">$condition</span>)-&gt;<span class="title function_ invoke__">save</span>(<span class="variable">$data</span>);</span><br><span class="line"><span class="number">10</span>     <span class="comment">//或者：$resul t= $Dao-&gt;where($condition)-&gt;data($data)-&gt;save();</span></span><br><span class="line"><span class="number">11</span> &#125;</span><br></pre></td></tr></table></figure><p>等同于SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> email<span class="operator">=</span><span class="string">&#x27;Jack@163.com&#x27;</span> <span class="keyword">WHERE</span> username<span class="operator">=</span><span class="string">&#x27;Jack&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>提示</strong></p><p>为了保证数据库的安全，避免出错更新整个数据表，如果没有任何更新条件，数据对象本身也不包含<a href="http://www.5idev.com/p-php_mysql_column_property.shtml">主键字段</a>的话，save方法不会更新任何数据库的记录。</p><p>因此要使用 save() 方法更新数据，必须<strong>指定更新条件</strong>或者<strong>更新的数据中包含主键字段</strong>。</p></blockquote><h2 id="4、查"><a href="#4、查" class="headerlink" title="4、查"></a>4、查</h2><p>　ThinkPHP 查询数据主要提供以下几类查询：　</p><h3 id="1）select"><a href="#1）select" class="headerlink" title="1）select"></a>1）select</h3><p>是 ThinkPHP 中最常用的普通查询方法，得到的是一个二维数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> 1 //方法php</span><br><span class="line"> 2 public function read()&#123;</span><br><span class="line"> 3     $Dao = M(&quot;User&quot;);</span><br><span class="line"> 4     </span><br><span class="line"> 5     // 查询数据</span><br><span class="line"> 6     $list = $Dao-&gt;select();</span><br><span class="line"> 7     //dump($list);    // 用 dump() 可以在调试阶段查看数据是否已读取</span><br><span class="line"> 8 </span><br><span class="line"> 9     // 模板变量赋值</span><br><span class="line">10     $this-&gt;assign(&quot;list&quot;, $list);</span><br><span class="line">11     // 输出模板</span><br><span class="line">12     $this-&gt;display();</span><br><span class="line">13 &#125;</span><br><span class="line">14 </span><br><span class="line">15 //模板html</span><br><span class="line">16 &lt;table border=&quot;1&quot;&gt;</span><br><span class="line">17     &lt;tr&gt;</span><br><span class="line">18         &lt;th width=&quot;10%&quot;&gt;ID&lt;/th&gt;</span><br><span class="line">19         &lt;th width=&quot;30%&quot;&gt;用户名&lt;/th&gt;</span><br><span class="line">20         &lt;th width=&quot;30%&quot;&gt;电子邮件&lt;/th&gt;</span><br><span class="line">21         &lt;th&gt;注册时间&lt;/th&gt;</span><br><span class="line">22     &lt;/tr&gt;</span><br><span class="line">23     &lt;volist name=&quot;list&quot; id=&quot;vo&quot;&gt;//循环显示</span><br><span class="line">24     &lt;tr&gt;</span><br><span class="line">25         &lt;td align=&quot;center&quot;&gt;&#123;$vo[&#x27;uid&#x27;]&#125;&lt;/td&gt;</span><br><span class="line">26         &lt;td&gt;&#123;$vo[&#x27;username&#x27;]&#125;&lt;/td&gt;</span><br><span class="line">27         &lt;td&gt;&#123;$vo[&#x27;email&#x27;]&#125;&lt;/td&gt;</span><br><span class="line">28         &lt;td&gt;&#123;$vo[&#x27;regdate&#x27;]|date=&#x27;Y-m-d H:i&#x27;,###&#125;&lt;/td&gt;</span><br><span class="line">29     &lt;/tr&gt;</span><br><span class="line">30     &lt;/volist&gt;</span><br><span class="line">31 &lt;/table&gt;</span><br></pre></td></tr></table></figure><h3 id="2）find"><a href="#2）find" class="headerlink" title="2）find"></a>2）find</h3><p>该方法是和 select() 用法类似的一个方法，不同之处 find() 查询出来的始终只有一条数据，即系统自动加上了 LIMIT 1 限制。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">//当确认查询的数据记录只能是一条记录时，建议使用 find() 方法查询，如用户登录账号检测：</span></span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">chekUser</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="number">4</span>     <span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Type:text/html; charset=utf-8&quot;</span>);</span><br><span class="line"> <span class="number">5</span>     <span class="variable">$Dao</span> = <span class="title function_ invoke__">M</span>(<span class="string">&quot;User&quot;</span>);</span><br><span class="line"> <span class="number">6</span>     </span><br><span class="line"> <span class="number">7</span>     <span class="comment">// 构造查询条件</span></span><br><span class="line"> <span class="number">8</span>     <span class="variable">$condition</span>[<span class="string">&#x27;username&#x27;</span>] = <span class="string">&#x27;Admin&#x27;</span>;</span><br><span class="line"> <span class="number">9</span>     <span class="variable">$condition</span>[<span class="string">&#x27;password&#x27;</span>] = <span class="title function_ invoke__">MD5</span>(<span class="string">&#x27;123456&#x27;</span>);</span><br><span class="line"><span class="number">10</span>     <span class="comment">// 查询数据</span></span><br><span class="line"><span class="number">11</span>     <span class="variable">$list</span> = <span class="variable">$Dao</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="variable">$condition</span>)-&gt;<span class="title function_ invoke__">find</span>();</span><br><span class="line"><span class="number">12</span> &#125;</span><br><span class="line"><span class="number">13</span> </span><br><span class="line"><span class="number">14</span> <span class="comment">//与 select() 的另一个不同之处在于，find() 返回的是一个一维数组，可以在模板里直接输出数组单元的值而无需使用 volist 等标签循环输出：</span></span><br><span class="line"><span class="number">15</span> </span><br><span class="line"><span class="number">16</span> &lt;p&gt;&#123;<span class="variable">$list</span>[<span class="string">&#x27;username&#x27;</span>]&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="3）getBy动态查询"><a href="#3）getBy动态查询" class="headerlink" title="3）getBy动态查询"></a>3）getBy动态查询</h3><p>是一个魔术方法，可以根据某个字段名称动态得到对应的一条数据记录。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">chekUser</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="number">2</span>     <span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Type:text/html; charset=utf-8&quot;</span>);</span><br><span class="line"><span class="number">3</span>     <span class="variable">$Dao</span> = <span class="title function_ invoke__">M</span>(<span class="string">&quot;User&quot;</span>);</span><br><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="number">5</span>     <span class="comment">// 查询数据</span></span><br><span class="line"><span class="number">6</span>     <span class="variable">$user</span> = <span class="variable">$Dao</span>-&gt;<span class="title function_ invoke__">getByUsername</span>(<span class="string">&#x27;Admin&#x27;</span>);</span><br><span class="line"><span class="number">7</span> &#125;</span><br></pre></td></tr></table></figure><p>等同于SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;Admin&#x27;</span> LIMIT <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>提示</strong>：</p><p>请注意，在getBy之后紧跟着的字段名称，首字母必须大写。对于如 user_name 这样的字段名称，以驼峰法自动识别下划线，即：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$user</span> = <span class="variable">$Dao</span>-&gt;<span class="title function_ invoke__">getByUserName</span>(<span class="string">&#x27;Admin&#x27;</span>);</span><br></pre></td></tr></table></figure><p>实际使用中可以灵活根据查询的字段名来定义 getBy 放入，如：getByEmail、getByTitle、getById 等。</p></blockquote><p>　　　　　　　　</p><h3 id="4）getField"><a href="#4）getField" class="headerlink" title="4）getField"></a>4）getField</h3><p>是专门用于获取某个字段的值或者多个字段的索引数组。该方法与 field方法 不同，是一个独立的方法而不需要再使用 find 或者 select 。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>fields</td><td>必须，需要查询的字段名称，可以是一个或多个字段</td></tr><tr><td>condition</td><td>可选，查询条件，可以是字符或数组，参考 select 方法查询条件</td></tr><tr><td>spea</td><td>可选，多个字段数据生成关联数组时，数据间隔符号，默认为空格</td></tr></tbody></table><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">select</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Type:text/html; charset=utf-8&quot;</span>);</span><br><span class="line"> <span class="number">3</span>     <span class="variable">$Dao</span> = <span class="title function_ invoke__">M</span>(<span class="string">&quot;User&quot;</span>);</span><br><span class="line"> <span class="number">4</span>     <span class="variable">$list</span> = <span class="variable">$Dao</span>-&gt;<span class="title function_ invoke__">getField</span>(<span class="string">&#x27;uid,username,email&#x27;</span>,<span class="string">&#x27;uid &lt; 4&#x27;</span>,<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line"> <span class="number">5</span>     <span class="title function_ invoke__">dump</span>(<span class="variable">$list</span>);</span><br><span class="line"> <span class="number">6</span> &#125;</span><br><span class="line"> <span class="number">7</span> </span><br><span class="line"> <span class="number">8</span>  <span class="comment">//dump 打印出的结果是：</span></span><br><span class="line"> <span class="number">9</span> </span><br><span class="line"><span class="number">10</span> <span class="keyword">array</span>(<span class="number">3</span>) &#123;</span><br><span class="line"><span class="number">11</span>   [<span class="number">1</span>] =&gt; <span class="keyword">string</span>(<span class="number">21</span>) <span class="string">&quot;admin|admin@5idev.com&quot;</span></span><br><span class="line"><span class="number">12</span>   [<span class="number">2</span>] =&gt; <span class="keyword">string</span>(<span class="number">23</span>) <span class="string">&quot;小明|xiaoming@163.com&quot;</span></span><br><span class="line"><span class="number">13</span>   [<span class="number">3</span>] =&gt; <span class="keyword">string</span>(<span class="number">19</span>) <span class="string">&quot;Jack|jack@gmail.com&quot;</span></span><br><span class="line"><span class="number">14</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="5）区间查询"><a href="#5）区间查询" class="headerlink" title="5）区间查询"></a>5）区间查询</h3><p>取得符合查询条件的区间记录</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="variable">$Dao</span> = <span class="title function_ invoke__">M</span>(<span class="string">&#x27;User&#x27;</span>);</span><br><span class="line"> <span class="number">3</span>     <span class="variable">$condition</span>[<span class="string">&#x27;uid&#x27;</span>] = <span class="keyword">array</span>(<span class="keyword">array</span>(<span class="string">&#x27;gt&#x27;</span>,<span class="number">1</span>),<span class="keyword">array</span>(<span class="string">&#x27;lt&#x27;</span>,<span class="number">5</span>));<span class="comment">//(uid &gt; 1) AND (uid &lt; 5)3.1    $condition[&#x27;uid&#x27;] = array(array(&#x27;gt&#x27;,3),array(&#x27;lt&#x27;,10), &#x27;or&#x27;);//(uid &lt; 1) OR (uid &gt; 10)3.2    $condition[&#x27;username&#x27;] = array(array(&#x27;like&#x27;,&#x27;%a%&#x27;), array(&#x27;like&#x27;,&#x27;%b%&#x27;), &#x27;Admin&#x27;,&#x27;or&#x27;);//(username LIKE &#x27;%a%&#x27;) OR (username LIKE &#x27;%b%&#x27;) OR (username = &#x27;Admin&#x27;)</span></span><br><span class="line"> <span class="number">4</span>     <span class="variable">$list</span> = <span class="variable">$Dao</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="variable">$condition</span>)-&gt;<span class="title function_ invoke__">select</span>();</span><br><span class="line"> <span class="number">5</span>     <span class="keyword">if</span>(<span class="variable">$list</span>)&#123;</span><br><span class="line"> <span class="number">6</span>         <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">assign</span>(<span class="string">&#x27;list&#x27;</span>, <span class="variable">$list</span>);</span><br><span class="line"> <span class="number">7</span>         <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">display</span>();</span><br><span class="line"> <span class="number">8</span>     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="number">9</span>         <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">error</span>(<span class="variable">$Dao</span>-&gt;<span class="title function_ invoke__">getError</span>());</span><br><span class="line"><span class="number">10</span>     &#125;</span><br><span class="line"><span class="number">11</span> &#125; </span><br></pre></td></tr></table></figure><p>等同于SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> ( (uid <span class="operator">&gt;</span> <span class="number">1</span>) <span class="keyword">AND</span> (uid <span class="operator">&lt;</span> <span class="number">5</span>) );</span><br></pre></td></tr></table></figure><h3 id="6）原生SQL查询"><a href="#6）原生SQL查询" class="headerlink" title="6）原生SQL查询"></a>6）原生SQL查询</h3><p>尽管ThinkPHP内置了大量的数据操作方法，但ThinkPHP仍保留了对原生SQL查询的支持，以便满足复杂查询的需要和一些特殊的数据操作。SQL查询的返回值是直接返回DB类的查询结果，没有做任何的处理，而且可以支持查询缓存。</p><p>原生SQL查询有 query() 和 execute() 两个方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">//query() 方法是用于 SQL 查询操作，和select()方法一样返回符合查询条件的数据集。</span></span><br><span class="line"> <span class="number">2</span> <span class="comment">//对于 query() 方法返回的数据集，跟 select() 一样，可以在模板里直接循环输出。</span></span><br><span class="line"> <span class="number">3</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="number">4</span>     <span class="comment">// 实例化一个空模型，没有对应任何数据表</span></span><br><span class="line"> <span class="number">5</span>     <span class="variable">$Dao</span> = <span class="title function_ invoke__">M</span>();</span><br><span class="line"> <span class="number">6</span>     <span class="comment">//或者使用 $Dao = new Model();</span></span><br><span class="line"> <span class="number">7</span> </span><br><span class="line"> <span class="number">8</span>     <span class="variable">$list</span> = <span class="variable">$Dao</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&quot;select * from user where uid&lt;5&quot;</span>);</span><br><span class="line"> <span class="number">9</span>     <span class="keyword">if</span>(<span class="variable">$list</span>)&#123;</span><br><span class="line"><span class="number">10</span>         <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">assign</span>(<span class="string">&#x27;list&#x27;</span>, <span class="variable">$list</span> );</span><br><span class="line"><span class="number">11</span>         <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">display</span>();</span><br><span class="line"><span class="number">12</span>     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">13</span>         <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">error</span>(<span class="variable">$Dao</span>-&gt;<span class="title function_ invoke__">getError</span>());</span><br><span class="line"><span class="number">14</span>     &#125;</span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span> </span><br><span class="line"><span class="number">17</span> </span><br><span class="line"><span class="number">18</span> <span class="comment">//execute() 方法用于更新和写入数据的 SQL 操作（注：非查询操作，无返回数据集），返回影响的记录数。</span></span><br><span class="line"><span class="number">19</span> </span><br><span class="line"><span class="number">20</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="number">21</span>     <span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Type:text/html; charset=utf-8&quot;</span>);</span><br><span class="line"><span class="number">22</span>     <span class="comment">// 实例化一个空模型，没有对应任何数据表</span></span><br><span class="line"><span class="number">23</span>     <span class="variable">$Dao</span> = <span class="title function_ invoke__">M</span>();</span><br><span class="line"><span class="number">24</span>     <span class="comment">//或者使用 $Dao = new Model();</span></span><br><span class="line"><span class="number">25</span> </span><br><span class="line"><span class="number">26</span>     <span class="variable">$num</span> = <span class="variable">$Dao</span>-&gt;<span class="title function_ invoke__">execute</span>(<span class="string">&quot;update user set email = &#x27;12345@xxx.com&#x27; where uid=3&quot;</span>);</span><br><span class="line"><span class="number">27</span>     &#125;</span><br></pre></td></tr></table></figure><h3 id="7）统计查询"><a href="#7）统计查询" class="headerlink" title="7）统计查询"></a>7）统计查询</h3><p>取得符合查询条件的统计数据 　　　　　　</p><h4 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h4><p>方法用于统计数据行数。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="variable">$Dao</span> = <span class="title function_ invoke__">M</span>(<span class="string">&#x27;User&#x27;</span>);</span><br><span class="line"> <span class="number">3</span>     <span class="comment">// 获取用户数：</span></span><br><span class="line"> <span class="number">4</span>     <span class="variable">$userCount</span> = <span class="variable">$Dao</span>-&gt;<span class="title function_ invoke__">count</span>();</span><br><span class="line"> <span class="number">5</span>     <span class="comment">// 添加条件：</span></span><br><span class="line"> <span class="number">6</span>     <span class="variable">$userCount2</span> = <span class="variable">$Dao</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;uid &gt; 10&#x27;</span>)-&gt;<span class="title function_ invoke__">count</span>();</span><br><span class="line"> <span class="number">7</span> </span><br><span class="line"> <span class="number">8</span>     <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">assign</span>(<span class="string">&#x27;userCount&#x27;</span>, <span class="variable">$userCount</span>);</span><br><span class="line"> <span class="number">9</span>     <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">display</span>();</span><br><span class="line"><span class="number">10</span> &#125;<span class="comment">//可以在模板中直接输出得到的统计数据：共有用户 &#123;$userCount&#125; 人。</span></span><br></pre></td></tr></table></figure><p>两个查询语句实际执行的 SQL 为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> tp_count <span class="keyword">FROM</span> <span class="keyword">user</span> LIMIT <span class="number">1</span> </span><br><span class="line"><span class="number">2</span> <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> tp_count <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> uid <span class="operator">&gt;</span> <span class="number">10</span> LIMIT <span class="number">1</span></span><br></pre></td></tr></table></figure><p> 　　　</p><h4 id="max"><a href="#max" class="headerlink" title="max()"></a>max()</h4><p>方法用于统计某个字段最大数据。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">//统计用户最大积分例子：</span></span><br><span class="line"><span class="number">2</span> <span class="variable">$maxScore</span> = <span class="variable">$Dao</span>-&gt;<span class="title function_ invoke__">max</span>(<span class="string">&#x27;score&#x27;</span>);</span><br></pre></td></tr></table></figure><p>实际执行的 SQL 为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(score) <span class="keyword">AS</span> tp_max <span class="keyword">FROM</span> <span class="keyword">user</span> LIMIT <span class="number">1</span> ;</span><br></pre></td></tr></table></figure><p>　</p><h4 id="min"><a href="#min" class="headerlink" title="min()"></a>min()</h4><p>统计某个字段最小数据。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">//获取积分大于 0 的用户的最小积分例子：</span></span><br><span class="line"><span class="number">2</span> <span class="variable">$minScore</span> = <span class="variable">$Dao</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;score&gt;0&#x27;</span>)-&gt;<span class="title function_ invoke__">min</span>(<span class="string">&#x27;score&#x27;</span>);</span><br></pre></td></tr></table></figure><p>实际执行的 SQL 为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(score) <span class="keyword">AS</span> tp_min <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> score<span class="operator">&gt;</span><span class="number">0</span> LIMIT <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p> 　　　</p><h4 id="avg"><a href="#avg" class="headerlink" title="avg()"></a>avg()</h4><p>统计某个字段平均数据。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">//获取用户的平均积分例子：</span></span><br><span class="line"><span class="number">2</span> <span class="variable">$avgScore</span> = <span class="variable">$Dao</span>-&gt;<span class="title function_ invoke__">avg</span>(<span class="string">&#x27;score&#x27;</span>);</span><br></pre></td></tr></table></figure><p>实际执行的 SQL 为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(score) <span class="keyword">AS</span> tp_avg <span class="keyword">FROM</span> <span class="keyword">user</span> LIMIT <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p> 　　</p><h4 id="sum"><a href="#sum" class="headerlink" title="sum()"></a>sum()</h4><p>统计某个字段数据之和。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">//统计积分排名前 10 名用户的积分之和：</span></span><br><span class="line"><span class="number">2</span> <span class="variable">$sumScore</span> = <span class="variable">$Dao</span>-&gt;<span class="title function_ invoke__">order</span>(<span class="string">&#x27;score DESC&#x27;</span>)-&gt;<span class="title function_ invoke__">limit</span>(<span class="string">&#x27;10&#x27;</span>)-&gt;<span class="title function_ invoke__">sum</span>(<span class="string">&#x27;score&#x27;</span>);</span><br></pre></td></tr></table></figure><p>实际执行的 SQL 为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(score) <span class="keyword">AS</span> tp_sum <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span> LIMIT <span class="number">10</span>; </span><br></pre></td></tr></table></figure><h2 id="5-软删除"><a href="#5-软删除" class="headerlink" title="5.软删除"></a>5.软删除</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">Login.php</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">app</span>\<span class="title class_">index</span>\<span class="title class_">controller</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">Controller</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Gregwar</span>\<span class="title">Captcha</span>\<span class="title">CaptchaBuilder</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">Loader</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">app</span>\<span class="title">index</span>\<span class="title">model</span>\<span class="title">Data</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">Db</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">extends</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">_initialize</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//parent::__construct();</span></span><br><span class="line"><span class="variable language_">$this</span>-&gt;data = <span class="title class_">Loader</span>::<span class="title function_ invoke__">model</span>(<span class="string">&#x27;data&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">delData</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//删除id=16的记录</span></span><br><span class="line"><span class="variable">$res</span> = <span class="title class_">Data</span>::<span class="title function_ invoke__">destroy</span>(<span class="number">16</span>);</span><br><span class="line"><span class="comment">//返回int(1)受影响记录数量</span></span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$res</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除后进行查询验证</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">selData</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//返回为null，表示删除成功</span></span><br><span class="line"><span class="comment">//dump(Data::get(16));</span></span><br><span class="line"><span class="variable">$res</span> = <span class="title class_">Data</span>::<span class="title function_ invoke__">select</span>();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$res</span> <span class="keyword">as</span> <span class="variable">$k</span> =&gt; <span class="variable">$v</span>) &#123;</span><br><span class="line"><span class="comment">//getData()函数可以获取对象里面的数据</span></span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$v</span>-&gt;<span class="title function_ invoke__">getData</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认情况下，查询到的数据不包含软删除数据，如果需要包含软删除的数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">selData1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//查询单条数据</span></span><br><span class="line"><span class="variable">$res</span> = <span class="title class_">Data</span>::<span class="title function_ invoke__">withTrashed</span>(<span class="literal">true</span>)-&gt;<span class="title function_ invoke__">find</span>();</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$res</span>-&gt;<span class="title function_ invoke__">getData</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询多条数据</span></span><br><span class="line"><span class="variable">$res</span> = <span class="title class_">Data</span>::<span class="title function_ invoke__">withTrashed</span>(<span class="literal">true</span>)-&gt;<span class="title function_ invoke__">select</span>();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$res</span> <span class="keyword">as</span> <span class="variable">$k</span> =&gt; <span class="variable">$v</span>) &#123;</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$v</span>-&gt;<span class="title function_ invoke__">getData</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果只想删除软删除的数据，相当于查看回收站</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">selData2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//单条数据</span></span><br><span class="line"><span class="variable">$res</span> = <span class="title class_">Data</span>::<span class="title function_ invoke__">onlyTrashed</span>(<span class="literal">true</span>)-&gt;<span class="title function_ invoke__">find</span>();</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$res</span>-&gt;<span class="title function_ invoke__">getData</span>());</span><br><span class="line"><span class="comment">//多条数据</span></span><br><span class="line"><span class="variable">$res</span> = <span class="title class_">Data</span>::<span class="title function_ invoke__">onlyTrashed</span>(<span class="literal">true</span>)-&gt;<span class="title function_ invoke__">select</span>();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$res</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$val</span>) &#123;</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$val</span>-&gt;<span class="title function_ invoke__">getData</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//恢复软删除记录</span></span><br><span class="line"><span class="comment">//控制器中将被软删除的delete_time更新为null即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">selData3</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable">$res</span> = <span class="title class_">Data</span>::<span class="title function_ invoke__">update</span>([</span><br><span class="line"><span class="string">&#x27;delete_time&#x27;</span> =&gt; <span class="literal">null</span>,</span><br><span class="line">], [<span class="string">&#x27;id&#x27;</span> =&gt; <span class="number">16</span>]);</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$res</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在就可以获取重新被软删除的记录了</span></span><br><span class="line"><span class="variable">$res</span> = <span class="title class_">Data</span>::<span class="title function_ invoke__">get</span>(<span class="number">16</span>);</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$res</span>-&gt;<span class="title function_ invoke__">getData</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//物理删除是指彻底将该记录从表中移除，不可恢复。给destroy()方法传入第二个参数true</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">delReal</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//删除id为16的记录</span></span><br><span class="line"><span class="variable">$res</span> = <span class="title class_">Data</span>::<span class="title function_ invoke__">destroy</span>(<span class="number">16</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$res</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用delete(true)实现物理删除</span></span><br><span class="line"><span class="variable">$res</span> = <span class="title class_">Data</span>::<span class="title function_ invoke__">where</span>(<span class="string">&#x27;id&#x27;</span>, <span class="number">18</span>)-&gt;<span class="title function_ invoke__">delete</span>();</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$res</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Data.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Data.php</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">app</span>\<span class="title class_">index</span>\<span class="title class_">model</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">Db</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">Model</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">traits</span>\<span class="title">model</span>\<span class="title">SoftDelete</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> <span class="keyword">extends</span> <span class="title">Model</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">//在当前类导入，就可以使用其中的方法啦</span></span><br><span class="line"><span class="keyword">use</span> <span class="title">SoftDelete</span>;</span><br><span class="line"><span class="comment">//如果你的字段名为框架默认的delete_time,可省略</span></span><br><span class="line"><span class="keyword">protected</span> <span class="variable">$deleteTime</span> = <span class="string">&#x27;delete_time&#x27;</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="variable">$table</span> = <span class="string">&#x27;bbs_data&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getMenu</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable">$res</span> = <span class="title class_">Db</span>::<span class="title function_ invoke__">name</span>(<span class="variable">$this</span>-&gt;table)-&gt;<span class="title function_ invoke__">select</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="variable">$res</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-TP5框架model操作【增删改查、聚合、时间戳、软删除等"><a href="#3-TP5框架model操作【增删改查、聚合、时间戳、软删除等" class="headerlink" title="3.TP5框架model操作【增删改查、聚合、时间戳、软删除等"></a>3.TP5框架model操作【增删改查、聚合、时间戳、软删除等</h1><ul><li>使用model 查询数据，添加数据，修改数据，删除数据</li><li>聚合操作</li><li>获取器，修改器</li><li>自动添加时间戳（创建时间，修改时间）</li><li>软删除</li></ul><h2 id="1、使用model查询数据"><a href="#1、使用model查询数据" class="headerlink" title="1、使用model查询数据"></a><strong>1、使用model查询数据</strong></h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$res</span> = <span class="title class_">User</span>::<span class="title function_ invoke__">get</span>(<span class="number">1</span>); <span class="comment">//获取主键为1的数据，得到的是一个对象</span></span><br><span class="line"> </span><br><span class="line"><span class="variable">$res</span> = <span class="variable">$res</span>- <span class="title function_ invoke__">toArray</span>(); <span class="comment">//将对象转化为数组</span></span><br><span class="line"> </span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$res</span>- name); <span class="comment">//获取 $res 里 name 字段的值</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用闭包函数查询 id=1 的记录</span></span><br><span class="line"><span class="variable">$res</span> = <span class="title class_">User</span>::<span class="title function_ invoke__">get</span>(function(<span class="variable">$query</span>)&#123;</span><br><span class="line">  <span class="variable">$query</span>- <span class="title function_ invoke__">where</span>(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;eq&quot;</span>,<span class="number">1</span>)</span><br><span class="line">     - <span class="title function_ invoke__">field</span>(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$res</span> = <span class="title class_">User</span>::<span class="title function_ invoke__">where</span>(<span class="string">&quot;id&quot;</span>,<span class="number">10</span>)- <span class="title function_ invoke__">value</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"><span class="variable">$res</span> = <span class="title class_">User</span>::<span class="title function_ invoke__">where</span>(<span class="string">&quot;id&quot;</span>,<span class="number">10</span>)- <span class="title function_ invoke__">field</span>(<span class="string">&#x27;name&#x27;</span>)- <span class="title function_ invoke__">find</span>();</span><br><span class="line"> </span><br><span class="line"><span class="variable">$res</span> = <span class="title class_">User</span>::<span class="title function_ invoke__">column</span>(<span class="string">&#x27;email&#x27;</span>);        <span class="comment">//查询所有的 email 字段值    </span></span><br><span class="line"><span class="variable">$res</span> = <span class="title class_">User</span>::<span class="title function_ invoke__">where</span>(<span class="string">&quot;id&quot;</span>,<span class="string">&quot; &quot;</span>,<span class="number">5</span>)- <span class="title function_ invoke__">select</span>();  <span class="comment">//查询所有id大于5的记录</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$res</span> = <span class="title class_">User</span>::<span class="title function_ invoke__">all</span>(<span class="string">&#x27;1,2&#x27;</span>); <span class="comment">//查询主键等于 1 或2 的记录</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$res</span> <span class="keyword">as</span> <span class="variable">$val</span>)  <span class="comment">//转化为数组</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="title function_ invoke__">dump</span>(<span class="variable">$val</span>- <span class="title function_ invoke__">toArray</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用闭包函数查询 id&lt;5 的记录</span></span><br><span class="line"><span class="variable">$res</span> = <span class="title class_">User</span>::<span class="title function_ invoke__">get</span>(function(<span class="variable">$query</span>)&#123;</span><br><span class="line">  <span class="variable">$query</span>- <span class="title function_ invoke__">where</span>(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;&lt;&quot;</span>,<span class="number">5</span>)</span><br><span class="line">     - <span class="title function_ invoke__">field</span>(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="2、使用model添加数据"><a href="#2、使用model添加数据" class="headerlink" title="2、使用model添加数据"></a><strong>2、使用model添加数据</strong></h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$res</span> = <span class="title class_">User</span>::<span class="title function_ invoke__">create</span>([</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span> =  <span class="string">&#x27;yulong&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pwd&#x27;</span> =  <span class="string">&#x27;123&#x27;</span></span><br><span class="line">],<span class="literal">true</span>);        </span><br><span class="line"><span class="comment">//第二个参数为true时，只添加数据表中已有的字段，不报错，不写则默认为false；；；true 也可以换成一个数组，数组里存放数据表中的字段，表示仅允许数组中的字段添加数据</span></span><br><span class="line"><span class="variable">$res</span>- id; <span class="comment">//本次添加的自增id</span></span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$res</span>);</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$usermodel</span> = <span class="keyword">new</span> <span class="title class_">User</span>;</span><br><span class="line"><span class="variable">$res</span> = <span class="variable">$usermodel</span></span><br><span class="line">  - <span class="title function_ invoke__">allowField</span>(<span class="literal">true</span>) <span class="comment">//仅允许添加数据表中存在的字段，也可以写成数组</span></span><br><span class="line">  - <span class="title function_ invoke__">save</span>([</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span> =  <span class="string">&#x27;yulong&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;pwd&#x27;</span> =  <span class="string">&#x27;123&#x27;</span></span><br><span class="line">  ]);</span><br><span class="line"> </span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$res</span>- id); <span class="comment">//获取新添加数据的自增id</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$usermodel</span> = <span class="keyword">new</span> <span class="title class_">User</span>;</span><br><span class="line"><span class="variable">$res</span> = <span class="variable">$usermodel</span>- <span class="title function_ invoke__">saveAll</span>([  //一次保存多条数据</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span> =  <span class="string">&#x27;yulong001&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span> =  <span class="string">&#x27;yulong002&#x27;</span></span><br><span class="line">]);</span><br><span class="line"> </span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$ers</span>);</span><br></pre></td></tr></table></figure><h2 id="3、使用model更新数据"><a href="#3、使用model更新数据" class="headerlink" title="3、使用model更新数据"></a><strong>3、使用model更新数据</strong></h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$res</span> = <span class="title class_">User</span>::<span class="title function_ invoke__">update</span>([</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span> =  <span class="string">&#x27;yulong002&#x27;</span></span><br><span class="line">],[<span class="string">&#x27;id&#x27;</span>= <span class="number">1</span>]);        <span class="comment">//更新 id=1 的记录</span></span><br><span class="line"> </span><br><span class="line"> <span class="variable">$res</span> = <span class="title class_">User</span>::<span class="title function_ invoke__">update</span>([</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span> =  <span class="string">&#x27;yulong002&#x27;</span></span><br><span class="line">],function()&#123;</span><br><span class="line">  <span class="variable">$query</span>- <span class="title function_ invoke__">where</span>(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;LT&quot;</span>,<span class="number">5</span>);  <span class="comment">//使用闭包函数更新 id&lt;5 的记录</span></span><br><span class="line">&#125;); </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$res</span>);</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$res</span> = <span class="title class_">User</span>::<span class="title function_ invoke__">where</span>(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;&lt;&quot;</span>,<span class="number">6</span>)   <span class="comment">//返回值是被更新数据的行数</span></span><br><span class="line">    - <span class="title function_ invoke__">update</span>([</span><br><span class="line">       <span class="string">&#x27;name&#x27;</span> =  <span class="string">&#x27;hahahaha&#x27;</span></span><br><span class="line">      ]);</span><br></pre></td></tr></table></figure><h2 id="4、使用model删除数据"><a href="#4、使用model删除数据" class="headerlink" title="4、使用model删除数据"></a><strong>4、使用model删除数据</strong></h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$res</span> = <span class="title class_">User</span>::<span class="title function_ invoke__">destriy</span>(<span class="number">1</span>);  <span class="comment">//删除主键为1的记录，返回影响数据的行数，也可以传递数组</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="variable">$usermodel</span> = <span class="title class_">User</span>::<span class="title function_ invoke__">get</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable">$res</span>    = <span class="variable">$usermodel</span>- <span class="title function_ invoke__">delete</span>();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="variable">$res</span> = <span class="title class_">User</span>::<span class="title function_ invoke__">where</span>(<span class="string">&quot;id&quot;</span>,<span class="number">5</span>)- <span class="title function_ invoke__">delete</span>(); <span class="comment">// where() 里面有三个参数， 字段值，条件，数值</span></span><br><span class="line"> </span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$res</span>);</span><br></pre></td></tr></table></figure><h2 id="5、使用model聚合操作"><a href="#5、使用model聚合操作" class="headerlink" title="5、使用model聚合操作"></a><strong>5、使用model聚合操作</strong></h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$res</span> = <span class="title class_">User</span>::<span class="title function_ invoke__">where</span>(<span class="string">&quot;id&quot;</span>,<span class="string">&quot; &quot;</span>,<span class="number">5</span>)- <span class="title function_ invoke__">count</span>(); <span class="comment">//查询id大于5的记录条数</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// max 可以换成其他的 如 min / sum / avg</span></span><br><span class="line"><span class="variable">$res</span> = <span class="title class_">User</span>::<span class="title function_ invoke__">max</span>(<span class="string">&#x27;num&#x27;</span>);         <span class="comment">//查询 num 字段中的最大值</span></span><br><span class="line"><span class="variable">$res</span> = <span class="title class_">User</span>::<span class="title function_ invoke__">where</span>(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;&lt;&quot;</span>,<span class="number">5</span>)- <span class="title function_ invoke__">max</span>(<span class="string">&#x27;num&#x27;</span>); <span class="comment">//id&lt;5 的记录中的 num 最大值</span></span><br></pre></td></tr></table></figure><h2 id="6、使用模型获取器"><a href="#6、使用模型获取器" class="headerlink" title="6、使用模型获取器"></a><strong>6、使用模型获取器</strong></h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//model </span></span><br><span class="line"><span class="comment">//方法名： get字段名Attr</span></span><br><span class="line"><span class="comment">//controller中获取原始数据使用 $res- getData()</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getSexSttr</span>(<span class="params"><span class="variable">$val</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(<span class="variable">$val</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;男&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;女&#x27;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;未知&#x27;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、使用模型修改器"><a href="#7、使用模型修改器" class="headerlink" title="7、使用模型修改器"></a><strong>7、使用模型修改器</strong></h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//model 修改器命名 set字段名Attr</span></span><br><span class="line"><span class="comment">//修改器作用：在往数据库添加字段时，控制器中写未处理的数据，在模型中的修改器中写处理数据的方法，这样添加到数据库中的数据就是处理过得数据了</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setPwdAttr</span>(<span class="params"><span class="variable">$val</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_ invoke__">md5</span>(<span class="variable">$val</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// $val代表 pwd 字段，$data代表接收到的所有数据 ，返回的值就是 pwd+email </span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setPwdAttr</span>(<span class="params"><span class="variable">$val</span>,<span class="variable">$data</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable">$val</span>.<span class="variable">$data</span>[<span class="string">&#x27;email&#x27;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、自动往-数据库-中添加时间戳"><a href="#8、自动往-数据库-中添加时间戳" class="headerlink" title="8、自动往[数据库]中添加时间戳"></a>8、自动往[数据库]中添加时间戳</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动往 time 字段中加入时间戳</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setTimeAttr</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_ invoke__">time</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//在数据添加时发生改变</span></span><br><span class="line"><span class="keyword">protected</span> <span class="variable">$insert</span> = [ <span class="string">&#x27;time_insert&#x27;</span> ]; <span class="comment">//设置字段</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setTimeInsertAttr</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//将字段值设置为当前时间</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_ invoke__">time</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//在更新数据时发生改变</span></span><br><span class="line"><span class="keyword">protected</span> <span class="variable">$update</span> = [ <span class="string">&#x27;time_update&#x27;</span> ]; <span class="comment">//设置字段</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setTimeUpdateAttr</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//将字段值设置为当前时间</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_ invoke__">time</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>9、model时间戳</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据库中的字段 create_time update_time</span></span><br><span class="line"><span class="comment">// database.php 中更改配置 &#x27;auto_timeStamp&#x27; =  true</span></span><br><span class="line"><span class="comment">// 不推荐使用此方法，因为如果你的数据库表中没有 对应的字段 ，程序可能就会报错</span></span><br><span class="line"><span class="comment">// 可以单独在 某个模型中 添加属性 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span> <span class="variable">$autoWriteTimeStamp</span> = <span class="literal">true</span>; <span class="comment">//开启自动加入时间戳</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span> <span class="variable">$createTime</span> = <span class="string">&#x27;create_at&#x27;</span>;  <span class="comment">//设置 创建的时候写入 的字段 ，值可以为false，关闭操作</span></span><br><span class="line">protedted <span class="variable">$updateTime</span> = <span class="string">&#x27;update_at&#x27;</span>;  <span class="comment">//设置 创建和更新的时候写入 的字段 ，值可以为false，关闭操作</span></span><br></pre></td></tr></table></figure><p><strong>10、软删除</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// model</span></span><br><span class="line"><span class="comment">// 数据表中的字段 delete_time，默认值可以为 null</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">use</span> <span class="title">traits</span>\<span class="title">model</span>\<span class="title">SoftDelete</span>; <span class="comment">//使用软删除的类</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Model</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">use</span> <span class="title">SoftDelete</span>;      <span class="comment">//在类的开头 use SoftDelete; </span></span><br><span class="line">  <span class="keyword">protected</span> <span class="variable">$deleteTime</span> = <span class="string">&#x27;delete_at&#x27;</span>;  <span class="comment">//设置软删除的字段，默认为 delete_time</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="variable">$res</span> = <span class="title class_">User</span>::<span class="title function_ invoke__">destroy</span>(<span class="number">3</span>,<span class="literal">true</span>); <span class="comment">//删除主键为3的记录，第二个参数为 true 时，不是软删除，是tm真删了</span></span><br><span class="line"> </span><br><span class="line"><span class="variable">$ress</span> = <span class="title class_">User</span>::<span class="title function_ invoke__">get</span>(<span class="number">4</span>);</span><br><span class="line"><span class="variable">$res</span> = <span class="variable">$ress</span>- <span class="title function_ invoke__">delete</span>(<span class="literal">true</span>); <span class="comment">// delete() 没值时，为软删除；值为true，tm的真删</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// controller 获取到 软删除 的记录</span></span><br><span class="line"><span class="variable">$res</span> = <span class="title class_">User</span>::<span class="title function_ invoke__">withTrashed</span>(<span class="literal">true</span>)- <span class="title function_ invoke__">find</span>(<span class="number">1</span>); <span class="comment">//得到id为1 的经过软删除 删除的记录</span></span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$res</span>- <span class="title function_ invoke__">getData</span>()); <span class="comment">//获取原始数据</span></span><br><span class="line"> </span><br><span class="line"><span class="variable">$res</span> = <span class="title class_">User</span>::<span class="title function_ invoke__">onlyTrashed</span>()- <span class="title function_ invoke__">select</span>(); <span class="comment">//获取所有软删除的数据</span></span><br></pre></td></tr></table></figure><h1 id="4-ThinkPHP-5-操作数据库三种方法"><a href="#4-ThinkPHP-5-操作数据库三种方法" class="headerlink" title="4.ThinkPHP 5 操作数据库三种方法"></a>4.ThinkPHP 5 操作数据库三种方法</h1><h2 id="一、原生的sql语句"><a href="#一、原生的sql语句" class="headerlink" title="一、原生的sql语句"></a>一、原生的sql语句</h2><h3 id="1-query：查询操作"><a href="#1-query：查询操作" class="headerlink" title="1. query：查询操作"></a>1. query：查询操作</h3><p><strong>query简单粗暴的方法</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getDetail</span>(<span class="params"><span class="variable">$id</span></span>)</span>&#123;</span><br><span class="line">      <span class="variable">$data</span>= <span class="title class_">Db</span>::<span class="title function_ invoke__">query</span>(<span class="string">&#x27;select * from test&#x27;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200723182034439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xjbF9rZXk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>可以传参数；用占位符或者命名占位符绑定</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getDetail</span>(<span class="params"><span class="variable">$id</span></span>)</span>&#123;</span><br><span class="line">      <span class="variable">$data</span>= <span class="title class_">Db</span>::<span class="title function_ invoke__">query</span>(<span class="string">&#x27;select * from test where id=?&#x27;</span>,[<span class="variable">$id</span>]);</span><br><span class="line">       <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200723182545707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xjbF9rZXk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2-execute：写入操作"><a href="#2-execute：写入操作" class="headerlink" title="2. execute：写入操作"></a>2. execute：写入操作</h3><p><strong>execute 插入数据，返回值是影响的记录数</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$data</span>= <span class="title class_">Db</span>::<span class="title function_ invoke__">execute</span>(<span class="string">&#x27;insert into test (name) values (?)&#x27;</span>,[<span class="string">&#x27;thinkphp&#x27;</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$data</span>;</span><br></pre></td></tr></table></figure><h2 id="二、使用查询构建器"><a href="#二、使用查询构建器" class="headerlink" title="二、使用查询构建器"></a>二、使用查询构建器</h2><p><strong>备注：TP5框架有助手函数</strong><br>Db::table(‘user’) 相当于 db(‘user’)</p><h3 id="1-find、select"><a href="#1-find、select" class="headerlink" title="1.find、select"></a>1.find、select</h3><p><strong>find()只能返回第一条数据（建议单个查询使用）；select()是把所有符合的查询出来</strong><br><strong>细节：</strong></p><blockquote><p>find 方法查询结果不存在，返回 null<br>select 方法查询结果不存在，返回空数组</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链式表达式   </span></span><br><span class="line"><span class="comment">//链式操作where(&#x27;字段名&#x27;,&#x27;表达式&#x27;,&#x27;查询条件&#x27;)</span></span><br><span class="line"><span class="comment">//这里的等号可以缺审</span></span><br><span class="line"><span class="variable">$data</span>=<span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;test&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;id&#x27;</span>,<span class="number">1</span>)-&gt;<span class="title function_ invoke__">find</span>();</span><br><span class="line"><span class="variable">$data</span>=<span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;test&#x27;</span>)-&gt;<span class="title function_ invoke__">select</span>();</span><br><span class="line"><span class="comment">//助手函数</span></span><br><span class="line"><span class="variable">$data</span> =<span class="title function_ invoke__">db</span>(<span class="string">&#x27;test&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;id&#x27;</span>,<span class="number">1</span>)-&gt;<span class="title function_ invoke__">find</span>();</span><br><span class="line"><span class="variable">$data</span> =<span class="title function_ invoke__">db</span>(<span class="string">&#x27;test&#x27;</span>)-&gt;<span class="title function_ invoke__">select</span>();</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200723200429293.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200723202726814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xjbF9rZXk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2-insert"><a href="#2-insert" class="headerlink" title="2.insert"></a>2.insert</h3><blockquote><p>update 方法返回影响数据的条数，没修改任何数据返回 0</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入单条数据</span></span><br><span class="line"> <span class="variable">$aa</span> = [<span class="string">&#x27;name&#x27;</span> =&gt; <span class="string">&#x27;good&#x27;</span>];</span><br><span class="line"> <span class="variable">$data</span>=<span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;test&#x27;</span>)-&gt;<span class="title function_ invoke__">insert</span>(<span class="variable">$aa</span>);</span><br><span class="line"><span class="comment">//插入多条数据</span></span><br><span class="line">  <span class="variable">$bb</span> = [</span><br><span class="line">            [<span class="string">&#x27;name&#x27;</span> =&gt; <span class="string">&#x27;bb&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;name&#x27;</span> =&gt; <span class="string">&#x27;cc&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;name&#x27;</span> =&gt; <span class="string">&#x27;dd&#x27;</span>],</span><br><span class="line">        ];</span><br><span class="line">  <span class="variable">$data</span> = <span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;test&#x27;</span>)-&gt;<span class="title function_ invoke__">insertAll</span>(<span class="variable">$bb</span>);</span><br><span class="line"><span class="comment">//函数助手</span></span><br><span class="line"><span class="comment">// 添加单条数据</span></span><br><span class="line"> <span class="title function_ invoke__">db</span>(<span class="string">&#x27;user&#x27;</span>)-&gt;<span class="title function_ invoke__">insert</span>(<span class="variable">$aa</span>);</span><br><span class="line"><span class="comment">// 添加多条数据</span></span><br><span class="line"> <span class="title function_ invoke__">db</span>(<span class="string">&#x27;user&#x27;</span>)-&gt;<span class="title function_ invoke__">insertAll</span>(<span class="variable">$bb</span>);</span><br></pre></td></tr></table></figure><h3 id="3-update"><a href="#3-update" class="headerlink" title="3.update"></a>3.update</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更新某一条记录</span></span><br><span class="line"> <span class="variable">$data</span> = <span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;test&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;id&#x27;</span>,<span class="number">1</span>)-&gt;<span class="title function_ invoke__">update</span>([<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;老张&#x27;</span>]);</span><br><span class="line"><span class="comment">//更新某条记录的某个字段的值：</span></span><br><span class="line"> <span class="variable">$data</span>=<span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;test&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;id&#x27;</span>,<span class="number">2</span>)-&gt;<span class="title function_ invoke__">setField</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;老四&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="4-delete"><a href="#4-delete" class="headerlink" title="4.delete"></a>4.delete</h3><blockquote><p>delete 方法返回影响数据的条数，没有删除返回 0</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据主键删除</span></span><br><span class="line"> <span class="variable">$data</span>=<span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;test&#x27;</span>)-&gt;<span class="title function_ invoke__">delete</span>(<span class="number">6</span>);</span><br><span class="line"><span class="comment">//可以传入数组，进行批量删除</span></span><br><span class="line"> <span class="variable">$data</span>=<span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;test&#x27;</span>)-&gt;<span class="title function_ invoke__">delete</span>([<span class="number">7</span>,<span class="number">8</span>]);</span><br></pre></td></tr></table></figure><h3 id="5-自增或自减一个字段的值"><a href="#5-自增或自减一个字段的值" class="headerlink" title="5.自增或自减一个字段的值"></a>5.自增或自减一个字段的值</h3><p><strong>自增或自减一个字段的值</strong><br><strong>setInc&#x2F;setDec 如不加第二个参数，默认值为1；第三个参数是延迟时间，单位秒</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// score 字段加 1</span></span><br><span class="line"><span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;think_user&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;id&#x27;</span>, <span class="number">1</span>)-&gt;<span class="title function_ invoke__">setInc</span>(<span class="string">&#x27;score&#x27;</span>);</span><br><span class="line"><span class="comment">// score 字段加 5</span></span><br><span class="line"><span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;think_user&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;id&#x27;</span>, <span class="number">1</span>)-&gt;<span class="title function_ invoke__">setInc</span>(<span class="string">&#x27;score&#x27;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// score 字段减 1</span></span><br><span class="line"><span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;think_user&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;id&#x27;</span>, <span class="number">1</span>)-&gt;<span class="title function_ invoke__">setDec</span>(<span class="string">&#x27;score&#x27;</span>);</span><br><span class="line"><span class="comment">//延迟更新，第三个参数是时间单位秒</span></span><br><span class="line"><span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;think_user&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;id&#x27;</span>, <span class="number">1</span>)-&gt;<span class="title function_ invoke__">setInc</span>(<span class="string">&#x27;score&#x27;</span>, <span class="number">1</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h3 id="6-使用Query或闭包查询"><a href="#6-使用Query或闭包查询" class="headerlink" title="6.使用Query或闭包查询"></a>6.使用Query或闭包查询</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">使用查询对象进行查询</span><br><span class="line"><span class="variable">$query</span> = <span class="keyword">new</span> \think\db\<span class="title function_ invoke__">Query</span>();</span><br><span class="line"><span class="variable">$query</span>-&gt;<span class="title function_ invoke__">table</span>(<span class="string">&#x27;think_user&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;status&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="title class_">Db</span>::<span class="title function_ invoke__">find</span>(<span class="variable">$query</span>);</span><br><span class="line"><span class="title class_">Db</span>::<span class="title function_ invoke__">select</span>(<span class="variable">$query</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用闭包函数查询</span></span><br><span class="line"><span class="title class_">Db</span>::<span class="title function_ invoke__">select</span>(function(<span class="variable">$query</span>)&#123;</span><br><span class="line">    <span class="variable">$query</span>-&gt;<span class="title function_ invoke__">table</span>(<span class="string">&#x27;think_user&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;status&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="7-查询表达式"><a href="#7-查询表达式" class="headerlink" title="7.查询表达式"></a>7.查询表达式</h3><blockquote><p>where(‘字段名’,‘表达式’,‘查询条件’);<br>whereOr(‘字段名’,‘表达式’,‘查询条件’);<br>表达式不分大小写，支持的查询表达式有下面几种，分别表示的含义是：</p></blockquote><table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td>EQ、&#x3D;</td><td>等于（&#x3D;）</td></tr><tr><td>NEQ、&lt;&gt;</td><td>不等于（&lt;&gt;）</td></tr><tr><td>GT、&gt;</td><td>大于（&gt;）</td></tr><tr><td>EGT、&gt;&#x3D;</td><td>大于等于（&gt;&#x3D;）</td></tr><tr><td>LT、&lt;</td><td>小于（&lt;）</td></tr><tr><td>ELT、&lt;&#x3D;</td><td>小于等于（&lt;&#x3D;）</td></tr><tr><td>LIKE</td><td>模糊查询</td></tr><tr><td>[NOT] BETWEEN</td><td>（不在）区间查询</td></tr><tr><td>[NOT] IN</td><td>（不在）IN 查询</td></tr><tr><td>[NOT] NULL</td><td>查询字段是否（不）是NULL</td></tr><tr><td>[NOT] EXISTS</td><td>EXISTS查询</td></tr><tr><td>EXP</td><td>表达式查询，支持SQL语法</td></tr><tr><td>&gt; time</td><td>时间比较</td></tr><tr><td>&lt; time</td><td>时间比较</td></tr><tr><td>between time</td><td>时间比较</td></tr><tr><td>notbetween time</td><td>时间比较</td></tr></tbody></table><p>显示简略信息</p><h3 id="8-链式操作-操作名称"><a href="#8-链式操作-操作名称" class="headerlink" title="8.链式操作 操作名称"></a>8.链式操作 操作名称</h3><blockquote><p>所有的连贯操作都返回当前的模型实例对象（this），其中带*标识的表示支持多次调用。</p></blockquote><table><thead><tr><th>连贯操作</th><th>作用</th><th>支持的参数类型</th></tr></thead><tbody><tr><td>where*</td><td>用于AND查询</td><td>字符串、数组和对象</td></tr><tr><td>whereOr*</td><td>用于OR查询</td><td>字符串、数组和对象</td></tr><tr><td>wheretime*</td><td>用于时间日期的快捷查询</td><td>字符串</td></tr><tr><td>table</td><td>用于定义要操作的数据表名称</td><td>字符串和数组</td></tr><tr><td>alias</td><td>用于给当前数据表定义别名</td><td>字符串</td></tr><tr><td>field*</td><td>用于定义要查询的字段（支持字段排除）</td><td>字符串和数组</td></tr><tr><td>order*</td><td>用于对结果排序</td><td>字符串和数组</td></tr><tr><td>limit</td><td>用于限制查询结果数量</td><td>字符串和数字</td></tr><tr><td>page</td><td>用于查询分页（内部会转换成limit）</td><td>字符串和数字</td></tr><tr><td>group</td><td>用于对查询的group支持</td><td>字符串</td></tr><tr><td>having</td><td>用于对查询的having支持</td><td>字符串</td></tr><tr><td>join*</td><td>用于对查询的join支持</td><td>字符串和数组</td></tr><tr><td>union*</td><td>用于对查询的union支持</td><td>字符串、数组和对象</td></tr><tr><td>view*</td><td>用于视图查询</td><td>字符串、数组</td></tr><tr><td>distinct</td><td>用于查询的distinct支持</td><td>布尔值</td></tr><tr><td>lock</td><td>用于数据库的锁机制</td><td>布尔值</td></tr><tr><td>cache</td><td>用于查询缓存</td><td>支持多个参数</td></tr><tr><td>relation*</td><td>用于关联查询</td><td>字符串</td></tr><tr><td>with*</td><td>用于关联预载入</td><td>字符串、数组</td></tr><tr><td>bind*</td><td>用于数据绑定操作</td><td>数组或多个参数</td></tr><tr><td>comment</td><td>用于SQL注释</td><td>字符串</td></tr><tr><td>force</td><td>用于数据集的强制索引</td><td>字符串</td></tr><tr><td>master</td><td>用于设置主服务器读取数据</td><td>布尔值</td></tr><tr><td>strict</td><td>用于设置是否严格检测字段名是否存在</td><td>布尔值</td></tr><tr><td>sequence</td><td>用于设置Pgsql的自增序列名</td><td>字符串</td></tr><tr><td>failException</td><td>用于设置没有查询到数据是否抛出异常</td><td>布尔值</td></tr><tr><td>partition</td><td>用于设置分表信息</td><td>数组 字符串</td></tr></tbody></table><h2 id="三、模型ORM"><a href="#三、模型ORM" class="headerlink" title="三、模型ORM"></a>三、模型ORM</h2><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p><img src="https://img-blog.csdnimg.cn/20200723215531172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xjbF9rZXk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>默认主键为自动识别，如果需要指定，<br>可以设置属性： <code>protected $pk = &#39;uid&#39;;</code></p></blockquote><h2 id="2-引用-获取数据-get-、all"><a href="#2-引用-获取数据-get-、all" class="headerlink" title="2.引用+获取数据 (get 、all)"></a>2.引用+获取数据 (get 、all)</h2><h3 id="获取单个数据"><a href="#获取单个数据" class="headerlink" title="获取单个数据"></a><strong>获取单个数据</strong></h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用</span></span><br><span class="line"><span class="keyword">use</span> <span class="title">app</span>\<span class="title">index</span>\<span class="title">model</span>\<span class="title">Test</span> <span class="keyword">as</span> <span class="title">TestModel</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//获取主键为1的数据</span></span><br><span class="line"> <span class="variable">$data</span> = <span class="title class_">TestModel</span>::<span class="title function_ invoke__">get</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//数组的方法</span></span><br><span class="line">  <span class="variable">$data</span> = <span class="title class_">TestModel</span>::<span class="title function_ invoke__">get</span>([<span class="string">&#x27;id&#x27;</span>=&gt;<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//闭包的方法</span></span><br><span class="line"> <span class="variable">$data</span> = <span class="title class_">TestModel</span>::<span class="title function_ invoke__">get</span>(function(<span class="variable">$query</span>)&#123;</span><br><span class="line">            <span class="variable">$query</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;id&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><h3 id="获取多个数据"><a href="#获取多个数据" class="headerlink" title="获取多个数据"></a><strong>获取多个数据</strong></h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用</span></span><br><span class="line"><span class="keyword">use</span> <span class="title">app</span>\<span class="title">index</span>\<span class="title">model</span>\<span class="title">Test</span> <span class="keyword">as</span> <span class="title">TestModel</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//获取所有数据</span></span><br><span class="line">  <span class="variable">$data</span> =<span class="title class_">TestModel</span>::<span class="title function_ invoke__">all</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据主键获取多个数据</span></span><br><span class="line"><span class="variable">$list</span> = <span class="title class_">User</span>::<span class="title function_ invoke__">all</span>(<span class="string">&#x27;1,2,3&#x27;</span>);</span><br><span class="line"><span class="comment">// 或者使用数组</span></span><br><span class="line"><span class="variable">$list</span> = <span class="title class_">User</span>::<span class="title function_ invoke__">all</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$list</span> <span class="keyword">as</span> <span class="variable">$key</span>=&gt;<span class="variable">$user</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$user</span>-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用数组查询</span></span><br><span class="line"><span class="variable">$list</span> = <span class="title class_">User</span>::<span class="title function_ invoke__">all</span>([<span class="string">&#x27;status&#x27;</span>=&gt;<span class="number">1</span>]);</span><br><span class="line"><span class="comment">// 使用闭包查询</span></span><br><span class="line"><span class="variable">$list</span> = <span class="title class_">User</span>::<span class="title function_ invoke__">all</span>(function(<span class="variable">$query</span>)&#123;</span><br><span class="line">    <span class="variable">$query</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;status&#x27;</span>, <span class="number">1</span>)-&gt;<span class="title function_ invoke__">limit</span>(<span class="number">3</span>)-&gt;<span class="title function_ invoke__">order</span>(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;asc&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$list</span> <span class="keyword">as</span> <span class="variable">$key</span>=&gt;<span class="variable">$user</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$user</span>-&gt;name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例化的方法"><a href="#实例化的方法" class="headerlink" title="实例化的方法"></a><strong>实例化的方法</strong></h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$user</span> = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">       <span class="comment">// 查询单个数据</span></span><br><span class="line">       <span class="variable">$data</span>=<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;id&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">           -&gt;<span class="title function_ invoke__">find</span>();</span><br><span class="line">       <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="3-新增（save、saveAll）"><a href="#3-新增（save、saveAll）" class="headerlink" title="3.新增（save、saveAll）"></a>3.新增（save、saveAll）</h2><h3 id="新增一条"><a href="#新增一条" class="headerlink" title="新增一条"></a><strong>新增一条</strong></h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新增一条</span></span><br><span class="line"><span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">Test</span>;</span><br><span class="line"><span class="variable">$test</span>-&gt;name = <span class="string">&#x27;thinkphp&#x27;</span>;</span><br><span class="line"><span class="variable">$test</span>-&gt;<span class="title function_ invoke__">save</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//data数组批量赋值</span></span><br><span class="line"><span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">Test</span>;</span><br><span class="line"><span class="variable">$test</span>-&gt;<span class="title function_ invoke__">data</span>([</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>  =&gt;  <span class="string">&#x27;thinkphp&#x27;</span>,</span><br><span class="line">]);</span><br><span class="line"><span class="variable">$test</span>-&gt;<span class="title function_ invoke__">save</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接在实例化的时候传入数据</span></span><br><span class="line"><span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">Test</span>([</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>  =&gt;  <span class="string">&#x27;thinkphp&#x27;</span>,</span><br><span class="line">]);</span><br><span class="line"><span class="variable">$test</span>-&gt;<span class="title function_ invoke__">save</span>();</span><br></pre></td></tr></table></figure><h3 id="批量新增"><a href="#批量新增" class="headerlink" title="批量新增"></a><strong>批量新增</strong></h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">Test</span>;</span><br><span class="line"><span class="variable">$list</span> = [</span><br><span class="line">    [<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;thinkphp&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;onethink&#x27;</span>]</span><br><span class="line">];</span><br><span class="line"><span class="variable">$test</span>-&gt;<span class="title function_ invoke__">saveAll</span>(<span class="variable">$list</span>);</span><br></pre></td></tr></table></figure><h2 id="4-更新（save、saveAll、update）"><a href="#4-更新（save、saveAll、update）" class="headerlink" title="4.更新（save、saveAll、update）"></a>4.更新（save、saveAll、update）</h2><h3 id="查询与更新"><a href="#查询与更新" class="headerlink" title="查询与更新"></a><strong>查询与更新</strong></h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在取出数据后，更改字段内容后更新数据。</span></span><br><span class="line"><span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">Test</span>;</span><br><span class="line"><span class="variable">$test</span>= <span class="title class_">Test</span>::<span class="title function_ invoke__">get</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable">$test</span>-&gt;name     = <span class="string">&#x27;thinkphp&#x27;</span>;</span><br><span class="line"><span class="variable">$test</span>-&gt;<span class="title function_ invoke__">save</span>();</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line"><span class="comment">//也可以直接带更新条件来更新数据</span></span><br><span class="line"><span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">Test</span>;</span><br><span class="line"><span class="comment">// save方法第二个参数为更新条件</span></span><br><span class="line"><span class="variable">$test</span>-&gt;<span class="title function_ invoke__">save</span>([</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>  =&gt; <span class="string">&#x27;thinkphp&#x27;</span>,</span><br><span class="line">],[<span class="string">&#x27;id&#x27;</span> =&gt; <span class="number">1</span>]);</span><br></pre></td></tr></table></figure><h3 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a><strong>批量更新</strong></h3><blockquote><p>批量更新仅能根据主键值进行更新，其它情况请使用foreach遍历更新。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$test</span> = <span class="keyword">new</span> <span class="title class_">Test</span>;</span><br><span class="line"><span class="variable">$list</span> = [</span><br><span class="line">    [<span class="string">&#x27;id&#x27;</span>=&gt;<span class="number">1</span>, <span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;thinkphp&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;id&#x27;</span>=&gt;<span class="number">2</span>, <span class="string">&#x27;name&#x27;</span>=&gt;<span class="string">&#x27;onethink&#x27;</span>]</span><br><span class="line">];</span><br><span class="line"><span class="variable">$test</span>-&gt;<span class="title function_ invoke__">saveAll</span>(<span class="variable">$list</span>);</span><br></pre></td></tr></table></figure><h3 id="静态方法更新"><a href="#静态方法更新" class="headerlink" title="静态方法更新"></a><strong>静态方法更新</strong></h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$data</span>=<span class="title class_">Test</span>::<span class="title function_ invoke__">where</span>(<span class="string">&#x27;id&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">    -&gt;<span class="title function_ invoke__">update</span>([<span class="string">&#x27;name&#x27;</span> =&gt; <span class="string">&#x27;thinkphp&#x27;</span>]);</span><br><span class="line"><span class="comment">//$data是受影响行数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者使用：</span></span><br><span class="line"><span class="variable">$data</span>=<span class="title class_">Test</span>::<span class="title function_ invoke__">update</span>([<span class="string">&#x27;id&#x27;</span> =&gt; <span class="number">1</span>, <span class="string">&#x27;name&#x27;</span> =&gt; <span class="string">&#x27;thinkphp&#x27;</span>]);</span><br><span class="line"><span class="comment">//$data返回结果集</span></span><br></pre></td></tr></table></figure><h2 id="5-删除（delete、destroy）"><a href="#5-删除（delete、destroy）" class="headerlink" title="5.删除（delete、destroy）"></a>5.删除（delete、destroy）</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//delete方法</span></span><br><span class="line"><span class="variable">$data</span> = <span class="title class_">Test</span>::<span class="title function_ invoke__">get</span>(<span class="number">5</span>);</span><br><span class="line"><span class="variable">$data</span>-&gt;<span class="title function_ invoke__">delete</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据主键删除</span></span><br><span class="line"><span class="comment">//或者直接调用静态方法</span></span><br><span class="line"><span class="title class_">User</span>::<span class="title function_ invoke__">destroy</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 支持批量删除多个数据</span></span><br><span class="line"><span class="title class_">User</span>::<span class="title function_ invoke__">destroy</span>(<span class="string">&#x27;1,2,3&#x27;</span>);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="title class_">User</span>::<span class="title function_ invoke__">destroy</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件删除</span></span><br><span class="line"><span class="comment">// 删除状态为0的数据</span></span><br><span class="line"><span class="title class_">User</span>::<span class="title function_ invoke__">destroy</span>([<span class="string">&#x27;status&#x27;</span> =&gt; <span class="number">0</span>]);</span><br><span class="line"><span class="comment">//或者通过数据库类的查询条件删除</span></span><br><span class="line"><span class="title class_">User</span>::<span class="title function_ invoke__">where</span>(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="number">10</span>)-&gt;<span class="title function_ invoke__">delete</span>();</span><br></pre></td></tr></table></figure><blockquote><p>V5.0.9+版本开始当destroy方法传入空值（包括空字符串和空数组）的时候不会做任何的数据删除操作，但传入0则是有效的</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thinkphp</title>
      <link href="/2024/03/13/thinkphp/"/>
      <url>/2024/03/13/thinkphp/</url>
      
        <content type="html"><![CDATA[<h2 id="Thinkphp5目录架构"><a href="#Thinkphp5目录架构" class="headerlink" title="Thinkphp5目录架构"></a>Thinkphp5目录架构</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">thinkphp  应用部署目录</span><br><span class="line">├─application           应用目录（可设置）</span><br><span class="line">│  ├─common             公共模块目录（可更改）</span><br><span class="line">│  ├─index              模块目录(可更改)</span><br><span class="line">│  │  ├─config.php      模块配置文件</span><br><span class="line">│  │  ├─common.php      模块函数文件</span><br><span class="line">│  │  ├─controller      控制器目录</span><br><span class="line">│  │  ├─model           模型目录</span><br><span class="line">│  │  ├─view            视图目录</span><br><span class="line">│  │  └─ ...            更多类库目录</span><br><span class="line">│  ├─command.php        命令行工具配置文件</span><br><span class="line">│  ├─common.php         应用公共（函数）文件</span><br><span class="line">│  ├─config.php         应用（公共）配置文件</span><br><span class="line">│  ├─database.php       数据库配置文件</span><br><span class="line">│  ├─tags.php           应用行为扩展定义文件</span><br><span class="line">│  └─route.php          路由配置文件</span><br><span class="line">├─extend                扩展类库目录（可定义）</span><br><span class="line">├─public                WEB 部署目录（对外访问目录）</span><br><span class="line">│  ├─static             静态资源存放目录(css,js,image)</span><br><span class="line">│  ├─index.php          应用入口文件</span><br><span class="line">│  ├─router.php         快速测试文件</span><br><span class="line">│  └─.htaccess          用于 apache 的重写</span><br><span class="line">├─runtime               应用的运行时目录（可写，可设置）</span><br><span class="line">├─vendor                第三方类库目录（Composer）</span><br><span class="line">├─thinkphp              框架系统目录</span><br><span class="line">│  ├─lang               语言包目录</span><br><span class="line">│  ├─library            框架核心类库目录</span><br><span class="line">│  │  ├─think           Think 类库包目录</span><br><span class="line">│  │  └─traits          系统 Traits 目录</span><br><span class="line">│  ├─tpl                系统模板目录</span><br><span class="line">│  ├─.htaccess          用于 apache 的重写</span><br><span class="line">│  ├─.travis.yml        CI 定义文件</span><br><span class="line">│  ├─base.php           基础定义文件</span><br><span class="line">│  ├─composer.json      composer 定义文件</span><br><span class="line">│  ├─console.php        控制台入口文件</span><br><span class="line">│  ├─convention.php     惯例配置文件</span><br><span class="line">│  ├─helper.php         助手函数文件（可选）</span><br><span class="line">│  ├─LICENSE.txt        授权说明文件</span><br><span class="line">│  ├─phpunit.xml        单元测试配置文件</span><br><span class="line">│  ├─README.md          README 文件</span><br><span class="line">│  └─start.php          框架引导文件</span><br><span class="line">├─build.php             自动生成定义文件（参考）</span><br><span class="line">├─composer.json         composer 定义文件</span><br><span class="line">├─LICENSE.txt           授权说明文件</span><br><span class="line">├─README.md             README 文件</span><br><span class="line">├─think                 命令行入口文件</span><br></pre></td></tr></table></figure><h2 id="命名空间规范"><a href="#命名空间规范" class="headerlink" title="命名空间规范"></a>命名空间规范</h2><p>应用类库的根命名空间统一为app(可以设置app_namespace配置参数更改)；<br>例如：app\index\controller\Index 和 app\index\model\User</p><h2 id="属性命名"><a href="#属性命名" class="headerlink" title="属性命名"></a>属性命名</h2><ul><li>类的命名采用驼峰法，并且首字母大写，例如User、UserType，默认不需要添加后缀，例如UserController应该直接命名为User;</li><li>在Thinkphp3中需要UserController等命名方式；</li><li>函数的命名使用小写和下划线（小写字母开头的方式），例如get_client_ip ;</li><li>方法的命名使用驼峰法，并且首字母小写，例如getUserName ;</li><li>属性的命名使用驼峰法，并且首字母小写，例如tableName 、 instance</li></ul><h2 id="变量类型方法"><a href="#变量类型方法" class="headerlink" title="变量类型方法"></a>变量类型方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>param</code></td><td>获取当前请求的变量</td></tr><tr><td><code>get</code></td><td>获取 $_GET 变量</td></tr><tr><td><code>post</code></td><td>获取 $_POST 变量</td></tr><tr><td><code>put</code></td><td>获取 $_PUT 变量</td></tr><tr><td><code>delete</code></td><td>获取 $_DELETE 变量</td></tr><tr><td><code>session</code></td><td>获取 $_SESSION 变量</td></tr><tr><td><code>cookie</code></td><td>获取 $_COOKIE 变量</td></tr><tr><td><code>request</code></td><td>获取 $_REQUEST 变量</td></tr><tr><td><code>server</code></td><td>获取 $_SERVER 变量</td></tr><tr><td><code>env</code></td><td>获取 $_ENV 变量</td></tr><tr><td><code>route</code></td><td>获取 路由（包括PATHINFO） 变量</td></tr><tr><td><code>file</code></td><td>获取 $_FILE 变量</td></tr></tbody></table><h2 id="获取PARAM参数"><a href="#获取PARAM参数" class="headerlink" title="获取PARAM参数"></a><strong>获取PARAM参数</strong></h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">input</span>(<span class="string">&#x27;param.name&#x27;</span>); <span class="comment">// 获取单个参数</span></span><br><span class="line"><span class="title function_ invoke__">input</span>(<span class="string">&#x27;param.&#x27;</span>); <span class="comment">// 获取全部参数</span></span><br><span class="line"><span class="comment">// 下面是等效的</span></span><br><span class="line"><span class="title function_ invoke__">input</span>(<span class="string">&#x27;name&#x27;</span>); </span><br><span class="line"><span class="title function_ invoke__">input</span>(<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="Thinkphp5目录架构-1"><a href="#Thinkphp5目录架构-1" class="headerlink" title="Thinkphp5目录架构#"></a>Thinkphp5目录架构<a href="https://www.cnblogs.com/nice0e3/p/15242077.html#thinkphp5%E7%9B%AE%E5%BD%95%E6%9E%B6%E6%9E%84">#</a></h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">thinkphp  应用部署目录</span><br><span class="line">├─application           应用目录（可设置）</span><br><span class="line">│  ├─common             公共模块目录（可更改）</span><br><span class="line">│  ├─index              模块目录(可更改)</span><br><span class="line">│  │  ├─config.php      模块配置文件</span><br><span class="line">│  │  ├─common.php      模块函数文件</span><br><span class="line">│  │  ├─controller      控制器目录</span><br><span class="line">│  │  ├─model           模型目录</span><br><span class="line">│  │  ├─view            视图目录</span><br><span class="line">│  │  └─ ...            更多类库目录</span><br><span class="line">│  ├─command.php        命令行工具配置文件</span><br><span class="line">│  ├─common.php         应用公共（函数）文件</span><br><span class="line">│  ├─config.php         应用（公共）配置文件</span><br><span class="line">│  ├─database.php       数据库配置文件</span><br><span class="line">│  ├─tags.php           应用行为扩展定义文件</span><br><span class="line">│  └─route.php          路由配置文件</span><br><span class="line">├─extend                扩展类库目录（可定义）</span><br><span class="line">├─<span class="keyword">public</span>                WEB 部署目录（对外访问目录）</span><br><span class="line">│  ├─<span class="built_in">static</span>             静态资源存放目录(css,js,image)</span><br><span class="line">│  ├─index.php          应用入口文件</span><br><span class="line">│  ├─router.php         快速测试文件</span><br><span class="line">│  └─.htaccess          用于 apache 的重写</span><br><span class="line">├─runtime               应用的运行时目录（可写，可设置）</span><br><span class="line">├─vendor                第三方类库目录（Composer）</span><br><span class="line">├─thinkphp              框架系统目录</span><br><span class="line">│  ├─lang               语言包目录</span><br><span class="line">│  ├─library            框架核心类库目录</span><br><span class="line">│  │  ├─think           Think 类库包目录</span><br><span class="line">│  │  └─traits          系统 Traits 目录</span><br><span class="line">│  ├─tpl                系统模板目录</span><br><span class="line">│  ├─.htaccess          用于 apache 的重写</span><br><span class="line">│  ├─.travis.yml        CI 定义文件</span><br><span class="line">│  ├─base.php           基础定义文件</span><br><span class="line">│  ├─composer.json      composer 定义文件</span><br><span class="line">│  ├─console.php        控制台入口文件</span><br><span class="line">│  ├─convention.php     惯例配置文件</span><br><span class="line">│  ├─helper.php         助手函数文件（可选）</span><br><span class="line">│  ├─LICENSE.txt        授权说明文件</span><br><span class="line">│  ├─phpunit.xml        单元测试配置文件</span><br><span class="line">│  ├─README.md          README 文件</span><br><span class="line">│  └─start.php          框架引导文件</span><br><span class="line">├─build.php             自动生成定义文件（参考）</span><br><span class="line">├─composer.json         composer 定义文件</span><br><span class="line">├─LICENSE.txt           授权说明文件</span><br><span class="line">├─README.md             README 文件</span><br><span class="line">├─think                 命令行入口文件</span><br></pre></td></tr></table></figure><h2 id="规范"><a href="#规范" class="headerlink" title="规范#"></a>规范<a href="https://www.cnblogs.com/nice0e3/p/15242077.html#%E8%A7%84%E8%8C%83">#</a></h2><p> ThinkPHP5.0的URl访问受路由决定，如果关闭路由或者没有匹配路由的情况下，则是基于：</p><p> <code>http://serverName/index.php</code>(或者其他应用入口文件，可省略) &#x2F;模块&#x2F; 控制器&#x2F;操作 &#x2F; 参数 &#x2F;值</p><p> 在Thinkphp5.0框架中，在url地址栏里面如果不写模块、控制器和操作名，默认访问的就是index模块下面的index控制器下面的index操作，可以在config.php文件中进行修改。</p><h2 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件#"></a>入口文件<a href="https://www.cnblogs.com/nice0e3/p/15242077.html#%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6">#</a></h2><p> 用户请求的PHP文件，负责处理一个请求（注意，不一定是URL请求）的生命周期，最常见的入口文件就是index.php, 有时候也会为了某些特殊的需求而增加新的入口文件，例如给后台模块单独设置的一个入口文件admin.php或者一个控制器程序入口think都属于入口文件。</p><h3 id="命名空间规范-1"><a href="#命名空间规范-1" class="headerlink" title="命名空间规范#"></a>命名空间规范<a href="https://www.cnblogs.com/nice0e3/p/15242077.html#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E8%A7%84%E8%8C%83">#</a></h3><p>应用类库的根命名空间统一为app(可以设置app_namespace配置参数更改)；<br>例如：app\index\controller\Index 和 app\index\model\User;</p><h3 id="属性命名-1"><a href="#属性命名-1" class="headerlink" title="属性命名#"></a>属性命名<a href="https://www.cnblogs.com/nice0e3/p/15242077.html#%E5%B1%9E%E6%80%A7%E5%91%BD%E5%90%8D">#</a></h3><ul><li>类的命名采用驼峰法，并且首字母大写，例如User、UserType，默认不需要添加后缀，例如UserController应该直接命名为User;</li><li>在Thinkphp3中需要UserController等命名方式；</li><li>函数的命名使用小写和下划线（小写字母开头的方式），例如get_client_ip ;</li><li>方法的命名使用驼峰法，并且首字母小写，例如getUserName ;</li><li>属性的命名使用驼峰法，并且首字母小写，例如tableName 、 instance;</li></ul><h3 id="应用类库命名空间规范"><a href="#应用类库命名空间规范" class="headerlink" title="应用类库命名空间规范#"></a>应用类库命名空间规范<a href="https://www.cnblogs.com/nice0e3/p/15242077.html#%E5%BA%94%E7%94%A8%E7%B1%BB%E5%BA%93%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E8%A7%84%E8%8C%83">#</a></h3><p>应用类库的根命名空间统一为app(可以设置app_namespace配置参数更改)；<br>例如：app\index\controller\Index 和 app\index\model\User;</p><h2 id="请求"><a href="#请求" class="headerlink" title="请求#"></a>请求<a href="https://www.cnblogs.com/nice0e3/p/15242077.html#%E8%AF%B7%E6%B1%82">#</a></h2><h3 id="Thinkphp助手参数"><a href="#Thinkphp助手参数" class="headerlink" title="Thinkphp助手参数#"></a>Thinkphp助手参数<a href="https://www.cnblogs.com/nice0e3/p/15242077.html#thinkphp%E5%8A%A9%E6%89%8B%E5%8F%82%E6%95%B0">#</a></h3><h3 id="判断变量是否定义"><a href="#判断变量是否定义" class="headerlink" title="判断变量是否定义"></a><strong>判断变量是否定义</strong></h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">input</span>(<span class="string">&#x27;?get.id&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">input</span>(<span class="string">&#x27;?post.name&#x27;</span>);</span><br></pre></td></tr></table></figure><p>变量类型方法:</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>param</code></td><td>获取当前请求的变量</td></tr><tr><td><code>get</code></td><td>获取 $_GET 变量</td></tr><tr><td><code>post</code></td><td>获取 $_POST 变量</td></tr><tr><td><code>put</code></td><td>获取 $_PUT 变量</td></tr><tr><td><code>delete</code></td><td>获取 $_DELETE 变量</td></tr><tr><td><code>session</code></td><td>获取 $_SESSION 变量</td></tr><tr><td><code>cookie</code></td><td>获取 $_COOKIE 变量</td></tr><tr><td><code>request</code></td><td>获取 $_REQUEST 变量</td></tr><tr><td><code>server</code></td><td>获取 $_SERVER 变量</td></tr><tr><td><code>env</code></td><td>获取 $_ENV 变量</td></tr><tr><td><code>route</code></td><td>获取 路由（包括PATHINFO） 变量</td></tr><tr><td><code>file</code></td><td>获取 $_FILE 变量</td></tr></tbody></table><h3 id="获取PARAM参数-1"><a href="#获取PARAM参数-1" class="headerlink" title="获取PARAM参数"></a><strong>获取PARAM参数</strong></h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">input</span>(<span class="string">&#x27;param.name&#x27;</span>); <span class="comment">// 获取单个参数</span></span><br><span class="line"><span class="title function_ invoke__">input</span>(<span class="string">&#x27;param.&#x27;</span>); <span class="comment">// 获取全部参数</span></span><br><span class="line"><span class="comment">// 下面是等效的</span></span><br><span class="line"><span class="title function_ invoke__">input</span>(<span class="string">&#x27;name&#x27;</span>); </span><br><span class="line"><span class="title function_ invoke__">input</span>(<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="获取GET参数"><a href="#获取GET参数" class="headerlink" title="获取GET参数"></a><strong>获取GET参数</strong></h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取单个变量</span></span><br><span class="line"><span class="title function_ invoke__">input</span>(<span class="string">&#x27;get.id&#x27;</span>);</span><br><span class="line"><span class="comment">// 使用过滤方法获取 默认为空字符串</span></span><br><span class="line"><span class="title function_ invoke__">input</span>(<span class="string">&#x27;get.name&#x27;</span>);</span><br><span class="line"><span class="comment">// 获取全部变量</span></span><br><span class="line"><span class="title function_ invoke__">input</span>(<span class="string">&#x27;get.&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="使用过滤方法"><a href="#使用过滤方法" class="headerlink" title="使用过滤方法"></a><strong>使用过滤方法</strong></h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">input</span>(<span class="string">&#x27;get.name&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;htmlspecialchars&#x27;</span>); <span class="comment">// 获取get变量 并用htmlspecialchars函数过滤</span></span><br><span class="line"><span class="title function_ invoke__">input</span>(<span class="string">&#x27;username&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;strip_tags&#x27;</span>); <span class="comment">// 获取param变量 并用strip_tags函数过滤</span></span><br><span class="line"><span class="title function_ invoke__">input</span>(<span class="string">&#x27;post.name&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;org\Filter::safeHtml&#x27;</span>); <span class="comment">// 获取post变量 并用org\Filter类的safeHtml方法过滤</span></span><br></pre></td></tr></table></figure><h3 id="使用变量修饰符"><a href="#使用变量修饰符" class="headerlink" title="使用变量修饰符"></a><strong>使用变量修饰符</strong></h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">input</span>(<span class="string">&#x27;get.id/d&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">input</span>(<span class="string">&#x27;post.name/s&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">input</span>(<span class="string">&#x27;post.ids/a&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><table><thead><tr><th>修饰符</th><th>作用</th></tr></thead><tbody><tr><td><code>s</code></td><td>强制转换为字符串类型</td></tr><tr><td><code>d</code></td><td>强制转换为整形类型</td></tr><tr><td><code>b</code></td><td>强制转换为布尔类型</td></tr><tr><td><code>a</code></td><td>强制转换为数组类型</td></tr><tr><td><code>f</code></td><td>强制转换为浮点类型</td></tr></tbody></table><h3 id="请求-1"><a href="#请求-1" class="headerlink" title="请求"></a>请求</h3><p>Request对象的主要职责是统一和更安全地获取当前的请求信息，你需要避免直接操作</p><p><code>$_GET、$_POST、$_REQUEST、$_SESSION、$_COOKIE、$_FILES等全局变量，</code></p><p><code>而是统一使用Request对象提供的方法来获取请求变量。</code></p><p>ThinkPHP5的Request对象由think\Request类完成。</p><p>$request &#x3D; Request::instance();</p><p> 也可以使用助手函数</p><p><code>$request = request()</code>;</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`<span class="variable">$request</span> = <span class="title class_">Request</span>::<span class="title function_ invoke__">instance</span>();`</span><br><span class="line"><span class="comment">// 获取当前域名</span></span><br><span class="line">`<span class="keyword">echo</span> <span class="string">&#x27;domain: &#x27;</span> . <span class="variable">$request</span>-&gt;<span class="title function_ invoke__">domain</span>() . <span class="string">&#x27;&lt;br/&gt;&#x27;</span>;`</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>方法</strong></th><th>描述</th></tr></thead><tbody><tr><td>param</td><td>获取当前请求的变量（自动识别GET、POST、PUT请求的一种变量获取方式，是系统推荐的获取请求参数方法）</td></tr><tr><td>get</td><td>获取<code>$_GET</code>变量</td></tr><tr><td>post</td><td>获取<code>$_POST</code>变量</td></tr><tr><td>put</td><td>获取<code>PUT</code>变量</td></tr><tr><td>delete</td><td>获取<code>DELETE</code>变量</td></tr><tr><td>session</td><td>获取<code>$_SESSION</code>变量</td></tr><tr><td>cookie</td><td>获取<code>$_COOKIE</code>变量</td></tr><tr><td>request</td><td>获取<code>$_REQUEST</code>变量</td></tr><tr><td>server</td><td>获取<code>$_SERVER</code>变量</td></tr><tr><td>env</td><td>获取<code>$_ENV</code>变量</td></tr><tr><td>file</td><td>获取<code>$_FILES</code>变量</td></tr></tbody></table><h2 id="改变变量"><a href="#改变变量" class="headerlink" title="改变变量"></a>改变变量</h2><p> 如果需要更改请求变量的值，可以通过下面的方式：</p><h3 id="更改GET变量"><a href="#更改GET变量" class="headerlink" title="更改GET变量"></a>更改GET变量</h3><p> <code>Request::instance()-&gt;get([&#39;id&#39;=&gt;10]);</code></p><h3 id="更改POST变量"><a href="#更改POST变量" class="headerlink" title="更改POST变量"></a>更改POST变量</h3><p> <code>Request::instance()-&gt;post([&#39;name&#39;=&gt;&#39;thinkphp&#39;]);</code></p><p> 尽量避免直接修改<code>$_GET</code>或者<code>$_POST</code> 数据,同时也不能直接修改param变量，例如下面的操作是无效的。</p><h3 id="更改请求变量"><a href="#更改请求变量" class="headerlink" title="更改请求变量"></a>更改请求变量</h3><p> <code>Request::instance()-&gt;param([&#39;id&#39;=&gt;10]);</code></p><h3 id="伪静态"><a href="#伪静态" class="headerlink" title="伪静态"></a>伪静态</h3><p> URL伪静态通常是为了满足更好的SEO效果，ThinkPHP支持伪静态URL设置，可以通过设置url_html_suffix参数随意在URL的最后增加你想要的静态后缀，而不影响当前操作的正常执行。例如，我们设置</p><p> <code>&#39;url_html_suffix&#39;=&gt;&#39;shtml&#39;</code></p><p>如果要获取当前的伪静态后缀，可以使用Request对象的ext方法。</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>路由功能由<code>\think\Route</code>类完成。</p><p>由于<code>ThinkPHP5.0默认采用的URL规则是：</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://server/module/controller/action/param/value/.....</span><br></pre></td></tr></table></figure><p>路由的作用是简化URL访问地址，并根据定义的路由类型做出正确的解析。</p><h3 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h3><p><code>ThinkPHP5.0</code>的路由比较灵活，并且不需要强制定义，可以总结归纳为如下三种方式：</p><h4 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h4><p>关闭路由，完全使用默认的<code>PATH_INFO</code>方式URL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url_route_on =&gt; false,</span><br></pre></td></tr></table></figure><p>路由关闭后，不会解析任何路由规则，采用默认的<code>PATH_INFO</code>模式访问URL:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://serverName/index.php/module/controller/action/param/value/...</span><br></pre></td></tr></table></figure><h4 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h4><p>开启路由，并使用路由定义+默认<code>PATH_INFO</code>方式的混合:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;url_route_on&#x27; =&gt; true,</span><br><span class="line">&#x27;url_route_must&#x27; =&gt; false,</span><br></pre></td></tr></table></figure><p>该方式下面，只需要对需要定义路由规则的访问地址定义路由规则，其他的仍然按照第一种普通模式的<code>PATH_INFO</code>模式访问URL。</p><h4 id="强制模式"><a href="#强制模式" class="headerlink" title="强制模式"></a>强制模式</h4><p>开启路由，并设置必须定义路由才能访问：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url_route_on =&gt; true,</span><br><span class="line">url_route_must =&gt; true,</span><br></pre></td></tr></table></figure><p>这种方式下面必须严格给每一个访问地址定义路由规则（包括首页），否则将抛出异常。</p><p>首页的路由规则采用<code>/</code>定义即可，例如下面把网站首页路由输出<code>Hello,world!</code>我们需要在<code>route.php</code>这个文件中配置路由，要使用官方的 <code>use think\Route</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Route</span>::<span class="title function_ invoke__">get</span>(<span class="string">&#x27;/&#x27;</span>,function()&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;Hello,world!&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="路由定义"><a href="#路由定义" class="headerlink" title="路由定义"></a>路由定义</h2><p>路由注册可以采用方法动态单个和批量注册，也可以直接定义路由定义文件的方式进行集中注册。</p><h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><p>路由定义采用<code>\think\Route</code>类的rule方法注册，通常是在应用的路由配置文件</p><p><code>application/route.php</code>进行注册，格式是：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Route</span>::<span class="title function_ invoke__">rule</span>(<span class="string">&#x27;路由表达式&#x27;</span>，<span class="string">&#x27;路由地址&#x27;</span>，<span class="string">&#x27;请求类型&#x27;</span>，<span class="string">&#x27;路由参数（数组）&#x27;</span>，<span class="string">&#x27;变量规则（数组）&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">Route</span>;</span><br><span class="line"><span class="comment">// 注册路由到index模块的Index控制器的list操作</span></span><br><span class="line"><span class="title class_">Route</span>::<span class="title function_ invoke__">rule</span>(<span class="string">&#x27;new/:id&#x27;</span>,<span class="string">&#x27;index/Index/list&#x27;</span>);</span><br><span class="line"><span class="comment">//表示定义的路由规则在POST请求下才有效。注意：请求类型参数必须大写。</span></span><br><span class="line"><span class="title class_">Route</span>::<span class="title function_ invoke__">rule</span>(<span class="string">&#x27;new/:id&#x27;</span>,<span class="string">&#x27;News/update&#x27;</span>,<span class="string">&#x27;POST&#x27;</span>); </span><br></pre></td></tr></table></figure><table><thead><tr><th>请求类型包括：</th><th>类型</th></tr></thead><tbody><tr><td>GET</td><td>GET请求</td></tr><tr><td>POST</td><td>POST请求</td></tr><tr><td>PUT</td><td>PUT请求</td></tr><tr><td>DELETE</td><td>DELETE请求</td></tr><tr><td>*</td><td>任何请求类型</td></tr></tbody></table><h3 id="系统提供了为不同的请求类型定义路由规则的简化方法，例如："><a href="#系统提供了为不同的请求类型定义路由规则的简化方法，例如：" class="headerlink" title="系统提供了为不同的请求类型定义路由规则的简化方法，例如："></a>系统提供了为不同的请求类型定义路由规则的简化方法，例如：</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Route</span>::<span class="title function_ invoke__">get</span>(<span class="string">&#x27;new/:id&#x27;</span>,<span class="string">&#x27;News/read&#x27;</span>); <span class="comment">// 定义GET请求路由规则</span></span><br><span class="line"><span class="title class_">Route</span>::<span class="title function_ invoke__">post</span>(<span class="string">&#x27;new/:id&#x27;</span>,<span class="string">&#x27;News/update&#x27;</span>); <span class="comment">// 定义POST请求路由规则</span></span><br><span class="line"><span class="title class_">Route</span>::<span class="title function_ invoke__">put</span>(<span class="string">&#x27;new/:id&#x27;</span>,<span class="string">&#x27;News/update&#x27;</span>); <span class="comment">// 定义PUT请求路由规则</span></span><br><span class="line"><span class="title class_">Route</span>::<span class="title function_ invoke__">delete</span>(<span class="string">&#x27;new/:id&#x27;</span>,<span class="string">&#x27;News/delete&#x27;</span>); <span class="comment">// 定义DELETE请求路由规则</span></span><br><span class="line"><span class="title class_">Route</span>::<span class="title function_ invoke__">any</span>(<span class="string">&#x27;new/:id&#x27;</span>,<span class="string">&#x27;News/read&#x27;</span>); <span class="comment">// 所有请求都支持的路由规则</span></span><br></pre></td></tr></table></figure><h3 id="如果要定义get和post请求支持的路由规则，也可以用："><a href="#如果要定义get和post请求支持的路由规则，也可以用：" class="headerlink" title="如果要定义get和post请求支持的路由规则，也可以用："></a>如果要定义get和post请求支持的路由规则，也可以用：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Route::rule(&#x27;new/:id&#x27;,&#x27;News/read&#x27;,&#x27;GET|POST&#x27;);</span><br></pre></td></tr></table></figure><h3 id="也可以批量注册路由规则"><a href="#也可以批量注册路由规则" class="headerlink" title="也可以批量注册路由规则"></a>也可以批量注册路由规则</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Route</span>::<span class="title function_ invoke__">rule</span>([<span class="string">&#x27;new/:id&#x27;</span>=&gt;<span class="string">&#x27;News/read&#x27;</span>,<span class="string">&#x27;blog/:name&#x27;</span>=&gt;<span class="string">&#x27;Blog/detail&#x27;</span>]);</span><br><span class="line"><span class="title class_">Route</span>::<span class="title function_ invoke__">get</span>([<span class="string">&#x27;new/:id&#x27;</span>=&gt;<span class="string">&#x27;News/read&#x27;</span>,<span class="string">&#x27;blog/:name&#x27;</span>=&gt;<span class="string">&#x27;Blog/detail&#x27;</span>]);</span><br><span class="line"><span class="title class_">Route</span>::<span class="title function_ invoke__">post</span>([<span class="string">&#x27;new/:id&#x27;</span>=&gt;<span class="string">&#x27;News/update&#x27;</span>,<span class="string">&#x27;blog/:name&#x27;</span>=&gt;<span class="string">&#x27;Blog/detail&#x27;</span>]);</span><br></pre></td></tr></table></figure><h4 id="注册多个路由规则后，系统会依次遍历注册过的满足请求类型的路由规则，一旦匹配到正确的路由规则后则开始调用控制器的操作方法，后续规则就不再检测。"><a href="#注册多个路由规则后，系统会依次遍历注册过的满足请求类型的路由规则，一旦匹配到正确的路由规则后则开始调用控制器的操作方法，后续规则就不再检测。" class="headerlink" title="注册多个路由规则后，系统会依次遍历注册过的满足请求类型的路由规则，一旦匹配到正确的路由规则后则开始调用控制器的操作方法，后续规则就不再检测。"></a>注册多个路由规则后，系统会依次遍历注册过的满足请求类型的路由规则，一旦匹配到正确的路由规则后则开始调用控制器的操作方法，后续规则就不再检测。</h4><h1 id="定义路由配置文件"><a href="#定义路由配置文件" class="headerlink" title="定义路由配置文件"></a>定义路由配置文件</h1><p>除了支持动态注册，也可以直接在应用目录下面的route.php的最后通过返回数组的方式直接定义路由规则</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="string">&#x27;new/:id&#x27;</span> =&gt; <span class="string">&#x27;News/read&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;blog/:id&#x27;</span> =&gt; [<span class="string">&#x27;Blog/update&#x27;</span>,[<span class="string">&#x27;method&#x27;</span> =&gt; <span class="string">&#x27;post|put&#x27;</span>], [<span class="string">&#x27;id&#x27;</span> =&gt; <span class="string">&#x27;\d+&#x27;</span>]],</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>路由动态注册和配置定义的方式可以并存。由于检测机制问题，动态注册的性能比路由配置要高一些，尤其是多种请求类型混合定义的时候。</p><p>默认情况下，只会加载一个路由配置文件<code>route.php</code>，如果需要定义多个路由文件，可以修改<code>route_config_file</code>的配置参数，例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定义路由配置文件（数组）</span><br><span class="line"><span class="string">&#x27;route_config_file&#x27;</span> =&gt; [<span class="string">&#x27;route&#x27;</span>, <span class="string">&#x27;route1&#x27;</span>, <span class="string">&#x27;route2&#x27;</span>],</span><br></pre></td></tr></table></figure><h1 id="资源路由"><a href="#资源路由" class="headerlink" title="资源路由"></a>资源路由</h1><p>5.0支持设置<code>RESTFul</code>请求的资源路由，方式如下：</p><p>Route::resource(‘blog’,’index&#x2F;blog’);</p><p>或者在路由配置文件中使用<code>__rest__</code>添加资源路由定义：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="comment">// 定义资源路由</span></span><br><span class="line">    <span class="string">&#x27;__rest__&#x27;</span>=&gt;[</span><br><span class="line">    <span class="comment">// 指向index模块的blog控制器</span></span><br><span class="line">    <span class="string">&#x27;blog&#x27;</span>=&gt;<span class="string">&#x27;index/blog&#x27;</span>,</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>设置过后会自动注册7个路由规则，如下：</p><table><thead><tr><th>标识</th><th>请求类型</th><th>生成路由规则</th><th>对应操作方法（默认）</th></tr></thead><tbody><tr><td>index</td><td>GET</td><td><code>blog</code></td><td>index</td></tr><tr><td>create</td><td>GET</td><td><code>blog/create</code></td><td>create</td></tr><tr><td>save</td><td>POST</td><td><code>blog</code></td><td>save</td></tr><tr><td>read</td><td>GET</td><td><code>blog/:id</code></td><td>read</td></tr><tr><td>edit</td><td>GET</td><td><code>blog/:id/edit</code></td><td>edit</td></tr><tr><td>update</td><td>PUT</td><td><code>blog/:id</code></td><td>update</td></tr><tr><td>delete</td><td>DELETE</td><td><code>blog/:id</code></td><td>delete</td></tr></tbody></table><p>具体指向的控制器由路由地址决定，例如上面的设置，会对应index模块的blog控制器，你只需要为Blog控制器创建以上对应的操作方法就可以支持下面的URL访问：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://serverName/blog/</span><br><span class="line">http://serverName/blog/128</span><br><span class="line">http://serverName/blog/28/edit</span><br></pre></td></tr></table></figure><p>Blog控制器中对应的方法如下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">app</span>\<span class="title class_">index</span>\<span class="title class_">controller</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blog</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">dump</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"><span class="variable">$id</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">dump</span>(update);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">delete</span>(<span class="params"><span class="variable">$id</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">dump</span>(delete);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快捷路由"><a href="#快捷路由" class="headerlink" title="快捷路由"></a>快捷路由</h1><p>快捷路由允许你快速给控制器注册路由，并且针对不同的请求类型可以设置方法前缀</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给User控制器设置快捷路由</span></span><br><span class="line"><span class="title class_">Route</span>::<span class="title function_ invoke__">controller</span>(<span class="string">&#x27;user&#x27;</span>,<span class="string">&#x27;index/User&#x27;</span>);</span><br></pre></td></tr></table></figure><p>User控制器定义如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">app</span>\<span class="title class_">index</span>\<span class="title class_">controller</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getPhone</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">postInfo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">putInfo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">deleteInfo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过下面的URL访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">get http://localhost/user/info</span><br><span class="line">get http://localhost/user/phone</span><br><span class="line">post http://localhost/user/info</span><br><span class="line">put http://localhost/user/info</span><br><span class="line">delete http://localhost/user/info</span><br></pre></td></tr></table></figure><h1 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h1><p>Base.php，需要鉴权继承该类即可</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">app</span>\<span class="title class_">index</span>\<span class="title class_">controller</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">Controller</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">Request</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> <span class="keyword">extends</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">//用来存放需要用户登录之后才能操作的方法的集合</span></span><br><span class="line"><span class="keyword">protected</span> <span class="variable">$is_check_login</span> = [<span class="string">&#x27;&#x27;</span>];</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">_initialize</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">isLogin</span>() &amp;&amp; (<span class="title function_ invoke__">in_array</span>(<span class="title class_">Request</span>::<span class="title function_ invoke__">instance</span>()-&gt;<span class="title function_ invoke__">action</span>(), <span class="variable">$this</span>-&gt;is_check_login)||<span class="variable language_">$this</span>-&gt;is_check_login[<span class="number">0</span>]==<span class="string">&#x27;*&#x27;</span>))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">error</span>(<span class="string">&#x27;请先登录系统！&#x27;</span>,<span class="string">&#x27;index/Index/login&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isLogin</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_ invoke__">session</span>(<span class="string">&#x27;?name&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GoodsController,进行所有方法鉴权</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">app</span>\<span class="title class_">index</span>\<span class="title class_">controller</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">app</span>\<span class="title">index</span>\<span class="title">controller</span>\<span class="title">Base</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">extends</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="variable">$is_check_login</span> = [<span class="string">&#x27;*&#x27;</span>];</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;我想要购买商品&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">edit</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;我想退货&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">delete</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;我不想买了&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>CommentController,仅对Add方法路由鉴权</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">app</span>\<span class="title class_">index</span>\<span class="title class_">controller</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">app</span>\<span class="title">index</span>\<span class="title">controller</span>\<span class="title">Base</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comment</span> <span class="keyword">extends</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="variable">$is_check_login</span> = [<span class="string">&#x27;add&#x27;</span>];</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;我想发表评论&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">edit</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;我想编辑一下自己的评论&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据库的操作"><a href="#数据库的操作" class="headerlink" title="数据库的操作"></a>数据库的操作</h1><p>ThinkPHP内置了抽象数据库访问层，把不同的数据库操作封装起来，我们只需要使用公共的Db类进行操作，而无需针对不同的数据库写不同的代码和底层实现，Db类会自动调用相应的数据库驱动来处理。采用PDO方式，目前包含了Mysql、SqlServer、PgSQL、Sqlite等数据库的支持。</p><h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h2><p>配置了数据库连接信息后，我们就可以直接使用数据库运行原生SQL操作了，支持<code>query</code>（查询操作）和<code>execute</code>（写入操作）方法，并且支持参数绑定。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$sql</span> = <span class="title class_">Db</span>::<span class="title function_ invoke__">query</span>(<span class="string">&#x27;select * from news&#x27;</span>);</span><br><span class="line">    <span class="title function_ invoke__">dump</span>(<span class="variable">$sql</span>);   </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>execute方法：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$sql</span> = <span class="title class_">Db</span>::<span class="title function_ invoke__">execute</span>(<span class="string">&#x27;insert into news (nid, rid) values (11, 11)&#x27;</span>);;</span><br><span class="line">    <span class="title function_ invoke__">dump</span>(<span class="variable">$sql</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也支持<strong>命名占位符</strong>绑定，例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$sql</span> = <span class="title class_">Db</span>::<span class="title function_ invoke__">query</span>(<span class="string">&#x27;select * from news where nid=:nid&#x27;</span>,[<span class="string">&#x27;nid&#x27;</span>=&gt;<span class="number">1</span>]);</span><br><span class="line">    <span class="title function_ invoke__">dump</span>(<span class="variable">$sql</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>execute方法：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$sql</span> = <span class="title class_">Db</span>::<span class="title function_ invoke__">execute</span>(<span class="string">&#x27;insert into news (nid, rid) values (:nid, :rid)&#x27;</span>,[<span class="string">&#x27;nid&#x27;</span>=&gt;<span class="number">18</span>,<span class="string">&#x27;rid&#x27;</span>=&gt;<span class="string">&#x27;121&#x27;</span>]);</span><br><span class="line">    <span class="title function_ invoke__">dump</span>(<span class="variable">$sql</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用多个数据库连接:</p><h2 id="2-查询构造器"><a href="#2-查询构造器" class="headerlink" title="2.查询构造器"></a>2.查询构造器</h2><p>听名字就知道，很装X..</p><p>先来看<strong>基本查询</strong>；</p><p>查询一个数据：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// table方法必须指定完整的数据表名</span></span><br><span class="line">   <span class="variable">$sql</span> =<span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;news&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;nid&#x27;</span>,<span class="number">1</span>)-&gt;<span class="title function_ invoke__">find</span>();</span><br><span class="line">   <span class="title function_ invoke__">dump</span>(<span class="variable">$sql</span>);</span><br></pre></td></tr></table></figure><p>find &#x3D; 查询一条；并且查询结果不存在，返回 null</p><p>输出：<img src="https://images2015.cnblogs.com/blog/1064450/201706/1064450-20170621140116913-1075525658.png" alt="img"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;think_user&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;status&#x27;</span>,<span class="number">1</span>)-&gt;<span class="title function_ invoke__">select</span>();</span><br></pre></td></tr></table></figure><p>这条查询语句与上面同效，但是select 方法查询结果不存在，返回空数组</p><p>额 这个玩意叫查询数据集，没错！</p><p>默认情况下，find和select方法返回的都是数组。</p><p>如果你要<strong>查询某个字段</strong>的值，咋整？</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 返回某个字段的值</span></span><br><span class="line">    <span class="variable">$sql</span> =<span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;news&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;nid&#x27;</span>,<span class="number">18</span>)-&gt;<span class="title function_ invoke__">value</span>(<span class="string">&#x27;rid&#x27;</span>);</span><br><span class="line">    <span class="title function_ invoke__">dump</span>(<span class="variable">$sql</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样看输出，我求rid的值：</p><p><img src="https://images2015.cnblogs.com/blog/1064450/201706/1064450-20170621140824570-825868735.png" alt="img"></p><p>如果你需要处理成千上百条数据库记录，可以考虑使用<strong>chunk方法</strong>，该方法一次获取结果集的一小块，然后填充每一小块数据到要处理的闭包，该方法在编写处理大量数据库记录的时候非常有用。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$sql</span> =<span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;news&#x27;</span>)-&gt;<span class="title function_ invoke__">chunk</span>(<span class="number">1</span>,function(<span class="variable">$user</span>)&#123;</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="variable">$user</span> <span class="keyword">as</span> <span class="variable">$u</span>)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$u</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个样子  就可以一条一条都给遍历出来了！</p><p>是“一条一条·”，嘿！</p><h2 id="3-添加数据跟删除数据"><a href="#3-添加数据跟删除数据" class="headerlink" title="3.添加数据跟删除数据"></a>3.添加数据跟删除数据</h2><p><strong>使用 <code>Db</code> 类的 <code>insert</code> 方法向数据库提交数据</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable">$data</span> = [<span class="string">&#x27;ntitle&#x27;</span> =&gt; <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;rid&#x27;</span> =&gt; <span class="string">&#x27;456&#x27;</span>];</span><br><span class="line"><span class="variable">$sql</span> = <span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;news&#x27;</span>)-&gt;<span class="title function_ invoke__">insert</span>(<span class="variable">$data</span>);</span><br><span class="line">    </span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$sql</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加成功后insert 方法返回添加成功的条数，insert 正常情况返回 1</p><p>添加数据后如果需要返回新增数据的自增主键，可以使用<code>getLastInsID</code>方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable">$data</span> = [<span class="string">&#x27;ntitle&#x27;</span> =&gt; <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;rid&#x27;</span> =&gt; <span class="string">&#x27;345&#x27;</span>];</span><br><span class="line"><span class="variable">$sql</span> = <span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;news&#x27;</span>)-&gt;<span class="title function_ invoke__">insert</span>(<span class="variable">$data</span>);</span><br><span class="line"><span class="variable">$userId</span> = <span class="title class_">Db</span>::<span class="title function_ invoke__">name</span>(<span class="string">&#x27;news&#x27;</span>)-&gt;<span class="title function_ invoke__">getLastInsID</span>(<span class="string">&#x27;nid&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$userId</span>);</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$sql</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>添加多条数据:</strong></p><p>添加多条数据直接向 Db 类的 insertAll 方法传入需要添加的数据即可;</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable">$data</span> = [</span><br><span class="line">[<span class="string">&#x27;ntitle&#x27;</span> =&gt;<span class="string">&#x27;gaga&#x27;</span>,<span class="string">&#x27;rid&#x27;</span> =&gt; <span class="string">&#x27;12&#x27;</span>],</span><br><span class="line">[<span class="string">&#x27;ntitle&#x27;</span> =&gt;<span class="string">&#x27;gaaaga&#x27;</span>,<span class="string">&#x27;rid&#x27;</span> =&gt; <span class="string">&#x27;123&#x27;</span>]</span><br><span class="line">];</span><br><span class="line"><span class="variable">$sql</span> = <span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;news&#x27;</span>)-&gt;<span class="title function_ invoke__">insertAll</span>(<span class="variable">$data</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$sql</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，返回的应该是两条2</p><p>删除数据：</p><p>根据主键来删除</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    根据主键 来删</span></span><br><span class="line"><span class="variable">$sql</span> = <span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;news&#x27;</span>)-&gt;<span class="title function_ invoke__">delete</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//多删</span></span><br><span class="line"><span class="comment">//$sql = Db::table(&#x27;news&#x27;)-&gt;delete(1,2,3);</span></span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$sql</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行成功返回影响行数；</p><p>还有一种是根据<strong>条件来删除</strong>的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    根据条件 来删</span></span><br><span class="line"><span class="variable">$sql</span> = <span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;news&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;nid&#x27;</span>,<span class="number">18</span>)-&gt;<span class="title function_ invoke__">delete</span>();</span><br><span class="line"><span class="comment">//多删</span></span><br><span class="line"><span class="comment">//$sql = Db::table(&#x27;news&#x27;)-&gt;where(&#x27;nid&#x27;,&#x27;&lt;&#x27;,1)-&gt;delete();</span></span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$sql</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行成功也是返回影响行数；</p><h2 id="4-查询方法："><a href="#4-查询方法：" class="headerlink" title="4.查询方法："></a>4.查询方法：</h2><p><strong>where方法：</strong></p><p>可以使用<code>where</code>方法进行<code>AND</code>条件查询：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable">$sql</span> = <span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;news&#x27;</span>)</span><br><span class="line">-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;nid&#x27;</span>,<span class="number">20</span>)</span><br><span class="line">-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;ntitle&#x27;</span>,<span class="number">123</span>)</span><br><span class="line">-&gt;<span class="title function_ invoke__">find</span>();</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$sql</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>whereOr方法：</strong></p><p>使用<code>whereOr</code>方法进行<code>OR</code>查询：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable">$sql</span> = <span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;news&#x27;</span>)</span><br><span class="line">-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;nid&#x27;</span>,<span class="number">20</span>)</span><br><span class="line">-&gt;<span class="title function_ invoke__">whereOr</span>(<span class="string">&#x27;ntitle&#x27;</span>,<span class="string">&#x27;like&#x27;</span>,<span class="string">&#x27;%123%&#x27;</span>)</span><br><span class="line">-&gt;<span class="title function_ invoke__">find</span>();</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$sql</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>混合查询：</strong></p><p>where方法和whereOr方法在复杂的查询条件中经常需要配合一起混合使用</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable">$sql</span> = <span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;news&#x27;</span>)</span><br><span class="line">-&gt;<span class="title function_ invoke__">where</span>(function(<span class="variable">$query</span>)&#123;</span><br><span class="line">    <span class="variable">$query</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;nid&#x27;</span>,<span class="number">21</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;nid&#x27;</span>,<span class="number">22</span>);</span><br><span class="line">&#125;)</span><br><span class="line">-&gt;<span class="title function_ invoke__">whereOr</span>(function(<span class="variable">$query</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$query</span>-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;ntitle&#x27;</span>,<span class="string">&#x27;123&#x27;</span>)-&gt;<span class="title function_ invoke__">whereOr</span>(<span class="string">&#x27;ntitle&#x27;</span>,<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">-&gt;<span class="title function_ invoke__">select</span>();</span><br><span class="line"><span class="title function_ invoke__">dump</span>(<span class="variable">$sql</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初创博客</title>
      <link href="/2023/11/24/hello-hexo/"/>
      <url>/2023/11/24/hello-hexo/</url>
      
        <content type="html"><![CDATA[<div class="aplayer" data-id="000PeZCQ1i4XVs" data-server="tencent" data-type="artist" data-mutex="true" data-preload="auto" data-theme="#3F51B5"></div>]]></content>
      
      
      
        <tags>
            
            <tag> 创建博客记录 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
