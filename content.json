{"meta":{"title":"音符跳动","subtitle":"","description":"...","author":"kk","url":"https://2486125878.github.io","root":"/"},"pages":[{"title":"tags","date":"2023-11-27T01:42:09.000Z","updated":"2023-11-27T01:42:09.060Z","comments":true,"path":"tags/index.html","permalink":"https://2486125878.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-11-27T01:41:58.000Z","updated":"2023-11-27T01:41:58.623Z","comments":true,"path":"categories/index.html","permalink":"https://2486125878.github.io/categories/index.html","excerpt":"","text":""},{"title":"ThinkPHP5.0笔记","date":"2024-03-13T03:41:58.000Z","updated":"2024-03-13T03:51:19.224Z","comments":true,"path":"categories/thinkphp.html","permalink":"https://2486125878.github.io/categories/thinkphp.html","excerpt":"","text":"ThinkPHP5.0Thinkphp5目录架构12345678910111213141516171819202122232425262728293031323334353637383940414243444546thinkphp 应用部署目录├─application 应用目录（可设置）│ ├─common 公共模块目录（可更改）│ ├─index 模块目录(可更改)│ │ ├─config.php 模块配置文件│ │ ├─common.php 模块函数文件│ │ ├─controller 控制器目录│ │ ├─model 模型目录│ │ ├─view 视图目录│ │ └─ ... 更多类库目录│ ├─command.php 命令行工具配置文件│ ├─common.php 应用公共（函数）文件│ ├─config.php 应用（公共）配置文件│ ├─database.php 数据库配置文件│ ├─tags.php 应用行为扩展定义文件│ └─route.php 路由配置文件├─extend 扩展类库目录（可定义）├─public WEB 部署目录（对外访问目录）│ ├─static 静态资源存放目录(css,js,image)│ ├─index.php 应用入口文件│ ├─router.php 快速测试文件│ └─.htaccess 用于 apache 的重写├─runtime 应用的运行时目录（可写，可设置）├─vendor 第三方类库目录（Composer）├─thinkphp 框架系统目录│ ├─lang 语言包目录│ ├─library 框架核心类库目录│ │ ├─think Think 类库包目录│ │ └─traits 系统 Traits 目录│ ├─tpl 系统模板目录│ ├─.htaccess 用于 apache 的重写│ ├─.travis.yml CI 定义文件│ ├─base.php 基础定义文件│ ├─composer.json composer 定义文件│ ├─console.php 控制台入口文件│ ├─convention.php 惯例配置文件│ ├─helper.php 助手函数文件（可选）│ ├─LICENSE.txt 授权说明文件│ ├─phpunit.xml 单元测试配置文件│ ├─README.md README 文件│ └─start.php 框架引导文件├─build.php 自动生成定义文件（参考）├─composer.json composer 定义文件├─LICENSE.txt 授权说明文件├─README.md README 文件├─think 命令行入口文件 命名空间规范应用类库的根命名空间统一为app(可以设置app_namespace配置参数更改)；例如：app\\index\\controller\\Index 和 app\\index\\model\\User 属性命名 类的命名采用驼峰法，并且首字母大写，例如User、UserType，默认不需要添加后缀，例如UserController应该直接命名为User; 在Thinkphp3中需要UserController等命名方式； 函数的命名使用小写和下划线（小写字母开头的方式），例如get_client_ip ; 方法的命名使用驼峰法，并且首字母小写，例如getUserName ; 属性的命名使用驼峰法，并且首字母小写，例如tableName 、 instance 变量类型方法 方法 描述 param 获取当前请求的变量 get 获取 $_GET 变量 post 获取 $_POST 变量 put 获取 $_PUT 变量 delete 获取 $_DELETE 变量 session 获取 $_SESSION 变量 cookie 获取 $_COOKIE 变量 request 获取 $_REQUEST 变量 server 获取 $_SERVER 变量 env 获取 $_ENV 变量 route 获取 路由（包括PATHINFO） 变量 file 获取 $_FILE 变量 获取PARAM参数12345input(&#x27;param.name&#x27;); // 获取单个参数input(&#x27;param.&#x27;); // 获取全部参数// 下面是等效的input(&#x27;name&#x27;); input(&#x27;&#x27;); Thinkphp5目录架构#12345678910111213141516171819202122232425262728293031323334353637383940414243444546thinkphp 应用部署目录├─application 应用目录（可设置）│ ├─common 公共模块目录（可更改）│ ├─index 模块目录(可更改)│ │ ├─config.php 模块配置文件│ │ ├─common.php 模块函数文件│ │ ├─controller 控制器目录│ │ ├─model 模型目录│ │ ├─view 视图目录│ │ └─ ... 更多类库目录│ ├─command.php 命令行工具配置文件│ ├─common.php 应用公共（函数）文件│ ├─config.php 应用（公共）配置文件│ ├─database.php 数据库配置文件│ ├─tags.php 应用行为扩展定义文件│ └─route.php 路由配置文件├─extend 扩展类库目录（可定义）├─public WEB 部署目录（对外访问目录）│ ├─static 静态资源存放目录(css,js,image)│ ├─index.php 应用入口文件│ ├─router.php 快速测试文件│ └─.htaccess 用于 apache 的重写├─runtime 应用的运行时目录（可写，可设置）├─vendor 第三方类库目录（Composer）├─thinkphp 框架系统目录│ ├─lang 语言包目录│ ├─library 框架核心类库目录│ │ ├─think Think 类库包目录│ │ └─traits 系统 Traits 目录│ ├─tpl 系统模板目录│ ├─.htaccess 用于 apache 的重写│ ├─.travis.yml CI 定义文件│ ├─base.php 基础定义文件│ ├─composer.json composer 定义文件│ ├─console.php 控制台入口文件│ ├─convention.php 惯例配置文件│ ├─helper.php 助手函数文件（可选）│ ├─LICENSE.txt 授权说明文件│ ├─phpunit.xml 单元测试配置文件│ ├─README.md README 文件│ └─start.php 框架引导文件├─build.php 自动生成定义文件（参考）├─composer.json composer 定义文件├─LICENSE.txt 授权说明文件├─README.md README 文件├─think 命令行入口文件 规范# ThinkPHP5.0的URl访问受路由决定，如果关闭路由或者没有匹配路由的情况下，则是基于： http://serverName/index.php(或者其他应用入口文件，可省略) &#x2F;模块&#x2F; 控制器&#x2F;操作 &#x2F; 参数 &#x2F;值 在Thinkphp5.0框架中，在url地址栏里面如果不写模块、控制器和操作名，默认访问的就是index模块下面的index控制器下面的index操作，可以在config.php文件中进行修改。 入口文件# 用户请求的PHP文件，负责处理一个请求（注意，不一定是URL请求）的生命周期，最常见的入口文件就是index.php, 有时候也会为了某些特殊的需求而增加新的入口文件，例如给后台模块单独设置的一个入口文件admin.php或者一个控制器程序入口think都属于入口文件。 命名空间规范#应用类库的根命名空间统一为app(可以设置app_namespace配置参数更改)；例如：app\\index\\controller\\Index 和 app\\index\\model\\User; 属性命名# 类的命名采用驼峰法，并且首字母大写，例如User、UserType，默认不需要添加后缀，例如UserController应该直接命名为User; 在Thinkphp3中需要UserController等命名方式； 函数的命名使用小写和下划线（小写字母开头的方式），例如get_client_ip ; 方法的命名使用驼峰法，并且首字母小写，例如getUserName ; 属性的命名使用驼峰法，并且首字母小写，例如tableName 、 instance; 应用类库命名空间规范#应用类库的根命名空间统一为app(可以设置app_namespace配置参数更改)；例如：app\\index\\controller\\Index 和 app\\index\\model\\User; 请求#Thinkphp助手参数#判断变量是否定义12input(&#x27;?get.id&#x27;);input(&#x27;?post.name&#x27;); 变量类型方法: 方法 描述 param 获取当前请求的变量 get 获取 $_GET 变量 post 获取 $_POST 变量 put 获取 $_PUT 变量 delete 获取 $_DELETE 变量 session 获取 $_SESSION 变量 cookie 获取 $_COOKIE 变量 request 获取 $_REQUEST 变量 server 获取 $_SERVER 变量 env 获取 $_ENV 变量 route 获取 路由（包括PATHINFO） 变量 file 获取 $_FILE 变量 获取PARAM参数12345input(&#x27;param.name&#x27;); // 获取单个参数input(&#x27;param.&#x27;); // 获取全部参数// 下面是等效的input(&#x27;name&#x27;); input(&#x27;&#x27;); 获取GET参数123456// 获取单个变量input(&#x27;get.id&#x27;);// 使用过滤方法获取 默认为空字符串input(&#x27;get.name&#x27;);// 获取全部变量input(&#x27;get.&#x27;); 使用过滤方法123input(&#x27;get.name&#x27;,&#x27;&#x27;,&#x27;htmlspecialchars&#x27;); // 获取get变量 并用htmlspecialchars函数过滤input(&#x27;username&#x27;,&#x27;&#x27;,&#x27;strip_tags&#x27;); // 获取param变量 并用strip_tags函数过滤input(&#x27;post.name&#x27;,&#x27;&#x27;,&#x27;org\\Filter::safeHtml&#x27;); // 获取post变量 并用org\\Filter类的safeHtml方法过滤 使用变量修饰符1234input(&#x27;get.id/d&#x27;);input(&#x27;post.name/s&#x27;);input(&#x27;post.ids/a&#x27;); 修饰符 修饰符 作用 s 强制转换为字符串类型 d 强制转换为整形类型 b 强制转换为布尔类型 a 强制转换为数组类型 f 强制转换为浮点类型 请求Request对象的主要职责是统一和更安全地获取当前的请求信息，你需要避免直接操作 $_GET、$_POST、$_REQUEST、$_SESSION、$_COOKIE、$_FILES等全局变量， 而是统一使用Request对象提供的方法来获取请求变量。 ThinkPHP5的Request对象由think\\Request类完成。 $request &#x3D; Request::instance(); 也可以使用助手函数 $request = request(); 123`$request = Request::instance();`// 获取当前域名`echo &#x27;domain: &#x27; . $request-&gt;domain() . &#x27;&lt;br/&gt;&#x27;;` 方法 描述 param 获取当前请求的变量（自动识别GET、POST、PUT请求的一种变量获取方式，是系统推荐的获取请求参数方法） get 获取$_GET变量 post 获取$_POST变量 put 获取PUT变量 delete 获取DELETE变量 session 获取$_SESSION变量 cookie 获取$_COOKIE变量 request 获取$_REQUEST变量 server 获取$_SERVER变量 env 获取$_ENV变量 file 获取$_FILES变量 改变变量 如果需要更改请求变量的值，可以通过下面的方式： 更改GET变量 Request::instance()-&gt;get([&#39;id&#39;=&gt;10]); 更改POST变量 Request::instance()-&gt;post([&#39;name&#39;=&gt;&#39;thinkphp&#39;]); 尽量避免直接修改$_GET或者$_POST 数据,同时也不能直接修改param变量，例如下面的操作是无效的。 更改请求变量 Request::instance()-&gt;param([&#39;id&#39;=&gt;10]); 伪静态 URL伪静态通常是为了满足更好的SEO效果，ThinkPHP支持伪静态URL设置，可以通过设置url_html_suffix参数随意在URL的最后增加你想要的静态后缀，而不影响当前操作的正常执行。例如，我们设置 &#39;url_html_suffix&#39;=&gt;&#39;shtml&#39; 如果要获取当前的伪静态后缀，可以使用Request对象的ext方法。 路由路由功能由\\think\\Route类完成。 由于ThinkPHP5.0默认采用的URL规则是： 1http://server/module/controller/action/param/value/..... 路由的作用是简化URL访问地址，并根据定义的路由类型做出正确的解析。 路由模式ThinkPHP5.0的路由比较灵活，并且不需要强制定义，可以总结归纳为如下三种方式： 普通模式关闭路由，完全使用默认的PATH_INFO方式URL： 1url_route_on =&gt; false, 路由关闭后，不会解析任何路由规则，采用默认的PATH_INFO模式访问URL: 1http://serverName/index.php/module/controller/action/param/value/... 混合模式开启路由，并使用路由定义+默认PATH_INFO方式的混合: 12&#x27;url_route_on&#x27; =&gt; true,&#x27;url_route_must&#x27; =&gt; false, 该方式下面，只需要对需要定义路由规则的访问地址定义路由规则，其他的仍然按照第一种普通模式的PATH_INFO模式访问URL。 强制模式开启路由，并设置必须定义路由才能访问： 12url_route_on =&gt; true,url_route_must =&gt; true, 这种方式下面必须严格给每一个访问地址定义路由规则（包括首页），否则将抛出异常。 首页的路由规则采用/定义即可，例如下面把网站首页路由输出Hello,world!我们需要在route.php这个文件中配置路由，要使用官方的 use think\\Route 123Route::get(&#x27;/&#x27;,function()&#123; return &#x27;Hello,world!&#x27;;&#125;); 路由定义路由注册可以采用方法动态单个和批量注册，也可以直接定义路由定义文件的方式进行集中注册。 动态注册路由定义采用\\think\\Route类的rule方法注册，通常是在应用的路由配置文件 application/route.php进行注册，格式是： 1234567Route::rule(&#x27;路由表达式&#x27;，&#x27;路由地址&#x27;，&#x27;请求类型&#x27;，&#x27;路由参数（数组）&#x27;，&#x27;变量规则（数组）&#x27;);use think\\Route;// 注册路由到index模块的Index控制器的list操作Route::rule(&#x27;new/:id&#x27;,&#x27;index/Index/list&#x27;);//表示定义的路由规则在POST请求下才有效。注意：请求类型参数必须大写。Route::rule(&#x27;new/:id&#x27;,&#x27;News/update&#x27;,&#x27;POST&#x27;); 请求类型包括： 类型 GET GET请求 POST POST请求 PUT PUT请求 DELETE DELETE请求 * 任何请求类型 系统提供了为不同的请求类型定义路由规则的简化方法，例如：12345Route::get(&#x27;new/:id&#x27;,&#x27;News/read&#x27;); // 定义GET请求路由规则Route::post(&#x27;new/:id&#x27;,&#x27;News/update&#x27;); // 定义POST请求路由规则Route::put(&#x27;new/:id&#x27;,&#x27;News/update&#x27;); // 定义PUT请求路由规则Route::delete(&#x27;new/:id&#x27;,&#x27;News/delete&#x27;); // 定义DELETE请求路由规则Route::any(&#x27;new/:id&#x27;,&#x27;News/read&#x27;); // 所有请求都支持的路由规则 如果要定义get和post请求支持的路由规则，也可以用：1Route::rule(&#x27;new/:id&#x27;,&#x27;News/read&#x27;,&#x27;GET|POST&#x27;); 也可以批量注册路由规则123Route::rule([&#x27;new/:id&#x27;=&gt;&#x27;News/read&#x27;,&#x27;blog/:name&#x27;=&gt;&#x27;Blog/detail&#x27;]);Route::get([&#x27;new/:id&#x27;=&gt;&#x27;News/read&#x27;,&#x27;blog/:name&#x27;=&gt;&#x27;Blog/detail&#x27;]);Route::post([&#x27;new/:id&#x27;=&gt;&#x27;News/update&#x27;,&#x27;blog/:name&#x27;=&gt;&#x27;Blog/detail&#x27;]); 注册多个路由规则后，系统会依次遍历注册过的满足请求类型的路由规则，一旦匹配到正确的路由规则后则开始调用控制器的操作方法，后续规则就不再检测。定义路由配置文件除了支持动态注册，也可以直接在应用目录下面的route.php的最后通过返回数组的方式直接定义路由规则 1234return [ &#x27;new/:id&#x27; =&gt; &#x27;News/read&#x27;, &#x27;blog/:id&#x27; =&gt; [&#x27;Blog/update&#x27;,[&#x27;method&#x27; =&gt; &#x27;post|put&#x27;], [&#x27;id&#x27; =&gt; &#x27;\\d+&#x27;]],]; 路由动态注册和配置定义的方式可以并存。由于检测机制问题，动态注册的性能比路由配置要高一些，尤其是多种请求类型混合定义的时候。 默认情况下，只会加载一个路由配置文件route.php，如果需要定义多个路由文件，可以修改route_config_file的配置参数，例如： 12定义路由配置文件（数组）&#x27;route_config_file&#x27; =&gt; [&#x27;route&#x27;, &#x27;route1&#x27;, &#x27;route2&#x27;], 资源路由5.0支持设置RESTFul请求的资源路由，方式如下： Route::resource(‘blog’,’index&#x2F;blog’); 或者在路由配置文件中使用__rest__添加资源路由定义： 123456return [ // 定义资源路由 &#x27;__rest__&#x27;=&gt;[ // 指向index模块的blog控制器 &#x27;blog&#x27;=&gt;&#x27;index/blog&#x27;,], 设置过后会自动注册7个路由规则，如下： 标识 请求类型 生成路由规则 对应操作方法（默认） index GET blog index create GET blog/create create save POST blog save read GET blog/:id read edit GET blog/:id/edit edit update PUT blog/:id update delete DELETE blog/:id delete 具体指向的控制器由路由地址决定，例如上面的设置，会对应index模块的blog控制器，你只需要为Blog控制器创建以上对应的操作方法就可以支持下面的URL访问： 123http://serverName/blog/http://serverName/blog/128http://serverName/blog/28/edit Blog控制器中对应的方法如下: 12345678910111213141516namespace app\\index\\controller;class Blog &#123; public function index() &#123; dump(index); &#125; public function update($id) &#123; dump(update); &#125; public function delete($id) &#123; dump(delete); &#125;&#125; 快捷路由快捷路由允许你快速给控制器注册路由，并且针对不同的请求类型可以设置方法前缀 12// 给User控制器设置快捷路由Route::controller(&#x27;user&#x27;,&#x27;index/User&#x27;); User控制器定义如下： 12345678910111213141516171819namespace app\\index\\controller;class User &#123; public function getInfo() &#123; &#125; public function getPhone() &#123; &#125; public function postInfo() &#123; &#125; public function putInfo() &#123; &#125; public function deleteInfo() &#123; &#125;&#125; 我们可以通过下面的URL访问 12345get http://localhost/user/infoget http://localhost/user/phonepost http://localhost/user/infoput http://localhost/user/infodelete http://localhost/user/info 权限控制Base.php，需要鉴权继承该类即可 12345678910111213141516171819&lt;?phpnamespace app\\index\\controller;use think\\Controller;use think\\Request;class Base extends Controller&#123; //用来存放需要用户登录之后才能操作的方法的集合 protected $is_check_login = [&#x27;&#x27;]; public function _initialize() &#123; if (!$this-&gt;isLogin() &amp;&amp; (in_array(Request::instance()-&gt;action(), $this-&gt;is_check_login)||$this-&gt;is_check_login[0]==&#x27;*&#x27;))&#123; return $this-&gt;error(&#x27;请先登录系统！&#x27;,&#x27;index/Index/login&#x27;); &#125; &#125; public function isLogin() &#123; return session(&#x27;?name&#x27;); &#125;&#125; GoodsController,进行所有方法鉴权 123456789101112131415161718192021&lt;?phpnamespace app\\index\\controller;use app\\index\\controller\\Base;class Goods extends Base&#123; protected $is_check_login = [&#x27;*&#x27;]; public function add() &#123; echo &#x27;我想要购买商品&#x27;; &#125; public function edit() &#123; echo &#x27;我想退货&#x27;; &#125; public function delete() &#123; echo &#x27;我不想买了&#x27;; &#125;&#125; CommentController,仅对Add方法路由鉴权 1234567891011121314151617&lt;?phpnamespace app\\index\\controller;use app\\index\\controller\\Base;class Comment extends Base&#123; protected $is_check_login = [&#x27;add&#x27;]; public function add() &#123; echo &#x27;我想发表评论&#x27;; &#125; public function edit() &#123; echo &#x27;我想编辑一下自己的评论&#x27;; &#125;&#125; 数据库的操作ThinkPHP内置了抽象数据库访问层，把不同的数据库操作封装起来，我们只需要使用公共的Db类进行操作，而无需针对不同的数据库写不同的代码和底层实现，Db类会自动调用相应的数据库驱动来处理。采用PDO方式，目前包含了Mysql、SqlServer、PgSQL、Sqlite等数据库的支持。 1.基本使用配置了数据库连接信息后，我们就可以直接使用数据库运行原生SQL操作了，支持query（查询操作）和execute（写入操作）方法，并且支持参数绑定。 123456public function read()&#123; $sql = Db::query(&#x27;select * from news&#x27;); dump($sql); &#125; execute方法： 12345public function read()&#123; $sql = Db::execute(&#x27;insert into news (nid, rid) values (11, 11)&#x27;);; dump($sql);&#125; 也支持命名占位符绑定，例如： 12345public function read()&#123; $sql = Db::query(&#x27;select * from news where nid=:nid&#x27;,[&#x27;nid&#x27;=&gt;1]); dump($sql);&#125; execute方法： 12345public function read()&#123; $sql = Db::execute(&#x27;insert into news (nid, rid) values (:nid, :rid)&#x27;,[&#x27;nid&#x27;=&gt;18,&#x27;rid&#x27;=&gt;&#x27;121&#x27;]); dump($sql);&#125; 可以使用多个数据库连接: 2.查询构造器听名字就知道，很装X.. 先来看基本查询； 查询一个数据： 123// table方法必须指定完整的数据表名 $sql =Db::table(&#x27;news&#x27;)-&gt;where(&#x27;nid&#x27;,1)-&gt;find(); dump($sql); find &#x3D; 查询一条；并且查询结果不存在，返回 null 输出： 1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;status&#x27;,1)-&gt;select(); 这条查询语句与上面同效，但是select 方法查询结果不存在，返回空数组 额 这个玩意叫查询数据集，没错！ 默认情况下，find和select方法返回的都是数组。 如果你要查询某个字段的值，咋整？ 123456public function read()&#123;// 返回某个字段的值 $sql =Db::table(&#x27;news&#x27;)-&gt;where(&#x27;nid&#x27;,18)-&gt;value(&#x27;rid&#x27;); dump($sql);&#125; 这样看输出，我求rid的值： 如果你需要处理成千上百条数据库记录，可以考虑使用chunk方法，该方法一次获取结果集的一小块，然后填充每一小块数据到要处理的闭包，该方法在编写处理大量数据库记录的时候非常有用。 1234567891011public function read()&#123; $sql =Db::table(&#x27;news&#x27;)-&gt;chunk(1,function($user)&#123; foreach($user as $u) &#123;dump($u); &#125; &#125;); &#125; 这个样子 就可以一条一条都给遍历出来了！ 是“一条一条·”，嘿！ 3.添加数据跟删除数据使用 Db 类的 insert 方法向数据库提交数据 1234567public function read()&#123;$data = [&#x27;ntitle&#x27; =&gt; &#x27;123&#x27;, &#x27;rid&#x27; =&gt; &#x27;456&#x27;];$sql = Db::table(&#x27;news&#x27;)-&gt;insert($data); dump($sql);&#125; 添加成功后insert 方法返回添加成功的条数，insert 正常情况返回 1 添加数据后如果需要返回新增数据的自增主键，可以使用getLastInsID方法： 12345678public function read()&#123;$data = [&#x27;ntitle&#x27; =&gt; &#x27;123&#x27;, &#x27;rid&#x27; =&gt; &#x27;345&#x27;];$sql = Db::table(&#x27;news&#x27;)-&gt;insert($data);$userId = Db::name(&#x27;news&#x27;)-&gt;getLastInsID(&#x27;nid&#x27;);dump($userId);dump($sql);&#125; 添加多条数据: 添加多条数据直接向 Db 类的 insertAll 方法传入需要添加的数据即可; 12345678910public function read()&#123;$data = [[&#x27;ntitle&#x27; =&gt;&#x27;gaga&#x27;,&#x27;rid&#x27; =&gt; &#x27;12&#x27;],[&#x27;ntitle&#x27; =&gt;&#x27;gaaaga&#x27;,&#x27;rid&#x27; =&gt; &#x27;123&#x27;]];$sql = Db::table(&#x27;news&#x27;)-&gt;insertAll($data);dump($sql);&#125; 这样的话，返回的应该是两条2 删除数据： 根据主键来删除 12345678public function read()&#123;// 根据主键 来删$sql = Db::table(&#x27;news&#x27;)-&gt;delete(1);//多删//$sql = Db::table(&#x27;news&#x27;)-&gt;delete(1,2,3);dump($sql);&#125; 执行成功返回影响行数； 还有一种是根据条件来删除的 12345678public function read()&#123;// 根据条件 来删$sql = Db::table(&#x27;news&#x27;)-&gt;where(&#x27;nid&#x27;,18)-&gt;delete();//多删//$sql = Db::table(&#x27;news&#x27;)-&gt;where(&#x27;nid&#x27;,&#x27;&lt;&#x27;,1)-&gt;delete();dump($sql);&#125; 执行成功也是返回影响行数； 4.查询方法：where方法： 可以使用where方法进行AND条件查询： 12345678public function read()&#123;$sql = Db::table(&#x27;news&#x27;)-&gt;where(&#x27;nid&#x27;,20)-&gt;where(&#x27;ntitle&#x27;,123)-&gt;find();dump($sql);&#125; whereOr方法： 使用whereOr方法进行OR查询： 12345678public function read()&#123;$sql = Db::table(&#x27;news&#x27;)-&gt;where(&#x27;nid&#x27;,20)-&gt;whereOr(&#x27;ntitle&#x27;,&#x27;like&#x27;,&#x27;%123%&#x27;)-&gt;find();dump($sql);&#125; 混合查询： where方法和whereOr方法在复杂的查询条件中经常需要配合一起混合使用 12345678910111213public function read()&#123;$sql = Db::table(&#x27;news&#x27;)-&gt;where(function($query)&#123; $query-&gt;where(&#x27;nid&#x27;,21)-&gt;where(&#x27;nid&#x27;,22);&#125;)-&gt;whereOr(function($query)&#123; $query-&gt;where(&#x27;ntitle&#x27;,&#x27;123&#x27;)-&gt;whereOr(&#x27;ntitle&#x27;,&#x27;123&#x27;);&#125;)-&gt;select();dump($sql);&#125;"},{"title":"thinkphp之SQL查询语句","date":"2023-03-13T03:50:58.000Z","updated":"2024-03-13T03:52:37.037Z","comments":true,"path":"categories/thinkphpsql.html","permalink":"https://2486125878.github.io/categories/thinkphpsql.html","excerpt":"","text":"1.thinkphp之SQL查询语句一：字符串条件查询12345//直接实例化Model$user=M(&#x27;user1&#x27;);var_dump($user-&gt;where (&#x27;id=1 OR age=55&#x27;)-&gt;select()); 最终生成的sql语句为：SELECT * FROM user1 WHERE ( id&#x3D;1 OR age&#x3D;55 ) PS:where 查询方法里面只要包含条件即可，多个条件加上 AND 等连接符即可 二：使用索引数组作为查询条件1234567891011$user=M(&#x27;user1&#x27;);$condition[&#x27;age&#x27;]=&#x27;55&#x27;;$condition[&#x27;name&#x27;]=&#x27;zs&#x27;;// 索引数组查询的默认逻辑关系是 AND，如果想改变为 OR，可以使用_logic 定义查询逻辑$condition[&#x27;_logic&#x27;] = &#x27;OR&#x27;;var_dump($user-&gt;where($condition)-&gt;select()); 最终生成的sql语句为：SELECT * FROM user1 WHERE id &#x3D; ‘1’ AND name &#x3D; ‘zs’ 三：使用对象方式查询123456789101112131415161718192021&lt;?phpnamespace Home\\Controller;use Think\\Controller;use Think\\stdClass;class EleController extends Controller&#123; $user=M(&#x27;user1&#x27;); $condition=new \\stdClass; $condition-&gt;id = &#x27;1&#x27;; var_dump($user-&gt;where($condition)-&gt;select());&#125; 最终生成的sql语句为：SELECT * FROM user1 WHERE id &#x3D; ‘1’ 四：表达式查询查询表达式格式：$map[‘字段名’] &#x3D; array(‘表达式’,’查询条件’); 12345$user=M(&#x27;user1&#x27;);$map[&#x27;age&#x27;] = array(&#x27;eq&#x27;, 55); //where 为 age=55var_dump($user-&gt;where($map)-&gt;select()); 五：快捷查询1234567891011121314151617//使用相同查询条件 $user = M(&#x27;user1&#x27;); $map[&#x27;name|email&#x27;] = &#x27;a&#x27;; //&#x27;|&#x27;换成&#x27;&amp;&#x27;变成AND var_dump($user-&gt;where($map)-&gt;select()); // 不同字段不同查询条件 //使用不同查询条件 $user = M(&#x27;user1&#x27;); $map[&#x27;name&amp;email&#x27;] =array(&#x27;a&#x27;,&#x27;test@qq.com&#x27;,&#x27;_multi&#x27;=&gt;true); var_dump($user-&gt;where($map)-&gt;select()); 第一条查询的结果：SELECT * FROM user1 WHERE ( name &#x3D; ‘a’ OR email &#x3D; ‘a’ ) 第二条查询的结果：SELECT * FROM user1 WHERE ( (name &#x3D; ‘a’) AND (email &#x3D; ‘&#116;&#101;&#115;&#116;&#x40;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;‘) ) 六：区间查询1234567891011121314151617// 区间查询 $user = M(&#x27;user1&#x27;); $map[&#x27;id&#x27;] = array(array(&#x27;gt&#x27;, 1), array(&#x27;lt&#x27;, 4)); var_dump($user-&gt;where($map)-&gt;select()); //第三个参数设置逻辑OR $user = M(&#x27;User1&#x27;); $map[&#x27;id&#x27;] = array(array(&#x27;gt&#x27;, 1), array(&#x27;lt&#x27;, 4), &#x27;OR&#x27;); var_dump($user-&gt;where($map)-&gt;select()&#125; 七：组合查询组合查询是基于索引数组查询方式的一个扩展性查询，添加了字符串查询(_string)、复合查询(_complex)、请求字符串查询(_query)，由于采用的是索引数组，重复的会被覆盖。 12345678910111213141516171819202122232425262728293031323334353637//字符串查询(_string) $user = M(&#x27;user1&#x27;); $map[&#x27;name&#x27;] = array(&#x27;eq&#x27;, &#x27;zs&#x27;); $map[&#x27;_string&#x27;] =&#x27;age=&quot;30&quot; AND email=&quot;zs@qq.com&quot;&#x27;; var_dump($user-&gt;where($map)-&gt;select()); //请求字符串查询(_query) $user = M(&#x27;user1&#x27;); $map[&#x27;id&#x27;] = array(&#x27;eq&#x27;, &quot;1&quot;); $map[&#x27;_query&#x27;] =&#x27;name=zs&amp;email=zs@qq.com&amp;_logic=OR&#x27;; var_dump($user-&gt;where($map)-&gt;select()); //复合查询(_complex) $user = M(&#x27;user1&#x27;); $where[&#x27;name&#x27;] = array(&#x27;like&#x27;, &#x27;z&#x27;); $where[&#x27;id&#x27;] = 1; $where[&#x27;_logic&#x27;] = &#x27;OR&#x27;; $map[&#x27;_complex&#x27;] = $where; $map[&#x27;id&#x27;] = 3; $map[&#x27;_logic&#x27;] = &#x27;OR&#x27;; var_dump($user-&gt;where($map)-&gt;select()); 第一条查询语句：SELECT * FROM user1 WHERE name &#x3D; ‘zs’ AND ( age&#x3D;”30” AND email&#x3D;”&#122;&#x73;&#x40;&#x71;&#x71;&#46;&#99;&#x6f;&#109;“ ) 第二条查询语句：SELECT * FROM user1 WHERE name &#x3D; ‘zs’ AND ( age&#x3D;”30” AND email&#x3D;”&#122;&#115;&#x40;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#109;“ ) AND ( name &#x3D; ‘zs’ OR email &#x3D; ‘&#x7a;&#x73;&#x40;&#113;&#113;&#46;&#x63;&#111;&#x6d;‘ ) 第三条查询语句：SELECT * FROM user1 WHERE name &#x3D; ‘zs’ OR ( age&#x3D;”30” AND email&#x3D;”&#122;&#x73;&#x40;&#x71;&#113;&#46;&#x63;&#111;&#x6d;“ ) OR ( name &#x3D; ‘zs’ OR email &#x3D; ‘&#122;&#115;&#64;&#x71;&#113;&#46;&#99;&#111;&#x6d;‘ ) OR ( name LIKE ‘z’ OR id &#x3D; 1 ) 八：统计查询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//数据总条数 //SHOW COLUMNS FROM `user1` $user = M(&#x27;user1&#x27;); var_dump($user-&gt;count()); //字段总条数，遇到NULL不统计 //SELECT COUNT(*) AS tp_count FROM `user1` LIMIT 1 $user = M(&#x27;user1&#x27;); var_dump($user-&gt;count(&#x27;email&#x27;)); //最大值 //SELECT MAX(id) AS tp_max FROM `user1` LIMIT 1 $user = M(&#x27;user1&#x27;); var_dump($user-&gt;max(&#x27;id&#x27;)); //最小值 //SELECT MIN(id) AS tp_min FROM `user1` LIMIT 1 $user = M(&#x27;user1&#x27;); var_dump($user-&gt;min(&#x27;id&#x27;)); //平均值 //SELECT AVG(id) AS tp_avg FROM `user1` LIMIT 1 $user = M(&#x27;user1&#x27;); var_dump($user-&gt;avg(&#x27;id&#x27;)); //求总和 //SELECT SUM(id) AS tp_sum FROM `user1` LIMIT 1 $user = M(&#x27;user1&#x27;); var_dump($user-&gt;sum(&#x27;id&#x27;)); 九：动态查询12345678910111213141516171819// 1.getBy 动态查询 //查找email=xiaoin@163.com的数据 //SELECT * FROM `user1` LIMIT 1 $user = M(&#x27;user1&#x27;); var_dump($user-&gt;getByemail(&#x27;zs@qq.com&#x27;)); // 2.getFieldBy 动态查询 //通过user得到相对应id值 //SELECT `id` FROM `user1` LIMIT 1 $user = M(&#x27;user1&#x27;); var_dump($user-&gt;getFieldByUser(&#x27;ls&#x27;, &#x27;id&#x27;)); 十：SQL查询12345678910111213141516171819202122 // 1.query 读取//查询结果集，如果采用分布式读写分离，则始终在读服务器执行//SELECT * FROM user1$user = M(&#x27;user1&#x27;);var_dump($user-&gt;query(&#x27;SELECT * FROM user1&#x27;));// 2.execute写入//更新和写入，如果采用分布式读写分离，则始终在写服务器执行//UPDATE user1 set name=&quot;xuexi&quot; WHERE id=&quot;1&quot;;$user = M(&#x27;user1&#x27;);var_dump($user-&gt;execute(&#x27;UPDATE user1 set name=&quot;xuexi&quot; WHERE id=&quot;1&quot;;&#x27;)); 十一：连贯查询 通过连贯操作可以有效的提供数据存取的代码清晰度和开发效率，并且支持所有的 CURD 操作 12345678910111213141516171819202122232425262728293031//连贯操作 //PS：这里的 where、order 和 limit 方法都是连贯操作方法，所以它们都能返回$user本身，可以互换位置。而 select 方法不是连贯方法，需要放在最后，用以显示数据集。 //SELECT * FROM `user1` WHERE ( id in (1,2,3,4) ) LIMIT 2 $user=M(&#x27;user1&#x27;); var_dump($user-&gt;where(&#x27;id in (1,2,3,4)&#x27;)-&gt;limit(2)-&gt;select()); //数组操作 //SELECT * FROM `user1` WHERE id in (1,2,3,4) LIMIT 2 $user = M(&#x27;user1&#x27;); var_dump($user-&gt;select(array(&#x27;where&#x27;=&gt;&#x27;id in (1,2,3,4)&#x27;, &#x27;limit&#x27;=&gt;&#x27;2&#x27;, ))); // CURD处理 // SELECT * FROM `user1` WHERE ( id=1 ) LIMIT 1 // DELETE FROM `user1` WHERE ( id=2 ) $user = M(&#x27;user1&#x27;); var_dump($user-&gt;where(&#x27;id=1&#x27;)-&gt;find()); var_dump($user-&gt;where(&#x27;id=2&#x27;)-&gt;delete()); 1.where(支持字符串条件、数组条件（推荐用法）和多次调用。)1234567891011121314151617181920212223242526//字符串方式 //SELECT * FROM `user1` WHERE ( id=6 ) var_dump($user-&gt;where(&#x27;id=6&#x27;)-&gt;select()); //索引数组方式 // SELECT * FROM `user1` WHERE `id` = 6 $map[&#x27;id&#x27;]=6; var_dump($user-&gt;where($map)-&gt;select()); //多次调用方式 SELECT * FROM `user1` WHERE `id` = 6 AND ( name=&quot;test&quot; ) $map[&#x27;id&#x27;]=array(&#x27;eq&#x27;,6); var_dump($user-&gt;where($map)-&gt;where(&#x27;name=&quot;test&quot;&#x27;)-&gt;select()); 2.order 用于对结果集排序1234567891011121314151617181920212223// 倒序 // SELECT * FROM `user1` ORDER BY id desc var_dump($user-&gt;order(&#x27;id desc&#x27;)-&gt;select()); // 第二排序 // SELECT * FROM `user1` ORDER BY id desc,age desc var_dump($user-&gt;order(&#x27;id desc,age desc&#x27;)-&gt;select()); //数组形式，防止字段和mysql关键字冲突 // SELECT * FROM `user1` ORDER BY `id` DESC,`email` DESC $map[&#x27;id&#x27;]=1; var_dump($user-&gt;order(array(&#x27;id&#x27;=&gt;&#x27;DESC&#x27;,&#x27;email&#x27;=&gt;&#x27;DESC&#x27;))-&gt;select()); 3.feild（feild 方法可以返回或操作字段，可以用于查询和写入操作。）123456789101112131415161718192021222324252627282930313233343536 // 只显示id和name两个字段 // SELECT `id`,`name` FROM `user1` var_dump($user-&gt;field(&#x27;id,name&#x27;)-&gt;select()); //使用SQL函数和别名 // SELECT SUM(id) as count,`name` FROM `user1` var_dump($user-&gt;field(&#x27;SUM(id) as count,name&#x27;)-&gt;select()); // 使用数组参数结合SQL函数 // SELECT `id`,LEFT(name,1) AS `left_user` FROM `user1` var_dump($user-&gt;field(array(&#x27;id&#x27;,&#x27;LEFT(name,1)&#x27;=&gt;&#x27;left_user&#x27;))-&gt;select()); //获取所有字段 // SELECT * FROM `user1` var_dump($user-&gt;field()-&gt;select()); //用于写入 $user-&gt;field(&#x27;name,email&#x27;)-&gt;create(); 4.limit（主要用于指定查询和操作的数量）12345678910111213//限制结果集数量 // SELECT * FROM `user1` LIMIT 2 var_dump($user-&gt;limit(2)-&gt;select()); //分页查询 // SELECT * FROM `user1` LIMIT 1,2 var_dump($user-&gt;limit(1,2)-&gt;select()); 5.page（page 方法完全用于分页查询）12345//page分页 // SELECT * FROM `user1` LIMIT 3,3 var_dump($user-&gt;page(2,3)-&gt;select()); 6.table（用于数据表操作，主要是切换数据表或多表操作）12345//切换数据表 // SELECT * FROM `test_user` var_dump($user-&gt;table(&#x27;test_user&#x27;)-&gt;select()); 7.alias （用于设置数据表别名）12345// 设置别名 // SELECT * FROM user1 a var_dump($user-&gt;alias(&#x27;a&#x27;)-&gt;select()); 8.group（用于对结合函数统计的结果集分组）12345 // 分组统计// SELECT `name`,max(id) FROM `user1` GROUP BY idvar_dump($user-&gt;field(&#x27;name,max(id)&#x27;)-&gt;group(&#x27;id&#x27;)-&gt;select()); 9.having（用于配合 group 方法完成从分组的结果中再筛选数据）12345//分组统计结合having // SELECT `user`,max(id) FROM `user1` GROUP BY id HAVING id&gt;2 var_dump($user-&gt;field(&#x27;user,max(id)&#x27;)-&gt;group(&#x27;id&#x27;)-&gt;having(&#x27;id&gt;2&#x27;)-&gt;select()); 10.comment （用于对 SQL 语句进行注释）12345//SQL注释 // SELECT * FROM `user1` /* test */ var_dump($user-&gt;comment(&#x27;test&#x27;)-&gt;select()); 2.ThinkPHP 数据的增删改查1、增ThinkPHP 内置的 add 方法用于向数据表添加数据，相当于 SQL 中的 INSERT INTO 行为。 12345678910111213 1 public function insert()&#123; 2 header(&quot;Content-Type:text/html; charset=utf-8&quot;); 3 $Dao = M(&quot;User&quot;); // 实例化模型类 4 5 // 构建写入的数据数组 6 $data[&quot;username&quot;] = &quot;小王&quot;; 7 $data[&quot;password&quot;] = md5(&quot;123456&quot;); 8 $data[&quot;email&quot;] = &quot;12345@163.com&quot;; 9 $data[&quot;regdate&quot;] = time();10 11 // 写入数据12 $insertM = $Dao-&gt;add($data)；13 &#125; 等同于SQL语句： 1INSERT INTO user(username,password,email,regdate) VALUES (&#x27;小王&#x27;,&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;,&#x27;12345@163.com&#x27;,1486974334); 2、删delete() 方法执行成功返回操作影响（删除）的记录数。 1234561 public function del()&#123;2 header(&quot;Content-Type:text/html; charset=utf-8&quot;);3 $Dao = M(&quot;User&quot;);4 // 删除 uid=5 的数据记录5 $result = $Dao-&gt;where(&#x27;uid = 5&#x27;)-&gt;delete();6 &#125; 等同于SQL语句： 1DELETE FROM user WHERE uid = 5; 3、改ThinkPHP 内置的 save() 方法用于向数据表更新数据，相当于 SQL 中的 UPDATE 行为。 1234567891011 1 public function update()&#123; 2 header(&quot;Content-Type:text/html; charset=utf-8&quot;); 3 $Dao = M(&quot;User&quot;); 4 5 // 需要更新的数据 6 $data[&#x27;email&#x27;] = &#x27;Jack@163.com&#x27;; 7 // 更新的条件 8 $condition[&#x27;username&#x27;] = &#x27;Jack&#x27;; 9 $result = $Dao-&gt;where($condition)-&gt;save($data);10 //或者：$resul t= $Dao-&gt;where($condition)-&gt;data($data)-&gt;save();11 &#125; 等同于SQL语句： 1UPDATE user SET email=&#x27;Jack@163.com&#x27; WHERE username=&#x27;Jack&#x27;; 提示 为了保证数据库的安全，避免出错更新整个数据表，如果没有任何更新条件，数据对象本身也不包含主键字段的话，save方法不会更新任何数据库的记录。 因此要使用 save() 方法更新数据，必须指定更新条件或者更新的数据中包含主键字段。 4、查 ThinkPHP 查询数据主要提供以下几类查询： 1）select是 ThinkPHP 中最常用的普通查询方法，得到的是一个二维数组。 12345678910111213141516171819202122232425262728293031 1 //方法php 2 public function read()&#123; 3 $Dao = M(&quot;User&quot;); 4 5 // 查询数据 6 $list = $Dao-&gt;select(); 7 //dump($list); // 用 dump() 可以在调试阶段查看数据是否已读取 8 9 // 模板变量赋值10 $this-&gt;assign(&quot;list&quot;, $list);11 // 输出模板12 $this-&gt;display();13 &#125;14 15 //模板html16 &lt;table border=&quot;1&quot;&gt;17 &lt;tr&gt;18 &lt;th width=&quot;10%&quot;&gt;ID&lt;/th&gt;19 &lt;th width=&quot;30%&quot;&gt;用户名&lt;/th&gt;20 &lt;th width=&quot;30%&quot;&gt;电子邮件&lt;/th&gt;21 &lt;th&gt;注册时间&lt;/th&gt;22 &lt;/tr&gt;23 &lt;volist name=&quot;list&quot; id=&quot;vo&quot;&gt;//循环显示24 &lt;tr&gt;25 &lt;td align=&quot;center&quot;&gt;&#123;$vo[&#x27;uid&#x27;]&#125;&lt;/td&gt;26 &lt;td&gt;&#123;$vo[&#x27;username&#x27;]&#125;&lt;/td&gt;27 &lt;td&gt;&#123;$vo[&#x27;email&#x27;]&#125;&lt;/td&gt;28 &lt;td&gt;&#123;$vo[&#x27;regdate&#x27;]|date=&#x27;Y-m-d H:i&#x27;,###&#125;&lt;/td&gt;29 &lt;/tr&gt;30 &lt;/volist&gt;31 &lt;/table&gt; 2）find该方法是和 select() 用法类似的一个方法，不同之处 find() 查询出来的始终只有一条数据，即系统自动加上了 LIMIT 1 限制。 12345678910111213141516 1 //当确认查询的数据记录只能是一条记录时，建议使用 find() 方法查询，如用户登录账号检测： 2 3 public function chekUser()&#123; 4 header(&quot;Content-Type:text/html; charset=utf-8&quot;); 5 $Dao = M(&quot;User&quot;); 6 7 // 构造查询条件 8 $condition[&#x27;username&#x27;] = &#x27;Admin&#x27;; 9 $condition[&#x27;password&#x27;] = MD5(&#x27;123456&#x27;);10 // 查询数据11 $list = $Dao-&gt;where($condition)-&gt;find();12 &#125;13 14 //与 select() 的另一个不同之处在于，find() 返回的是一个一维数组，可以在模板里直接输出数组单元的值而无需使用 volist 等标签循环输出：15 16 &lt;p&gt;&#123;$list[&#x27;username&#x27;]&#125;&lt;/p&gt; 3）getBy动态查询是一个魔术方法，可以根据某个字段名称动态得到对应的一条数据记录。 12345671 public function chekUser()&#123;2 header(&quot;Content-Type:text/html; charset=utf-8&quot;);3 $Dao = M(&quot;User&quot;);4 5 // 查询数据6 $user = $Dao-&gt;getByUsername(&#x27;Admin&#x27;);7 &#125; 等同于SQL语句： 1SELECT * FROM user WHERE username = &#x27;Admin&#x27; LIMIT 1 提示： 请注意，在getBy之后紧跟着的字段名称，首字母必须大写。对于如 user_name 这样的字段名称，以驼峰法自动识别下划线，即： 1$user = $Dao-&gt;getByUserName(&#x27;Admin&#x27;); 实际使用中可以灵活根据查询的字段名来定义 getBy 放入，如：getByEmail、getByTitle、getById 等。 4）getField是专门用于获取某个字段的值或者多个字段的索引数组。该方法与 field方法 不同，是一个独立的方法而不需要再使用 find 或者 select 。 参数 说明 fields 必须，需要查询的字段名称，可以是一个或多个字段 condition 可选，查询条件，可以是字符或数组，参考 select 方法查询条件 spea 可选，多个字段数据生成关联数组时，数据间隔符号，默认为空格 1234567891011121314 1 public function select()&#123; 2 header(&quot;Content-Type:text/html; charset=utf-8&quot;); 3 $Dao = M(&quot;User&quot;); 4 $list = $Dao-&gt;getField(&#x27;uid,username,email&#x27;,&#x27;uid &lt; 4&#x27;,&#x27;|&#x27;); 5 dump($list); 6 &#125; 7 8 //dump 打印出的结果是： 9 10 array(3) &#123;11 [1] =&gt; string(21) &quot;admin|admin@5idev.com&quot;12 [2] =&gt; string(23) &quot;小明|xiaoming@163.com&quot;13 [3] =&gt; string(19) &quot;Jack|jack@gmail.com&quot;14 &#125; 5）区间查询取得符合查询条件的区间记录 1234567891011 1 public function read()&#123; 2 $Dao = M(&#x27;User&#x27;); 3 $condition[&#x27;uid&#x27;] = array(array(&#x27;gt&#x27;,1),array(&#x27;lt&#x27;,5));//(uid &gt; 1) AND (uid &lt; 5)3.1 $condition[&#x27;uid&#x27;] = array(array(&#x27;gt&#x27;,3),array(&#x27;lt&#x27;,10), &#x27;or&#x27;);//(uid &lt; 1) OR (uid &gt; 10)3.2 $condition[&#x27;username&#x27;] = array(array(&#x27;like&#x27;,&#x27;%a%&#x27;), array(&#x27;like&#x27;,&#x27;%b%&#x27;), &#x27;Admin&#x27;,&#x27;or&#x27;);//(username LIKE &#x27;%a%&#x27;) OR (username LIKE &#x27;%b%&#x27;) OR (username = &#x27;Admin&#x27;) 4 $list = $Dao-&gt;where($condition)-&gt;select(); 5 if($list)&#123; 6 $this-&gt;assign(&#x27;list&#x27;, $list); 7 $this-&gt;display(); 8 &#125; else &#123; 9 $this-&gt;error($Dao-&gt;getError());10 &#125;11 &#125; 等同于SQL语句： 1SELECT * FROM user WHERE ( (uid &gt; 1) AND (uid &lt; 5) ); 6）原生SQL查询尽管ThinkPHP内置了大量的数据操作方法，但ThinkPHP仍保留了对原生SQL查询的支持，以便满足复杂查询的需要和一些特殊的数据操作。SQL查询的返回值是直接返回DB类的查询结果，没有做任何的处理，而且可以支持查询缓存。 原生SQL查询有 query() 和 execute() 两个方法： 123456789101112131415161718192021222324252627 1 //query() 方法是用于 SQL 查询操作，和select()方法一样返回符合查询条件的数据集。 2 //对于 query() 方法返回的数据集，跟 select() 一样，可以在模板里直接循环输出。 3 public function read()&#123; 4 // 实例化一个空模型，没有对应任何数据表 5 $Dao = M(); 6 //或者使用 $Dao = new Model(); 7 8 $list = $Dao-&gt;query(&quot;select * from user where uid&lt;5&quot;); 9 if($list)&#123;10 $this-&gt;assign(&#x27;list&#x27;, $list );11 $this-&gt;display();12 &#125; else &#123;13 $this-&gt;error($Dao-&gt;getError());14 &#125;15 &#125;16 17 18 //execute() 方法用于更新和写入数据的 SQL 操作（注：非查询操作，无返回数据集），返回影响的记录数。19 20 public function read()&#123;21 header(&quot;Content-Type:text/html; charset=utf-8&quot;);22 // 实例化一个空模型，没有对应任何数据表23 $Dao = M();24 //或者使用 $Dao = new Model();25 26 $num = $Dao-&gt;execute(&quot;update user set email = &#x27;12345@xxx.com&#x27; where uid=3&quot;);27 &#125; 7）统计查询取得符合查询条件的统计数据 count()方法用于统计数据行数。 12345678910 1 public function read()&#123; 2 $Dao = M(&#x27;User&#x27;); 3 // 获取用户数： 4 $userCount = $Dao-&gt;count(); 5 // 添加条件： 6 $userCount2 = $Dao-&gt;where(&#x27;uid &gt; 10&#x27;)-&gt;count(); 7 8 $this-&gt;assign(&#x27;userCount&#x27;, $userCount); 9 $this-&gt;display();10 &#125;//可以在模板中直接输出得到的统计数据：共有用户 &#123;$userCount&#125; 人。 两个查询语句实际执行的 SQL 为： 121 SELECT COUNT(*) AS tp_count FROM user LIMIT 1 2 SELECT COUNT(*) AS tp_count FROM user WHERE uid &gt; 10 LIMIT 1 max()方法用于统计某个字段最大数据。 121 //统计用户最大积分例子：2 $maxScore = $Dao-&gt;max(&#x27;score&#x27;); 实际执行的 SQL 为： 1SELECT MAX(score) AS tp_max FROM user LIMIT 1 ; min()统计某个字段最小数据。 121 //获取积分大于 0 的用户的最小积分例子：2 $minScore = $Dao-&gt;where(&#x27;score&gt;0&#x27;)-&gt;min(&#x27;score&#x27;); 实际执行的 SQL 为： 1SELECT MIN(score) AS tp_min FROM user WHERE score&gt;0 LIMIT 1; avg()统计某个字段平均数据。 121 //获取用户的平均积分例子：2 $avgScore = $Dao-&gt;avg(&#x27;score&#x27;); 实际执行的 SQL 为： 1SELECT AVG(score) AS tp_avg FROM user LIMIT 1; sum()统计某个字段数据之和。 121 //统计积分排名前 10 名用户的积分之和：2 $sumScore = $Dao-&gt;order(&#x27;score DESC&#x27;)-&gt;limit(&#x27;10&#x27;)-&gt;sum(&#x27;score&#x27;); 实际执行的 SQL 为： 1SELECT SUM(score) AS tp_sum FROM user ORDER BY score DESC LIMIT 10; 5.软删除123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293Login.php&lt;?phpnamespace app\\index\\controller;use think\\Controller;use Gregwar\\Captcha\\CaptchaBuilder;use think\\Loader;use app\\index\\model\\Data;use think\\Db;class Login extends Controller&#123;public function _initialize()&#123;//parent::__construct();$this-&gt;data = Loader::model(&#x27;data&#x27;);&#125;public function delData()&#123;//删除id=16的记录$res = Data::destroy(16);//返回int(1)受影响记录数量dump($res);&#125;//删除后进行查询验证public function selData()&#123;//返回为null，表示删除成功//dump(Data::get(16));$res = Data::select();foreach ($res as $k =&gt; $v) &#123;//getData()函数可以获取对象里面的数据dump($v-&gt;getData());&#125;&#125;//默认情况下，查询到的数据不包含软删除数据，如果需要包含软删除的数据public function selData1()&#123;//查询单条数据$res = Data::withTrashed(true)-&gt;find();dump($res-&gt;getData());//查询多条数据$res = Data::withTrashed(true)-&gt;select();foreach ($res as $k =&gt; $v) &#123;dump($v-&gt;getData());&#125;&#125;//如果只想删除软删除的数据，相当于查看回收站public function selData2()&#123;//单条数据$res = Data::onlyTrashed(true)-&gt;find();dump($res-&gt;getData());//多条数据$res = Data::onlyTrashed(true)-&gt;select();foreach ($res as $key =&gt; $val) &#123;dump($val-&gt;getData());&#125;&#125; //恢复软删除记录//控制器中将被软删除的delete_time更新为null即可public function selData3()&#123;$res = Data::update([&#x27;delete_time&#x27; =&gt; null,], [&#x27;id&#x27; =&gt; 16]);dump($res);//现在就可以获取重新被软删除的记录了$res = Data::get(16);dump($res-&gt;getData());&#125; //物理删除是指彻底将该记录从表中移除，不可恢复。给destroy()方法传入第二个参数truepublic function delReal()&#123;//删除id为16的记录$res = Data::destroy(16, true);dump($res);//使用delete(true)实现物理删除$res = Data::where(&#x27;id&#x27;, 18)-&gt;delete();dump($res);&#125;&#125; Data.php 123456789101112131415161718192021222324Data.php&lt;?phpnamespace app\\index\\model;use think\\Db;use think\\Model;use traits\\model\\SoftDelete;class Data extends Model&#123;//在当前类导入，就可以使用其中的方法啦use SoftDelete;//如果你的字段名为框架默认的delete_time,可省略protected $deleteTime = &#x27;delete_time&#x27;;protected $table = &#x27;bbs_data&#x27;;public function getMenu()&#123;$res = Db::name($this-&gt;table)-&gt;select();return $res;&#125;&#125; 3.TP5框架model操作【增删改查、聚合、时间戳、软删除等 使用model 查询数据，添加数据，修改数据，删除数据 聚合操作 获取器，修改器 自动添加时间戳（创建时间，修改时间） 软删除 1、使用model查询数据12345$res = User::get(1); //获取主键为1的数据，得到的是一个对象 $res = $res- toArray(); //将对象转化为数组 dump($res- name); //获取 $res 里 name 字段的值 12345//使用闭包函数查询 id=1 的记录$res = User::get(function($query)&#123; $query- where(&quot;id&quot;,&quot;eq&quot;,1) - field(&#x27;name&#x27;)&#125;); 12345$res = User::where(&quot;id&quot;,10)- value(&#x27;name&#x27;);$res = User::where(&quot;id&quot;,10)- field(&#x27;name&#x27;)- find(); $res = User::column(&#x27;email&#x27;); //查询所有的 email 字段值 $res = User::where(&quot;id&quot;,&quot; &quot;,5)- select(); //查询所有id大于5的记录 12345$res = User::all(&#x27;1,2&#x27;); //查询主键等于 1 或2 的记录foreach($res as $val) //转化为数组&#123; dump($val- toArray());&#125; 12345//使用闭包函数查询 id&lt;5 的记录$res = User::get(function($query)&#123; $query- where(&quot;id&quot;,&quot;&lt;&quot;,5) - field(&#x27;name&#x27;)&#125;); 2、使用model添加数据1234567$res = User::create([ &#x27;name&#x27; = &#x27;yulong&#x27;, &#x27;pwd&#x27; = &#x27;123&#x27;],true); //第二个参数为true时，只添加数据表中已有的字段，不报错，不写则默认为false；；；true 也可以换成一个数组，数组里存放数据表中的字段，表示仅允许数组中的字段添加数据$res- id; //本次添加的自增iddump($res); 123456789$usermodel = new User;$res = $usermodel - allowField(true) //仅允许添加数据表中存在的字段，也可以写成数组 - save([ &#x27;name&#x27; = &#x27;yulong&#x27;, &#x27;pwd&#x27; = &#x27;123&#x27; ]); dump($res- id); //获取新添加数据的自增id 1234567$usermodel = new User;$res = $usermodel- saveAll([ //一次保存多条数据 &#x27;name&#x27; = &#x27;yulong001&#x27;, &#x27;name&#x27; = &#x27;yulong002&#x27;]); dump($ers); 3、使用model更新数据123456789101112$res = User::update([ &#x27;name&#x27; = &#x27;yulong002&#x27;],[&#x27;id&#x27;= 1]); //更新 id=1 的记录 $res = User::update([ &#x27;name&#x27; = &#x27;yulong002&#x27;],function()&#123; $query- where(&quot;id&quot;,&quot;LT&quot;,5); //使用闭包函数更新 id&lt;5 的记录&#125;); dump($res); 1234$res = User::where(&quot;id&quot;,&quot;&lt;&quot;,6) //返回值是被更新数据的行数 - update([ &#x27;name&#x27; = &#x27;hahahaha&#x27; ]); 4、使用model删除数据12345678910$res = User::destriy(1); //删除主键为1的记录，返回影响数据的行数，也可以传递数组 $usermodel = User::get(1);$res = $usermodel- delete(); $res = User::where(&quot;id&quot;,5)- delete(); // where() 里面有三个参数， 字段值，条件，数值 dump($res); 5、使用model聚合操作12345$res = User::where(&quot;id&quot;,&quot; &quot;,5)- count(); //查询id大于5的记录条数 // max 可以换成其他的 如 min / sum / avg$res = User::max(&#x27;num&#x27;); //查询 num 字段中的最大值$res = User::where(&quot;id&quot;,&quot;&lt;&quot;,5)- max(&#x27;num&#x27;); //id&lt;5 的记录中的 num 最大值 6、使用模型获取器1234567891011121314151617//model //方法名： get字段名Attr//controller中获取原始数据使用 $res- getData() public function getSexSttr($val)&#123; switch($val)&#123; case &#x27;1&#x27;: return &quot;男&quot;; break; case &#x27;2&#x27;; return &#x27;女&#x27;; break; default: return &#x27;未知&#x27;; break; &#125;&#125; 7、使用模型修改器12345678910//model 修改器命名 set字段名Attr//修改器作用：在往数据库添加字段时，控制器中写未处理的数据，在模型中的修改器中写处理数据的方法，这样添加到数据库中的数据就是处理过得数据了public function setPwdAttr($val)&#123; return md5($val);&#125; // $val代表 pwd 字段，$data代表接收到的所有数据 ，返回的值就是 pwd+email public function setPwdAttr($val,$data)&#123; return $val.$data[&#x27;email&#x27;];&#125; 8、自动往[数据库]中添加时间戳12345678910111213141516//自动往 time 字段中加入时间戳public function setTimeAttr()&#123; return time();&#125; //在数据添加时发生改变protected $insert = [ &#x27;time_insert&#x27; ]; //设置字段public function setTimeInsertAttr()&#123; //将字段值设置为当前时间 return time();&#125; //在更新数据时发生改变protected $update = [ &#x27;time_update&#x27; ]; //设置字段public function setTimeUpdateAttr()&#123; //将字段值设置为当前时间 return time();&#125; 9、model时间戳 123456789// 数据库中的字段 create_time update_time// database.php 中更改配置 &#x27;auto_timeStamp&#x27; = true// 不推荐使用此方法，因为如果你的数据库表中没有 对应的字段 ，程序可能就会报错// 可以单独在 某个模型中 添加属性 protected $autoWriteTimeStamp = true; //开启自动加入时间戳 protected $createTime = &#x27;create_at&#x27;; //设置 创建的时候写入 的字段 ，值可以为false，关闭操作protedted $updateTime = &#x27;update_at&#x27;; //设置 创建和更新的时候写入 的字段 ，值可以为false，关闭操作 10、软删除 12345678910111213141516171819202122// model// 数据表中的字段 delete_time，默认值可以为 null use traits\\model\\SoftDelete; //使用软删除的类 class User extends Model&#123; use SoftDelete; //在类的开头 use SoftDelete; protected $deleteTime = &#x27;delete_at&#x27;; //设置软删除的字段，默认为 delete_time&#125; $res = User::destroy(3,true); //删除主键为3的记录，第二个参数为 true 时，不是软删除，是tm真删了 $ress = User::get(4);$res = $ress- delete(true); // delete() 没值时，为软删除；值为true，tm的真删 // controller 获取到 软删除 的记录$res = User::withTrashed(true)- find(1); //得到id为1 的经过软删除 删除的记录dump($res- getData()); //获取原始数据 $res = User::onlyTrashed()- select(); //获取所有软删除的数据 4.ThinkPHP 5 操作数据库三种方法一、原生的sql语句1. query：查询操作query简单粗暴的方法 1234public function getDetail($id)&#123; $data= Db::query(&#x27;select * from test&#x27;); return $data; &#125; 可以传参数；用占位符或者命名占位符绑定 1234public function getDetail($id)&#123; $data= Db::query(&#x27;select * from test where id=?&#x27;,[$id]); return $data; &#125; 2. execute：写入操作execute 插入数据，返回值是影响的记录数 12$data= Db::execute(&#x27;insert into test (name) values (?)&#x27;,[&#x27;thinkphp&#x27;]); return $data; 二、使用查询构建器备注：TP5框架有助手函数Db::table(‘user’) 相当于 db(‘user’) 1.find、selectfind()只能返回第一条数据（建议单个查询使用）；select()是把所有符合的查询出来细节： find 方法查询结果不存在，返回 nullselect 方法查询结果不存在，返回空数组 12345678//链式表达式 //链式操作where(&#x27;字段名&#x27;,&#x27;表达式&#x27;,&#x27;查询条件&#x27;)//这里的等号可以缺审$data=Db::table(&#x27;test&#x27;)-&gt;where(&#x27;id&#x27;,1)-&gt;find();$data=Db::table(&#x27;test&#x27;)-&gt;select();//助手函数$data =db(&#x27;test&#x27;)-&gt;where(&#x27;id&#x27;,1)-&gt;find();$data =db(&#x27;test&#x27;)-&gt;select(); 2.insert update 方法返回影响数据的条数，没修改任何数据返回 0 123456789101112131415//插入单条数据 $aa = [&#x27;name&#x27; =&gt; &#x27;good&#x27;]; $data=Db::table(&#x27;test&#x27;)-&gt;insert($aa);//插入多条数据 $bb = [ [&#x27;name&#x27; =&gt; &#x27;bb&#x27;], [&#x27;name&#x27; =&gt; &#x27;cc&#x27;], [&#x27;name&#x27; =&gt; &#x27;dd&#x27;], ]; $data = Db::table(&#x27;test&#x27;)-&gt;insertAll($bb);//函数助手// 添加单条数据 db(&#x27;user&#x27;)-&gt;insert($aa);// 添加多条数据 db(&#x27;user&#x27;)-&gt;insertAll($bb); 3.update1234//更新某一条记录 $data = Db::table(&#x27;test&#x27;)-&gt;where(&#x27;id&#x27;,1)-&gt;update([&#x27;name&#x27;=&gt;&#x27;老张&#x27;]);//更新某条记录的某个字段的值： $data=Db::table(&#x27;test&#x27;)-&gt;where(&#x27;id&#x27;,2)-&gt;setField(&#x27;name&#x27;, &#x27;老四&#x27;); 4.delete delete 方法返回影响数据的条数，没有删除返回 0 1234// 根据主键删除 $data=Db::table(&#x27;test&#x27;)-&gt;delete(6);//可以传入数组，进行批量删除 $data=Db::table(&#x27;test&#x27;)-&gt;delete([7,8]); 5.自增或自减一个字段的值自增或自减一个字段的值setInc&#x2F;setDec 如不加第二个参数，默认值为1；第三个参数是延迟时间，单位秒 12345678// score 字段加 1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;id&#x27;, 1)-&gt;setInc(&#x27;score&#x27;);// score 字段加 5Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;id&#x27;, 1)-&gt;setInc(&#x27;score&#x27;, 5);// score 字段减 1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;id&#x27;, 1)-&gt;setDec(&#x27;score&#x27;);//延迟更新，第三个参数是时间单位秒Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;id&#x27;, 1)-&gt;setInc(&#x27;score&#x27;, 1, 10); 6.使用Query或闭包查询12345678910使用查询对象进行查询$query = new \\think\\db\\Query();$query-&gt;table(&#x27;think_user&#x27;)-&gt;where(&#x27;status&#x27;,1);Db::find($query);Db::select($query);//使用闭包函数查询Db::select(function($query)&#123; $query-&gt;table(&#x27;think_user&#x27;)-&gt;where(&#x27;status&#x27;,1);&#125;); 7.查询表达式 where(‘字段名’,‘表达式’,‘查询条件’);whereOr(‘字段名’,‘表达式’,‘查询条件’);表达式不分大小写，支持的查询表达式有下面几种，分别表示的含义是： 表达式 含义 EQ、&#x3D; 等于（&#x3D;） NEQ、&lt;&gt; 不等于（&lt;&gt;） GT、&gt; 大于（&gt;） EGT、&gt;&#x3D; 大于等于（&gt;&#x3D;） LT、&lt; 小于（&lt;） ELT、&lt;&#x3D; 小于等于（&lt;&#x3D;） LIKE 模糊查询 [NOT] BETWEEN （不在）区间查询 [NOT] IN （不在）IN 查询 [NOT] NULL 查询字段是否（不）是NULL [NOT] EXISTS EXISTS查询 EXP 表达式查询，支持SQL语法 &gt; time 时间比较 &lt; time 时间比较 between time 时间比较 notbetween time 时间比较 显示简略信息 8.链式操作 操作名称 所有的连贯操作都返回当前的模型实例对象（this），其中带*标识的表示支持多次调用。 连贯操作 作用 支持的参数类型 where* 用于AND查询 字符串、数组和对象 whereOr* 用于OR查询 字符串、数组和对象 wheretime* 用于时间日期的快捷查询 字符串 table 用于定义要操作的数据表名称 字符串和数组 alias 用于给当前数据表定义别名 字符串 field* 用于定义要查询的字段（支持字段排除） 字符串和数组 order* 用于对结果排序 字符串和数组 limit 用于限制查询结果数量 字符串和数字 page 用于查询分页（内部会转换成limit） 字符串和数字 group 用于对查询的group支持 字符串 having 用于对查询的having支持 字符串 join* 用于对查询的join支持 字符串和数组 union* 用于对查询的union支持 字符串、数组和对象 view* 用于视图查询 字符串、数组 distinct 用于查询的distinct支持 布尔值 lock 用于数据库的锁机制 布尔值 cache 用于查询缓存 支持多个参数 relation* 用于关联查询 字符串 with* 用于关联预载入 字符串、数组 bind* 用于数据绑定操作 数组或多个参数 comment 用于SQL注释 字符串 force 用于数据集的强制索引 字符串 master 用于设置主服务器读取数据 布尔值 strict 用于设置是否严格检测字段名是否存在 布尔值 sequence 用于设置Pgsql的自增序列名 字符串 failException 用于设置没有查询到数据是否抛出异常 布尔值 partition 用于设置分表信息 数组 字符串 三、模型ORM1.定义 默认主键为自动识别，如果需要指定，可以设置属性： protected $pk = &#39;uid&#39;; 2.引用+获取数据 (get 、all)获取单个数据1234567891011//引用use app\\index\\model\\Test as TestModel;//获取主键为1的数据 $data = TestModel::get(1);//数组的方法 $data = TestModel::get([&#x27;id&#x27;=&gt;1]);//闭包的方法 $data = TestModel::get(function($query)&#123; $query-&gt;where(&#x27;id&#x27;, 1); &#125;); 获取多个数据12345678910111213141516171819202122//引用use app\\index\\model\\Test as TestModel;//获取所有数据 $data =TestModel::all();// 根据主键获取多个数据$list = User::all(&#x27;1,2,3&#x27;);// 或者使用数组$list = User::all([1,2,3]);foreach($list as $key=&gt;$user)&#123; echo $user-&gt;name;&#125;// 使用数组查询$list = User::all([&#x27;status&#x27;=&gt;1]);// 使用闭包查询$list = User::all(function($query)&#123; $query-&gt;where(&#x27;status&#x27;, 1)-&gt;limit(3)-&gt;order(&#x27;id&#x27;, &#x27;asc&#x27;);&#125;);foreach($list as $key=&gt;$user)&#123; echo $user-&gt;name;&#125; 实例化的方法1234567$user = new Test(); // 查询单个数据 $data=$user-&gt;where(&#x27;id&#x27;, 1) -&gt;find(); return $data; &#125; 3.新增（save、saveAll）新增一条1234567891011121314151617//新增一条$test = new Test;$test-&gt;name = &#x27;thinkphp&#x27;;$test-&gt;save();//data数组批量赋值$test = new Test;$test-&gt;data([ &#x27;name&#x27; =&gt; &#x27;thinkphp&#x27;,]);$test-&gt;save();//直接在实例化的时候传入数据$test = new Test([ &#x27;name&#x27; =&gt; &#x27;thinkphp&#x27;,]);$test-&gt;save(); 批量新增123456$test = new Test;$list = [ [&#x27;name&#x27;=&gt;&#x27;thinkphp&#x27;], [&#x27;name&#x27;=&gt;&#x27;onethink&#x27;]];$test-&gt;saveAll($list); 4.更新（save、saveAll、update）查询与更新123456789101112//在取出数据后，更改字段内容后更新数据。$test = new Test;$test= Test::get(1);$test-&gt;name = &#x27;thinkphp&#x27;;$test-&gt;save();//也可以直接带更新条件来更新数据$test = new Test;// save方法第二个参数为更新条件$test-&gt;save([ &#x27;name&#x27; =&gt; &#x27;thinkphp&#x27;,],[&#x27;id&#x27; =&gt; 1]); 批量更新 批量更新仅能根据主键值进行更新，其它情况请使用foreach遍历更新。 123456$test = new Test;$list = [ [&#x27;id&#x27;=&gt;1, &#x27;name&#x27;=&gt;&#x27;thinkphp&#x27;], [&#x27;id&#x27;=&gt;2, &#x27;name&#x27;=&gt;&#x27;onethink&#x27;]];$test-&gt;saveAll($list); 静态方法更新1234567$data=Test::where(&#x27;id&#x27;, 1) -&gt;update([&#x27;name&#x27; =&gt; &#x27;thinkphp&#x27;]);//$data是受影响行数//或者使用：$data=Test::update([&#x27;id&#x27; =&gt; 1, &#x27;name&#x27; =&gt; &#x27;thinkphp&#x27;]);//$data返回结果集 5.删除（delete、destroy）1234567891011121314151617//delete方法$data = Test::get(5);$data-&gt;delete();//根据主键删除//或者直接调用静态方法User::destroy(1);// 支持批量删除多个数据User::destroy(&#x27;1,2,3&#x27;);// 或者User::destroy([1,2,3]);//条件删除// 删除状态为0的数据User::destroy([&#x27;status&#x27; =&gt; 0]);//或者通过数据库类的查询条件删除User::where(&#x27;id&#x27;,&#x27;&gt;&#x27;,10)-&gt;delete(); V5.0.9+版本开始当destroy方法传入空值（包括空字符串和空数组）的时候不会做任何的数据删除操作，但传入0则是有效的"}],"posts":[{"title":"初创博客","slug":"hello-hexo","date":"2023-11-24T07:04:22.000Z","updated":"2023-11-24T11:04:33.446Z","comments":true,"path":"2023/11/24/hello-hexo/","permalink":"https://2486125878.github.io/2023/11/24/hello-hexo/","excerpt":"","text":"","categories":[],"tags":[{"name":"创建博客记录","slug":"创建博客记录","permalink":"https://2486125878.github.io/tags/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/"}]}],"categories":[],"tags":[{"name":"创建博客记录","slug":"创建博客记录","permalink":"https://2486125878.github.io/tags/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/"}]}