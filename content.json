{"meta":{"title":"凯瑟兰森","subtitle":"","description":"...","author":"凯瑟兰森","url":"https://2486125878.github.io","root":"/"},"pages":[{"title":"照片","date":"2024-03-14T09:43:03.000Z","updated":"2024-08-22T11:10:16.000Z","comments":true,"path":"Gallery/index.html","permalink":"https://2486125878.github.io/Gallery/index.html","excerpt":"","text":"壁紙收藏 收藏的一些壁纸，侵删 生活记录 相册是我快乐过的证据 素材收集 谁又不是在努力地活着 代码记录 代码人生中的青春"},{"title":"关于我","date":"2024-03-15T02:24:24.000Z","updated":"2024-08-25T08:47:37.675Z","comments":false,"path":"about/index.html","permalink":"https://2486125878.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-11-27T01:41:58.000Z","updated":"2024-03-13T08:16:28.000Z","comments":true,"path":"categories/index.html","permalink":"https://2486125878.github.io/categories/index.html","excerpt":"","text":""},{"title":"ThinkPHP5.0笔记","date":"2024-03-13T03:41:58.000Z","updated":"2024-03-13T03:51:20.000Z","comments":true,"path":"categories/thinkphp.html","permalink":"https://2486125878.github.io/categories/thinkphp.html","excerpt":"","text":"ThinkPHP5.0Thinkphp5目录架构12345678910111213141516171819202122232425262728293031323334353637383940414243444546thinkphp 应用部署目录├─application 应用目录（可设置）│ ├─common 公共模块目录（可更改）│ ├─index 模块目录(可更改)│ │ ├─config.php 模块配置文件│ │ ├─common.php 模块函数文件│ │ ├─controller 控制器目录│ │ ├─model 模型目录│ │ ├─view 视图目录│ │ └─ ... 更多类库目录│ ├─command.php 命令行工具配置文件│ ├─common.php 应用公共（函数）文件│ ├─config.php 应用（公共）配置文件│ ├─database.php 数据库配置文件│ ├─tags.php 应用行为扩展定义文件│ └─route.php 路由配置文件├─extend 扩展类库目录（可定义）├─public WEB 部署目录（对外访问目录）│ ├─static 静态资源存放目录(css,js,image)│ ├─index.php 应用入口文件│ ├─router.php 快速测试文件│ └─.htaccess 用于 apache 的重写├─runtime 应用的运行时目录（可写，可设置）├─vendor 第三方类库目录（Composer）├─thinkphp 框架系统目录│ ├─lang 语言包目录│ ├─library 框架核心类库目录│ │ ├─think Think 类库包目录│ │ └─traits 系统 Traits 目录│ ├─tpl 系统模板目录│ ├─.htaccess 用于 apache 的重写│ ├─.travis.yml CI 定义文件│ ├─base.php 基础定义文件│ ├─composer.json composer 定义文件│ ├─console.php 控制台入口文件│ ├─convention.php 惯例配置文件│ ├─helper.php 助手函数文件（可选）│ ├─LICENSE.txt 授权说明文件│ ├─phpunit.xml 单元测试配置文件│ ├─README.md README 文件│ └─start.php 框架引导文件├─build.php 自动生成定义文件（参考）├─composer.json composer 定义文件├─LICENSE.txt 授权说明文件├─README.md README 文件├─think 命令行入口文件 命名空间规范应用类库的根命名空间统一为app(可以设置app_namespace配置参数更改)；例如：app\\index\\controller\\Index 和 app\\index\\model\\User 属性命名 类的命名采用驼峰法，并且首字母大写，例如User、UserType，默认不需要添加后缀，例如UserController应该直接命名为User; 在Thinkphp3中需要UserController等命名方式； 函数的命名使用小写和下划线（小写字母开头的方式），例如get_client_ip ; 方法的命名使用驼峰法，并且首字母小写，例如getUserName ; 属性的命名使用驼峰法，并且首字母小写，例如tableName 、 instance 变量类型方法 方法 描述 param 获取当前请求的变量 get 获取 $_GET 变量 post 获取 $_POST 变量 put 获取 $_PUT 变量 delete 获取 $_DELETE 变量 session 获取 $_SESSION 变量 cookie 获取 $_COOKIE 变量 request 获取 $_REQUEST 变量 server 获取 $_SERVER 变量 env 获取 $_ENV 变量 route 获取 路由（包括PATHINFO） 变量 file 获取 $_FILE 变量 获取PARAM参数12345input(&#x27;param.name&#x27;); // 获取单个参数input(&#x27;param.&#x27;); // 获取全部参数// 下面是等效的input(&#x27;name&#x27;); input(&#x27;&#x27;); Thinkphp5目录架构#12345678910111213141516171819202122232425262728293031323334353637383940414243444546thinkphp 应用部署目录├─application 应用目录（可设置）│ ├─common 公共模块目录（可更改）│ ├─index 模块目录(可更改)│ │ ├─config.php 模块配置文件│ │ ├─common.php 模块函数文件│ │ ├─controller 控制器目录│ │ ├─model 模型目录│ │ ├─view 视图目录│ │ └─ ... 更多类库目录│ ├─command.php 命令行工具配置文件│ ├─common.php 应用公共（函数）文件│ ├─config.php 应用（公共）配置文件│ ├─database.php 数据库配置文件│ ├─tags.php 应用行为扩展定义文件│ └─route.php 路由配置文件├─extend 扩展类库目录（可定义）├─public WEB 部署目录（对外访问目录）│ ├─static 静态资源存放目录(css,js,image)│ ├─index.php 应用入口文件│ ├─router.php 快速测试文件│ └─.htaccess 用于 apache 的重写├─runtime 应用的运行时目录（可写，可设置）├─vendor 第三方类库目录（Composer）├─thinkphp 框架系统目录│ ├─lang 语言包目录│ ├─library 框架核心类库目录│ │ ├─think Think 类库包目录│ │ └─traits 系统 Traits 目录│ ├─tpl 系统模板目录│ ├─.htaccess 用于 apache 的重写│ ├─.travis.yml CI 定义文件│ ├─base.php 基础定义文件│ ├─composer.json composer 定义文件│ ├─console.php 控制台入口文件│ ├─convention.php 惯例配置文件│ ├─helper.php 助手函数文件（可选）│ ├─LICENSE.txt 授权说明文件│ ├─phpunit.xml 单元测试配置文件│ ├─README.md README 文件│ └─start.php 框架引导文件├─build.php 自动生成定义文件（参考）├─composer.json composer 定义文件├─LICENSE.txt 授权说明文件├─README.md README 文件├─think 命令行入口文件 规范# ThinkPHP5.0的URl访问受路由决定，如果关闭路由或者没有匹配路由的情况下，则是基于： http://serverName/index.php(或者其他应用入口文件，可省略) &#x2F;模块&#x2F; 控制器&#x2F;操作 &#x2F; 参数 &#x2F;值 在Thinkphp5.0框架中，在url地址栏里面如果不写模块、控制器和操作名，默认访问的就是index模块下面的index控制器下面的index操作，可以在config.php文件中进行修改。 入口文件# 用户请求的PHP文件，负责处理一个请求（注意，不一定是URL请求）的生命周期，最常见的入口文件就是index.php, 有时候也会为了某些特殊的需求而增加新的入口文件，例如给后台模块单独设置的一个入口文件admin.php或者一个控制器程序入口think都属于入口文件。 命名空间规范#应用类库的根命名空间统一为app(可以设置app_namespace配置参数更改)；例如：app\\index\\controller\\Index 和 app\\index\\model\\User; 属性命名# 类的命名采用驼峰法，并且首字母大写，例如User、UserType，默认不需要添加后缀，例如UserController应该直接命名为User; 在Thinkphp3中需要UserController等命名方式； 函数的命名使用小写和下划线（小写字母开头的方式），例如get_client_ip ; 方法的命名使用驼峰法，并且首字母小写，例如getUserName ; 属性的命名使用驼峰法，并且首字母小写，例如tableName 、 instance; 应用类库命名空间规范#应用类库的根命名空间统一为app(可以设置app_namespace配置参数更改)；例如：app\\index\\controller\\Index 和 app\\index\\model\\User; 请求#Thinkphp助手参数#判断变量是否定义12input(&#x27;?get.id&#x27;);input(&#x27;?post.name&#x27;); 变量类型方法: 方法 描述 param 获取当前请求的变量 get 获取 $_GET 变量 post 获取 $_POST 变量 put 获取 $_PUT 变量 delete 获取 $_DELETE 变量 session 获取 $_SESSION 变量 cookie 获取 $_COOKIE 变量 request 获取 $_REQUEST 变量 server 获取 $_SERVER 变量 env 获取 $_ENV 变量 route 获取 路由（包括PATHINFO） 变量 file 获取 $_FILE 变量 获取PARAM参数12345input(&#x27;param.name&#x27;); // 获取单个参数input(&#x27;param.&#x27;); // 获取全部参数// 下面是等效的input(&#x27;name&#x27;); input(&#x27;&#x27;); 获取GET参数123456// 获取单个变量input(&#x27;get.id&#x27;);// 使用过滤方法获取 默认为空字符串input(&#x27;get.name&#x27;);// 获取全部变量input(&#x27;get.&#x27;); 使用过滤方法123input(&#x27;get.name&#x27;,&#x27;&#x27;,&#x27;htmlspecialchars&#x27;); // 获取get变量 并用htmlspecialchars函数过滤input(&#x27;username&#x27;,&#x27;&#x27;,&#x27;strip_tags&#x27;); // 获取param变量 并用strip_tags函数过滤input(&#x27;post.name&#x27;,&#x27;&#x27;,&#x27;org\\Filter::safeHtml&#x27;); // 获取post变量 并用org\\Filter类的safeHtml方法过滤 使用变量修饰符1234input(&#x27;get.id/d&#x27;);input(&#x27;post.name/s&#x27;);input(&#x27;post.ids/a&#x27;); 修饰符 修饰符 作用 s 强制转换为字符串类型 d 强制转换为整形类型 b 强制转换为布尔类型 a 强制转换为数组类型 f 强制转换为浮点类型 请求Request对象的主要职责是统一和更安全地获取当前的请求信息，你需要避免直接操作 $_GET、$_POST、$_REQUEST、$_SESSION、$_COOKIE、$_FILES等全局变量， 而是统一使用Request对象提供的方法来获取请求变量。 ThinkPHP5的Request对象由think\\Request类完成。 $request &#x3D; Request::instance(); 也可以使用助手函数 $request = request(); 123`$request = Request::instance();`// 获取当前域名`echo &#x27;domain: &#x27; . $request-&gt;domain() . &#x27;&lt;br/&gt;&#x27;;` 方法 描述 param 获取当前请求的变量（自动识别GET、POST、PUT请求的一种变量获取方式，是系统推荐的获取请求参数方法） get 获取$_GET变量 post 获取$_POST变量 put 获取PUT变量 delete 获取DELETE变量 session 获取$_SESSION变量 cookie 获取$_COOKIE变量 request 获取$_REQUEST变量 server 获取$_SERVER变量 env 获取$_ENV变量 file 获取$_FILES变量 改变变量 如果需要更改请求变量的值，可以通过下面的方式： 更改GET变量 Request::instance()-&gt;get([&#39;id&#39;=&gt;10]); 更改POST变量 Request::instance()-&gt;post([&#39;name&#39;=&gt;&#39;thinkphp&#39;]); 尽量避免直接修改$_GET或者$_POST 数据,同时也不能直接修改param变量，例如下面的操作是无效的。 更改请求变量 Request::instance()-&gt;param([&#39;id&#39;=&gt;10]); 伪静态 URL伪静态通常是为了满足更好的SEO效果，ThinkPHP支持伪静态URL设置，可以通过设置url_html_suffix参数随意在URL的最后增加你想要的静态后缀，而不影响当前操作的正常执行。例如，我们设置 &#39;url_html_suffix&#39;=&gt;&#39;shtml&#39; 如果要获取当前的伪静态后缀，可以使用Request对象的ext方法。 路由路由功能由\\think\\Route类完成。 由于ThinkPHP5.0默认采用的URL规则是： 1http://server/module/controller/action/param/value/..... 路由的作用是简化URL访问地址，并根据定义的路由类型做出正确的解析。 路由模式ThinkPHP5.0的路由比较灵活，并且不需要强制定义，可以总结归纳为如下三种方式： 普通模式关闭路由，完全使用默认的PATH_INFO方式URL： 1url_route_on =&gt; false, 路由关闭后，不会解析任何路由规则，采用默认的PATH_INFO模式访问URL: 1http://serverName/index.php/module/controller/action/param/value/... 混合模式开启路由，并使用路由定义+默认PATH_INFO方式的混合: 12&#x27;url_route_on&#x27; =&gt; true,&#x27;url_route_must&#x27; =&gt; false, 该方式下面，只需要对需要定义路由规则的访问地址定义路由规则，其他的仍然按照第一种普通模式的PATH_INFO模式访问URL。 强制模式开启路由，并设置必须定义路由才能访问： 12url_route_on =&gt; true,url_route_must =&gt; true, 这种方式下面必须严格给每一个访问地址定义路由规则（包括首页），否则将抛出异常。 首页的路由规则采用/定义即可，例如下面把网站首页路由输出Hello,world!我们需要在route.php这个文件中配置路由，要使用官方的 use think\\Route 123Route::get(&#x27;/&#x27;,function()&#123; return &#x27;Hello,world!&#x27;;&#125;); 路由定义路由注册可以采用方法动态单个和批量注册，也可以直接定义路由定义文件的方式进行集中注册。 动态注册路由定义采用\\think\\Route类的rule方法注册，通常是在应用的路由配置文件 application/route.php进行注册，格式是： 1234567Route::rule(&#x27;路由表达式&#x27;，&#x27;路由地址&#x27;，&#x27;请求类型&#x27;，&#x27;路由参数（数组）&#x27;，&#x27;变量规则（数组）&#x27;);use think\\Route;// 注册路由到index模块的Index控制器的list操作Route::rule(&#x27;new/:id&#x27;,&#x27;index/Index/list&#x27;);//表示定义的路由规则在POST请求下才有效。注意：请求类型参数必须大写。Route::rule(&#x27;new/:id&#x27;,&#x27;News/update&#x27;,&#x27;POST&#x27;); 请求类型包括： 类型 GET GET请求 POST POST请求 PUT PUT请求 DELETE DELETE请求 * 任何请求类型 系统提供了为不同的请求类型定义路由规则的简化方法，例如：12345Route::get(&#x27;new/:id&#x27;,&#x27;News/read&#x27;); // 定义GET请求路由规则Route::post(&#x27;new/:id&#x27;,&#x27;News/update&#x27;); // 定义POST请求路由规则Route::put(&#x27;new/:id&#x27;,&#x27;News/update&#x27;); // 定义PUT请求路由规则Route::delete(&#x27;new/:id&#x27;,&#x27;News/delete&#x27;); // 定义DELETE请求路由规则Route::any(&#x27;new/:id&#x27;,&#x27;News/read&#x27;); // 所有请求都支持的路由规则 如果要定义get和post请求支持的路由规则，也可以用：1Route::rule(&#x27;new/:id&#x27;,&#x27;News/read&#x27;,&#x27;GET|POST&#x27;); 也可以批量注册路由规则123Route::rule([&#x27;new/:id&#x27;=&gt;&#x27;News/read&#x27;,&#x27;blog/:name&#x27;=&gt;&#x27;Blog/detail&#x27;]);Route::get([&#x27;new/:id&#x27;=&gt;&#x27;News/read&#x27;,&#x27;blog/:name&#x27;=&gt;&#x27;Blog/detail&#x27;]);Route::post([&#x27;new/:id&#x27;=&gt;&#x27;News/update&#x27;,&#x27;blog/:name&#x27;=&gt;&#x27;Blog/detail&#x27;]); 注册多个路由规则后，系统会依次遍历注册过的满足请求类型的路由规则，一旦匹配到正确的路由规则后则开始调用控制器的操作方法，后续规则就不再检测。定义路由配置文件除了支持动态注册，也可以直接在应用目录下面的route.php的最后通过返回数组的方式直接定义路由规则 1234return [ &#x27;new/:id&#x27; =&gt; &#x27;News/read&#x27;, &#x27;blog/:id&#x27; =&gt; [&#x27;Blog/update&#x27;,[&#x27;method&#x27; =&gt; &#x27;post|put&#x27;], [&#x27;id&#x27; =&gt; &#x27;\\d+&#x27;]],]; 路由动态注册和配置定义的方式可以并存。由于检测机制问题，动态注册的性能比路由配置要高一些，尤其是多种请求类型混合定义的时候。 默认情况下，只会加载一个路由配置文件route.php，如果需要定义多个路由文件，可以修改route_config_file的配置参数，例如： 12定义路由配置文件（数组）&#x27;route_config_file&#x27; =&gt; [&#x27;route&#x27;, &#x27;route1&#x27;, &#x27;route2&#x27;], 资源路由5.0支持设置RESTFul请求的资源路由，方式如下： Route::resource(‘blog’,’index&#x2F;blog’); 或者在路由配置文件中使用__rest__添加资源路由定义： 123456return [ // 定义资源路由 &#x27;__rest__&#x27;=&gt;[ // 指向index模块的blog控制器 &#x27;blog&#x27;=&gt;&#x27;index/blog&#x27;,], 设置过后会自动注册7个路由规则，如下： 标识 请求类型 生成路由规则 对应操作方法（默认） index GET blog index create GET blog/create create save POST blog save read GET blog/:id read edit GET blog/:id/edit edit update PUT blog/:id update delete DELETE blog/:id delete 具体指向的控制器由路由地址决定，例如上面的设置，会对应index模块的blog控制器，你只需要为Blog控制器创建以上对应的操作方法就可以支持下面的URL访问： 123http://serverName/blog/http://serverName/blog/128http://serverName/blog/28/edit Blog控制器中对应的方法如下: 12345678910111213141516namespace app\\index\\controller;class Blog &#123; public function index() &#123; dump(index); &#125; public function update($id) &#123; dump(update); &#125; public function delete($id) &#123; dump(delete); &#125;&#125; 快捷路由快捷路由允许你快速给控制器注册路由，并且针对不同的请求类型可以设置方法前缀 12// 给User控制器设置快捷路由Route::controller(&#x27;user&#x27;,&#x27;index/User&#x27;); User控制器定义如下： 12345678910111213141516171819namespace app\\index\\controller;class User &#123; public function getInfo() &#123; &#125; public function getPhone() &#123; &#125; public function postInfo() &#123; &#125; public function putInfo() &#123; &#125; public function deleteInfo() &#123; &#125;&#125; 我们可以通过下面的URL访问 12345get http://localhost/user/infoget http://localhost/user/phonepost http://localhost/user/infoput http://localhost/user/infodelete http://localhost/user/info 权限控制Base.php，需要鉴权继承该类即可 12345678910111213141516171819&lt;?phpnamespace app\\index\\controller;use think\\Controller;use think\\Request;class Base extends Controller&#123; //用来存放需要用户登录之后才能操作的方法的集合 protected $is_check_login = [&#x27;&#x27;]; public function _initialize() &#123; if (!$this-&gt;isLogin() &amp;&amp; (in_array(Request::instance()-&gt;action(), $this-&gt;is_check_login)||$this-&gt;is_check_login[0]==&#x27;*&#x27;))&#123; return $this-&gt;error(&#x27;请先登录系统！&#x27;,&#x27;index/Index/login&#x27;); &#125; &#125; public function isLogin() &#123; return session(&#x27;?name&#x27;); &#125;&#125; GoodsController,进行所有方法鉴权 123456789101112131415161718192021&lt;?phpnamespace app\\index\\controller;use app\\index\\controller\\Base;class Goods extends Base&#123; protected $is_check_login = [&#x27;*&#x27;]; public function add() &#123; echo &#x27;我想要购买商品&#x27;; &#125; public function edit() &#123; echo &#x27;我想退货&#x27;; &#125; public function delete() &#123; echo &#x27;我不想买了&#x27;; &#125;&#125; CommentController,仅对Add方法路由鉴权 1234567891011121314151617&lt;?phpnamespace app\\index\\controller;use app\\index\\controller\\Base;class Comment extends Base&#123; protected $is_check_login = [&#x27;add&#x27;]; public function add() &#123; echo &#x27;我想发表评论&#x27;; &#125; public function edit() &#123; echo &#x27;我想编辑一下自己的评论&#x27;; &#125;&#125; 数据库的操作ThinkPHP内置了抽象数据库访问层，把不同的数据库操作封装起来，我们只需要使用公共的Db类进行操作，而无需针对不同的数据库写不同的代码和底层实现，Db类会自动调用相应的数据库驱动来处理。采用PDO方式，目前包含了Mysql、SqlServer、PgSQL、Sqlite等数据库的支持。 1.基本使用配置了数据库连接信息后，我们就可以直接使用数据库运行原生SQL操作了，支持query（查询操作）和execute（写入操作）方法，并且支持参数绑定。 123456public function read()&#123; $sql = Db::query(&#x27;select * from news&#x27;); dump($sql); &#125; execute方法： 12345public function read()&#123; $sql = Db::execute(&#x27;insert into news (nid, rid) values (11, 11)&#x27;);; dump($sql);&#125; 也支持命名占位符绑定，例如： 12345public function read()&#123; $sql = Db::query(&#x27;select * from news where nid=:nid&#x27;,[&#x27;nid&#x27;=&gt;1]); dump($sql);&#125; execute方法： 12345public function read()&#123; $sql = Db::execute(&#x27;insert into news (nid, rid) values (:nid, :rid)&#x27;,[&#x27;nid&#x27;=&gt;18,&#x27;rid&#x27;=&gt;&#x27;121&#x27;]); dump($sql);&#125; 可以使用多个数据库连接: 2.查询构造器听名字就知道，很装X.. 先来看基本查询； 查询一个数据： 123// table方法必须指定完整的数据表名 $sql =Db::table(&#x27;news&#x27;)-&gt;where(&#x27;nid&#x27;,1)-&gt;find(); dump($sql); find &#x3D; 查询一条；并且查询结果不存在，返回 null 输出： 1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;status&#x27;,1)-&gt;select(); 这条查询语句与上面同效，但是select 方法查询结果不存在，返回空数组 额 这个玩意叫查询数据集，没错！ 默认情况下，find和select方法返回的都是数组。 如果你要查询某个字段的值，咋整？ 123456public function read()&#123;// 返回某个字段的值 $sql =Db::table(&#x27;news&#x27;)-&gt;where(&#x27;nid&#x27;,18)-&gt;value(&#x27;rid&#x27;); dump($sql);&#125; 这样看输出，我求rid的值： 如果你需要处理成千上百条数据库记录，可以考虑使用chunk方法，该方法一次获取结果集的一小块，然后填充每一小块数据到要处理的闭包，该方法在编写处理大量数据库记录的时候非常有用。 1234567891011public function read()&#123; $sql =Db::table(&#x27;news&#x27;)-&gt;chunk(1,function($user)&#123; foreach($user as $u) &#123;dump($u); &#125; &#125;); &#125; 这个样子 就可以一条一条都给遍历出来了！ 是“一条一条·”，嘿！ 3.添加数据跟删除数据使用 Db 类的 insert 方法向数据库提交数据 1234567public function read()&#123;$data = [&#x27;ntitle&#x27; =&gt; &#x27;123&#x27;, &#x27;rid&#x27; =&gt; &#x27;456&#x27;];$sql = Db::table(&#x27;news&#x27;)-&gt;insert($data); dump($sql);&#125; 添加成功后insert 方法返回添加成功的条数，insert 正常情况返回 1 添加数据后如果需要返回新增数据的自增主键，可以使用getLastInsID方法： 12345678public function read()&#123;$data = [&#x27;ntitle&#x27; =&gt; &#x27;123&#x27;, &#x27;rid&#x27; =&gt; &#x27;345&#x27;];$sql = Db::table(&#x27;news&#x27;)-&gt;insert($data);$userId = Db::name(&#x27;news&#x27;)-&gt;getLastInsID(&#x27;nid&#x27;);dump($userId);dump($sql);&#125; 添加多条数据: 添加多条数据直接向 Db 类的 insertAll 方法传入需要添加的数据即可; 12345678910public function read()&#123;$data = [[&#x27;ntitle&#x27; =&gt;&#x27;gaga&#x27;,&#x27;rid&#x27; =&gt; &#x27;12&#x27;],[&#x27;ntitle&#x27; =&gt;&#x27;gaaaga&#x27;,&#x27;rid&#x27; =&gt; &#x27;123&#x27;]];$sql = Db::table(&#x27;news&#x27;)-&gt;insertAll($data);dump($sql);&#125; 这样的话，返回的应该是两条2 删除数据： 根据主键来删除 12345678public function read()&#123;// 根据主键 来删$sql = Db::table(&#x27;news&#x27;)-&gt;delete(1);//多删//$sql = Db::table(&#x27;news&#x27;)-&gt;delete(1,2,3);dump($sql);&#125; 执行成功返回影响行数； 还有一种是根据条件来删除的 12345678public function read()&#123;// 根据条件 来删$sql = Db::table(&#x27;news&#x27;)-&gt;where(&#x27;nid&#x27;,18)-&gt;delete();//多删//$sql = Db::table(&#x27;news&#x27;)-&gt;where(&#x27;nid&#x27;,&#x27;&lt;&#x27;,1)-&gt;delete();dump($sql);&#125; 执行成功也是返回影响行数； 4.查询方法：where方法： 可以使用where方法进行AND条件查询： 12345678public function read()&#123;$sql = Db::table(&#x27;news&#x27;)-&gt;where(&#x27;nid&#x27;,20)-&gt;where(&#x27;ntitle&#x27;,123)-&gt;find();dump($sql);&#125; whereOr方法： 使用whereOr方法进行OR查询： 12345678public function read()&#123;$sql = Db::table(&#x27;news&#x27;)-&gt;where(&#x27;nid&#x27;,20)-&gt;whereOr(&#x27;ntitle&#x27;,&#x27;like&#x27;,&#x27;%123%&#x27;)-&gt;find();dump($sql);&#125; 混合查询： where方法和whereOr方法在复杂的查询条件中经常需要配合一起混合使用 12345678910111213public function read()&#123;$sql = Db::table(&#x27;news&#x27;)-&gt;where(function($query)&#123; $query-&gt;where(&#x27;nid&#x27;,21)-&gt;where(&#x27;nid&#x27;,22);&#125;)-&gt;whereOr(function($query)&#123; $query-&gt;where(&#x27;ntitle&#x27;,&#x27;123&#x27;)-&gt;whereOr(&#x27;ntitle&#x27;,&#x27;123&#x27;);&#125;)-&gt;select();dump($sql);&#125;"},{"title":"友链","date":"2024-03-14T08:55:22.000Z","updated":"2024-08-28T13:48:42.768Z","comments":true,"path":"link/index.html","permalink":"https://2486125878.github.io/link/index.html","excerpt":"","text":""},{"title":"thinkphp之SQL查询语句","date":"2023-03-13T03:50:58.000Z","updated":"2024-03-13T03:52:38.000Z","comments":true,"path":"categories/thinkphpsql.html","permalink":"https://2486125878.github.io/categories/thinkphpsql.html","excerpt":"","text":"1.thinkphp之SQL查询语句一：字符串条件查询12345//直接实例化Model$user=M(&#x27;user1&#x27;);var_dump($user-&gt;where (&#x27;id=1 OR age=55&#x27;)-&gt;select()); 最终生成的sql语句为：SELECT * FROM user1 WHERE ( id&#x3D;1 OR age&#x3D;55 ) PS:where 查询方法里面只要包含条件即可，多个条件加上 AND 等连接符即可 二：使用索引数组作为查询条件1234567891011$user=M(&#x27;user1&#x27;);$condition[&#x27;age&#x27;]=&#x27;55&#x27;;$condition[&#x27;name&#x27;]=&#x27;zs&#x27;;// 索引数组查询的默认逻辑关系是 AND，如果想改变为 OR，可以使用_logic 定义查询逻辑$condition[&#x27;_logic&#x27;] = &#x27;OR&#x27;;var_dump($user-&gt;where($condition)-&gt;select()); 最终生成的sql语句为：SELECT * FROM user1 WHERE id &#x3D; ‘1’ AND name &#x3D; ‘zs’ 三：使用对象方式查询123456789101112131415161718192021&lt;?phpnamespace Home\\Controller;use Think\\Controller;use Think\\stdClass;class EleController extends Controller&#123; $user=M(&#x27;user1&#x27;); $condition=new \\stdClass; $condition-&gt;id = &#x27;1&#x27;; var_dump($user-&gt;where($condition)-&gt;select());&#125; 最终生成的sql语句为：SELECT * FROM user1 WHERE id &#x3D; ‘1’ 四：表达式查询查询表达式格式：$map[‘字段名’] &#x3D; array(‘表达式’,’查询条件’); 12345$user=M(&#x27;user1&#x27;);$map[&#x27;age&#x27;] = array(&#x27;eq&#x27;, 55); //where 为 age=55var_dump($user-&gt;where($map)-&gt;select()); 五：快捷查询1234567891011121314151617//使用相同查询条件 $user = M(&#x27;user1&#x27;); $map[&#x27;name|email&#x27;] = &#x27;a&#x27;; //&#x27;|&#x27;换成&#x27;&amp;&#x27;变成AND var_dump($user-&gt;where($map)-&gt;select()); // 不同字段不同查询条件 //使用不同查询条件 $user = M(&#x27;user1&#x27;); $map[&#x27;name&amp;email&#x27;] =array(&#x27;a&#x27;,&#x27;test@qq.com&#x27;,&#x27;_multi&#x27;=&gt;true); var_dump($user-&gt;where($map)-&gt;select()); 第一条查询的结果：SELECT * FROM user1 WHERE ( name &#x3D; ‘a’ OR email &#x3D; ‘a’ ) 第二条查询的结果：SELECT * FROM user1 WHERE ( (name &#x3D; ‘a’) AND (email &#x3D; ‘&#x74;&#101;&#x73;&#x74;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#x6d;‘) ) 六：区间查询1234567891011121314151617// 区间查询 $user = M(&#x27;user1&#x27;); $map[&#x27;id&#x27;] = array(array(&#x27;gt&#x27;, 1), array(&#x27;lt&#x27;, 4)); var_dump($user-&gt;where($map)-&gt;select()); //第三个参数设置逻辑OR $user = M(&#x27;User1&#x27;); $map[&#x27;id&#x27;] = array(array(&#x27;gt&#x27;, 1), array(&#x27;lt&#x27;, 4), &#x27;OR&#x27;); var_dump($user-&gt;where($map)-&gt;select()&#125; 七：组合查询组合查询是基于索引数组查询方式的一个扩展性查询，添加了字符串查询(_string)、复合查询(_complex)、请求字符串查询(_query)，由于采用的是索引数组，重复的会被覆盖。 12345678910111213141516171819202122232425262728293031323334353637//字符串查询(_string) $user = M(&#x27;user1&#x27;); $map[&#x27;name&#x27;] = array(&#x27;eq&#x27;, &#x27;zs&#x27;); $map[&#x27;_string&#x27;] =&#x27;age=&quot;30&quot; AND email=&quot;zs@qq.com&quot;&#x27;; var_dump($user-&gt;where($map)-&gt;select()); //请求字符串查询(_query) $user = M(&#x27;user1&#x27;); $map[&#x27;id&#x27;] = array(&#x27;eq&#x27;, &quot;1&quot;); $map[&#x27;_query&#x27;] =&#x27;name=zs&amp;email=zs@qq.com&amp;_logic=OR&#x27;; var_dump($user-&gt;where($map)-&gt;select()); //复合查询(_complex) $user = M(&#x27;user1&#x27;); $where[&#x27;name&#x27;] = array(&#x27;like&#x27;, &#x27;z&#x27;); $where[&#x27;id&#x27;] = 1; $where[&#x27;_logic&#x27;] = &#x27;OR&#x27;; $map[&#x27;_complex&#x27;] = $where; $map[&#x27;id&#x27;] = 3; $map[&#x27;_logic&#x27;] = &#x27;OR&#x27;; var_dump($user-&gt;where($map)-&gt;select()); 第一条查询语句：SELECT * FROM user1 WHERE name &#x3D; ‘zs’ AND ( age&#x3D;”30” AND email&#x3D;”&#122;&#x73;&#64;&#x71;&#x71;&#x2e;&#99;&#111;&#109;“ ) 第二条查询语句：SELECT * FROM user1 WHERE name &#x3D; ‘zs’ AND ( age&#x3D;”30” AND email&#x3D;”&#x7a;&#x73;&#x40;&#113;&#x71;&#x2e;&#x63;&#111;&#109;“ ) AND ( name &#x3D; ‘zs’ OR email &#x3D; ‘&#x7a;&#115;&#64;&#x71;&#113;&#46;&#x63;&#x6f;&#109;‘ ) 第三条查询语句：SELECT * FROM user1 WHERE name &#x3D; ‘zs’ OR ( age&#x3D;”30” AND email&#x3D;”&#x7a;&#x73;&#x40;&#x71;&#x71;&#46;&#x63;&#x6f;&#109;“ ) OR ( name &#x3D; ‘zs’ OR email &#x3D; ‘&#122;&#115;&#x40;&#x71;&#x71;&#x2e;&#99;&#x6f;&#x6d;‘ ) OR ( name LIKE ‘z’ OR id &#x3D; 1 ) 八：统计查询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//数据总条数 //SHOW COLUMNS FROM `user1` $user = M(&#x27;user1&#x27;); var_dump($user-&gt;count()); //字段总条数，遇到NULL不统计 //SELECT COUNT(*) AS tp_count FROM `user1` LIMIT 1 $user = M(&#x27;user1&#x27;); var_dump($user-&gt;count(&#x27;email&#x27;)); //最大值 //SELECT MAX(id) AS tp_max FROM `user1` LIMIT 1 $user = M(&#x27;user1&#x27;); var_dump($user-&gt;max(&#x27;id&#x27;)); //最小值 //SELECT MIN(id) AS tp_min FROM `user1` LIMIT 1 $user = M(&#x27;user1&#x27;); var_dump($user-&gt;min(&#x27;id&#x27;)); //平均值 //SELECT AVG(id) AS tp_avg FROM `user1` LIMIT 1 $user = M(&#x27;user1&#x27;); var_dump($user-&gt;avg(&#x27;id&#x27;)); //求总和 //SELECT SUM(id) AS tp_sum FROM `user1` LIMIT 1 $user = M(&#x27;user1&#x27;); var_dump($user-&gt;sum(&#x27;id&#x27;)); 九：动态查询12345678910111213141516171819// 1.getBy 动态查询 //查找email=xiaoin@163.com的数据 //SELECT * FROM `user1` LIMIT 1 $user = M(&#x27;user1&#x27;); var_dump($user-&gt;getByemail(&#x27;zs@qq.com&#x27;)); // 2.getFieldBy 动态查询 //通过user得到相对应id值 //SELECT `id` FROM `user1` LIMIT 1 $user = M(&#x27;user1&#x27;); var_dump($user-&gt;getFieldByUser(&#x27;ls&#x27;, &#x27;id&#x27;)); 十：SQL查询12345678910111213141516171819202122 // 1.query 读取//查询结果集，如果采用分布式读写分离，则始终在读服务器执行//SELECT * FROM user1$user = M(&#x27;user1&#x27;);var_dump($user-&gt;query(&#x27;SELECT * FROM user1&#x27;));// 2.execute写入//更新和写入，如果采用分布式读写分离，则始终在写服务器执行//UPDATE user1 set name=&quot;xuexi&quot; WHERE id=&quot;1&quot;;$user = M(&#x27;user1&#x27;);var_dump($user-&gt;execute(&#x27;UPDATE user1 set name=&quot;xuexi&quot; WHERE id=&quot;1&quot;;&#x27;)); 十一：连贯查询 通过连贯操作可以有效的提供数据存取的代码清晰度和开发效率，并且支持所有的 CURD 操作 12345678910111213141516171819202122232425262728293031//连贯操作 //PS：这里的 where、order 和 limit 方法都是连贯操作方法，所以它们都能返回$user本身，可以互换位置。而 select 方法不是连贯方法，需要放在最后，用以显示数据集。 //SELECT * FROM `user1` WHERE ( id in (1,2,3,4) ) LIMIT 2 $user=M(&#x27;user1&#x27;); var_dump($user-&gt;where(&#x27;id in (1,2,3,4)&#x27;)-&gt;limit(2)-&gt;select()); //数组操作 //SELECT * FROM `user1` WHERE id in (1,2,3,4) LIMIT 2 $user = M(&#x27;user1&#x27;); var_dump($user-&gt;select(array(&#x27;where&#x27;=&gt;&#x27;id in (1,2,3,4)&#x27;, &#x27;limit&#x27;=&gt;&#x27;2&#x27;, ))); // CURD处理 // SELECT * FROM `user1` WHERE ( id=1 ) LIMIT 1 // DELETE FROM `user1` WHERE ( id=2 ) $user = M(&#x27;user1&#x27;); var_dump($user-&gt;where(&#x27;id=1&#x27;)-&gt;find()); var_dump($user-&gt;where(&#x27;id=2&#x27;)-&gt;delete()); 1.where(支持字符串条件、数组条件（推荐用法）和多次调用。)1234567891011121314151617181920212223242526//字符串方式 //SELECT * FROM `user1` WHERE ( id=6 ) var_dump($user-&gt;where(&#x27;id=6&#x27;)-&gt;select()); //索引数组方式 // SELECT * FROM `user1` WHERE `id` = 6 $map[&#x27;id&#x27;]=6; var_dump($user-&gt;where($map)-&gt;select()); //多次调用方式 SELECT * FROM `user1` WHERE `id` = 6 AND ( name=&quot;test&quot; ) $map[&#x27;id&#x27;]=array(&#x27;eq&#x27;,6); var_dump($user-&gt;where($map)-&gt;where(&#x27;name=&quot;test&quot;&#x27;)-&gt;select()); 2.order 用于对结果集排序1234567891011121314151617181920212223// 倒序 // SELECT * FROM `user1` ORDER BY id desc var_dump($user-&gt;order(&#x27;id desc&#x27;)-&gt;select()); // 第二排序 // SELECT * FROM `user1` ORDER BY id desc,age desc var_dump($user-&gt;order(&#x27;id desc,age desc&#x27;)-&gt;select()); //数组形式，防止字段和mysql关键字冲突 // SELECT * FROM `user1` ORDER BY `id` DESC,`email` DESC $map[&#x27;id&#x27;]=1; var_dump($user-&gt;order(array(&#x27;id&#x27;=&gt;&#x27;DESC&#x27;,&#x27;email&#x27;=&gt;&#x27;DESC&#x27;))-&gt;select()); 3.feild（feild 方法可以返回或操作字段，可以用于查询和写入操作。）123456789101112131415161718192021222324252627282930313233343536 // 只显示id和name两个字段 // SELECT `id`,`name` FROM `user1` var_dump($user-&gt;field(&#x27;id,name&#x27;)-&gt;select()); //使用SQL函数和别名 // SELECT SUM(id) as count,`name` FROM `user1` var_dump($user-&gt;field(&#x27;SUM(id) as count,name&#x27;)-&gt;select()); // 使用数组参数结合SQL函数 // SELECT `id`,LEFT(name,1) AS `left_user` FROM `user1` var_dump($user-&gt;field(array(&#x27;id&#x27;,&#x27;LEFT(name,1)&#x27;=&gt;&#x27;left_user&#x27;))-&gt;select()); //获取所有字段 // SELECT * FROM `user1` var_dump($user-&gt;field()-&gt;select()); //用于写入 $user-&gt;field(&#x27;name,email&#x27;)-&gt;create(); 4.limit（主要用于指定查询和操作的数量）12345678910111213//限制结果集数量 // SELECT * FROM `user1` LIMIT 2 var_dump($user-&gt;limit(2)-&gt;select()); //分页查询 // SELECT * FROM `user1` LIMIT 1,2 var_dump($user-&gt;limit(1,2)-&gt;select()); 5.page（page 方法完全用于分页查询）12345//page分页 // SELECT * FROM `user1` LIMIT 3,3 var_dump($user-&gt;page(2,3)-&gt;select()); 6.table（用于数据表操作，主要是切换数据表或多表操作）12345//切换数据表 // SELECT * FROM `test_user` var_dump($user-&gt;table(&#x27;test_user&#x27;)-&gt;select()); 7.alias （用于设置数据表别名）12345// 设置别名 // SELECT * FROM user1 a var_dump($user-&gt;alias(&#x27;a&#x27;)-&gt;select()); 8.group（用于对结合函数统计的结果集分组）12345 // 分组统计// SELECT `name`,max(id) FROM `user1` GROUP BY idvar_dump($user-&gt;field(&#x27;name,max(id)&#x27;)-&gt;group(&#x27;id&#x27;)-&gt;select()); 9.having（用于配合 group 方法完成从分组的结果中再筛选数据）12345//分组统计结合having // SELECT `user`,max(id) FROM `user1` GROUP BY id HAVING id&gt;2 var_dump($user-&gt;field(&#x27;user,max(id)&#x27;)-&gt;group(&#x27;id&#x27;)-&gt;having(&#x27;id&gt;2&#x27;)-&gt;select()); 10.comment （用于对 SQL 语句进行注释）12345//SQL注释 // SELECT * FROM `user1` /* test */ var_dump($user-&gt;comment(&#x27;test&#x27;)-&gt;select()); 2.ThinkPHP 数据的增删改查1、增ThinkPHP 内置的 add 方法用于向数据表添加数据，相当于 SQL 中的 INSERT INTO 行为。 12345678910111213 1 public function insert()&#123; 2 header(&quot;Content-Type:text/html; charset=utf-8&quot;); 3 $Dao = M(&quot;User&quot;); // 实例化模型类 4 5 // 构建写入的数据数组 6 $data[&quot;username&quot;] = &quot;小王&quot;; 7 $data[&quot;password&quot;] = md5(&quot;123456&quot;); 8 $data[&quot;email&quot;] = &quot;12345@163.com&quot;; 9 $data[&quot;regdate&quot;] = time();10 11 // 写入数据12 $insertM = $Dao-&gt;add($data)；13 &#125; 等同于SQL语句： 1INSERT INTO user(username,password,email,regdate) VALUES (&#x27;小王&#x27;,&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;,&#x27;12345@163.com&#x27;,1486974334); 2、删delete() 方法执行成功返回操作影响（删除）的记录数。 1234561 public function del()&#123;2 header(&quot;Content-Type:text/html; charset=utf-8&quot;);3 $Dao = M(&quot;User&quot;);4 // 删除 uid=5 的数据记录5 $result = $Dao-&gt;where(&#x27;uid = 5&#x27;)-&gt;delete();6 &#125; 等同于SQL语句： 1DELETE FROM user WHERE uid = 5; 3、改ThinkPHP 内置的 save() 方法用于向数据表更新数据，相当于 SQL 中的 UPDATE 行为。 1234567891011 1 public function update()&#123; 2 header(&quot;Content-Type:text/html; charset=utf-8&quot;); 3 $Dao = M(&quot;User&quot;); 4 5 // 需要更新的数据 6 $data[&#x27;email&#x27;] = &#x27;Jack@163.com&#x27;; 7 // 更新的条件 8 $condition[&#x27;username&#x27;] = &#x27;Jack&#x27;; 9 $result = $Dao-&gt;where($condition)-&gt;save($data);10 //或者：$resul t= $Dao-&gt;where($condition)-&gt;data($data)-&gt;save();11 &#125; 等同于SQL语句： 1UPDATE user SET email=&#x27;Jack@163.com&#x27; WHERE username=&#x27;Jack&#x27;; 提示 为了保证数据库的安全，避免出错更新整个数据表，如果没有任何更新条件，数据对象本身也不包含主键字段的话，save方法不会更新任何数据库的记录。 因此要使用 save() 方法更新数据，必须指定更新条件或者更新的数据中包含主键字段。 4、查 ThinkPHP 查询数据主要提供以下几类查询： 1）select是 ThinkPHP 中最常用的普通查询方法，得到的是一个二维数组。 12345678910111213141516171819202122232425262728293031 1 //方法php 2 public function read()&#123; 3 $Dao = M(&quot;User&quot;); 4 5 // 查询数据 6 $list = $Dao-&gt;select(); 7 //dump($list); // 用 dump() 可以在调试阶段查看数据是否已读取 8 9 // 模板变量赋值10 $this-&gt;assign(&quot;list&quot;, $list);11 // 输出模板12 $this-&gt;display();13 &#125;14 15 //模板html16 &lt;table border=&quot;1&quot;&gt;17 &lt;tr&gt;18 &lt;th width=&quot;10%&quot;&gt;ID&lt;/th&gt;19 &lt;th width=&quot;30%&quot;&gt;用户名&lt;/th&gt;20 &lt;th width=&quot;30%&quot;&gt;电子邮件&lt;/th&gt;21 &lt;th&gt;注册时间&lt;/th&gt;22 &lt;/tr&gt;23 &lt;volist name=&quot;list&quot; id=&quot;vo&quot;&gt;//循环显示24 &lt;tr&gt;25 &lt;td align=&quot;center&quot;&gt;&#123;$vo[&#x27;uid&#x27;]&#125;&lt;/td&gt;26 &lt;td&gt;&#123;$vo[&#x27;username&#x27;]&#125;&lt;/td&gt;27 &lt;td&gt;&#123;$vo[&#x27;email&#x27;]&#125;&lt;/td&gt;28 &lt;td&gt;&#123;$vo[&#x27;regdate&#x27;]|date=&#x27;Y-m-d H:i&#x27;,###&#125;&lt;/td&gt;29 &lt;/tr&gt;30 &lt;/volist&gt;31 &lt;/table&gt; 2）find该方法是和 select() 用法类似的一个方法，不同之处 find() 查询出来的始终只有一条数据，即系统自动加上了 LIMIT 1 限制。 12345678910111213141516 1 //当确认查询的数据记录只能是一条记录时，建议使用 find() 方法查询，如用户登录账号检测： 2 3 public function chekUser()&#123; 4 header(&quot;Content-Type:text/html; charset=utf-8&quot;); 5 $Dao = M(&quot;User&quot;); 6 7 // 构造查询条件 8 $condition[&#x27;username&#x27;] = &#x27;Admin&#x27;; 9 $condition[&#x27;password&#x27;] = MD5(&#x27;123456&#x27;);10 // 查询数据11 $list = $Dao-&gt;where($condition)-&gt;find();12 &#125;13 14 //与 select() 的另一个不同之处在于，find() 返回的是一个一维数组，可以在模板里直接输出数组单元的值而无需使用 volist 等标签循环输出：15 16 &lt;p&gt;&#123;$list[&#x27;username&#x27;]&#125;&lt;/p&gt; 3）getBy动态查询是一个魔术方法，可以根据某个字段名称动态得到对应的一条数据记录。 12345671 public function chekUser()&#123;2 header(&quot;Content-Type:text/html; charset=utf-8&quot;);3 $Dao = M(&quot;User&quot;);4 5 // 查询数据6 $user = $Dao-&gt;getByUsername(&#x27;Admin&#x27;);7 &#125; 等同于SQL语句： 1SELECT * FROM user WHERE username = &#x27;Admin&#x27; LIMIT 1 提示： 请注意，在getBy之后紧跟着的字段名称，首字母必须大写。对于如 user_name 这样的字段名称，以驼峰法自动识别下划线，即： 1$user = $Dao-&gt;getByUserName(&#x27;Admin&#x27;); 实际使用中可以灵活根据查询的字段名来定义 getBy 放入，如：getByEmail、getByTitle、getById 等。 4）getField是专门用于获取某个字段的值或者多个字段的索引数组。该方法与 field方法 不同，是一个独立的方法而不需要再使用 find 或者 select 。 参数 说明 fields 必须，需要查询的字段名称，可以是一个或多个字段 condition 可选，查询条件，可以是字符或数组，参考 select 方法查询条件 spea 可选，多个字段数据生成关联数组时，数据间隔符号，默认为空格 1234567891011121314 1 public function select()&#123; 2 header(&quot;Content-Type:text/html; charset=utf-8&quot;); 3 $Dao = M(&quot;User&quot;); 4 $list = $Dao-&gt;getField(&#x27;uid,username,email&#x27;,&#x27;uid &lt; 4&#x27;,&#x27;|&#x27;); 5 dump($list); 6 &#125; 7 8 //dump 打印出的结果是： 9 10 array(3) &#123;11 [1] =&gt; string(21) &quot;admin|admin@5idev.com&quot;12 [2] =&gt; string(23) &quot;小明|xiaoming@163.com&quot;13 [3] =&gt; string(19) &quot;Jack|jack@gmail.com&quot;14 &#125; 5）区间查询取得符合查询条件的区间记录 1234567891011 1 public function read()&#123; 2 $Dao = M(&#x27;User&#x27;); 3 $condition[&#x27;uid&#x27;] = array(array(&#x27;gt&#x27;,1),array(&#x27;lt&#x27;,5));//(uid &gt; 1) AND (uid &lt; 5)3.1 $condition[&#x27;uid&#x27;] = array(array(&#x27;gt&#x27;,3),array(&#x27;lt&#x27;,10), &#x27;or&#x27;);//(uid &lt; 1) OR (uid &gt; 10)3.2 $condition[&#x27;username&#x27;] = array(array(&#x27;like&#x27;,&#x27;%a%&#x27;), array(&#x27;like&#x27;,&#x27;%b%&#x27;), &#x27;Admin&#x27;,&#x27;or&#x27;);//(username LIKE &#x27;%a%&#x27;) OR (username LIKE &#x27;%b%&#x27;) OR (username = &#x27;Admin&#x27;) 4 $list = $Dao-&gt;where($condition)-&gt;select(); 5 if($list)&#123; 6 $this-&gt;assign(&#x27;list&#x27;, $list); 7 $this-&gt;display(); 8 &#125; else &#123; 9 $this-&gt;error($Dao-&gt;getError());10 &#125;11 &#125; 等同于SQL语句： 1SELECT * FROM user WHERE ( (uid &gt; 1) AND (uid &lt; 5) ); 6）原生SQL查询尽管ThinkPHP内置了大量的数据操作方法，但ThinkPHP仍保留了对原生SQL查询的支持，以便满足复杂查询的需要和一些特殊的数据操作。SQL查询的返回值是直接返回DB类的查询结果，没有做任何的处理，而且可以支持查询缓存。 原生SQL查询有 query() 和 execute() 两个方法： 123456789101112131415161718192021222324252627 1 //query() 方法是用于 SQL 查询操作，和select()方法一样返回符合查询条件的数据集。 2 //对于 query() 方法返回的数据集，跟 select() 一样，可以在模板里直接循环输出。 3 public function read()&#123; 4 // 实例化一个空模型，没有对应任何数据表 5 $Dao = M(); 6 //或者使用 $Dao = new Model(); 7 8 $list = $Dao-&gt;query(&quot;select * from user where uid&lt;5&quot;); 9 if($list)&#123;10 $this-&gt;assign(&#x27;list&#x27;, $list );11 $this-&gt;display();12 &#125; else &#123;13 $this-&gt;error($Dao-&gt;getError());14 &#125;15 &#125;16 17 18 //execute() 方法用于更新和写入数据的 SQL 操作（注：非查询操作，无返回数据集），返回影响的记录数。19 20 public function read()&#123;21 header(&quot;Content-Type:text/html; charset=utf-8&quot;);22 // 实例化一个空模型，没有对应任何数据表23 $Dao = M();24 //或者使用 $Dao = new Model();25 26 $num = $Dao-&gt;execute(&quot;update user set email = &#x27;12345@xxx.com&#x27; where uid=3&quot;);27 &#125; 7）统计查询取得符合查询条件的统计数据 count()方法用于统计数据行数。 12345678910 1 public function read()&#123; 2 $Dao = M(&#x27;User&#x27;); 3 // 获取用户数： 4 $userCount = $Dao-&gt;count(); 5 // 添加条件： 6 $userCount2 = $Dao-&gt;where(&#x27;uid &gt; 10&#x27;)-&gt;count(); 7 8 $this-&gt;assign(&#x27;userCount&#x27;, $userCount); 9 $this-&gt;display();10 &#125;//可以在模板中直接输出得到的统计数据：共有用户 &#123;$userCount&#125; 人。 两个查询语句实际执行的 SQL 为： 121 SELECT COUNT(*) AS tp_count FROM user LIMIT 1 2 SELECT COUNT(*) AS tp_count FROM user WHERE uid &gt; 10 LIMIT 1 max()方法用于统计某个字段最大数据。 121 //统计用户最大积分例子：2 $maxScore = $Dao-&gt;max(&#x27;score&#x27;); 实际执行的 SQL 为： 1SELECT MAX(score) AS tp_max FROM user LIMIT 1 ; min()统计某个字段最小数据。 121 //获取积分大于 0 的用户的最小积分例子：2 $minScore = $Dao-&gt;where(&#x27;score&gt;0&#x27;)-&gt;min(&#x27;score&#x27;); 实际执行的 SQL 为： 1SELECT MIN(score) AS tp_min FROM user WHERE score&gt;0 LIMIT 1; avg()统计某个字段平均数据。 121 //获取用户的平均积分例子：2 $avgScore = $Dao-&gt;avg(&#x27;score&#x27;); 实际执行的 SQL 为： 1SELECT AVG(score) AS tp_avg FROM user LIMIT 1; sum()统计某个字段数据之和。 121 //统计积分排名前 10 名用户的积分之和：2 $sumScore = $Dao-&gt;order(&#x27;score DESC&#x27;)-&gt;limit(&#x27;10&#x27;)-&gt;sum(&#x27;score&#x27;); 实际执行的 SQL 为： 1SELECT SUM(score) AS tp_sum FROM user ORDER BY score DESC LIMIT 10; 5.软删除123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293Login.php&lt;?phpnamespace app\\index\\controller;use think\\Controller;use Gregwar\\Captcha\\CaptchaBuilder;use think\\Loader;use app\\index\\model\\Data;use think\\Db;class Login extends Controller&#123;public function _initialize()&#123;//parent::__construct();$this-&gt;data = Loader::model(&#x27;data&#x27;);&#125;public function delData()&#123;//删除id=16的记录$res = Data::destroy(16);//返回int(1)受影响记录数量dump($res);&#125;//删除后进行查询验证public function selData()&#123;//返回为null，表示删除成功//dump(Data::get(16));$res = Data::select();foreach ($res as $k =&gt; $v) &#123;//getData()函数可以获取对象里面的数据dump($v-&gt;getData());&#125;&#125;//默认情况下，查询到的数据不包含软删除数据，如果需要包含软删除的数据public function selData1()&#123;//查询单条数据$res = Data::withTrashed(true)-&gt;find();dump($res-&gt;getData());//查询多条数据$res = Data::withTrashed(true)-&gt;select();foreach ($res as $k =&gt; $v) &#123;dump($v-&gt;getData());&#125;&#125;//如果只想删除软删除的数据，相当于查看回收站public function selData2()&#123;//单条数据$res = Data::onlyTrashed(true)-&gt;find();dump($res-&gt;getData());//多条数据$res = Data::onlyTrashed(true)-&gt;select();foreach ($res as $key =&gt; $val) &#123;dump($val-&gt;getData());&#125;&#125; //恢复软删除记录//控制器中将被软删除的delete_time更新为null即可public function selData3()&#123;$res = Data::update([&#x27;delete_time&#x27; =&gt; null,], [&#x27;id&#x27; =&gt; 16]);dump($res);//现在就可以获取重新被软删除的记录了$res = Data::get(16);dump($res-&gt;getData());&#125; //物理删除是指彻底将该记录从表中移除，不可恢复。给destroy()方法传入第二个参数truepublic function delReal()&#123;//删除id为16的记录$res = Data::destroy(16, true);dump($res);//使用delete(true)实现物理删除$res = Data::where(&#x27;id&#x27;, 18)-&gt;delete();dump($res);&#125;&#125; Data.php 123456789101112131415161718192021222324Data.php&lt;?phpnamespace app\\index\\model;use think\\Db;use think\\Model;use traits\\model\\SoftDelete;class Data extends Model&#123;//在当前类导入，就可以使用其中的方法啦use SoftDelete;//如果你的字段名为框架默认的delete_time,可省略protected $deleteTime = &#x27;delete_time&#x27;;protected $table = &#x27;bbs_data&#x27;;public function getMenu()&#123;$res = Db::name($this-&gt;table)-&gt;select();return $res;&#125;&#125; 3.TP5框架model操作【增删改查、聚合、时间戳、软删除等 使用model 查询数据，添加数据，修改数据，删除数据 聚合操作 获取器，修改器 自动添加时间戳（创建时间，修改时间） 软删除 1、使用model查询数据12345$res = User::get(1); //获取主键为1的数据，得到的是一个对象 $res = $res- toArray(); //将对象转化为数组 dump($res- name); //获取 $res 里 name 字段的值 12345//使用闭包函数查询 id=1 的记录$res = User::get(function($query)&#123; $query- where(&quot;id&quot;,&quot;eq&quot;,1) - field(&#x27;name&#x27;)&#125;); 12345$res = User::where(&quot;id&quot;,10)- value(&#x27;name&#x27;);$res = User::where(&quot;id&quot;,10)- field(&#x27;name&#x27;)- find(); $res = User::column(&#x27;email&#x27;); //查询所有的 email 字段值 $res = User::where(&quot;id&quot;,&quot; &quot;,5)- select(); //查询所有id大于5的记录 12345$res = User::all(&#x27;1,2&#x27;); //查询主键等于 1 或2 的记录foreach($res as $val) //转化为数组&#123; dump($val- toArray());&#125; 12345//使用闭包函数查询 id&lt;5 的记录$res = User::get(function($query)&#123; $query- where(&quot;id&quot;,&quot;&lt;&quot;,5) - field(&#x27;name&#x27;)&#125;); 2、使用model添加数据1234567$res = User::create([ &#x27;name&#x27; = &#x27;yulong&#x27;, &#x27;pwd&#x27; = &#x27;123&#x27;],true); //第二个参数为true时，只添加数据表中已有的字段，不报错，不写则默认为false；；；true 也可以换成一个数组，数组里存放数据表中的字段，表示仅允许数组中的字段添加数据$res- id; //本次添加的自增iddump($res); 123456789$usermodel = new User;$res = $usermodel - allowField(true) //仅允许添加数据表中存在的字段，也可以写成数组 - save([ &#x27;name&#x27; = &#x27;yulong&#x27;, &#x27;pwd&#x27; = &#x27;123&#x27; ]); dump($res- id); //获取新添加数据的自增id 1234567$usermodel = new User;$res = $usermodel- saveAll([ //一次保存多条数据 &#x27;name&#x27; = &#x27;yulong001&#x27;, &#x27;name&#x27; = &#x27;yulong002&#x27;]); dump($ers); 3、使用model更新数据123456789101112$res = User::update([ &#x27;name&#x27; = &#x27;yulong002&#x27;],[&#x27;id&#x27;= 1]); //更新 id=1 的记录 $res = User::update([ &#x27;name&#x27; = &#x27;yulong002&#x27;],function()&#123; $query- where(&quot;id&quot;,&quot;LT&quot;,5); //使用闭包函数更新 id&lt;5 的记录&#125;); dump($res); 1234$res = User::where(&quot;id&quot;,&quot;&lt;&quot;,6) //返回值是被更新数据的行数 - update([ &#x27;name&#x27; = &#x27;hahahaha&#x27; ]); 4、使用model删除数据12345678910$res = User::destriy(1); //删除主键为1的记录，返回影响数据的行数，也可以传递数组 $usermodel = User::get(1);$res = $usermodel- delete(); $res = User::where(&quot;id&quot;,5)- delete(); // where() 里面有三个参数， 字段值，条件，数值 dump($res); 5、使用model聚合操作12345$res = User::where(&quot;id&quot;,&quot; &quot;,5)- count(); //查询id大于5的记录条数 // max 可以换成其他的 如 min / sum / avg$res = User::max(&#x27;num&#x27;); //查询 num 字段中的最大值$res = User::where(&quot;id&quot;,&quot;&lt;&quot;,5)- max(&#x27;num&#x27;); //id&lt;5 的记录中的 num 最大值 6、使用模型获取器1234567891011121314151617//model //方法名： get字段名Attr//controller中获取原始数据使用 $res- getData() public function getSexSttr($val)&#123; switch($val)&#123; case &#x27;1&#x27;: return &quot;男&quot;; break; case &#x27;2&#x27;; return &#x27;女&#x27;; break; default: return &#x27;未知&#x27;; break; &#125;&#125; 7、使用模型修改器12345678910//model 修改器命名 set字段名Attr//修改器作用：在往数据库添加字段时，控制器中写未处理的数据，在模型中的修改器中写处理数据的方法，这样添加到数据库中的数据就是处理过得数据了public function setPwdAttr($val)&#123; return md5($val);&#125; // $val代表 pwd 字段，$data代表接收到的所有数据 ，返回的值就是 pwd+email public function setPwdAttr($val,$data)&#123; return $val.$data[&#x27;email&#x27;];&#125; 8、自动往[数据库]中添加时间戳12345678910111213141516//自动往 time 字段中加入时间戳public function setTimeAttr()&#123; return time();&#125; //在数据添加时发生改变protected $insert = [ &#x27;time_insert&#x27; ]; //设置字段public function setTimeInsertAttr()&#123; //将字段值设置为当前时间 return time();&#125; //在更新数据时发生改变protected $update = [ &#x27;time_update&#x27; ]; //设置字段public function setTimeUpdateAttr()&#123; //将字段值设置为当前时间 return time();&#125; 9、model时间戳 123456789// 数据库中的字段 create_time update_time// database.php 中更改配置 &#x27;auto_timeStamp&#x27; = true// 不推荐使用此方法，因为如果你的数据库表中没有 对应的字段 ，程序可能就会报错// 可以单独在 某个模型中 添加属性 protected $autoWriteTimeStamp = true; //开启自动加入时间戳 protected $createTime = &#x27;create_at&#x27;; //设置 创建的时候写入 的字段 ，值可以为false，关闭操作protedted $updateTime = &#x27;update_at&#x27;; //设置 创建和更新的时候写入 的字段 ，值可以为false，关闭操作 10、软删除 12345678910111213141516171819202122// model// 数据表中的字段 delete_time，默认值可以为 null use traits\\model\\SoftDelete; //使用软删除的类 class User extends Model&#123; use SoftDelete; //在类的开头 use SoftDelete; protected $deleteTime = &#x27;delete_at&#x27;; //设置软删除的字段，默认为 delete_time&#125; $res = User::destroy(3,true); //删除主键为3的记录，第二个参数为 true 时，不是软删除，是tm真删了 $ress = User::get(4);$res = $ress- delete(true); // delete() 没值时，为软删除；值为true，tm的真删 // controller 获取到 软删除 的记录$res = User::withTrashed(true)- find(1); //得到id为1 的经过软删除 删除的记录dump($res- getData()); //获取原始数据 $res = User::onlyTrashed()- select(); //获取所有软删除的数据 4.ThinkPHP 5 操作数据库三种方法一、原生的sql语句1. query：查询操作query简单粗暴的方法 1234public function getDetail($id)&#123; $data= Db::query(&#x27;select * from test&#x27;); return $data; &#125; 可以传参数；用占位符或者命名占位符绑定 1234public function getDetail($id)&#123; $data= Db::query(&#x27;select * from test where id=?&#x27;,[$id]); return $data; &#125; 2. execute：写入操作execute 插入数据，返回值是影响的记录数 12$data= Db::execute(&#x27;insert into test (name) values (?)&#x27;,[&#x27;thinkphp&#x27;]); return $data; 二、使用查询构建器备注：TP5框架有助手函数Db::table(‘user’) 相当于 db(‘user’) 1.find、selectfind()只能返回第一条数据（建议单个查询使用）；select()是把所有符合的查询出来细节： find 方法查询结果不存在，返回 nullselect 方法查询结果不存在，返回空数组 12345678//链式表达式 //链式操作where(&#x27;字段名&#x27;,&#x27;表达式&#x27;,&#x27;查询条件&#x27;)//这里的等号可以缺审$data=Db::table(&#x27;test&#x27;)-&gt;where(&#x27;id&#x27;,1)-&gt;find();$data=Db::table(&#x27;test&#x27;)-&gt;select();//助手函数$data =db(&#x27;test&#x27;)-&gt;where(&#x27;id&#x27;,1)-&gt;find();$data =db(&#x27;test&#x27;)-&gt;select(); 2.insert update 方法返回影响数据的条数，没修改任何数据返回 0 123456789101112131415//插入单条数据 $aa = [&#x27;name&#x27; =&gt; &#x27;good&#x27;]; $data=Db::table(&#x27;test&#x27;)-&gt;insert($aa);//插入多条数据 $bb = [ [&#x27;name&#x27; =&gt; &#x27;bb&#x27;], [&#x27;name&#x27; =&gt; &#x27;cc&#x27;], [&#x27;name&#x27; =&gt; &#x27;dd&#x27;], ]; $data = Db::table(&#x27;test&#x27;)-&gt;insertAll($bb);//函数助手// 添加单条数据 db(&#x27;user&#x27;)-&gt;insert($aa);// 添加多条数据 db(&#x27;user&#x27;)-&gt;insertAll($bb); 3.update1234//更新某一条记录 $data = Db::table(&#x27;test&#x27;)-&gt;where(&#x27;id&#x27;,1)-&gt;update([&#x27;name&#x27;=&gt;&#x27;老张&#x27;]);//更新某条记录的某个字段的值： $data=Db::table(&#x27;test&#x27;)-&gt;where(&#x27;id&#x27;,2)-&gt;setField(&#x27;name&#x27;, &#x27;老四&#x27;); 4.delete delete 方法返回影响数据的条数，没有删除返回 0 1234// 根据主键删除 $data=Db::table(&#x27;test&#x27;)-&gt;delete(6);//可以传入数组，进行批量删除 $data=Db::table(&#x27;test&#x27;)-&gt;delete([7,8]); 5.自增或自减一个字段的值自增或自减一个字段的值setInc&#x2F;setDec 如不加第二个参数，默认值为1；第三个参数是延迟时间，单位秒 12345678// score 字段加 1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;id&#x27;, 1)-&gt;setInc(&#x27;score&#x27;);// score 字段加 5Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;id&#x27;, 1)-&gt;setInc(&#x27;score&#x27;, 5);// score 字段减 1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;id&#x27;, 1)-&gt;setDec(&#x27;score&#x27;);//延迟更新，第三个参数是时间单位秒Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;id&#x27;, 1)-&gt;setInc(&#x27;score&#x27;, 1, 10); 6.使用Query或闭包查询12345678910使用查询对象进行查询$query = new \\think\\db\\Query();$query-&gt;table(&#x27;think_user&#x27;)-&gt;where(&#x27;status&#x27;,1);Db::find($query);Db::select($query);//使用闭包函数查询Db::select(function($query)&#123; $query-&gt;table(&#x27;think_user&#x27;)-&gt;where(&#x27;status&#x27;,1);&#125;); 7.查询表达式 where(‘字段名’,‘表达式’,‘查询条件’);whereOr(‘字段名’,‘表达式’,‘查询条件’);表达式不分大小写，支持的查询表达式有下面几种，分别表示的含义是： 表达式 含义 EQ、&#x3D; 等于（&#x3D;） NEQ、&lt;&gt; 不等于（&lt;&gt;） GT、&gt; 大于（&gt;） EGT、&gt;&#x3D; 大于等于（&gt;&#x3D;） LT、&lt; 小于（&lt;） ELT、&lt;&#x3D; 小于等于（&lt;&#x3D;） LIKE 模糊查询 [NOT] BETWEEN （不在）区间查询 [NOT] IN （不在）IN 查询 [NOT] NULL 查询字段是否（不）是NULL [NOT] EXISTS EXISTS查询 EXP 表达式查询，支持SQL语法 &gt; time 时间比较 &lt; time 时间比较 between time 时间比较 notbetween time 时间比较 显示简略信息 8.链式操作 操作名称 所有的连贯操作都返回当前的模型实例对象（this），其中带*标识的表示支持多次调用。 连贯操作 作用 支持的参数类型 where* 用于AND查询 字符串、数组和对象 whereOr* 用于OR查询 字符串、数组和对象 wheretime* 用于时间日期的快捷查询 字符串 table 用于定义要操作的数据表名称 字符串和数组 alias 用于给当前数据表定义别名 字符串 field* 用于定义要查询的字段（支持字段排除） 字符串和数组 order* 用于对结果排序 字符串和数组 limit 用于限制查询结果数量 字符串和数字 page 用于查询分页（内部会转换成limit） 字符串和数字 group 用于对查询的group支持 字符串 having 用于对查询的having支持 字符串 join* 用于对查询的join支持 字符串和数组 union* 用于对查询的union支持 字符串、数组和对象 view* 用于视图查询 字符串、数组 distinct 用于查询的distinct支持 布尔值 lock 用于数据库的锁机制 布尔值 cache 用于查询缓存 支持多个参数 relation* 用于关联查询 字符串 with* 用于关联预载入 字符串、数组 bind* 用于数据绑定操作 数组或多个参数 comment 用于SQL注释 字符串 force 用于数据集的强制索引 字符串 master 用于设置主服务器读取数据 布尔值 strict 用于设置是否严格检测字段名是否存在 布尔值 sequence 用于设置Pgsql的自增序列名 字符串 failException 用于设置没有查询到数据是否抛出异常 布尔值 partition 用于设置分表信息 数组 字符串 三、模型ORM1.定义 默认主键为自动识别，如果需要指定，可以设置属性： protected $pk = &#39;uid&#39;; 2.引用+获取数据 (get 、all)获取单个数据1234567891011//引用use app\\index\\model\\Test as TestModel;//获取主键为1的数据 $data = TestModel::get(1);//数组的方法 $data = TestModel::get([&#x27;id&#x27;=&gt;1]);//闭包的方法 $data = TestModel::get(function($query)&#123; $query-&gt;where(&#x27;id&#x27;, 1); &#125;); 获取多个数据12345678910111213141516171819202122//引用use app\\index\\model\\Test as TestModel;//获取所有数据 $data =TestModel::all();// 根据主键获取多个数据$list = User::all(&#x27;1,2,3&#x27;);// 或者使用数组$list = User::all([1,2,3]);foreach($list as $key=&gt;$user)&#123; echo $user-&gt;name;&#125;// 使用数组查询$list = User::all([&#x27;status&#x27;=&gt;1]);// 使用闭包查询$list = User::all(function($query)&#123; $query-&gt;where(&#x27;status&#x27;, 1)-&gt;limit(3)-&gt;order(&#x27;id&#x27;, &#x27;asc&#x27;);&#125;);foreach($list as $key=&gt;$user)&#123; echo $user-&gt;name;&#125; 实例化的方法1234567$user = new Test(); // 查询单个数据 $data=$user-&gt;where(&#x27;id&#x27;, 1) -&gt;find(); return $data; &#125; 3.新增（save、saveAll）新增一条1234567891011121314151617//新增一条$test = new Test;$test-&gt;name = &#x27;thinkphp&#x27;;$test-&gt;save();//data数组批量赋值$test = new Test;$test-&gt;data([ &#x27;name&#x27; =&gt; &#x27;thinkphp&#x27;,]);$test-&gt;save();//直接在实例化的时候传入数据$test = new Test([ &#x27;name&#x27; =&gt; &#x27;thinkphp&#x27;,]);$test-&gt;save(); 批量新增123456$test = new Test;$list = [ [&#x27;name&#x27;=&gt;&#x27;thinkphp&#x27;], [&#x27;name&#x27;=&gt;&#x27;onethink&#x27;]];$test-&gt;saveAll($list); 4.更新（save、saveAll、update）查询与更新123456789101112//在取出数据后，更改字段内容后更新数据。$test = new Test;$test= Test::get(1);$test-&gt;name = &#x27;thinkphp&#x27;;$test-&gt;save();//也可以直接带更新条件来更新数据$test = new Test;// save方法第二个参数为更新条件$test-&gt;save([ &#x27;name&#x27; =&gt; &#x27;thinkphp&#x27;,],[&#x27;id&#x27; =&gt; 1]); 批量更新 批量更新仅能根据主键值进行更新，其它情况请使用foreach遍历更新。 123456$test = new Test;$list = [ [&#x27;id&#x27;=&gt;1, &#x27;name&#x27;=&gt;&#x27;thinkphp&#x27;], [&#x27;id&#x27;=&gt;2, &#x27;name&#x27;=&gt;&#x27;onethink&#x27;]];$test-&gt;saveAll($list); 静态方法更新1234567$data=Test::where(&#x27;id&#x27;, 1) -&gt;update([&#x27;name&#x27; =&gt; &#x27;thinkphp&#x27;]);//$data是受影响行数//或者使用：$data=Test::update([&#x27;id&#x27; =&gt; 1, &#x27;name&#x27; =&gt; &#x27;thinkphp&#x27;]);//$data返回结果集 5.删除（delete、destroy）1234567891011121314151617//delete方法$data = Test::get(5);$data-&gt;delete();//根据主键删除//或者直接调用静态方法User::destroy(1);// 支持批量删除多个数据User::destroy(&#x27;1,2,3&#x27;);// 或者User::destroy([1,2,3]);//条件删除// 删除状态为0的数据User::destroy([&#x27;status&#x27; =&gt; 0]);//或者通过数据库类的查询条件删除User::where(&#x27;id&#x27;,&#x27;&gt;&#x27;,10)-&gt;delete(); V5.0.9+版本开始当destroy方法传入空值（包括空字符串和空数组）的时候不会做任何的数据删除操作，但传入0则是有效的"},{"title":"电影","date":"2024-03-14T09:42:50.000Z","updated":"2024-08-23T03:23:46.000Z","comments":true,"path":"movies/index.html","permalink":"https://2486125878.github.io/movies/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-11-27T01:42:09.000Z","updated":"2024-03-13T08:16:56.000Z","comments":true,"path":"tags/index.html","permalink":"https://2486125878.github.io/tags/index.html","excerpt":"","text":""},{"title":"音乐","date":"2024-03-14T09:42:50.000Z","updated":"2024-08-23T10:15:56.000Z","comments":true,"path":"music/index.html","permalink":"https://2486125878.github.io/music/index.html","excerpt":"","text":""},{"title":"素材收集","date":"2024-08-22T11:03:21.000Z","updated":"2024-08-23T02:26:44.000Z","comments":true,"path":"album/work/index.html","permalink":"https://2486125878.github.io/album/work/index.html","excerpt":"","text":""},{"title":"生活记录","date":"2024-08-22T10:59:07.000Z","updated":"2024-08-22T11:10:54.000Z","comments":true,"path":"album/life/index.html","permalink":"https://2486125878.github.io/album/life/index.html","excerpt":"","text":""},{"title":"代码记录","date":"2024-08-22T11:03:32.000Z","updated":"2024-08-22T11:11:02.000Z","comments":true,"path":"album/indian/index.html","permalink":"https://2486125878.github.io/album/indian/index.html","excerpt":"","text":""},{"title":"壁纸收藏","date":"2024-08-22T11:03:06.000Z","updated":"2024-08-22T11:11:10.000Z","comments":true,"path":"album/wallpaper/index.html","permalink":"https://2486125878.github.io/album/wallpaper/index.html","excerpt":"","text":""}],"posts":[{"title":"thinkphp后台笔记","slug":"thinkphp后台笔记","date":"2024-03-14T07:51:34.000Z","updated":"2024-03-14T08:13:16.000Z","comments":true,"path":"2024/03/14/thinkphp后台笔记/","permalink":"https://2486125878.github.io/2024/03/14/thinkphp%E5%90%8E%E5%8F%B0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"thinkphp仅实现登录管理员列表增删改查功能controllerapplication&#x2F;admin&#x2F;controller&#x2F;Base.php123456789101112131415&lt;?phpnamespace app\\admin\\controller;use think\\Controller;class Base extends Controller&#123; public function _initialize() &#123; if(!session(&#x27;name&#x27;))&#123; $this-&gt;error(&#x27;请先登录系统&#x27;,&#x27;Index/login&#x27;); &#125; &#125;&#125; application&#x2F;admin&#x2F;controller&#x2F;index.php12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpnamespace app\\admin\\controller;use think\\Controller;use app\\admin\\model\\User;class Index extends Controller&#123; public function login()&#123; return $this-&gt;fetch(); &#125; public function check()&#123; $data=input(&#x27;post.&#x27;); $user=new User(); $result= $user-&gt;where(&#x27;name&#x27;,$data[&#x27;name&#x27;])-&gt;find(); if($result)&#123; if($result[&#x27;password&#x27;]===md5($data[&#x27;password&#x27;]))&#123; session(&#x27;name&#x27;,$data[&#x27;name&#x27;]); &#125;else&#123; $this-&gt;error(&#x27;密码不正确&#x27;); &#125; &#125;else&#123; $this-&gt;error(&#x27;用户名不存在&#x27;); exit; &#125; if(captcha_check($data[&#x27;code&#x27;]))&#123; $this-&gt;success(&#x27;验证码正确,登录成功&#x27;,&#x27;User/index&#x27;); &#125;else&#123; $this-&gt;error(&#x27;验证码不正确&#x27;); &#125; return $this-&gt;fetch(); &#125; public function logout()&#123; $ret= session(null); $this-&gt;success(&#x27;退出登录成功&#x27;,&#x27;admin/Index/login&#x27;); &#125;&#125; application&#x2F;admin&#x2F;controller&#x2F;User.php1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;?phpnamespace app\\admin\\controller;use think\\Controller;use app\\admin\\model\\User as UserModel;use app\\admin\\validate\\User as UserValidate;use app\\admin\\controller\\Base;class User extends Base&#123; public function index()&#123; return $this-&gt;fetch(); &#125; public function list()&#123;// $data=UserModel::all();// $this-&gt;assign(&#x27;data&#x27;,$data);// 通过分页显示 $data=UserModel::paginate(3); $page=$data-&gt;render(); $this-&gt;assign(&#x27;data&#x27;,$data); $this-&gt;assign(&#x27;page&#x27;,$page); return $this-&gt;fetch(); &#125; public function add()&#123; return $this-&gt;fetch(); &#125; public function insert()&#123; $data=input(&#x27;post.&#x27;); $val=new UserValidate(); if(!$val-&gt;check($data))&#123; $this-&gt;error($val-&gt;getError()); exit; &#125; $user=new UserModel($data); $ret=$user-&gt;allowField(true)-&gt;save(); if($ret)&#123; $this-&gt;success(&#x27;新增管理员成功&#x27;,&#x27;User/list&#x27;); &#125;else&#123; $this-&gt;error(&#x27;新增管理员失效&#x27;); &#125; &#125; public function edit()&#123; $id=input(&#x27;get.id&#x27;); $data=UserModel::get($id); $this-&gt;assign(&#x27;data&#x27;,$data); return $this-&gt;fetch(); &#125; public function update()&#123; $data=input(&#x27;post.&#x27;); $id=input(&#x27;post.id&#x27;); $val=new UserValidate(); if(!$val-&gt;check($data))&#123; $this-&gt;error($val-&gt;getError()); exit; &#125; $user=new UserModel(); $ret=$user-&gt;allowField(true)-&gt;save($data,[&#x27;id&#x27;=&gt;$id]); if($ret)&#123; $this-&gt;success(&#x27;管理员信息修改成功&#x27;,&#x27;User/list&#x27;); &#125;else&#123; $this-&gt;error(&#x27;管理员信息修改失效&#x27;); &#125; &#125; public function delete()&#123; $id=input(&#x27;get.id&#x27;); $ret=UserModel::destroy($id);//软删除// $ret=UserModel::destroy($id,true); //真实删除 // $user=new UserModel();// $ret=$user-&gt;delete($id); if($ret)&#123; $this-&gt;success(&#x27;删除用户成功&#x27;,&#x27;User/list&#x27;); &#125;else&#123; $this-&gt;error(&#x27;删除用户失效&#x27;); &#125; &#125;&#125; modelapplication&#x2F;admin&#x2F;model&#x2F;User.php1234567891011121314151617181920212223242526&lt;?phpnamespace app\\admin\\model;use think\\Model;use traits\\model\\SoftDelete;class User extends Model&#123; use SoftDelete;// 软删除 protected static $deleteTime=&#x27;delete_time&#x27;; protected $auto=[&#x27;ip&#x27;,&#x27;password&#x27;,&#x27;repassword&#x27;]; protected function setIpAttr()&#123; return request()-&gt;ip(); &#125;// 加密 protected function setPasswordAttr($value)&#123; return md5($value); &#125; protected function setRepasswordAttr($value)&#123; return md5($value); &#125;&#125; validateapplication&#x2F;admin&#x2F;validate&#x2F;User.php1234567891011121314151617181920212223&lt;?phpnamespace app\\admin\\validate;use think\\Validate;class User extends Validate&#123; protected $rule=[ &#x27;name|用户名&#x27;=&gt;&#x27;require|min:3&#x27;, &#x27;password|密码&#x27;=&gt;&#x27;require|min:6|confirm:repassword&#x27;, &#x27;email|邮箱&#x27;=&gt;&#x27;require&#x27;, ]; protected $message=[ &#x27;name.require&#x27;=&gt;&#x27;用户名不能为空&#x27;, &#x27;name.min&#x27;=&gt;&#x27;用户名长度不能少于3位&#x27;, &#x27;password.require&#x27;=&gt;&#x27;密码不能为空&#x27;, &#x27;password.min&#x27;=&gt;&#x27;密码不能少于6位&#x27;, &#x27;password.confirm&#x27;=&gt;&#x27;两次密码不一致&#x27;, &#x27;email.require&#x27;=&gt;&#x27;邮箱不能为空&#x27;, ];&#125; viewapplication&#x2F;admin&#x2F;view&#x2F;index&#x2F;login.html1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cn&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot; /&gt; &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; &lt;title&gt;登录&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/pintuer.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/admin.css&quot;&gt; &lt;script src=&quot;/js/jquery.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/js/pintuer.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;bg&quot;&gt;&lt;/div&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;line bouncein&quot;&gt; &lt;div class=&quot;xs6 xm4 xs3-move xm4-move&quot;&gt; &lt;div style=&quot;height:150px;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;media media-y margin-big-bottom&quot;&gt; &lt;/div&gt; &lt;form action=&quot;check&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;panel loginbox&quot;&gt; &lt;div class=&quot;text-center margin-big padding-big-top&quot;&gt;&lt;h1&gt;后台管理中心&lt;/h1&gt;&lt;/div&gt; &lt;div class=&quot;panel-body&quot; style=&quot;padding:30px; padding-bottom:10px; padding-top:10px;&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;field field-icon-right&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;input input-big&quot; name=&quot;name&quot; placeholder=&quot;登录账号&quot; data-validate=&quot;required:请填写账号&quot; /&gt; &lt;span class=&quot;icon icon-user margin-small&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;field field-icon-right&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;input input-big&quot; name=&quot;password&quot; placeholder=&quot;登录密码&quot; data-validate=&quot;required:请填写密码&quot; /&gt; &lt;span class=&quot;icon icon-key margin-small&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;field&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;input input-big&quot; name=&quot;code&quot; placeholder=&quot;填写右侧的验证码&quot; data-validate=&quot;required:请填写右侧的验证码&quot; /&gt; &lt;img src=&quot;&#123;:captcha_src()&#125;&quot; alt=&quot;capcha&quot; width=&quot;100&quot; height=&quot;32&quot; class=&quot;passcode&quot; style=&quot;height:43px;cursor:pointer;&quot; onclick=&quot;this.src=this.src+&#x27;?&#x27;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;padding:30px;&quot;&gt;&lt;input type=&quot;submit&quot; class=&quot;button button-block bg-main text-big input-big&quot; value=&quot;登录&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; application&#x2F;admin&#x2F;view&#x2F;user&#x2F;index.html1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cn&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot; /&gt; &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; &lt;title&gt;后台管理中心&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/pintuer.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/admin.css&quot;&gt; &lt;script src=&quot;/js/jquery.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body style=&quot;background-color:#f2f9fd;&quot;&gt;&lt;div class=&quot;header bg-main&quot;&gt; &lt;div class=&quot;logo margin-big-left fadein-top&quot;&gt; &lt;h1&gt;&lt;img src=&quot;/images/y.jpg&quot; class=&quot;radius-circle rotate-hover&quot; height=&quot;50&quot; alt=&quot;&quot; /&gt;后台管理中心&lt;/h1&gt; &lt;/div&gt; &lt;div class=&quot;head-l&quot;&gt;&lt;a class=&quot;button button-little bg-green&quot; href=&quot;&#123;:url(&#x27;admin/User/index&#x27;)&#125;&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;icon-home&quot;&gt;&lt;/span&gt; 前台首页&lt;/a&gt; &amp;nbsp;&amp;nbsp;&lt;a href=&quot;##&quot; class=&quot;button button-little bg-blue&quot;&gt; &lt;span class=&quot;icon-wrench&quot;&gt;&lt;/span&gt; 清除缓存&lt;/a&gt; &amp;nbsp;&amp;nbsp; &lt;a class=&quot;button button-little bg-red&quot; href=&quot;&#123;:url(&#x27;admin/Index/logout&#x27;)&#125;&quot;&gt; &lt;span class=&quot;icon-power-off&quot;&gt;&lt;/span&gt; 退出登录&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;leftnav&quot;&gt; &lt;div class=&quot;leftnav-title&quot;&gt; &lt;strong&gt;&lt;span class=&quot;icon-list&quot;&gt;&lt;/span&gt;菜单列表&lt;/strong&gt; &lt;/div&gt; &lt;h2&gt;&lt;span class=&quot;icon-user&quot;&gt;&lt;/span&gt;基本设置&lt;/h2&gt; &lt;ul style=&quot;display:block&quot;&gt; &lt;li&gt;&lt;a href=&quot;info.html&quot; target=&quot;right&quot;&gt;&lt;span class=&quot;icon-caret-right&quot;&gt;&lt;/span&gt;网站设置&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;pass.html&quot; target=&quot;right&quot;&gt;&lt;span class=&quot;icon-caret-right&quot;&gt;&lt;/span&gt;修改密码&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;page.html&quot; target=&quot;right&quot;&gt;&lt;span class=&quot;icon-caret-right&quot;&gt;&lt;/span&gt;单页管理&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;adv.html&quot; target=&quot;right&quot;&gt;&lt;span class=&quot;icon-caret-right&quot;&gt;&lt;/span&gt;首页轮播&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;book.html&quot; target=&quot;right&quot;&gt;&lt;span class=&quot;icon-caret-right&quot;&gt;&lt;/span&gt;留言管理&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;column.html&quot; target=&quot;right&quot;&gt;&lt;span class=&quot;icon-caret-right&quot;&gt;&lt;/span&gt;栏目管理&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;&lt;span class=&quot;icon-pencil-square-o&quot;&gt;&lt;/span&gt;栏目管理&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;list.html&quot; target=&quot;right&quot;&gt;&lt;span class=&quot;icon-caret-right&quot;&gt;&lt;/span&gt;内容管理&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;add.html&quot; target=&quot;right&quot;&gt;&lt;span class=&quot;icon-caret-right&quot;&gt;&lt;/span&gt;添加内容&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;cate.html&quot; target=&quot;right&quot;&gt;&lt;span class=&quot;icon-caret-right&quot;&gt;&lt;/span&gt;分类管理&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;$(function()&#123; $(&quot;.leftnav h2&quot;).click(function()&#123; $(this).next().slideToggle(200); $(this).toggleClass(&quot;on&quot;); &#125;) $(&quot;.leftnav ul li a&quot;).click(function()&#123; $(&quot;#a_leader_txt&quot;).text($(this).text()); $(&quot;.leftnav ul li a&quot;).removeClass(&quot;on&quot;); $(this).addClass(&quot;on&quot;); &#125;)&#125;);&lt;/script&gt;&lt;ul class=&quot;bread&quot;&gt; &lt;li&gt;&lt;a href=&quot;##&quot; id=&quot;a_leader_txt&quot;&gt;网站信息&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;当前语言：&lt;/b&gt;&lt;span style=&quot;color:#ffffff;&quot;&gt;中文&lt;/span&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;切换语言：&lt;a href=&quot;##&quot;&gt;中文&lt;/a&gt; &amp;nbsp;&amp;nbsp;&lt;a href=&quot;##&quot;&gt;英文&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;admin&quot;&gt; &lt;iframe scrolling=&quot;auto&quot; rameborder=&quot;0&quot; src=&quot;list&quot; name=&quot;right&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;div style=&quot;text-align:center;&quot;&gt;&lt;p&gt;来源:&lt;a href=&quot;http://www.php.cn/&quot; target=&quot;_blank&quot;&gt;PHP中文网下载站&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; application&#x2F;admin&#x2F;view&#x2F;user&#x2F;list.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cn&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot; /&gt;&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/pintuer.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/admin.css&quot;&gt;&lt;script src=&quot;/js/jquery.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/js/pintuer.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=&quot;post&quot; action=&quot;&quot; id=&quot;listform&quot;&gt; &lt;div class=&quot;panel admin-panel&quot;&gt; &lt;div class=&quot;panel-head&quot;&gt;&lt;strong class=&quot;icon-reorder&quot;&gt; 用户列表&lt;/strong&gt; &lt;strong class=&quot;icon-reorder&quot;&gt; &lt;a href=&quot;add&quot; style=&quot;float:right;&quot;&gt;添加管理员&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt; &lt;table class=&quot;table table-hover text-center&quot;&gt; &lt;tr&gt; &lt;th width=&quot;10%&quot; style=&quot;text-align:left; padding-left:20px;&quot;&gt;ID&lt;/th&gt; &lt;th width=&quot;10%&quot; style=&quot;text-align:left; padding-left:20px;&quot;&gt;用户名&lt;/th&gt; &lt;th width=&quot;20%&quot; style=&quot;text-align:left; padding-left:20px;&quot;&gt;密码&lt;/th&gt; &lt;th width=&quot;20%&quot; style=&quot;text-align:left; padding-left:20px;&quot;&gt;邮箱&lt;/th&gt; &lt;th width=&quot;20%&quot; style=&quot;text-align:left; padding-left:20px;&quot;&gt;创建时间&lt;/th&gt; &lt;/tr&gt; &lt;volist name=&quot;list&quot; id=&quot;vo&quot;&gt; &#123;foreach $data as $value&#125; &lt;tr&gt;&lt;!-- &lt;td style=&quot;text-align:left; padding-left:20px;&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;id[]&quot; value=&quot;&quot; /&gt;--&gt;&lt;!-- &#123;$value.id&#125;&lt;/td&gt;--&gt; &lt;td&gt;&#123;$value.id&#125;&lt;/td&gt; &lt;td&gt;&#123;$value.name&#125;&lt;/td&gt; &lt;td width=&quot;10%&quot;&gt;&#123;$value.password&#125;&lt;/td&gt; &lt;td&gt;&#123;$value.email&#125;&lt;/td&gt; &lt;td&gt;&lt;font color=&quot;#00CC99&quot;&gt;&lt;/font&gt;&#123;$value.create_time&#125;&lt;/td&gt; &lt;td&gt;&lt;div class=&quot;button-group&quot;&gt; &lt;a class=&quot;button border-main&quot; href=&quot;edit?id=&#123;$value.id&#125;&quot;&gt; &lt;span class=&quot;icon-edit&quot;&gt;&lt;/span&gt; 修改&lt;/a&gt; &lt;a class=&quot;button border-red&quot; href=&quot;delete?id=&#123;$value.id&#125;&quot; onclick=&quot;return del(1,1,1)&quot;&gt; &lt;span class=&quot;icon-trash-o&quot;&gt;&lt;/span&gt; 删除&lt;/a&gt; &lt;/div&gt; &lt;/td&gt; &#123;/foreach&#125; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;8&quot;&gt;&lt;!-- &lt;div class=&quot;pagelist&quot;&gt;--&gt;&lt;!-- &lt;a href=&quot;&quot;&gt;上一页&lt;/a&gt;--&gt; &lt;span class=&quot;current&quot;&gt;&#123;$page&#125;&lt;/span&gt;&lt;!-- &lt;a href=&quot;&quot;&gt;2&lt;/a&gt;--&gt;&lt;!-- &lt;a href=&quot;&quot;&gt;3&lt;/a&gt;--&gt;&lt;!-- &lt;a href=&quot;&quot;&gt;下一页&lt;/a&gt;--&gt;&lt;!-- &lt;a href=&quot;&quot;&gt;尾页&lt;/a&gt;--&gt;&lt;!-- &lt;/div&gt;--&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/form&gt;&lt;script type=&quot;text/javascript&quot;&gt;//搜索function changesearch()&#123; &#125;//单个删除function del(id,mid,iscid)&#123; if(confirm(&quot;您确定要删除吗?&quot;))&#123; &#125;&#125;//全选$(&quot;#checkall&quot;).click(function()&#123; $(&quot;input[name=&#x27;id[]&#x27;]&quot;).each(function()&#123; if (this.checked) &#123; this.checked = false; &#125; else &#123; this.checked = true; &#125; &#125;);&#125;)//批量删除function DelSelect()&#123; var Checkbox=false; $(&quot;input[name=&#x27;id[]&#x27;]&quot;).each(function()&#123; if (this.checked==true) &#123; Checkbox=true; &#125; &#125;); if (Checkbox)&#123; var t=confirm(&quot;您确认要删除选中的内容吗？&quot;); if (t==false) return false; $(&quot;#listform&quot;).submit(); &#125; else&#123; alert(&quot;请选择您要删除的内容!&quot;); return false; &#125;&#125;//批量排序function sorts()&#123; var Checkbox=false; $(&quot;input[name=&#x27;id[]&#x27;]&quot;).each(function()&#123; if (this.checked==true) &#123; Checkbox=true; &#125; &#125;); if (Checkbox)&#123; $(&quot;#listform&quot;).submit(); &#125; else&#123; alert(&quot;请选择要操作的内容!&quot;); return false; &#125;&#125;//批量首页显示function changeishome(o)&#123; var Checkbox=false; $(&quot;input[name=&#x27;id[]&#x27;]&quot;).each(function()&#123; if (this.checked==true) &#123; Checkbox=true; &#125; &#125;); if (Checkbox)&#123; $(&quot;#listform&quot;).submit(); &#125; else&#123; alert(&quot;请选择要操作的内容!&quot;); return false; &#125;&#125;//批量推荐function changeisvouch(o)&#123; var Checkbox=false; $(&quot;input[name=&#x27;id[]&#x27;]&quot;).each(function()&#123; if (this.checked==true) &#123; Checkbox=true; &#125; &#125;); if (Checkbox)&#123; $(&quot;#listform&quot;).submit(); &#125; else&#123; alert(&quot;请选择要操作的内容!&quot;); return false; &#125;&#125;//批量置顶function changeistop(o)&#123; var Checkbox=false; $(&quot;input[name=&#x27;id[]&#x27;]&quot;).each(function()&#123; if (this.checked==true) &#123; Checkbox=true; &#125; &#125;); if (Checkbox)&#123; $(&quot;#listform&quot;).submit(); &#125; else&#123; alert(&quot;请选择要操作的内容!&quot;); return false; &#125;&#125;//批量移动function changecate(o)&#123; var Checkbox=false; $(&quot;input[name=&#x27;id[]&#x27;]&quot;).each(function()&#123; if (this.checked==true) &#123; Checkbox=true; &#125; &#125;); if (Checkbox)&#123; $(&quot;#listform&quot;).submit(); &#125; else&#123; alert(&quot;请选择要操作的内容!&quot;); return false; &#125;&#125;//批量复制function changecopy(o)&#123; var Checkbox=false; $(&quot;input[name=&#x27;id[]&#x27;]&quot;).each(function()&#123; if (this.checked==true) &#123; Checkbox=true; &#125; &#125;); if (Checkbox)&#123; var i = 0; $(&quot;input[name=&#x27;id[]&#x27;]&quot;).each(function()&#123; if (this.checked==true) &#123; i++; &#125; &#125;); if(i&gt;1)&#123; alert(&quot;只能选择一条信息!&quot;); $(o).find(&quot;option:first&quot;).prop(&quot;selected&quot;,&quot;selected&quot;); &#125;else&#123; $(&quot;#listform&quot;).submit(); &#125; &#125; else&#123; alert(&quot;请选择要复制的内容!&quot;); $(o).find(&quot;option:first&quot;).prop(&quot;selected&quot;,&quot;selected&quot;); return false; &#125;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; application&#x2F;admin&#x2F;view&#x2F;user&#x2F;add.html1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cn&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot; /&gt;&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/pintuer.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/admin.css&quot;&gt;&lt;script src=&quot;/js/jquery.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/js/pintuer.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;panel admin-panel&quot;&gt; &lt;div class=&quot;panel-head&quot; id=&quot;add&quot;&gt;&lt;strong&gt;&lt;span class=&quot;icon-pencil-square-o&quot;&gt;&lt;/span&gt;增加管理员&lt;/strong&gt; &lt;strong&gt;&lt;a href=&quot;list.html&quot;&gt;&lt;span class=&quot;icon-pencil-square-o&quot;&gt;&lt;/span&gt;返回&lt;/a&gt; &lt;/strong&gt; &lt;/div&gt; &lt;div class=&quot;body-content&quot;&gt; &lt;form method=&quot;post&quot; class=&quot;form-x&quot; action=&quot;insert&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;label&quot;&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;field&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;input w50&quot; value=&quot;&quot; name=&quot;name&quot; data-validate=&quot;required:请输入标题&quot; /&gt; &lt;div class=&quot;tips&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;label&quot;&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;field&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;input w50&quot; name=&quot;password&quot; value=&quot;&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;label&quot;&gt; &lt;label&gt;确认密码：&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;field&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;input w50&quot; name=&quot;repassword&quot; value=&quot;&quot;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;label&quot;&gt; &lt;label&gt;邮箱：&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;field&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;input w50&quot; name=&quot;email&quot; value=&quot;&quot; /&gt; &lt;div class=&quot;tips&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;label&quot;&gt; &lt;label&gt;&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;field&quot;&gt; &lt;button class=&quot;button bg-main icon-check-square-o&quot; type=&quot;submit&quot;&gt; 提交&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; application&#x2F;admin&#x2F;view&#x2F;user&#x2F;edit.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cn&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot; /&gt;&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/pintuer.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/admin.css&quot;&gt;&lt;script src=&quot;/js/jquery.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/js/pintuer.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;panel admin-panel&quot;&gt; &lt;div class=&quot;panel-head&quot; id=&quot;add&quot;&gt;&lt;strong&gt;&lt;span class=&quot;icon-pencil-square-o&quot;&gt;&lt;/span&gt;修改管理员&lt;/strong&gt; &lt;strong&gt; &lt;a href=&quot;list&quot;&gt;&lt;span class=&quot;icon-pencil-square-o&quot;&gt;&lt;/span&gt;取消&lt;/a&gt; &lt;/strong&gt; &lt;/div&gt; &lt;div class=&quot;body-content&quot;&gt; &lt;form method=&quot;post&quot; class=&quot;form-x&quot; action=&quot;update&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;&#123;$data.id&#125;&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;label&quot;&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;field&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;input w50&quot; value=&quot;&#123;$data.name&#125;&quot; name=&quot;name&quot; data-validate=&quot;required:请输入标题&quot; /&gt; &lt;div class=&quot;tips&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;label&quot;&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;field&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;input w50&quot; name=&quot;password&quot; value=&quot;&#123;$data.password&#125;&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;label&quot;&gt; &lt;label&gt;确认密码：&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;field&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;input w50&quot; name=&quot;repassword&quot; value=&quot;&#123;$data.repassword&#125;&quot;/&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;label&quot;&gt; &lt;label&gt;邮箱：&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;field&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;input w50&quot; name=&quot;email&quot; value=&quot;&#123;$data.email&#125;&quot; /&gt; &lt;div class=&quot;tips&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;label&quot;&gt; &lt;label&gt;&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;field&quot;&gt; &lt;button class=&quot;button bg-main icon-check-square-o&quot; type=&quot;submit&quot;&gt;修改&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; application&#x2F;config.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260&lt;?php// +----------------------------------------------------------------------// | ThinkPHP [ WE CAN DO IT JUST THINK ]// +----------------------------------------------------------------------// | Copyright (c) 2006~2018 http://thinkphp.cn All rights reserved.// +----------------------------------------------------------------------// | Licensed ( http://www.apache.org/licenses/LICENSE-2.0 )// +----------------------------------------------------------------------// | Author: liu21st &lt;liu21st@gmail.com&gt;// +----------------------------------------------------------------------return [ // +---------------------------------------------------------------------- // | 应用设置 // +---------------------------------------------------------------------- // 应用调试模式 &#x27;app_debug&#x27; =&gt; false, // 应用Trace &#x27;app_trace&#x27; =&gt; false, // 应用模式状态 &#x27;app_status&#x27; =&gt; &#x27;&#x27;, // 是否支持多模块 &#x27;app_multi_module&#x27; =&gt; true, // 入口自动绑定模块 &#x27;auto_bind_module&#x27; =&gt; false, // 注册的根命名空间 &#x27;root_namespace&#x27; =&gt; [], // 扩展函数文件 &#x27;extra_file_list&#x27; =&gt; [THINK_PATH . &#x27;helper&#x27; . EXT], // 默认输出类型 &#x27;default_return_type&#x27; =&gt; &#x27;html&#x27;, // 默认AJAX 数据返回格式,可选json xml ... &#x27;default_ajax_return&#x27; =&gt; &#x27;json&#x27;, // 默认JSONP格式返回的处理方法 &#x27;default_jsonp_handler&#x27; =&gt; &#x27;jsonpReturn&#x27;, // 默认JSONP处理方法 &#x27;var_jsonp_handler&#x27; =&gt; &#x27;callback&#x27;, // 默认时区 &#x27;default_timezone&#x27; =&gt; &#x27;PRC&#x27;, // 是否开启多语言 &#x27;lang_switch_on&#x27; =&gt; false, // 默认全局过滤方法 用逗号分隔多个 &#x27;default_filter&#x27; =&gt; &#x27;&#x27;, // 默认语言 &#x27;default_lang&#x27; =&gt; &#x27;zh-cn&#x27;, // 应用类库后缀 &#x27;class_suffix&#x27; =&gt; false, // 控制器类后缀 &#x27;controller_suffix&#x27; =&gt; false, // +---------------------------------------------------------------------- // | 模块设置 // +---------------------------------------------------------------------- // 默认模块名 &#x27;default_module&#x27; =&gt; &#x27;index&#x27;, // 禁止访问模块 &#x27;deny_module_list&#x27; =&gt; [&#x27;common&#x27;], // 默认控制器名 &#x27;default_controller&#x27; =&gt; &#x27;Index&#x27;, // 默认操作名 &#x27;default_action&#x27; =&gt; &#x27;index&#x27;, // 默认验证器 &#x27;default_validate&#x27; =&gt; &#x27;&#x27;, // 默认的空控制器名 &#x27;empty_controller&#x27; =&gt; &#x27;Error&#x27;, // 操作方法后缀 &#x27;action_suffix&#x27; =&gt; &#x27;&#x27;, // 自动搜索控制器 &#x27;controller_auto_search&#x27; =&gt; true, // +---------------------------------------------------------------------- // | URL设置 // +---------------------------------------------------------------------- // PATHINFO变量名 用于兼容模式 &#x27;var_pathinfo&#x27; =&gt; &#x27;s&#x27;, // 兼容PATH_INFO获取 &#x27;pathinfo_fetch&#x27; =&gt; [&#x27;ORIG_PATH_INFO&#x27;, &#x27;REDIRECT_PATH_INFO&#x27;, &#x27;REDIRECT_URL&#x27;], // pathinfo分隔符 &#x27;pathinfo_depr&#x27; =&gt; &#x27;/&#x27;, // URL伪静态后缀 &#x27;url_html_suffix&#x27; =&gt; &#x27;html&#x27;, // URL普通方式参数 用于自动生成 &#x27;url_common_param&#x27; =&gt; false, // URL参数方式 0 按名称成对解析 1 按顺序解析 &#x27;url_param_type&#x27; =&gt; 0, // 是否开启路由 &#x27;url_route_on&#x27; =&gt; true, // 路由使用完整匹配 &#x27;route_complete_match&#x27; =&gt; false, // 路由配置文件（支持配置多个） &#x27;route_config_file&#x27; =&gt; [&#x27;route&#x27;], // 是否开启路由解析缓存 &#x27;route_check_cache&#x27; =&gt; false, // 是否强制使用路由 &#x27;url_route_must&#x27; =&gt; false, // 域名部署 &#x27;url_domain_deploy&#x27; =&gt; false, // 域名根，如thinkphp.cn &#x27;url_domain_root&#x27; =&gt; &#x27;&#x27;, // 是否自动转换URL中的控制器和操作名 &#x27;url_convert&#x27; =&gt; true, // 默认的访问控制器层 &#x27;url_controller_layer&#x27; =&gt; &#x27;controller&#x27;, // 表单请求类型伪装变量 &#x27;var_method&#x27; =&gt; &#x27;_method&#x27;, // 表单ajax伪装变量 &#x27;var_ajax&#x27; =&gt; &#x27;_ajax&#x27;, // 表单pjax伪装变量 &#x27;var_pjax&#x27; =&gt; &#x27;_pjax&#x27;, // 是否开启请求缓存 true自动缓存 支持设置请求缓存规则 &#x27;request_cache&#x27; =&gt; false, // 请求缓存有效期 &#x27;request_cache_expire&#x27; =&gt; null, // 全局请求缓存排除规则 &#x27;request_cache_except&#x27; =&gt; [], // +---------------------------------------------------------------------- // | 模板设置 // +---------------------------------------------------------------------- &#x27;template&#x27; =&gt; [ // 模板引擎类型 支持 php think 支持扩展 &#x27;type&#x27; =&gt; &#x27;Think&#x27;, // 默认模板渲染规则 1 解析为小写+下划线 2 全部转换小写 &#x27;auto_rule&#x27; =&gt; 1, // 模板路径 &#x27;view_path&#x27; =&gt; &#x27;&#x27;, // 模板后缀 &#x27;view_suffix&#x27; =&gt; &#x27;html&#x27;, // 模板文件名分隔符 &#x27;view_depr&#x27; =&gt; DS, // 模板引擎普通标签开始标记 &#x27;tpl_begin&#x27; =&gt; &#x27;&#123;&#x27;, // 模板引擎普通标签结束标记 &#x27;tpl_end&#x27; =&gt; &#x27;&#125;&#x27;, // 标签库标签开始标记 &#x27;taglib_begin&#x27; =&gt; &#x27;&#123;&#x27;, // 标签库标签结束标记 &#x27;taglib_end&#x27; =&gt; &#x27;&#125;&#x27;, ], // 视图输出字符串内容替换 &#x27;view_replace_str&#x27; =&gt; [], // 默认跳转页面对应的模板文件 &#x27;dispatch_success_tmpl&#x27; =&gt; THINK_PATH . &#x27;tpl&#x27; . DS . &#x27;dispatch_jump.tpl&#x27;, &#x27;dispatch_error_tmpl&#x27; =&gt; THINK_PATH . &#x27;tpl&#x27; . DS . &#x27;dispatch_jump.tpl&#x27;, // +---------------------------------------------------------------------- // | 异常及错误设置 // +---------------------------------------------------------------------- // 异常页面的模板文件 &#x27;exception_tmpl&#x27; =&gt; THINK_PATH . &#x27;tpl&#x27; . DS . &#x27;think_exception.tpl&#x27;, // 错误显示信息,非调试模式有效 &#x27;error_message&#x27; =&gt; &#x27;页面错误！请稍后再试～&#x27;, // 显示错误信息 &#x27;show_error_msg&#x27; =&gt; false, // 异常处理handle类 留空使用 \\think\\exception\\Handle &#x27;exception_handle&#x27; =&gt; &#x27;&#x27;, // +---------------------------------------------------------------------- // | 日志设置 // +---------------------------------------------------------------------- &#x27;log&#x27; =&gt; [ // 日志记录方式，内置 file socket 支持扩展 &#x27;type&#x27; =&gt; &#x27;File&#x27;, // 日志保存目录 &#x27;path&#x27; =&gt; LOG_PATH, // 日志记录级别 &#x27;level&#x27; =&gt; [], ], // +---------------------------------------------------------------------- // | Trace设置 开启 app_trace 后 有效 // +---------------------------------------------------------------------- &#x27;trace&#x27; =&gt; [ // 内置Html Console 支持扩展 &#x27;type&#x27; =&gt; &#x27;Html&#x27;, ], // +---------------------------------------------------------------------- // | 缓存设置 // +---------------------------------------------------------------------- &#x27;cache&#x27; =&gt; [ // 驱动方式 &#x27;type&#x27; =&gt; &#x27;File&#x27;, // 缓存保存目录 &#x27;path&#x27; =&gt; CACHE_PATH, // 缓存前缀 &#x27;prefix&#x27; =&gt; &#x27;&#x27;, // 缓存有效期 0表示永久缓存 &#x27;expire&#x27; =&gt; 0, ], // +---------------------------------------------------------------------- // | 会话设置 // +---------------------------------------------------------------------- &#x27;session&#x27; =&gt; [ &#x27;id&#x27; =&gt; &#x27;&#x27;, // SESSION_ID的提交变量,解决flash上传跨域 &#x27;var_session_id&#x27; =&gt; &#x27;&#x27;, // SESSION 前缀 &#x27;prefix&#x27; =&gt; &#x27;think&#x27;, // 驱动方式 支持redis memcache memcached &#x27;type&#x27; =&gt; &#x27;&#x27;, // 是否自动开启 SESSION &#x27;auto_start&#x27; =&gt; true, ], // +---------------------------------------------------------------------- // | Cookie设置 // +---------------------------------------------------------------------- &#x27;cookie&#x27; =&gt; [ // cookie 名称前缀 &#x27;prefix&#x27; =&gt; &#x27;&#x27;, // cookie 保存时间 &#x27;expire&#x27; =&gt; 0, // cookie 保存路径 &#x27;path&#x27; =&gt; &#x27;/&#x27;, // cookie 有效域名 &#x27;domain&#x27; =&gt; &#x27;&#x27;, // cookie 启用安全传输 &#x27;secure&#x27; =&gt; false, // httponly设置 &#x27;httponly&#x27; =&gt; &#x27;&#x27;, // 是否使用 setcookie &#x27;setcookie&#x27; =&gt; true, ], //分页配置 &#x27;paginate&#x27; =&gt; [ &#x27;type&#x27; =&gt; &#x27;bootstrap&#x27;, &#x27;var_page&#x27; =&gt; &#x27;page&#x27;, &#x27;list_rows&#x27; =&gt; 15, ], &#x27;captcha&#x27; =&gt; [ //验证码的字符集 &#x27;codeSet&#x27; =&gt; &#x27;23456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;, //设置验证码大小 &#x27;fontSize&#x27; =&gt; 18, //添加混淆曲线 &#x27;useCurve&#x27; =&gt; false, //设置图片的高度、宽度 &#x27;imageW&#x27; =&gt; 150, &#x27;imageH&#x27; =&gt; 35, //验证码位数 &#x27;length&#x27; =&gt;4, //验证成功后重置 &#x27;reset&#x27; =&gt;true ],]; application&#x2F;database.php1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?php// +----------------------------------------------------------------------// | ThinkPHP [ WE CAN DO IT JUST THINK ]// +----------------------------------------------------------------------// | Copyright (c) 2006~2018 http://thinkphp.cn All rights reserved.// +----------------------------------------------------------------------// | Licensed ( http://www.apache.org/licenses/LICENSE-2.0 )// +----------------------------------------------------------------------// | Author: liu21st &lt;liu21st@gmail.com&gt;// +----------------------------------------------------------------------return [ // 数据库类型 &#x27;type&#x27; =&gt; &#x27;mysql&#x27;, // 服务器地址 &#x27;hostname&#x27; =&gt; &#x27;127.0.0.1&#x27;, // 数据库名 &#x27;database&#x27; =&gt; &#x27;think&#x27;, // 用户名 &#x27;username&#x27; =&gt; &#x27;root&#x27;, // 密码 &#x27;password&#x27; =&gt; &#x27;123456&#x27;, // 端口 &#x27;hostport&#x27; =&gt; &#x27;3306&#x27;, // 连接dsn &#x27;dsn&#x27; =&gt; &#x27;&#x27;, // 数据库连接参数 &#x27;params&#x27; =&gt; [], // 数据库编码默认采用utf8 &#x27;charset&#x27; =&gt; &#x27;utf8&#x27;, // 数据库表前缀 &#x27;prefix&#x27; =&gt; &#x27;think_&#x27;, // 数据库调试模式 &#x27;debug&#x27; =&gt; true, // 数据库部署方式:0 集中式(单一服务器),1 分布式(主从服务器) &#x27;deploy&#x27; =&gt; 0, // 数据库读写是否分离 主从式有效 &#x27;rw_separate&#x27; =&gt; false, // 读写分离后 主服务器数量 &#x27;master_num&#x27; =&gt; 1, // 指定从服务器序号 &#x27;slave_no&#x27; =&gt; &#x27;&#x27;, // 自动读取主库数据 &#x27;read_master&#x27; =&gt; false, // 是否严格检查字段是否存在 &#x27;fields_strict&#x27; =&gt; true, // 数据集返回类型 &#x27;resultset_type&#x27; =&gt; &#x27;array&#x27;, // 自动写入时间戳字段 &#x27;auto_timestamp&#x27; =&gt; &#x27;datetime&#x27;, // 时间字段取出后的默认时间格式 &#x27;datetime_format&#x27; =&gt; &#x27;Y-m-d H:i:s&#x27;, // 是否需要进行SQL性能分析 &#x27;sql_explain&#x27; =&gt; false,];","categories":[{"name":"thinkphp项目","slug":"thinkphp项目","permalink":"https://2486125878.github.io/categories/thinkphp%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"php","slug":"php","permalink":"https://2486125878.github.io/tags/php/"}]},{"title":"thinkphp学习笔记","slug":"thinkphp学习笔记","date":"2024-03-14T07:32:59.000Z","updated":"2024-03-14T07:51:00.000Z","comments":true,"path":"2024/03/14/thinkphp学习笔记/","permalink":"https://2486125878.github.io/2024/03/14/thinkphp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"controller&#x2F;Index.php1234567891011121314151617181920212223242526272829303132&lt;?phpnamespace app\\index\\controller;use think\\Controller;use think\\Env;class Index extends Controller&#123; protected function _initialize() &#123; parent::_initialize(); TODO: Change the autogenerated stub echo &#x27;init&#x27;; &#125; public function index() &#123; return &#x27;index模块&#x27; .Env::get(&#x27;app_path&#x27;) ; &#125; public function test()&#123; return &#x27;测试类&#x27;; &#125; public function arr()&#123; $data=array(&#x27;a&#x27;=&gt;1,&#x27;b&#x27;=&gt;2,&#x27;c&#x27;=&gt;3); return json($data); &#125; public function abc()&#123; return view(); &#125;&#125; controller&#x2F;Address.php12345678910111213141516&lt;?phpnamespace app\\index\\controller;use think\\Controller;class Address extends Controller&#123; public function index()&#123; return &#x27;Address&#x27;; &#125; public function details($id)&#123; return &#x27;deatlls id:&#x27;.$id; &#125;&#125; controller&#x2F;Before.php12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpnamespace app\\index\\controller;use think\\Controller;class Before extends Controller&#123; protected $beforeActionList=[ &#x27;first&#x27;, &#x27;second&#x27; =&gt; [&#x27;except&#x27;=&gt;&#x27;one&#x27;], &#x27;third&#x27; =&gt; [&#x27;only&#x27;=&gt;&#x27;one&#x27;,&#x27;two&#x27;] ]; protected $flag = true; protected function first()&#123; echo &#x27;first&#x27;; &#125; protected function second()&#123; echo &#x27;second&#x27;; &#125; protected function third()&#123; echo &#x27;third&#x27;; &#125; 空方法public function _empty($name)&#123; return &#x27;该方法不存在:&#x27;.$name;&#125; public function index()&#123; if($this-&gt;flag)&#123; $this-&gt;success(&#x27;注册成功&#x27;,&#x27;../&#x27;); &#125;else&#123; $this-&gt;error(&#x27;失败!&#x27;); &#125; return &#x27;index&#x27;; &#125; public function one()&#123; return &#x27;one&#x27;; &#125; public function two()&#123; return &#x27;two&#x27;; &#125;&#125; controller&#x2F;Block.php1234567891011121314&lt;?phpnamespace app\\index\\controller;use think\\Controller;class Block extends Controller&#123; public function index()&#123; $this-&gt;view-&gt;engine-&gt;layout(true); $this-&gt;assign(&#x27;title&#x27;,&#x27;模板&#x27;); return $this-&gt;fetch(&#x27;index&#x27;); &#125;&#125; controller&#x2F;Chain.php1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?phpnamespace app\\index\\controller;use app\\index\\model\\User as usermodel;use think\\Db;class Chain&#123; public function index()&#123; $result=Db::name(&#x27;user&#x27;)-&gt;where([ &#x27;price&#x27; =&gt; 70, &#x27;gender&#x27;=&gt; &#x27;男&#x27; ])-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;where([ [&#x27;gender&#x27;,&#x27;=&#x27;,&#x27;男&#x27;], [&#x27;price&#x27;,&#x27;=&#x27;,&#x27;100&#x27;] ])-&gt;select(); $map[]=[&#x27;price&#x27;,&#x27;in&#x27;,[70,80,90]]; $map[]=[&#x27;gender&#x27;,&#x27;=&#x27;,&#x27;男&#x27;]; $result=Db::name(&#x27;user&#x27;)-&gt;where($map)-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;where(&#x27;gender=&quot;男&quot; AND price IN (60,70,100)&#x27;)-&gt;select(); $result= Db::name(&#x27;user&#x27;)-&gt;field([&#x27;id&#x27;,&#x27;username&#x27;,&#x27;email&#x27;])-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;field(&#x27;SUM(price)&#x27;)-&gt;select(); $result= Db::name(&#x27;user&#x27;)-&gt;field([&#x27;id&#x27;,&#x27;LEFT(email,5)&#x27;=&gt;&#x27;leftemail&#x27;])-&gt;select(); $result= Db::name(&#x27;user&#x27;)-&gt;field(true)-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;field(&#x27;detalis&#x27;,true)-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;alias(&#x27;a&#x27;)-&gt;field(&#x27;details,uid&#x27;,true)-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;limit(1)-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;limit(2,3)-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;limit(0,3)-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;limit(4,3)-&gt;select(); 分页 $result=Db::name(&#x27;user&#x27;)-&gt;page(1,1)-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;page(2,1)-&gt;select(); 倒叙 $result=Db::name(&#x27;user&#x27;)-&gt;order(&#x27;id&#x27;,&#x27;desc&#x27;)-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;order([&#x27;create_time&#x27;=&gt;&#x27;desc&#x27;,&#x27;price&#x27;=&gt;&#x27;asc&#x27;])-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;field(&#x27;gender,SUM(price)&#x27;)-&gt;group(&#x27;gender,password&#x27;) -&gt;select(); $result=Db::name(&#x27;user&#x27;) -&gt;field(&#x27;gender,SUM(price)&#x27;) -&gt;group(&#x27;gender&#x27;) -&gt;having(&#x27;SUM(price)&gt;180&#x27;) -&gt;select(); $result=usermodel::select(); return Db::getLastSql(); return json($result); &#125;&#125; controller&#x2F;DataTest.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;?phpnamespace app\\index\\controller;use app\\index\\model\\User;use think\\Controller;use think\\Db;use think\\db\\exception\\DataNotFoundException;class DataTest extends Controller&#123; 查询 public function index()&#123; $data= Db::table(&#x27;tp_user&#x27;)-&gt;find(); $data=Db::table(&#x27;tp_user&#x27;)-&gt;where(&#x27;id&#x27;,2)-&gt;find(); $data=Db::table(&#x27;tp_user&#x27;)-&gt;where(&#x27;id&#x27;,124)-&gt;find(); try &#123; $data=Db::table(&#x27;tp_user&#x27;)-&gt;where(&#x27;id&#x27;,124)-&gt;findOrFail(); &#125;catch (DataNotFoundException $e)&#123; return &#x27;查询不到数据&#x27;; &#125; $data=Db::table(&#x27;tp_user&#x27;)-&gt;where(&#x27;id&#x27;,124)-&gt;findOrEmpty() 没有这个方法; return Db::getLastSql(); $data= Db::table(&#x27;tp_user&#x27;)-&gt;select(); $data= Db::table(&#x27;tp_user&#x27;)-&gt;where(&#x27;id&#x27;,127)-&gt;selectOrFail(); $data= Db::name(&#x27;user&#x27;)-&gt;select(); $data= Db::name(&#x27;user&#x27;)-&gt;where(&#x27;id&#x27;,2)-&gt;value(&#x27;username&#x27;); $data= Db::name(&#x27;user&#x27;)-&gt;column(&#x27;username&#x27;,&#x27;id&#x27;); print_r(Db::name(&#x27;user&#x27;)); $data=$user-&gt;where(&#x27;id&#x27;,1)-&gt;order(&#x27;id&#x27;,&#x27;desc&#x27;)-&gt;find(); $user=Db::name(&#x27;user&#x27;); $data1=$user-&gt;where(&#x27;id&#x27;,1)-&gt;order(&#x27;id&#x27;,&#x27;desc&#x27;); $data2=$user-&gt;removeOption(&#x27;where&#x27;)-&gt;removeOption(&#x27;order&#x27;)-&gt;select(); return json($data2); return Db::getLastSql(); return ($data); &#125; 插入 public function insert()&#123; $data=[ &#x27;id&#x27;=&gt;&#x27;5&#x27;, &#x27;username&#x27; =&gt; &#x27;辉夜3&#x27;, &#x27;password&#x27; =&gt; &#x27;123456&#x27;, &#x27;gender&#x27;=&gt;&#x27;男&#x27;, &#x27;email&#x27;=&gt;&#x27;1565165@qq.com&#x27;, &#x27;price&#x27;=&gt;&#x27;1516&#x27;, &#x27;detalis&#x27;=&gt;&#x27;2132321&#x27; ]; $insert= Db::name(&#x27;user&#x27;)-&gt;data($data)-&gt;insert(); $insert= Db::name(&#x27;user&#x27;)-&gt;insert($data,true); return Db::getLastInsID(); return $insert; &#125; 批量插入 public function insertAll()&#123; $dataAll=[ [ &#x27;username&#x27; =&gt; &#x27;辉夜1&#x27;, &#x27;password&#x27; =&gt; &#x27;1234526&#x27;, &#x27;gender&#x27;=&gt;&#x27;男&#x27;, &#x27;email&#x27;=&gt;&#x27;1565165@qq.com&#x27;, &#x27;price&#x27;=&gt;&#x27;1516&#x27;, &#x27;detalis&#x27;=&gt;&#x27;2132321&#x27; ],[ &#x27;username&#x27; =&gt; &#x27;辉夜2&#x27;, &#x27;password&#x27; =&gt; &#x27;123456&#x27;, &#x27;gender&#x27;=&gt;&#x27;男&#x27;, &#x27;email&#x27;=&gt;&#x27;1565165@qq.com&#x27;, &#x27;price&#x27;=&gt;&#x27;1516&#x27;, &#x27;detalis&#x27;=&gt;&#x27;2132321&#x27; ] ]; Db::name(&#x27;user&#x27;)-&gt;insertAll($dataAll); &#125; 修改 public function update()&#123; $data=[ &#x27;username&#x27;=&gt;&#x27;李白2&#x27;, &#x27;id&#x27;=&gt;75, &#x27;email&#x27;=&gt;Db::raw(&#x27;UPPER(email)&#x27;), &#x27;price&#x27;=&gt;Db::raw(&#x27;price-3&#x27;) ]; Db::name(&#x27;user&#x27;)-&gt;where(&#x27;id&#x27;,7)-&gt;update($data); Db::name(&#x27;user&#x27;)-&gt;where(&#x27;id&#x27;,7)-&gt;data($data)-&gt;update([&#x27;password&#x27;=&gt;&#x27;52554&#x27;]); Db::name(&#x27;user&#x27;)-&gt;inc(&#x27;price&#x27;,5)-&gt;update($data); Db::name(&#x27;user&#x27;)-&gt;update($data); Db::name(&#x27;user&#x27;)-&gt;where(&#x27;id&#x27;,75)-&gt;setField(&#x27;username&#x27;,&#x27;王五&#x27;); Db::name(&#x27;user&#x27;)-&gt;where(&#x27;id&#x27;,75)-&gt;setInc(&#x27;price&#x27;,5); Db::name(&#x27;user&#x27;)-&gt;where(&#x27;id&#x27;,75)-&gt;setField(&#x27;price&#x27;,5); &#125; 删除 public function delete()&#123; Db::name(&#x27;user&#x27;)-&gt;delete(1); Db::name(&#x27;user&#x27;)-&gt;delete([2,3,4]); Db::name(&#x27;user&#x27;)-&gt;where(&#x27;id&#x27;,75)-&gt;delete(); Db::name(&#x27;user&#x27;)-&gt;delete(true); &#125; public function getNoModelData()&#123; $data=Db::table(&#x27;tp_user&#x27;)-&gt;select(); $data=Db::name(&#x27;user&#x27;)-&gt;select(); return json($data); &#125; public function getModelData()&#123; $data= User::all(); return json($data); &#125;&#125; controller&#x2F;Error.php123456789101112&lt;?phpnamespace app\\index\\controller;use think\\Request;class Error&#123; public function index(Request $r)&#123; return &#x27;此控制器不存在&#x27;.$r-&gt;controller(); &#125;&#125; controller&#x2F;Reqt.php123456789101112131415&lt;?phpnamespace app\\index\\controller;use think\\Request;class Reqt&#123; public function index()&#123; $request=Request::instance(); dump($request); echo &#x27;当前的域名是:&#x27;.$request-&gt;domain().&#x27;&lt;br/&gt;&#x27;; echo &#x27;当前的入口文件是:&#x27;.$request-&gt;baseFile().&#x27;&lt;br/&gt;&#x27;; echo &#x27;当前url后缀信息是:&#x27;.$request-&gt;ext().&#x27;&lt;br/&gt;&#x27;; &#125;&#125; controller&#x2F;See.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;?phpnamespace app\\index\\controller;use think\\Controller;use app\\index\\model\\User as UserModel;class See extends Controller&#123; public function _initialize() &#123; parent::_initialize(); TODO: Change the autogenerated stub $this-&gt;assign(function ($content)&#123; return str_replace(&#x27;1&#x27;,&#x27;&lt;br&gt;&#x27;,$content); &#125;); return view()-&gt;filter(function ($content)&#123; return str_replace(&#x27;1&#x27;,&#x27;&lt;br&gt;&#x27;,$content); &#125;); &#125; public function index()&#123; 自动定位 return $this-&gt;fetch(); return $this-&gt;fetch(&#x27;edit&#x27;); return $this-&gt;fetch(&#x27;../template/public/edit&#x27;); return $this-&gt;fetch(&#x27;admin@/public/edit&#x27;); return $this-&gt;fetch(&#x27;/edit&#x27;); return view(&#x27;edit&#x27;);助手函数 $this-&gt;assign(&#x27;name&#x27;,&#x27;Mr.Lee&#x27;); $this-&gt;assign([ &#x27;username&#x27;=&gt;&#x27;辉夜&#x27;, &#x27;email&#x27;=&gt;&#x27;51516@qq.com&#x27; ]); return $this-&gt;fetch(&#x27;index&#x27;); return $this-&gt;fetch(&#x27;index&#x27;,[ &#x27;username&#x27;=&gt;&#x27;辉1夜&#x27;, &#x27;email&#x27;=&gt;&#x27;51516@qq.com&#x27; ]); &#125; public function textdisplay()&#123; $content=&#x27;&#123;$username&#125;,&#123;$email&#125;&#x27;; return $this-&gt;display($content,[ &#x27;username&#x27;=&gt;&#x27;辉夜&#x27;, &#x27;email&#x27;=&gt;&#x27;51516@qq.com&#x27; ]); 助手函数 return view(&#x27;index&#x27;,[ &#x27;username&#x27;=&gt;&#x27;辉1夜&#x27;, &#x27;email&#x27;=&gt;&#x27;51516@qq.com&#x27; ]); $this-&gt;filter(function ($content)&#123; return str_replace(&#x27;1&#x27;,&#x27;&lt;br&gt;&#x27;,$content); &#125;); return view(&#x27;index&#x27;)-&gt;assign([ &#x27;name&#x27;=&gt;&#x27;dfdsf&#x27;, &#x27;username&#x27;=&gt;&#x27;辉1夜&#x27;, &#x27;email&#x27;=&gt;&#x27;51516@qq.com&#x27; ]); &#125; public function varOutput()&#123; $this-&gt;assign(&#x27;name&#x27;,&#x27;Thinkphp&#x27;); $data[&#x27;username&#x27;]=&#x27;辉夜&#x27;; $data[&#x27;email&#x27;]=&#x27;huiye@163.com&amp;&#x27;; $this-&gt;assign(&#x27;user&#x27;,$data); $obj=new \\stdClass(); $obj-&gt;username = &#x27;辉夜&#x27;; $obj-&gt;email=&#x27;huiye@163.com&#x27;; $this-&gt;assign(&#x27;obj&#x27;,$obj); $this-&gt;assign(&#x27;password&#x27;,&#x27;123456&#x27;); $this-&gt;assign(&#x27;time&#x27;,time()); $this-&gt;assign(&#x27;number&#x27;,14); return $this-&gt;fetch(&#x27;var&#x27;); &#125; public function loop()&#123; $list=UserModel::all(); $this-&gt;assign(&#x27;list&#x27;,$list); return $this-&gt;fetch(&#x27;loop/index&#x27;); &#125; public function compare()&#123; $this-&gt;assign(&#x27;username&#x27;,&#x27;Mr.Lee&#x27;); $this-&gt;assign(&#x27;number&#x27;,55); return $this-&gt;fetch(&#x27;compare/index&#x27;); &#125; public function condtion()&#123; $this-&gt;assign(&#x27;number&#x27;,30); $user=new \\stdClass(); $user-&gt;username=&#x27;Mr.Lee&#x27;; $this-&gt;assign(&#x27;user&#x27;,$user); return $this-&gt;fetch(&#x27;condtion/index&#x27;); &#125;&#125; controller&#x2F;User.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373&lt;?phpnamespace app\\index\\controller;use app\\index\\model\\User as UserModel;use think\\Controller;use think\\Db;class User extends Controller&#123; public function index()&#123; $result=modeluser::select(); $result= modeluser::destroy(11); $result=modeluser::select(); $user=UserModel::get(82); $user=UserModel::where(&#x27;username&#x27;,&#x27;凯&#x27;)-&gt;find(); echo $user-&gt;email; $user=new UserModel(); echo $user-&gt;getEmail(); $user=UserModel::all(&#x27;82,84,85&#x27;); $user=UserModel::where(&#x27;gender&#x27;,&#x27;男&#x27;)-&gt;order(&#x27;id&#x27;,&#x27;asc&#x27;)-&gt;limit(2)-&gt;select(); print_r($user); $user=UserModel::where(&#x27;id&#x27;,82)-&gt;value(&#x27;username&#x27;); $user=UserModel::whereIn(&#x27;id&#x27;,[82,84,85])-&gt;column(&#x27;username&#x27;,&#x27;id&#x27;); 动态查询 return (UserModel::getByUsername(&#x27;凯&#x27;)); 聚合查询 return UserModel::max(&#x27;price&#x27;); $user=UserModel::get(84); return json($user-&gt;getData()); return $user-&gt;status; dump($user-&gt;nothing); return json($user); 没有这个方法 $result=UserModel::withAttr(&#x27;email&#x27;,function ($value)&#123; return strtoupper($value); &#125;)-&gt;select(); return json($result); 没有这个方法 $result=UserModel::withSearch([&#x27;email&#x27;,&#x27;create_time&#x27;=&gt;&#x27;ctime&#x27;],[ &#x27;email&#x27;=&gt;&#x27;xiao&#x27;, &#x27;create_time&#x27;=&gt;[&#x27;2015-1-1&#x27;,&#x27;2017-1-1&#x27;], &#x27;sort&#x27;=&gt;[&#x27;price&#x27;=&gt;&#x27;desc&#x27;] ])&gt;where(&#x27;gender&#x27;,&#x27;男&#x27;)-&gt;order(&#x27;id&#x27;,desc)-&gt;select(); return Db::getLastSql(); $result=UserModel::where(&#x27;id&#x27;,135)-&gt;select(); if($result-&gt;isEmpty())&#123; return &#x27;数据结果集不存在&#x27;; &#125; $result=UserModel::select()-&gt;where(&#x27;price&#x27;,&#x27;=&#x27;,30)-&gt;order(&#x27;id&#x27;,&#x27;desc&#x27;); $result=UserModel::select()-&gt;filter(function ($data)&#123; return $data[&#x27;price&#x27;] = 30; &#125;); $result-&gt;hidden([&#x27;password&#x27;]); $result-&gt;visible([&#x27;password&#x27;]); $result-&gt;append([&#x27;nothing&#x27;])-&gt;withAttr(&#x27;email&#x27;,function ($value)&#123; return strtoupper($value); &#125;); $result=$result-&gt;filter(function ($data)&#123; return $data[&#x27;price&#x27;] &lt; 30; &#125;); $result1=UserModel::where(&#x27;price&#x27;,&#x27;&gt;&#x27;,30)-&gt;select(); $result2=UserModel::where(&#x27;price&#x27;,&#x27;&lt;&#x27;,32)-&gt;select(); return json($result1-&gt;diff($result2)); return json($result1-&gt;intersect($result2)); &#125; public function insert()&#123; $user=new UserModel; $user-&gt;username = &#x27;李白&#x27;; $user-&gt;password = &#x27;123&#x27;; $user-&gt;gender = &#x27;女&#x27;; $user-&gt;email = &#x27;123@qq.com&#x27;; $user-&gt;price = &#x27;90&#x27;; $user-&gt;detalis = &#x27;123ss&#x27;; $user-&gt;uid = &#x27;1102&#x27;; $user-&gt;create_time = date(&#x27;Y-m-d H:i:s&#x27;); $user-&gt;save(); $result=$user-&gt;save([ &#x27;username&#x27; =&gt; &#x27;李白22&#x27;, &#x27;password&#x27; =&gt; &#x27;213&#x27;, &#x27;gender&#x27; =&gt; &#x27;女&#x27;, &#x27;email&#x27; =&gt; &#x27;123@qq.com&#x27;, &#x27;price&#x27; =&gt; &#x27;30&#x27;, &#x27;detalis&#x27; =&gt; &#x27;123ss&#x27;, &#x27;uid&#x27; =&gt; &#x27;1101&#x27;, &#x27;create_time&#x27; =&gt; date(&#x27;Y-m-d H:i:s&#x27;) ]); echo $user-&gt;id; $dataAll=[ [&#x27;username&#x27; =&gt; &#x27;王强&#x27;, &#x27;password&#x27; =&gt; &#x27;213&#x27;, &#x27;gender&#x27; =&gt; &#x27;女&#x27;, &#x27;email&#x27; =&gt; &#x27;123@qq.com&#x27;, &#x27;price&#x27; =&gt; &#x27;30&#x27;, &#x27;detalis&#x27; =&gt; &#x27;123ss&#x27;, &#x27;uid&#x27; =&gt; &#x27;1101&#x27;, &#x27;create_time&#x27; =&gt; date(&#x27;Y-m-d H:i:s&#x27;) ], [&#x27;username&#x27; =&gt; &#x27;李凌&#x27;, &#x27;password&#x27; =&gt; &#x27;213&#x27;, &#x27;gender&#x27; =&gt; &#x27;男&#x27;, &#x27;email&#x27; =&gt; &#x27;123@qq.com&#x27;, &#x27;price&#x27; =&gt; &#x27;60&#x27;, &#x27;detalis&#x27; =&gt; &#x27;123ss&#x27;, &#x27;uid&#x27; =&gt; &#x27;1101&#x27;, &#x27;create_time&#x27; =&gt; date(&#x27;Y-m-d H:i:s&#x27;) ] ]; $user-&gt;saveAll($dataAll); $dataAll=[ [&#x27;username&#x27; =&gt; &#x27;王强&#x27;, &#x27;password&#x27; =&gt; &#x27;213&#x27;, &#x27;gender&#x27; =&gt; &#x27;女&#x27;, &#x27;email&#x27; =&gt; &#x27;123@qq.com&#x27;, &#x27;price&#x27; =&gt; &#x27;30&#x27;, &#x27;detalis&#x27; =&gt; &#x27;123ss&#x27;, &#x27;uid&#x27; =&gt; &#x27;1101&#x27;, ], [&#x27;username&#x27; =&gt; &#x27;李凌&#x27;, &#x27;password&#x27; =&gt; &#x27;213&#x27;, &#x27;gender&#x27; =&gt; &#x27;男&#x27;, &#x27;email&#x27; =&gt; &#x27;123@qq.com&#x27;, &#x27;price&#x27; =&gt; &#x27;60&#x27;, &#x27;detalis&#x27; =&gt; &#x27;123ss&#x27;, &#x27;uid&#x27; =&gt; &#x27;1101&#x27;, ] ]; $user-&gt;saveAll($dataAll); $insert=$user-&gt;save([ &#x27;username&#x27; =&gt; &#x27;李白&#x27;, &#x27;password&#x27; =&gt; &#x27;213&#x27;, &#x27;gender&#x27; =&gt; &#x27;女&#x27;, &#x27;email&#x27; =&gt; &#x27;123@qq.com&#x27;, &#x27;price&#x27; =&gt; &#x27;30&#x27;, &#x27;detalis&#x27; =&gt; &#x27;123ss&#x27;, &#x27;uid&#x27; =&gt; &#x27;1101&#x27;, &#x27;create_time&#x27; =&gt; date(&#x27;Y-m-d H:i:s&#x27;) ]); $user=new UserModel; $user-&gt;username = &#x27;李白23&#x27;; $user-&gt;password = &#x27;123&#x27;; $user-&gt;gender = &#x27;女&#x27;; $user-&gt;email = &#x27;123@qq.com&#x27;; $user-&gt;price = &#x27;90&#x27;; $user-&gt;save(); print_r($user); &#125; public function delete()&#123; $user=UserModel::get(83); $user-&gt;delete(); UserModel::destroy(81); UserModel::destroy([80,79,78]); UserModel::where(&#x27;id&#x27;,&#x27;&lt;&#x27;,80)-&gt;delete(); UserModel::destroy(function ($query)&#123; $query-&gt;where(&#x27;id&#x27;,&#x27;&lt;&#x27;,80); &#125;); &#125; public function updata()&#123; $user=UserModel::get(&#x27;90&#x27;); $user-&gt;username = &#x27;李te&#x27;; $user-&gt;email = &#x27;2552@.com&#x27;; $user-&gt;gender = &#x27;女&#x27;; echo $user-&gt;isAutoWriteTimestamp(false)-&gt;save(); $user=UserModel::where(&#x27;username&#x27;,&#x27;李黑&#x27;)-&gt;find(); $user-&gt;username = &#x27;李黑2&#x27;; $user-&gt;email = &#x27;2552@.com&#x27;; echo $user-&gt;isUpdate(true)-&gt;save(); 修改 echo $user-&gt;isUpdate(false)-&gt;save(); 新增 $user=UserModel::get(&#x27;82&#x27;); $user-&gt;price = Db::raw(&#x27;price+2&#x27;); $user-&gt;price = [&#x27;inc&#x27;,1]; $user-&gt;price = [&#x27;dec&#x27;,1]; echo $user-&gt;save(); $user=new UserModel(); $user-&gt;save([ &#x27;username&#x27;=&gt;&#x27;李凯&#x27;, &#x27;email&#x27;=&gt;&#x27;lm153.com&#x27; ],[ &#x27;id&#x27;=&gt;82 ]); $user= new UserModel; $user-&gt;saveAll([ [&#x27;id&#x27;=&gt;82,&#x27;username&#x27;=&gt;&#x27;李白&#x27;,&#x27;email&#x27;=&gt;&#x27;123.com&#x27;], [&#x27;id&#x27;=&gt;84,&#x27;username&#x27;=&gt;&#x27;李白&#x27;,&#x27;email&#x27;=&gt;&#x27;123.com&#x27;] ]); UserModel::where(&#x27;id&#x27;,82)-&gt;update([ &#x27;username&#x27;=&gt;&#x27;李凯&#x27;, &#x27;email&#x27;=&gt;&#x27;lm153.com&#x27; ]); UserModel::update([ &#x27;id&#x27;=&gt;85, &#x27;username&#x27;=&gt;&#x27;凯&#x27;, &#x27;email&#x27;=&gt;&#x27;2227.com&#x27; ]); $user=UserModel::get(&#x27;93&#x27;); $user-&gt;username = &#x27;李te&#x27;; $user-&gt;email = &#x27;2552@.com&#x27;; echo $user-&gt;save(); &#125; public function typeConversion()&#123; $user=UserModel::get(85) ; var_dump($user-&gt;price); var_dump($user-&gt;status); var_dump($user-&gt;create_time); var_dump($user-&gt;email); &#125; public function queryScope()&#123; $result=UserModel::scope(&#x27;gendermale&#x27;)-&gt;select(); $result=UserModel::genderMale()-&gt;select(); $result=UserModel::useGlobalScope(false)-&gt;emailLike(&#x27;2&#x27;)-&gt;priceGreater(60)-&gt;select(); return Db::getLastSql(); return json($result); &#125; public function view()&#123; $user=UserModel::get(93); $this-&gt;assign(&#x27;user&#x27;,$user); return $this-&gt;fetch(); &#125; public function output()&#123; $user=UserModel::get(93); print_r($user-&gt;toArray()); print_r($user-&gt;hidden([&#x27;password&#x27;])-&gt;toArray()); print_r($user-&gt;toJson()); &#125; public function jsons()&#123; $data=[ &#x27;username&#x27; =&gt; &#x27;辉夜3&#x27;, &#x27;password&#x27; =&gt; &#x27;123456&#x27;, &#x27;gender&#x27;=&gt;&#x27;男&#x27;, &#x27;email&#x27;=&gt;&#x27;1565165@qq.com&#x27;, &#x27;price&#x27;=&gt;&#x27;86&#x27;, &#x27;detalis&#x27;=&gt;[&#x27;content&#x27;=&gt;&#x27;123&#x27;], &#x27;uid&#x27;=&gt;&#x27;1111&#x27;, &#x27;list&#x27;=&gt;[&#x27;username&#x27;=&gt;&#x27;李四&#x27;,&#x27;gender&#x27;=&gt;&#x27;男&#x27;,&#x27;email&#x27;=&gt;&#x27;dsfdsf@qq.com&#x27;,&#x27;uid&#x27;=&gt;&#x27;1011&#x27;] ]; 没有这个方法json Db::name(&#x27;user&#x27;)-&gt;json([&#x27;detalis&#x27;,&#x27;list&#x27;])-&gt;insert($data); $user=Db::name(&#x27;user&#x27;)-&gt;where(&#x27;id&#x27;,93)-&gt;find(); dump($user); return json($user); $user=Db::name(&#x27;user&#x27;)-&gt;where(&#x27;list-&gt;username&#x27;,&#x27;李te&#x27;)-&gt;find(); $data[&#x27;list-&gt;gender&#x27;]=&#x27;男&#x27;; $data[&#x27;list&#x27;]=[&#x27;username&#x27;=&gt;&#x27;李四&#x27;,&#x27;gender&#x27;=&gt;&#x27;男&#x27;,&#x27;email&#x27;=&gt;&#x27;dsfdsf@qq.com&#x27;,&#x27;uid&#x27;=&gt;&#x27;1011&#x27;]; Db::name(&#x27;user&#x27;)-&gt;json(&#x27;detalis&#x27;,&#x27;list&#x27;)-&gt;where(&#x27;id&#x27;,93)-&gt;update($data); return json($user); 模型的新增 $user=new UserModel(); $user-&gt;username=&#x27;张伟&#x27;; $user-&gt;password=&#x27;213213&#x27;; $user-&gt;gender=&#x27;男&#x27;; $user-&gt;email=&#x27;1516@qq.com&#x27;; $user-&gt;price=&#x27;90&#x27;; $user-&gt;list=[&#x27;content&#x27;=&gt;&#x27;李四2312&#x27;]; $user-&gt;save(); $user=new UserModel(); $data=[ &#x27;username&#x27;=&gt;&#x27;www&#x27; ]; $list=new \\StdClass(); $list-&gt;username=&#x27;灰灰&#x27;; $list-&gt;gender=&#x27;女&#x27;; $user-&gt;list=$data; $user-&gt;save(); $user=UserModel::get(93); return $user-&gt;list-&gt;username; $user=UserModel::where(&#x27;list-&gt;username&#x27;,&#x27;李黑&#x27;)-&gt;find(); return json($user); 出错无法修改json格式数据 $user=UserModel::get(93); $user-&gt;list-&gt;account=&#x27;erwrew&#x27;; $user-&gt;save(); &#125; 软删除 public function softDelete()&#123; Db::name(&#x27;user&#x27;)-&gt;where(&#x27;id&#x27;,93)-&gt;useSoftDelete(&#x27;delete_time&#x27;,date(&#x27;Y-m-d H:i:s&#x27;))-&gt;delete(); return Db::getLastSql(); $user=UserModel::select(); return Db::getLastSql(); return json($user); $user=UserModel::withTrashed()-&gt;select(); $user=UserModel::onlyTrashed()-&gt;select(); $user=UserModel::onlyTrashed()-&gt;find(); $user-&gt;restore(); return json($user); $user=UserModel::get(93); $user-&gt;delete(); 没有get方法 $user=UserModel::onlyTrashed()-&gt;find(); $user-&gt;delete(true); &#125;&#125; controller&#x2F;Search.php12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?phpnamespace app\\index\\controller;use think\\Db;class Search&#123; public function index()&#123; $result = Db::name(&#x27;user&#x27;)-&gt;where(&#x27;id&#x27;,76)-&gt;select(); $result = Db::name(&#x27;user&#x27;)-&gt;where(&#x27;id&#x27;,&#x27;=&#x27;,76)-&gt;select(); $result = Db::name(&#x27;user&#x27;)-&gt;where(&#x27;id&#x27;,&#x27;&lt;&gt;&#x27;,76)-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;where(&#x27;email&#x27;,&#x27;like&#x27;,&#x27;ye%&#x27;)-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;where(&#x27;email&#x27;,&#x27;like&#x27;,[&#x27;ye%&#x27;,&#x27;hui%&#x27;],&#x27;or&#x27;)-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;whereLike(&#x27;email&#x27;,&#x27;1565%&#x27;)-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;whereNotLike(&#x27;email&#x27;,&#x27;1565%&#x27;)-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;whereBetween(&#x27;id&#x27;,[76,78])-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;whereIn(&#x27;id&#x27;,[76,78])-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;whereNull(&#x27;uid&#x27;)-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;where(&#x27;id&#x27;,&#x27;exp&#x27;,&#x27;In(76,75,79)&#x27;)-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;whereExp(&#x27;id&#x27;,&#x27;In(76,77,79)&#x27;)-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;where(&#x27;create_time&#x27;,&#x27;&gt; time&#x27;,&#x27;2024-3-4&#x27;)-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;where(&#x27;create_time&#x27;,&#x27;between time&#x27;,[&#x27;2024-3-4&#x27;,&#x27;2024-3-6&#x27;])-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;whereTime(&#x27;create_time&#x27;,&#x27;&gt;&#x27;,&#x27;2024-3-4&#x27;)-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;whereBetween(&#x27;create_time&#x27;,[&#x27;2024-3-4&#x27;,&#x27;2024-3-6&#x27;])-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;whereNotBetween(&#x27;create_time&#x27;,[&#x27;2024-3-4&#x27;,&#x27;2024-3-6&#x27;])-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;whereTime(&#x27;create_time&#x27;,&#x27;last week&#x27;)-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;whereTime(&#x27;create_time&#x27;,&#x27;-2 hour&#x27;)-&gt;select(); $result=Db::name(&#x27;user&#x27;)-&gt;whereBetweenTimeField(&#x27;create_time&#x27;,&#x27;create_time&#x27;)-&gt;select(); return Db::getLastSql(); return json($result); $result=Db::name(&#x27;user&#x27;)-&gt;count(&#x27;uid&#x27;); $result=Db::name(&#x27;user&#x27;)-&gt;max(&#x27;price&#x27;); $result=Db::name(&#x27;user&#x27;)-&gt;max(&#x27;price&#x27;,false); $result=Db::name(&#x27;user&#x27;)-&gt;min(&#x27;price&#x27;); $result=Db::name(&#x27;user&#x27;)-&gt;avg(&#x27;price&#x27;); $result=Db::name(&#x27;user&#x27;)-&gt;sum(&#x27;price&#x27;); $subQuery=Db::name(&#x27;user&#x27;)-&gt;fetchSql(true)-&gt;select(); $subQuery=Db::name(&#x27;user&#x27;)-&gt;buildSql(true); $subQuery=Db::name(&#x27;one&#x27;)-&gt;field(&#x27;uid&#x27;)-&gt;where(&#x27;gender&#x27;,&#x27;男&#x27;) -&gt;buildSql(true); $result=Db::name(&#x27;two&#x27;)-&gt;where(&#x27;id&#x27;,&#x27;exp&#x27;,&#x27;IN&#x27;.$subQuery)-&gt;select(); return $subQuery; 子查询 $result=Db::name(&#x27;two&#x27;)-&gt;where(&#x27;id&#x27;,&#x27;in&#x27;,function ($query)&#123; $query-&gt;name(&#x27;one&#x27;)-&gt;field(&#x27;uid&#x27;)-&gt;where(&#x27;gender&#x27;,&#x27;男&#x27;); &#125;)-&gt;select(); return json($result); &#125;&#125; model&#x2F;User.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;?phpnamespace app\\index\\model;use think\\Model;use traits\\model\\SoftDelete;class User extends Model&#123; 开启自动时间戳 protected $autoWriteTimestamp=true;protected $autoWriteTimestamp = &#x27;datetime&#x27;;use SoftDelete;protected $deleteTime = &#x27;delete_time&#x27;; protected $readonly=[&#x27;username&#x27;,&#x27;email&#x27;]; 设置json字段protected $json = [&#x27;detalis&#x27;,&#x27;list&#x27;]; 设置类型转换protected $type=[ &#x27;price&#x27;=&gt;&#x27;integer&#x27;, &#x27;status&#x27;=&gt;&#x27;boolean&#x27;, &#x27;create_time&#x27;=&gt;&#x27;datetime:Y-m-d&#x27;, &#x27;email&#x27;=&gt;&#x27;integer&#x27;]; 数据自动完成protected $auto=[&#x27;email&#x27;];protected $insert=[&#x27;uid&#x27;=&gt;1];protected $update=[]; 设置全局查询protected function base($query)&#123; $query-&gt;where(&#x27;status&#x27;,1);&#125; 设置主键 protected $pk =&#x27;uid&#x27;; 设置其他表 protected $table=&#x27;tp_one&#x27;; 初始化protected static function init()&#123; parent::init(); echo &#x27;初始化&#x27;;&#125; public function getEmail()&#123; return self::where(&#x27;username&#x27;,&#x27;凯&#x27;)-&gt;find()-&gt;getAttr(&#x27;username&#x27;); &#125; 创建一个获取器status字段 public function getStatusAttr($value)&#123; $myGet=[-1=&gt;&#x27;删除&#x27;,0=&gt;&#x27;禁用&#x27;,1=&gt;&#x27;正常&#x27;,2=&gt;&#x27;待审合&#x27;]; return $myGet[$value]; &#125; 创建一个虚拟字段的获取器，可以对多字段进行过滤 public function getNothingAttr($value,$data)&#123; $myGet=[-1=&gt;&#x27;删除&#x27;,0=&gt;&#x27;禁用&#x27;,1=&gt;&#x27;正常&#x27;,2=&gt;&#x27;待审合&#x27;]; return $myGet[$data[&#x27;status&#x27;]]; &#125; 创建一个修改器public function setEmailAttr($value)&#123; return strtoupper($value);&#125; 创建邮箱模糊查询的搜索器 public function searchEmailAttr($query,$value,$data)&#123; dump($data); $query-&gt;where(&#x27;email&#x27;,&#x27;like&#x27;,$value.&#x27;%&#x27;); if(isset($data[&#x27;sort&#x27;]))&#123; $query-&gt;order($data[&#x27;sort&#x27;]); &#125; &#125; public function searchCreateTimeAttr($query,$value)&#123; $query-&gt;whereBetweenTime(&#x27;create_time&#x27;,$value[0],$value[1]); &#125; 创建一个查询范围 public function scopeGenderMale($query)&#123; $query-&gt;where(&#x27;gender&#x27;,&#x27;男&#x27;)-&gt;limit(5); &#125; public function scopeEmailLike($query,$value)&#123; $query-&gt;where(&#x27;email&#x27;,&#x27;like&#x27;,&#x27;%&#x27;.$value.&#x27;%&#x27;); &#125; public function scopePriceGreater($query,$value)&#123; $query-&gt;where(&#x27;price&#x27;,&#x27;&gt;&#x27;,$value); &#125;&#125; 模板view&#x2F;compare123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;比较标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;eq name=&#x27;$username&#x27; value=&#x27;$username&#x27;&#125; 是 &#123;/eq&#125; &#123;neq name=&#x27;$username&#x27; value=&#x27;fff&#x27;&#125; 否 &#123;/neq&#125; &#123;eq name=&#x27;$username&#x27; value=&#x27;21321&#x27;&#125; 是22 &#123;else/&#125; 不相等 &#123;/eq&#125; &#123;egt name=&#x27;$number&#x27; value=&#x27;10&#x27;&#125; 大于等于10 &#123;else/&#125; 小于10 &#123;/egt&#125; &#123;compare type=&#x27;eq&#x27; name=&#x27;$username&#x27; value=&#x27;Mr.Lee&#x27;&#125; 李显示 &#123;/compare&#125; &#123;assign name=&#x27;var&#x27; value=&#x27;656&#x27;&#125; &#123;$var&#125; &#123;define name=&#x27;PI&#x27; value=&#x27;3.14159265354&#x27;&#125; &#123;$Think.const.PI&#125;&lt;br&gt;&#123;php&#125;echo &#x27;但是犯得上房贷首付&#x27;&#123;/php&#125;&lt;/body&gt;&lt;/html&gt; view&#x2F;condition12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;条件判断标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;switch $number&#125; &#123;case 1&#125;1&#123;/case&#125; &#123;case 5&#125;5&#123;/case&#125; &#123;case 10|20|30&#125;10,20,30均可&#123;/case&#125; &#123;default/&#125;没有 &#123;/switch&#125;&lt;br&gt; &#123;if ($number &gt; 10) OR ($number &gt; 5)&#125; 大于10 &#123;/if&#125; &#123;if ($number &gt; 10)&#125; 大于10 &#123;else/&#125; 小于10 &#123;/if&#125; &#123;if ($number &gt; 100)&#125; 大于100 &#123;elseif $number&gt;50&#125; 大于50 &#123;else/&#125; 小于50 &#123;/if&#125;&lt;br&gt;&#123;if strtoupper($user-&gt;username)==&#x27;MR.LEE&#x27;&#125; 是李先生&#123;/if&#125;&lt;br&gt;&#123;in name=&#x27;$number&#x27; value=&#x27;10,20,30,40,50&#x27;&#125; 是数组中的某一个元素&#123;/in&#125;&lt;br&gt;&#123;between name=&#x27;$number&#x27; value=&#x27;10,30&#x27;&#125;是在这个范围中&#123;/between&#125; &#123;between name=&#x27;$number&#x27; value=&#x27;10,20,40&#x27;&#125; 是在这个范围中 &#123;else/&#125; 不在这个范围中 &#123;/between&#125;&lt;br&gt;&#123;present name=&#x27;$user&#x27;&#125; 存在声明了&#123;/present&#125; &#123;present name=&#x27;$usersss&#x27;&#125; 存在声明了 &#123;else/&#125; 不存在 &#123;/present&#125;&lt;br&gt;&#123;empty name=&#x27;$user1&#x27;&#125; 这个变量是空的&#123;/empty&#125; &#123;defined name=&#x27;PI&#x27; value=&#x27;3.14&#x27;&#125;&#123;/defined&#125;&#123;defined name=&#x27;PI&#x27;&#125;PI存在&#123;/defined&#125;&lt;br&gt;&lt;/body&gt;&lt;/html&gt; view&#x2F;loop123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;循环标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&#123;foreach $list as $key1=&gt;$obj1&#125; &#123;$key1&#125; &#123;$obj1.id&#125;&#123;$obj1.username&#125;&#123;$obj1.gender&#125;&#123;$obj1.email&#125;&lt;br&gt;&#123;/foreach&#125;&lt;hr&gt;&#123;foreach :model(&#x27;user&#x27;)-&gt;all() as $key1=&gt;$obj1&#125;&#123;$key1&#125; &#123;$obj1.id&#125;&#123;$obj1.username&#125;&#123;$obj1.gender&#125;&#123;$obj1.email&#125;&lt;br&gt;&#123;/foreach&#125;&lt;hr&gt;&#123;volist name=&#x27;list&#x27; id=&#x27;obj&#x27;&#125;&#123;$key&#125;&#123;$obj.id&#125;&#123;$obj.username&#125;&#123;$obj.gender&#125;&#123;$obj.email&#125;&lt;br&gt;&#123;/volist&#125;&lt;hr&gt;&#123;volist name=&#x27;:model(&quot;user&quot;)-&gt;all()&#x27; id=&#x27;obj&#x27;&#125;&#123;$key&#125;&#123;$obj.id&#125;&#123;$obj.username&#125;&#123;$obj.gender&#125;&#123;$obj.email&#125;&lt;br&gt;&#123;/volist&#125;&lt;hr&gt;&#123;volist name=&#x27;list&#x27; id=&#x27;obj&#x27; offset=&#x27;3&#x27; length=&#x27;5&#x27;&#125;&#123;$key&#125;&#123;$obj.id&#125;&#123;$obj.username&#125;&#123;$obj.gender&#125;&#123;$obj.email&#125;&lt;br&gt;&#123;/volist&#125;&lt;hr&gt;&#123;volist name=&#x27;list&#x27; id=&#x27;obj&#x27; mod=&#x27;2&#x27;&#125;&#123;eq name=&#x27;mod&#x27; value=&#x27;0&#x27;&#125;&#123;$key&#125;&#123;$obj.id&#125;&#123;$obj.username&#125;&#123;$obj.gender&#125;&#123;$obj.email&#125;&lt;br&gt;&#123;/eq&#125;&#123;/volist&#125;&lt;hr&gt;&#123;volist name=&#x27;:model(&quot;user&quot;)-&gt;where(&quot;id&quot;,1000)-&gt;select()&#x27; id=&#x27;obj&#x27; empty=&#x27;没有任何数据&#x27;&#125;&#123;$key&#125;&#123;$obj.id&#125;&#123;$obj.username&#125;&#123;$obj.gender&#125;&#123;$obj.email&#125;&lt;br&gt;&#123;/volist&#125;&lt;hr&gt;&#123;volist name=&#x27;list&#x27; id=&#x27;obj&#x27; key=&#x27;k&#x27;&#125;&#123;eq name=&#x27;$obj.username&#x27; value=&#x27;李白23&#x27;&#125;&#123;$key&#125;.&#123;$k&#125;.&#123;$obj.id&#125;&#123;$obj.username&#125;&#123;$obj.gender&#125;&#123;$obj.email&#125;&lt;br&gt;&#123;/eq&#125;&#123;/volist&#125;&lt;hr&gt;&#123;for start=&#x27;1&#x27; end=&#x27;100&#x27; step=&#x27;2&#x27; name=&#x27;i&#x27; comparison=&#x27;&gt;&#x27;&#125; &#123;$i&#125;&#123;/for&#125;&lt;/body&gt;&lt;/html&gt; view&#x2F;see&#x2F;var.html1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;变量输出&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;$name | default=&#x27;没有值&#x27;&#125; &#123;$user.username&#125; &#123;$user[&#x27;email&#x27;]&#125;&lt;br&gt; &#123;$obj-&gt;username&#125; &#123;$obj-&gt;email&#125;&lt;br&gt; &#123;$Think.get.key&#125; &#123;$Think.const.PHP_VERSION&#125; &#123;$Think.PHP_VERSION&#125; &#123;$Think.config.var_method&#125;&lt;br&gt; &#123;$password | md5&#125;. &#123;$number&#125; &#123;$name|substr=0,3&#125; &#123;$password|md5|substr=0,3&#125;&lt;br&gt; &#123;:substr(strtoupper(md5($password)),0,3)&#125;&lt;br&gt;&#123;$number+$number&#125;&lt;br&gt;&#123;$name?&#x27;正确&#x27;:&#x27;错误&#x27;&#125;&#123;$name?=&#x27;真&#x27;&#125;&#123;$Think.get.name ?? &#x27;不存在&#x27;&#125;&#123;$name?:&#x27;不存在&#x27;&#125;&#123;$number == $number ? &#x27;真&#x27;:&#x27;假&#x27;&#125;&lt;br&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"thinkphp查询","slug":"thinkphp查询","permalink":"https://2486125878.github.io/categories/thinkphp%E6%9F%A5%E8%AF%A2/"}],"tags":[{"name":"php","slug":"php","permalink":"https://2486125878.github.io/tags/php/"}]},{"title":"thinkphp数据库其他","slug":"thinkphp数据库其他","date":"2024-03-14T04:04:00.000Z","updated":"2024-03-14T06:09:10.000Z","comments":true,"path":"2024/03/14/thinkphp数据库其他/","permalink":"https://2486125878.github.io/2024/03/14/thinkphp%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B6%E4%BB%96/","excerpt":"","text":"查询事件 查询事件（V5.0.4+）从5.0.4+版本开始，增加了数据库的CURD操作事件支持，包括： 事件 描述 before_select select查询前回调 before_find find查询前回调 after_insert insert操作成功后回调 after_update update操作成功后回调 after_delete delete操作成功后回调 查询事件仅支持find、select、insert、update和delete方法。 注册事件使用下面的方法注册数据库查询事件 12345Query::event(&#x27;after_insert&#x27;,&#x27;callback&#x27;);Query::event(&#x27;before_select&#x27;,function($options,$query)&#123; // 事件处理 return $result;&#125;); 事务操作 使用事务处理的话，需要数据库引擎支持事务处理。比如 MySQL 的 MyISAM 不支持事务处理，需要使用 InnoDB 引擎。 使用 transaction 方法操作数据库事务，当发生异常会自动回滚，例如： 自动控制事务处理 1234Db::transaction(function()&#123; Db::table(&#x27;think_user&#x27;)-&gt;find(1); Db::table(&#x27;think_user&#x27;)-&gt;delete(1);&#125;); 也可以手动控制事务，例如： 123456789// 启动事务Db::startTrans();try&#123;Db::table(&#x27;think_user&#x27;)-&gt;find(1); Db::table(&#x27;think_user&#x27;)-&gt;delete(1); // 提交事务 Db::commit(); &#125; catch (\\Exception $e) &#123; // 回滚事务 Db::rollback();&#125; 注意在事务操作的时候，确保你的数据库连接是相同的。 监听SQL 如果开启数据库的调试模式的话，你可以对数据库执行的任何SQL操作进行监听，使用如下方法： 123456Db::listen(function($sql, $time, $explain)&#123; // 记录SQL echo $sql. &#x27; [&#x27;.$time.&#x27;s]&#x27;; // 查看性能分析结果 dump($explain);&#125;); 默认如果没有注册任何监听操作的话，这些SQL执行会被根据不同的日志类型记录到日志中。 存储过程 5.0支持存储过程，如果我们定义了一个数据库存储过程sp_query，可以使用下面的方式调用： 1$result = Db::query(&#x27;call sp_query(8)&#x27;); 返回的是一个二维数组，也可以使用参数绑定，例如： 123$result = Db::query(&#x27;call sp_query(?)&#x27;,[8]);// 或者命名绑定$result = Db::query(&#x27;call sp_query(:id)&#x27;,[&#x27;id&#x27;=&gt;8]); 数据集 数据库的查询结果也就是数据集，默认的配置下，数据集的类型是一个二维数组，我们可以配置成数据集类，就可以支持对数据集更多的对象化操作，需要使用数据集类功能，可以配置数据库的resultset_type参数如下： 123456789101112131415161718192021222324return [ // 数据库类型 &#x27;type&#x27; =&gt; &#x27;mysql&#x27;, // 数据库连接DSN配置 &#x27;dsn&#x27; =&gt; &#x27;&#x27;, // 服务器地址 &#x27;hostname&#x27; =&gt; &#x27;127.0.0.1&#x27;, // 数据库名 &#x27;database&#x27; =&gt; &#x27;thinkphp&#x27;, // 数据库用户名 &#x27;username&#x27; =&gt; &#x27;root&#x27;, // 数据库密码 &#x27;password&#x27; =&gt; &#x27;&#x27;, // 数据库连接端口 &#x27;hostport&#x27; =&gt; &#x27;&#x27;, // 数据库连接参数 &#x27;params&#x27; =&gt; [], // 数据库编码默认采用utf8 &#x27;charset&#x27; =&gt; &#x27;utf8&#x27;, // 数据库表前缀 &#x27;prefix&#x27; =&gt; &#x27;think_&#x27;, // 数据集返回类型 &#x27;resultset_type&#x27; =&gt; &#x27;collection&#x27;,]; 返回的数据集对象是think\\Collection，提供了和数组无差别用法，并且另外封装了一些额外的方法。 可以直接使用数组的方式操作数据集对象，例如： 1234567891011// 获取数据集$users = Db::name(&#x27;user&#x27;)-&gt;select();// 直接操作第一个元素$item = $users[0];// 获取数据集记录数$count = count($users);// 遍历数据集foreach($users as $user)&#123; echo $user[&#x27;name&#x27;]; echo $user[&#x27;id&#x27;];&#125; 需要注意的是，如果要判断数据集是否为空，不能直接使用empty判断，而必须使用数据集对象的isEmpty方法判断，例如： 1234$users = Db::name(&#x27;user&#x27;)-&gt;select();if($users-&gt;isEmpty())&#123; echo &#x27;数据集为空&#x27;;&#125; Collection类包含了下列主要方法： 方法 描述 isEmpty 是否为空 toArray 转换为数组 all 所有数据 merge 合并其它数据 diff 比较数组，返回差集 flip 交换数据中的键和值 intersect 比较数组，返回交集 keys 返回数据中的所有键名 pop 删除数据中的最后一个元素 shift 删除数据中的第一个元素 unshift 在数据开头插入一个元素 reduce 通过使用用户自定义函数，以字符串返回数组 reverse 数据倒序重排 chunk 数据分隔为多个数据块 each 给数据的每个元素执行回调 filter 用回调函数过滤数据中的元素 column 返回数据中的指定列 sort 对数据排序 shuffle 将数据打乱 slice 截取数据中的一部分 如果只是个别数据的查询需要返回数据集对象，则可以使用 123Db::name(&#x27;user&#x27;) -&gt;fetchClass(&#x27;\\think\\Collection&#x27;) -&gt;select(); 分布式数据库 ThinkPHP内置了分布式数据库的支持，包括主从式数据库的读写分离，但是分布式数据库必须是相同的数据库类型。 配置database.deploy 为1 可以采用分布式数据库支持。如果采用分布式数据库，定义数据库配置信息的方式如下： 1234567891011121314151617//分布式数据库配置定义return [ // 启用分布式数据库 &#x27;deploy&#x27; =&gt; 1, // 数据库类型 &#x27;type&#x27; =&gt; &#x27;mysql&#x27;, // 服务器地址 &#x27;hostname&#x27; =&gt; &#x27;192.168.1.1,192.168.1.2&#x27;, // 数据库名 &#x27;database&#x27; =&gt; &#x27;demo&#x27;, // 数据库用户名 &#x27;username&#x27; =&gt; &#x27;root&#x27;, // 数据库密码 &#x27;password&#x27; =&gt; &#x27;&#x27;, // 数据库连接端口 &#x27;hostport&#x27; =&gt; &#x27;&#x27;,] 连接的数据库个数取决于hostname定义的数量，所以即使是两个相同的IP也需要重复定义，但是其他的参数如果存在相同的可以不用重复定义，例如： 1&#x27;hostport&#x27;=&gt;&#x27;3306,3306&#x27; 和 1&#x27;hostport&#x27;=&gt;&#x27;3306&#x27; 等效。 1&#x27;username&#x27;=&gt;&#x27;user1&#x27;, &#x27;password&#x27;=&gt;&#x27;pwd1&#x27;, 和 1&#x27;username&#x27;=&gt;&#x27;user1,user1&#x27;, &#x27;password&#x27;=&gt;&#x27;pwd1,pwd1&#x27;, 等效。 还可以设置分布式数据库的读写是否分离，默认的情况下读写不分离，也就是每台服务器都可以进行读写操作，对于主从式数据库而言，需要设置读写分离，通过下面的设置就可以： 1&#x27;rw_separate&#x27; =&gt; true, 在读写分离的情况下，默认第一个数据库配置是主服务器的配置信息，负责写入数据，如果设置了master_num参数，则可以支持多个主服务器写入。其它的都是从数据库的配置信息，负责读取数据，数量不限制。每次连接从服务器并且进行读取操作的时候，系统会随机进行在从服务器中选择。 还可以设置slave_no 指定某个服务器进行读操作。 如果从数据库连接错误，会自动切换到主数据库连接。 调用模型的CURD操作的话，系统会自动判断当前执行的方法的读操作还是写操作，如果你用的是原生SQL，那么需要注意系统的默认规则： 写操作必须用模型的execute方法，读操作必须用模型的query方法，否则会发生主从读写错乱的情况。 注意：主从数据库的数据同步工作不在框架实现，需要数据库考虑自身的同步或者复制机制。","categories":[{"name":"thinkphp查询","slug":"thinkphp查询","permalink":"https://2486125878.github.io/categories/thinkphp%E6%9F%A5%E8%AF%A2/"}],"tags":[{"name":"php","slug":"php","permalink":"https://2486125878.github.io/tags/php/"}]},{"title":"thinkphp多种查询","slug":"thinkphp高级查询","date":"2024-03-14T03:47:23.000Z","updated":"2024-03-14T04:03:20.000Z","comments":true,"path":"2024/03/14/thinkphp高级查询/","permalink":"https://2486125878.github.io/2024/03/14/thinkphp%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"聚合查询 在应用中我们经常会用到一些统计数据，例如当前所有（或者满足某些条件）的用户数、所有用户的最大积分、用户的平均成绩等等，ThinkPHP为这些统计操作提供了一系列的内置方法，包括： 方法 说明 count 统计数量，参数是要统计的字段名（可选） max 获取最大值，参数是要统计的字段名（必须） min 获取最小值，参数是要统计的字段名（必须） avg 获取平均值，参数是要统计的字段名（必须） sum 获取总分，参数是要统计的字段名（必须） 用法示例： 获取用户数： 1Db::table(&#x27;think_user&#x27;)-&gt;count(); 或者根据字段统计： 1Db::table(&#x27;think_user&#x27;)-&gt;count(&#x27;id&#x27;); 获取用户的最大积分： 1Db::table(&#x27;think_user&#x27;)-&gt;max(&#x27;score&#x27;); 获取积分大于0的用户的最小积分： 1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;score&gt;0&#x27;)-&gt;min(&#x27;score&#x27;); 获取用户的平均积分： 1Db::table(&#x27;think_user&#x27;)-&gt;avg(&#x27;score&#x27;); 统计用户的总成绩： 1Db::table(&#x27;think_user&#x27;)-&gt;sum(&#x27;score&#x27;); 时间查询 时间比较使用where方法where方法支持时间比较，例如： 123456// 大于某个时间where(&#x27;create_time&#x27;,&#x27;&gt; time&#x27;,&#x27;2016-1-1&#x27;);// 小于某个时间where(&#x27;create_time&#x27;,&#x27;&lt;= time&#x27;,&#x27;2016-1-1&#x27;);// 时间区间查询where(&#x27;create_time&#x27;,&#x27;between time&#x27;,[&#x27;2015-1-1&#x27;,&#x27;2016-1-1&#x27;]); 第三个参数可以传入任何有效的时间表达式，会自动识别你的时间字段类型，支持的时间类型包括timestamps、datetime、date和int。 使用whereTime方法whereTime方法提供了日期和时间字段的快捷查询，示例如下： 12345678910111213141516// 大于某个时间db(&#x27;user&#x27;) -&gt;whereTime(&#x27;birthday&#x27;, &#x27;&gt;=&#x27;, &#x27;1970-10-1&#x27;) -&gt;select();// 小于某个时间db(&#x27;user&#x27;) -&gt;whereTime(&#x27;birthday&#x27;, &#x27;&lt;&#x27;, &#x27;2000-10-1&#x27;) -&gt;select();// 时间区间查询db(&#x27;user&#x27;) -&gt;whereTime(&#x27;birthday&#x27;, &#x27;between&#x27;, [&#x27;1970-10-1&#x27;, &#x27;2000-10-1&#x27;]) -&gt;select();// 不在某个时间区间db(&#x27;user&#x27;) -&gt;whereTime(&#x27;birthday&#x27;, &#x27;not between&#x27;, [&#x27;1970-10-1&#x27;, &#x27;2000-10-1&#x27;]) -&gt;select(); 时间表达式还提供了更方便的时间表达式查询，例如： 12345678910111213141516171819202122232425262728293031// 获取今天的博客db(&#x27;blog&#x27;) -&gt;whereTime(&#x27;create_time&#x27;, &#x27;today&#x27;) -&gt;select();// 获取昨天的博客db(&#x27;blog&#x27;) -&gt;whereTime(&#x27;create_time&#x27;, &#x27;yesterday&#x27;) -&gt;select();// 获取本周的博客db(&#x27;blog&#x27;) -&gt;whereTime(&#x27;create_time&#x27;, &#x27;week&#x27;) -&gt;select(); // 获取上周的博客db(&#x27;blog&#x27;) -&gt;whereTime(&#x27;create_time&#x27;, &#x27;last week&#x27;) -&gt;select(); // 获取本月的博客db(&#x27;blog&#x27;) -&gt;whereTime(&#x27;create_time&#x27;, &#x27;month&#x27;) -&gt;select(); // 获取上月的博客db(&#x27;blog&#x27;) -&gt;whereTime(&#x27;create_time&#x27;, &#x27;last month&#x27;) -&gt;select(); // 获取今年的博客db(&#x27;blog&#x27;) -&gt;whereTime(&#x27;create_time&#x27;, &#x27;year&#x27;) -&gt;select(); // 获取去年的博客db(&#x27;blog&#x27;) -&gt;whereTime(&#x27;create_time&#x27;, &#x27;last year&#x27;) -&gt;select(); 如果查询当天、本周、本月和今年的时间，还可以简化为： 12345678910111213141516// 获取今天的博客db(&#x27;blog&#x27;) -&gt;whereTime(&#x27;create_time&#x27;, &#x27;d&#x27;) -&gt;select();// 获取本周的博客db(&#x27;blog&#x27;) -&gt;whereTime(&#x27;create_time&#x27;, &#x27;w&#x27;) -&gt;select(); // 获取本月的博客db(&#x27;blog&#x27;) -&gt;whereTime(&#x27;create_time&#x27;, &#x27;m&#x27;) -&gt;select(); // 获取今年的博客db(&#x27;blog&#x27;) -&gt;whereTime(&#x27;create_time&#x27;, &#x27;y&#x27;) -&gt;select(); 高级查询 快捷查询快捷查询方式是一种多字段相同查询条件的简化写法，可以进一步简化查询条件的写法，在多个字段之间用|分割表示OR查询，用&amp;分割表示AND查询，可以实现下面的查询，例如： 1234Db::table(&#x27;think_user&#x27;) -&gt;where(&#x27;name|title&#x27;,&#x27;like&#x27;,&#x27;thinkphp%&#x27;) -&gt;where(&#x27;create_time&amp;update_time&#x27;,&#x27;&gt;&#x27;,0) -&gt;find(); 生成的查询SQL是： 1SELECT * FROM `think_user` WHERE ( `name` LIKE &#x27;thinkphp%&#x27; OR `title` LIKE &#x27;thinkphp%&#x27; ) AND ( `create_time` &gt; 0 AND `update_time` &gt; 0 ) LIMIT 1 快捷查询支持所有的查询表达式。 区间查询区间查询是一种同一字段多个查询条件的简化写法，例如： 1234Db::table(&#x27;think_user&#x27;) -&gt;where(&#x27;name&#x27;,[&#x27;like&#x27;,&#x27;thinkphp%&#x27;],[&#x27;like&#x27;,&#x27;%thinkphp&#x27;]) -&gt;where(&#x27;id&#x27;,[&#x27;&gt;&#x27;,0],[&#x27;&lt;&gt;&#x27;,10],&#x27;or&#x27;) -&gt;find(); 生成的SQL语句为： 1SELECT * FROM `think_user` WHERE ( `name` LIKE &#x27;thinkphp%&#x27; AND `name` LIKE &#x27;%thinkphp&#x27; ) AND ( `id` &gt; 0 OR `id` &lt;&gt; 10 ) LIMIT 1 区间查询的查询条件必须使用数组定义方式，支持所有的查询表达式。 下面的查询方式是错误的： 1234Db::table(&#x27;think_user&#x27;) -&gt;where(&#x27;name&#x27;,[&#x27;like&#x27;,&#x27;thinkphp%&#x27;],[&#x27;like&#x27;,&#x27;%thinkphp&#x27;]) -&gt;where(&#x27;id&#x27;,5,[&#x27;&lt;&gt;&#x27;,10],&#x27;or&#x27;) -&gt;find(); 批量查询可以进行多个条件的批量条件查询定义，例如： 12345678Db::table(&#x27;think_user&#x27;) -&gt;where([ &#x27;name&#x27; =&gt; [&#x27;like&#x27;,&#x27;thinkphp%&#x27;], &#x27;title&#x27; =&gt; [&#x27;like&#x27;,&#x27;%thinkphp&#x27;], &#x27;id&#x27; =&gt; [&#x27;&gt;&#x27;,0], &#x27;status&#x27;=&gt; 1 ]) -&gt;select(); 生成的SQL语句为： 1SELECT * FROM `think_user` WHERE `name` LIKE &#x27;thinkphp%&#x27; AND `title` LIKE &#x27;%thinkphp&#x27; AND `id` &gt; 0 AND `status` = &#x27;1&#x27; 闭包查询1234Db::table(&#x27;think_user&#x27;)-&gt;select(function($query)&#123; $query-&gt;where(&#x27;name&#x27;,&#x27;thinkphp&#x27;) -&gt;whereOr(&#x27;id&#x27;,&#x27;&gt;&#x27;,10);&#125;); 生成的SQL语句为： 1SELECT * FROM `think_user` WHERE `name` = &#x27;thinkphp&#x27; OR `id` &gt; 10 使用Query对象查询也可以事先封装Query对象，并传入select方法，例如： 123456$query = new \\think\\db\\Query;$query-&gt;name(&#x27;user&#x27;) -&gt;where(&#x27;name&#x27;,&#x27;like&#x27;,&#x27;%think%&#x27;) -&gt;where(&#x27;id&#x27;,&#x27;&gt;&#x27;,10) -&gt;limit(10);Db::select($query); 如果使用Query对象的话，select方法之前调用的任何的链式操作都是无效。 混合查询可以结合前面提到的所有方式进行混合查询，例如： 123456Db::table(&#x27;think_user&#x27;) -&gt;where(&#x27;name&#x27;,[&#x27;like&#x27;,&#x27;thinkphp%&#x27;],[&#x27;like&#x27;,&#x27;%thinkphp&#x27;]) -&gt;where(function($query)&#123; $query-&gt;where(&#x27;id&#x27;,[&#x27;&lt;&#x27;,10],[&#x27;&gt;&#x27;,100],&#x27;or&#x27;); &#125;) -&gt;select(); 生成的SQL语句是： 1SELECT * FROM `think_user` WHERE ( `name` LIKE &#x27;thinkphp%&#x27; AND `name` LIKE &#x27;%thinkphp&#x27; ) AND ( `id` &lt; 10 or `id` &gt; 100 ) 字符串条件查询对于一些实在复杂的查询，也可以直接使用原生SQL语句进行查询，例如： 123Db::table(&#x27;think_user&#x27;) -&gt;where(&#x27;id &gt; 0 AND name LIKE &quot;thinkphp%&quot;&#x27;) -&gt;select(); 为了安全起见，我们可以对字符串查询条件使用参数绑定，例如： 123Db::table(&#x27;think_user&#x27;) -&gt;where(&#x27;id &gt; :id AND name LIKE :name &#x27;,[&#x27;id&#x27;=&gt;0, &#x27;name&#x27;=&gt;&#x27;thinkphp%&#x27;]) -&gt;select(); V5.0.4+开始，ThinkPHP支持对同一个字段多次调用查询条件，例如： 123456Db::table(&#x27;think_user&#x27;) -&gt;where(&#x27;name&#x27;,&#x27;like&#x27;,&#x27;%think%&#x27;) -&gt;where(&#x27;name&#x27;,&#x27;like&#x27;,&#x27;%php%&#x27;) -&gt;where(&#x27;id&#x27;,&#x27;in&#x27;,[1,5,80,50]) -&gt;where(&#x27;id&#x27;,&#x27;&gt;&#x27;,10) -&gt;find(); 视图查询 视图查询可以实现不依赖数据库视图的多表查询，并不需要数据库支持视图，例如： 12345Db::view(&#x27;User&#x27;,&#x27;id,name&#x27;) -&gt;view(&#x27;Profile&#x27;,&#x27;truename,phone,email&#x27;,&#x27;Profile.user_id=User.id&#x27;) -&gt;view(&#x27;Score&#x27;,&#x27;score&#x27;,&#x27;Score.user_id=Profile.id&#x27;) -&gt;where(&#x27;score&#x27;,&#x27;&gt;&#x27;,80) -&gt;select(); 生成的SQL语句类似于： 1SELECT User.id,User.name,Profile.truename,Profile.phone,Profile.email,Score.score FROM think_user User INNER JOIN think_profile Profile ON Profile.user_id=User.id INNER JOIN think_socre Score ON Score.user_id=Profile.id WHERE Score.score &gt; 80 注意，视图查询无需调用table和join方法，并且在调用where和order方法的时候只需要使用字段名而不需要加表名。 默认使用INNER join查询，如果需要更改，可以使用： 12345Db::view(&#x27;User&#x27;,&#x27;id,name&#x27;) -&gt;view(&#x27;Profile&#x27;,&#x27;truename,phone,email&#x27;,&#x27;Profile.user_id=User.id&#x27;,&#x27;LEFT&#x27;) -&gt;view(&#x27;Score&#x27;,&#x27;score&#x27;,&#x27;Score.user_id=Profile.id&#x27;,&#x27;RIGHT&#x27;) -&gt;where(&#x27;score&#x27;,&#x27;&gt;&#x27;,80) -&gt;select(); 生成的SQL语句类似于： 1SELECT User.id,User.name,Profile.truename,Profile.phone,Profile.email,Score.score FROM think_user User LEFT JOIN think_profile Profile ON Profile.user_id=User.id RIGHT JOIN think_socre Score ON Score.user_id=Profile.id WHERE Score.score &gt; 80 可以使用别名： 12345Db::view(&#x27;User&#x27;,[&#x27;id&#x27;=&gt;&#x27;uid&#x27;,&#x27;name&#x27;=&gt;&#x27;account&#x27;]) -&gt;view(&#x27;Profile&#x27;,&#x27;truename,phone,email&#x27;,&#x27;Profile.user_id=User.id&#x27;) -&gt;view(&#x27;Score&#x27;,&#x27;score&#x27;,&#x27;Score.user_id=Profile.id&#x27;) -&gt;where(&#x27;score&#x27;,&#x27;&gt;&#x27;,80) -&gt;select(); 生成的SQL语句变成： 1SELECT User.id AS uid,User.name AS account,Profile.truename,Profile.phone,Profile.email,Score.score FROM think_user User INNER JOIN think_profile Profile ON Profile.user_id=User.id INNER JOIN think_socre Score ON Score.user_id=Profile.id WHERE Score.score &gt; 80 可以使用数组的方式定义表名以及别名，例如： 12345Db::view([&#x27;think_user&#x27;=&gt;&#x27;member&#x27;],[&#x27;id&#x27;=&gt;&#x27;uid&#x27;,&#x27;name&#x27;=&gt;&#x27;account&#x27;]) -&gt;view(&#x27;Profile&#x27;,&#x27;truename,phone,email&#x27;,&#x27;Profile.user_id=member.id&#x27;) -&gt;view(&#x27;Score&#x27;,&#x27;score&#x27;,&#x27;Score.user_id=Profile.id&#x27;) -&gt;where(&#x27;score&#x27;,&#x27;&gt;&#x27;,80) -&gt;select(); 生成的SQL语句变成： 1SELECT member.id AS uid,member.name AS account,Profile.truename,Profile.phone,Profile.email,Score.score FROM think_user member INNER JOIN think_profile Profile ON Profile.user_id=member.id INNER JOIN think_socre Score ON Score.user_id=Profile.id WHERE Score.score &gt; 80 子查询 首先构造子查询SQL，可以使用下面三种的方式来构建子查询。 1、使用select方法当select方法的参数为false的时候，表示不进行查询只是返回构建SQL，例如： 1234$subQuery = Db::table(&#x27;think_user&#x27;) -&gt;field(&#x27;id,name&#x27;) -&gt;where(&#x27;id&#x27;,&#x27;&gt;&#x27;,10) -&gt;select(false); 生成的subQuery结果为： 1SELECT `id`,`name` FROM `think_user` WHERE `id` &gt; 10 2、使用fetchSql方法fetchSql方法表示不进行查询而只是返回构建的SQL语句，并且不仅仅支持select，而是支持所有的CURD查询。 12345$subQuery = Db::table(&#x27;think_user&#x27;) -&gt;field(&#x27;id,name&#x27;) -&gt;where(&#x27;id&#x27;,&#x27;&gt;&#x27;,10) -&gt;fetchSql(true) -&gt;select(); 生成的subQuery结果为： 1SELECT `id`,`name` FROM `think_user` WHERE `id` &gt; 10 3、使用buildSql构造子查询1234$subQuery = Db::table(&#x27;think_user&#x27;) -&gt;field(&#x27;id,name&#x27;) -&gt;where(&#x27;id&#x27;,&#x27;&gt;&#x27;,10) -&gt;buildSql(); 生成的subQuery结果为： 1( SELECT `id`,`name` FROM `think_user` WHERE `id` &gt; 10 ) 调用buildSql方法后不会进行实际的查询操作，而只是生成该次查询的SQL语句（为了避免混淆，会在SQL两边加上括号），然后我们直接在后续的查询中直接调用。 需要注意的是，使用前两种方法需要自行添加‘括号’。 然后使用子查询构造新的查询： 1234Db::table($subQuery.&#x27; a&#x27;) -&gt;where(&#x27;a.name&#x27;,&#x27;like&#x27;,&#x27;thinkphp&#x27;) -&gt;order(&#x27;id&#x27;,&#x27;desc&#x27;) -&gt;select(); 生成的SQL语句为： 1SELECT * FROM ( SELECT `id`,`name` FROM `think_user` WHERE `id` &gt; 10 ) a WHERE a.name LIKE &#x27;thinkphp&#x27; ORDER BY `id` desc 4、使用闭包构造子查询IN/NOT IN和EXISTS/NOT EXISTS之类的查询可以直接使用闭包作为子查询，例如： 1234Db::table(&#x27;think_user&#x27;) -&gt;where(&#x27;id&#x27;,&#x27;IN&#x27;,function($query)&#123; $query-&gt;table(&#x27;think_profile&#x27;)-&gt;where(&#x27;status&#x27;,1)-&gt;field(&#x27;id&#x27;); &#125;)-&gt;select(); 生成的SQL语句是 12345SELECT * FROM `think_user` WHERE `id` IN ( SELECT `id` FROM `think_profile` WHERE `status` = 1 ) Db::table(&#x27;think_user&#x27;)-&gt;where(function($query)&#123; $query-&gt;table(&#x27;think_profile&#x27;)-&gt;where(&#x27;status&#x27;,1); &#125;,&#x27;exists&#x27;)-&gt;find(); 生成的SQL语句为 1SELECT * FROM `think_user` WHERE EXISTS ( SELECT * FROM `think_profile` WHERE `status` = 1 ) 原生查询 Db类支持原生SQL查询操作，主要包括下面两个方法： query方法query方法用于执行SQL查询操作，如果数据非法或者查询错误则返回false，否则返回查询结果数据集（同select方法）。 使用示例： 1Db::query(&quot;select * from think_user where status=1&quot;); 如果你当前采用了分布式数据库，并且设置了读写分离的话，query方法始终是在读服务器执行，因此query方法对应的都是读操作，而不管你的SQL语句是什么。 execute方法execute用于更新和写入数据的sql操作，如果数据非法或者查询错误则返回false ，否则返回影响的记录数。 使用示例： 1Db::execute(&quot;update think_user set name=&#x27;thinkphp&#x27; where status=1&quot;); 如果你当前采用了分布式数据库，并且设置了读写分离的话，execute方法始终是在写服务器执行，因此execute方法对应的都是写操作，而不管你的SQL语句是什么。 参数绑定支持在原生查询的时候使用参数绑定，包括问号占位符或者命名占位符，例如： 1Db::query(&quot;select * from think_user where id=? AND status=?&quot;,[8,1]);// 命名绑定Db::execute(&quot;update think_user set name=:name where status=:status&quot;,[&#x27;name&#x27;=&gt;&#x27;thinkphp&#x27;,&#x27;status&#x27;=&gt;1]);","categories":[{"name":"thinkphp查询","slug":"thinkphp查询","permalink":"https://2486125878.github.io/categories/thinkphp%E6%9F%A5%E8%AF%A2/"}],"tags":[{"name":"php","slug":"php","permalink":"https://2486125878.github.io/tags/php/"}]},{"title":"thinkphp链式操作","slug":"thinkphp链式操作","date":"2024-03-14T03:18:02.000Z","updated":"2024-03-14T03:46:06.000Z","comments":true,"path":"2024/03/14/thinkphp链式操作/","permalink":"https://2486125878.github.io/2024/03/14/thinkphp%E9%93%BE%E5%BC%8F%E6%93%8D%E4%BD%9C/","excerpt":"","text":"链式操作 数据库提供的链式操作方法，可以有效的提高数据存取的代码清晰度和开发效率，并且支持所有的CURD操作。 使用也比较简单，假如我们现在要查询一个User表的满足状态为1的前10条记录，并希望按照用户的创建时间排序 ，代码如下： 12345Db::table(&#x27;think_user&#x27;) -&gt;where(&#x27;status&#x27;,1) -&gt;order(&#x27;create_time&#x27;) -&gt;limit(10) -&gt;select(); 这里的where、order和limit方法就被称之为链式操作方法，除了select方法必须放到最后一个外（因为select方法并不是链式操作方法），链式操作的方法调用顺序没有先后，例如，下面的代码和上面的等效： 1Db::table(&#x27;think_user&#x27;)-&gt;order(&#x27;create_time&#x27;)-&gt;limit(10)-&gt;where(&#x27;status&#x27;,1)-&gt;select(); 其实不仅仅是查询方法可以使用连贯操作，包括所有的CURD方法都可以使用，例如： 1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;id&#x27;,1)-&gt;field(&#x27;id,name,email&#x27;)-&gt;find(); Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;status&#x27;,1)-&gt;where(&#x27;id&#x27;,1)-&gt;delete(); 链式操作在完成查询后会自动清空链式操作的所有传值。简而言之，链式操作的结果不会带入后面的其它查询。 系统支持的链式操作方法有： 连贯操作 作用 支持的参数类型 where* 用于AND查询 字符串、数组和对象 whereOr* 用于OR查询 字符串、数组和对象 wheretime* 用于时间日期的快捷查询 字符串 table 用于定义要操作的数据表名称 字符串和数组 alias 用于给当前数据表定义别名 字符串 field* 用于定义要查询的字段（支持字段排除） 字符串和数组 order 用于对结果排序 字符串和数组 limit 用于限制查询结果数量 字符串和数字 page 用于查询分页（内部会转换成limit） 字符串和数字 group 用于对查询的group支持 字符串 having 用于对查询的having支持 字符串 join* 用于对查询的join支持 字符串和数组 union* 用于对查询的union支持 字符串、数组和对象 view 用于视图查询 字符串、数组 distinct 用于查询的distinct支持 布尔值 lock 用于数据库的锁机制 布尔值 cache 用于查询缓存 支持多个参数 relation 用于关联查询 字符串 with 用于关联预载入 字符串、数组 bind* 用于数据绑定操作 数组或多个参数 comment 用于SQL注释 字符串 force 用于数据集的强制索引 字符串 master 用于设置主服务器读取数据 布尔值 strict 用于设置是否严格检测字段名是否存在 布尔值 sequence 用于设置Pgsql的自增序列名 字符串 failException 用于设置没有查询到数据是否抛出异常 布尔值 partition 用于设置分表信息 数组 字符串 所有的连贯操作都返回当前的模型实例对象（this），其中带*标识的表示支持多次调用。 where where方法的用法是ThinkPHP查询语言的精髓，也是ThinkPHP ORM的重要组成部分和亮点所在，可以完成包括普通查询、表达式查询、快捷查询、区间查询、组合查询在内的查询操作。where方法的参数支持字符串和数组，虽然也可以使用对象但并不建议。 表达式查询新版的表达式查询采用全新的方式，查询表达式的使用格式： 1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;id&#x27;,&#x27;&gt;&#x27;,1)-&gt;where(&#x27;name&#x27;,&#x27;thinkphp&#x27;)-&gt;select(); 更多的表达式查询语法，可以参考查询语法部分。 数组条件可以通过数组方式批量设置查询条件。 普通查询最简单的数组查询方式如下： 123$map[&#x27;name&#x27;] = &#x27;thinkphp&#x27;;$map[&#x27;status&#x27;] = 1;// 把查询条件传入查询方法Db::table(&#x27;think_user&#x27;)-&gt;where($map)-&gt;select(); 最后生成的SQL语句是 1SELECT * FROM think_user WHERE `name`=&#x27;thinkphp&#x27; AND status=1 表达式查询可以在数组条件中使用查询表达式，例如： 123$map[&#x27;id&#x27;]=[&#x27;&gt;&#x27;,1];$map[&#x27;mail&#x27;]=[&#x27;like&#x27;,&#x27;%thinkphp@qq.com%&#x27;];Db::table(&#x27;think_user&#x27;)-&gt;where($map)-&gt;select(); 字符串条件使用字符串条件直接查询和操作，例如： 1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;type=1 AND status=1&#x27;)-&gt;select(); 最后生成的SQL语句是 1SELECT * FROM think_user WHERE type=1 AND status=1 使用字符串条件的时候，建议配合预处理机制，确保更加安全，例如： 1234Db::table(&#x27;think_user&#x27;) -&gt;where(&quot;id=:id and username=:name&quot;) -&gt;bind([&#x27;id&#x27;=&gt;[1,\\PDO::PARAM_INT],&#x27;name&#x27;=&gt;&#x27;thinkphp&#x27;]) -&gt;select(); table table方法主要用于指定操作的数据表。 用法一般情况下，操作模型的时候系统能够自动识别当前对应的数据表，所以，使用table方法的情况通常是为了： 切换操作的数据表； 对多表进行操作； 例如： 1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;status&gt;1&#x27;)-&gt;select(); 也可以在table方法中指定数据库，例如： 1Db::table(&#x27;db_name.think_user&#x27;)-&gt;where(&#x27;status&gt;1&#x27;)-&gt;select(); table方法指定的数据表需要完整的表名，但可以采用下面的方式简化数据表前缀的传入，例如： 1Db::table(&#x27;__USER__&#x27;)-&gt;where(&#x27;status&gt;1&#x27;)-&gt;select(); 会自动获取当前模型对应的数据表前缀来生成 think_user 数据表名称。 需要注意的是table方法不会改变数据库的连接，所以你要确保当前连接的用户有权限操作相应的数据库和数据表。 切换数据表后，系统会自动重新获取切换后的数据表的字段缓存信息。 如果需要对多表进行操作，可以这样使用： 1234Db::field(&#x27;user.name,role.title&#x27;) -&gt;table(&#x27;think_user user,think_role role&#x27;) -&gt;limit(10) -&gt;select(); 为了尽量避免和mysql的关键字冲突，可以建议使用数组方式定义，例如： 1234Db::field(&#x27;user.name,role.title&#x27;) -&gt;table([&#x27;think_user&#x27;=&gt;&#x27;user&#x27;,&#x27;think_role&#x27;=&gt;&#x27;role&#x27;]) -&gt;limit(10) -&gt;select(); 使用数组方式定义的优势是可以避免因为表名和关键字冲突而出错的情况。 alias alias用于设置当前数据表的别名，便于使用其他的连贯操作例如join方法等。 示例： 1Db::table(&#x27;think_user&#x27;)-&gt;alias(&#x27;a&#x27;)-&gt;join(&#x27;__DEPT__ b &#x27;,&#x27;b.user_id= a.id&#x27;)-&gt;select(); 最终生成的SQL语句类似于： 1SELECT * FROM think_user a INNER JOIN think_dept b ON b.user_id= a.id v5.0.2+版本开始，可以传入数组批量设置数据表以及别名，例如： 1234Db::table(&#x27;think_user&#x27;) -&gt;alias([&#x27;think_user&#x27;=&gt;&#x27;user&#x27;,&#x27;think_dept&#x27;=&gt;&#x27;dept&#x27;]) -&gt;join(&#x27;think_dept&#x27;,&#x27;dept.user_id= user.id&#x27;) -&gt;select(); 最终生成的SQL语句类似于： 1SELECT * FROM think_user user INNER JOIN think_dept dept ON dept.user_id= user.id field field方法属于模型的连贯操作方法之一，主要目的是标识要返回或者操作的字段，可以用于查询和写入操作。 用于查询指定字段在查询操作中field方法是使用最频繁的。 1Db::table(&#x27;think_user&#x27;)-&gt;field(&#x27;id,title,content&#x27;)-&gt;select(); 这里使用field方法指定了查询的结果集中包含id,title,content三个字段的值。执行的SQL相当于： 1SELECT id,title,content FROM table 可以给某个字段设置别名，例如： 1Db::table(&#x27;think_user&#x27;)-&gt;field(&#x27;id,nickname as name&#x27;)-&gt;select(); 执行的SQL语句相当于： 1SELECT id,nickname as name FROM table 使用SQL函数可以在field方法中直接使用函数，例如： 1Db::table(&#x27;think_user&#x27;)-&gt;field(&#x27;id,SUM(score)&#x27;)-&gt;select(); 执行的SQL相当于： 1SELECT id,SUM(score) FROM table 除了select方法之外，所有的查询方法，包括find等都可以使用field方法。 使用数组参数field方法的参数可以支持数组，例如： 1Db::table(&#x27;think_user&#x27;)-&gt;field([&#x27;id&#x27;,&#x27;title&#x27;,&#x27;content&#x27;])-&gt;select(); 最终执行的SQL和前面用字符串方式是等效的。 数组方式的定义可以为某些字段定义别名，例如： 1Db::table(&#x27;think_user&#x27;)-&gt;field([&#x27;id&#x27;,&#x27;nickname&#x27;=&gt;&#x27;name&#x27;])-&gt;select(); 执行的SQL相当于： 1SELECT id,nickname as name FROM table 对于一些更复杂的字段要求，数组的优势则更加明显，例如： 123Db::table(&#x27;think_user&#x27;) -&gt;field([&#x27;id&#x27;,&#x27;concat(name,&quot;-&quot;,id)&#x27;=&gt;&#x27;truename&#x27;,&#x27;LEFT(title,7)&#x27;=&gt;&#x27;sub_title&#x27;]) -&gt;select(); 执行的SQL相当于： 1SELECT id,concat(name,&#x27;-&#x27;,id) as truename,LEFT(title,7) as sub_title FROM table 获取所有字段如果有一个表有非常多的字段，需要获取所有的字段（这个也许很简单，因为不调用field方法或者直接使用空的field方法都能做到）： 1Db::table(&#x27;think_user&#x27;)-&gt;select();Db::table(&#x27;think_user&#x27;)-&gt;field(&#x27;*&#x27;)-&gt;select(); 上面的用法是等效的，都相当于执行SQL： 1SELECT * FROM table 但是这并不是我说的获取所有字段，而是显式的调用所有字段（对于对性能要求比较高的系统，这个要求并不过分，起码是一个比较好的习惯），下面的用法可以完成预期的作用： 1Db::table(&#x27;think_user&#x27;)-&gt;field(true)-&gt;select(); field(true)的用法会显式的获取数据表的所有字段列表，哪怕你的数据表有100个字段。 字段排除如果我希望获取排除数据表中的content字段（文本字段的值非常耗内存）之外的所有字段值，我们就可以使用field方法的排除功能，例如下面的方式就可以实现所说的功能： 1Db::table(&#x27;think_user&#x27;)-&gt;field(&#x27;content&#x27;,true)-&gt;select(); 则表示获取除了content之外的所有字段，要排除更多的字段也可以： 123Db::table(&#x27;think_user&#x27;)-&gt;field(&#x27;user_id,content&#x27;,true)-&gt;select();//或者用Db::table(&#x27;think_user&#x27;)-&gt;field([&#x27;user_id&#x27;,&#x27;content&#x27;],true)-&gt;select(); 注意的是 字段排除功能不支持跨表和join操作。 用于写入除了查询操作之外，field方法还有一个非常重要的安全功能–字段合法性检测。field方法结合数据库的写入方法使用就可以完成表单提交的字段合法性检测，如果我们在表单提交的处理方法中使用了： 1Db::table(&#x27;think_user&#x27;)-&gt;field(&#x27;title,email,content&#x27;)-&gt;insert($data); 即表示表单中的合法字段只有title,email和content字段，无论用户通过什么手段更改或者添加了浏览器的提交字段，都会直接屏蔽。因为，其他是所有字段我们都不希望由用户提交来决定，你可以通过自动完成功能定义额外的字段写入。 order order方法属于模型的连贯操作方法之一，用于对操作的结果排序。 用法如下： 1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;status=1&#x27;)-&gt;order(&#x27;id desc&#x27;)-&gt;limit(5)-&gt;select(); 注意：连贯操作方法没有顺序，可以在select方法调用之前随便改变调用顺序。 支持对多个字段的排序，例如： 1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;status=1&#x27;)-&gt;order(&#x27;id desc,status&#x27;)-&gt;limit(5)-&gt;select(); 如果没有指定desc或者asc排序规则的话，默认为asc。 如果你的字段和mysql关键字有冲突，那么建议采用数组方式调用，例如： 12345Db::table(&#x27;think_user&#x27;) -&gt;where(&#x27;status=1&#x27;) -&gt;order([&#x27;order&#x27;,&#x27;id&#x27;=&gt;&#x27;desc&#x27;]) -&gt;limit(5) -&gt;select(); limit limit方法也是模型类的连贯操作方法之一，主要用于指定查询和操作的数量，特别在分页查询的时候使用较多。ThinkPHP的limit方法可以兼容所有的数据库驱动类的。 限制结果数量例如获取满足要求的10个用户，如下调用即可： 1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;status=1&#x27;)-&gt;field(&#x27;id,name&#x27;)-&gt;limit(10)-&gt;select(); limit方法也可以用于写操作，例如更新满足要求的3条数据： 1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;score=100&#x27;)-&gt;limit(3)-&gt;update([&#x27;level&#x27;=&gt;&#x27;A&#x27;]); 分页查询用于文章分页查询是limit方法比较常用的场合，例如： 1Db::table(&#x27;think_article&#x27;)-&gt;limit(&#x27;10,25&#x27;)-&gt;select(); 表示查询文章数据，从第10行开始的25条数据（可能还取决于where条件和order排序的影响 这个暂且不提）。 你也可以这样使用，作用是一样的： 1Db::table(&#x27;think_article&#x27;)-&gt;limit(10,25)-&gt;select(); 对于大数据表，尽量使用limit限制查询结果，否则会导致很大的内存开销和性能问题。 page page方法也是模型的连贯操作方法之一，是完全为分页查询而诞生的一个人性化操作方法。 我们在前面已经了解了关于limit方法用于分页查询的情况，而page方法则是更人性化的进行分页查询的方法，例如还是以文章列表分页为例来说，如果使用limit方法，我们要查询第一页和第二页（假设我们每页输出10条数据）写法如下： 1234// 查询第一页数据Db::table(&#x27;think_article&#x27;)-&gt;limit(&#x27;0,10&#x27;)-&gt;select(); // 查询第二页数据Db::table(&#x27;think_article&#x27;)-&gt;limit(&#x27;10,10&#x27;)-&gt;select(); 虽然利用扩展类库中的分页类Page可以自动计算出每个分页的limit参数，但是如果要自己写就比较费力了，如果用page方法来写则简单多了，例如： 12345678// 查询第一页数据Db::table(&#x27;think_article&#x27;) -&gt;page(&#x27;1,10&#x27;) -&gt;select(); // 查询第二页数据Db::table(&#x27;think_article&#x27;) -&gt;page(&#x27;2,10&#x27;) -&gt;select(); 显而易见的是，使用page方法你不需要计算每个分页数据的起始位置，page方法内部会自动计算。 和limit方法一样，page方法也支持2个参数的写法，例如： 1234567Db::table(&#x27;think_article&#x27;) -&gt;page(1,10) -&gt;select();// 和下面的用法等效Db::table(&#x27;think_article&#x27;) -&gt;page(&#x27;1,10&#x27;) -&gt;select(); page方法还可以和limit方法配合使用，例如： 1234Db::table(&#x27;think_article&#x27;) -&gt;limit(25) -&gt;page(3) -&gt;select(); 当page方法只有一个值传入的时候，表示第几页，而limit方法则用于设置每页显示的数量，也就是说上面的写法等同于： 123Db::table(&#x27;think_article&#x27;) -&gt;page(&#x27;3,25&#x27;) -&gt;select(); group GROUP方法也是连贯操作方法之一，通常用于结合合计函数，根据一个或多个列对结果集进行分组 。 group方法只有一个参数，并且只能使用字符串。 例如，我们都查询结果按照用户id进行分组统计： 1234Db::table(&#x27;think_user&#x27;) -&gt;field(&#x27;user_id,username,max(score)&#x27;) -&gt;group(&#x27;user_id&#x27;) -&gt;select(); 生成的SQL语句是： 1SELECT user_id,username,max(score) FROM think_score GROUP BY user_id 也支持对多个字段进行分组，例如： 1234Db::table(&#x27;think_user&#x27;) -&gt;field(&#x27;user_id,test_time,username,max(score)&#x27;) -&gt;group(&#x27;user_id,test_time&#x27;) -&gt;select(); 生成的SQL语句是： 1SELECT user_id,test_time,username,max(score) FROM think_score GROUP BY user_id,test_time having HAVING方法也是连贯操作之一，用于配合group方法完成从分组的结果中筛选（通常是聚合条件）数据。 having方法只有一个参数，并且只能使用字符串，例如： 12345Db::table(&#x27;think_user&#x27;) -&gt;field(&#x27;username,max(score)&#x27;) -&gt;group(&#x27;user_id&#x27;) -&gt;having(&#x27;count(test_time)&gt;3&#x27;) -&gt;select(); 生成的SQL语句是： 1SELECT username,max(score) FROM think_score GROUP BY user_id HAVING count(test_time)&gt;3 join join通常有下面几种类型，不同类型的join操作会影响返回的数据结果。 INNER JOIN: 等同于 JOIN（默认的JOIN类型）,如果表中有至少一个匹配，则返回行 LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行 RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行 FULL JOIN: 只要其中一个表中存在匹配，就返回行 说明 1object join ( mixed join [, mixed $condition = null [, string $type = &#x27;INNER&#x27;]] ) JOIN方法也是连贯操作方法之一，用于根据两个或多个表中的列之间的关系，从这些表中查询数据。 参数 join1要关联的（完整）表名以及别名 支持三种写法： 123写法1：[ &#x27;完整表名或者子查询&#x27;=&gt;&#x27;别名&#x27; ]写法2：&#x27;完整表名 别名&#x27;写法3：&#x27;不带数据表前缀的表名&#x27; condition1关联条件。可以为字符串或数组， 为数组时每一个元素都是一个关联条件。 type1关联类型。可以为:INNER、LEFT、RIGHT、FULL，不区分大小写，默认为INNER。 返回值模型对象 举例 1234567891011121314151617181920Db::table(&#x27;think_artist&#x27;) -&gt;alias(&#x27;a&#x27;) -&gt;join(&#x27;think_work w&#x27;,&#x27;a.id = w.artist_id&#x27;) -&gt;join(&#x27;think_card c&#x27;,&#x27;a.card_id = c.id&#x27;) -&gt;select();Db::table(&#x27;think_artist&#x27;) -&gt;alias(&#x27;a&#x27;) -&gt;join(&#x27;__WORK__ w&#x27;,&#x27;a.id = w.artist_id&#x27;) -&gt;join(&#x27;__CARD__ c&#x27;,&#x27;a.card_id = c.id&#x27;) -&gt;select();$join = [ [&#x27;think_work w&#x27;,&#x27;a.id=w.artist_id&#x27;], [&#x27;think_card c&#x27;,&#x27;a.card_id=c.id&#x27;],];Db::table(&#x27;think_user&#x27;) -&gt;alias(&#x27;a&#x27;) -&gt;join($join) -&gt;select(); 以上三种写法的效果一样，__WORK__和 __CARD__在最终解析的时候会转换为 think_work和 think_card。注意:’*表名*’这种方式中间的表名需要用大写 如果不想使用别名，后面的条件就要使用表全名，可以使用下面这种方式 123Db::table(&#x27;think_user&#x27;) -&gt;join(&#x27;__WORK__&#x27;,&#x27;__ARTIST__.id = __WORK__.artist_id&#x27;) -&gt;select(); 默认采用INNER JOIN 方式，如果需要用其他的JOIN方式，可以改成 1234Db::table(&#x27;think_user&#x27;) -&gt;alias(&#x27;a&#x27;) -&gt;join(&#x27;word w&#x27;,&#x27;a.id = w.artist_id&#x27;,&#x27;RIGHT&#x27;) -&gt;select(); 表名也可以是一个子查询 123456789$subsql = Db::table(&#x27;think_work&#x27;) -&gt;where([&#x27;status&#x27;=&gt;1]) -&gt;field(&#x27;artist_id,count(id) count&#x27;) -&gt;group(&#x27;artist_id&#x27;) -&gt;buildSql();Db::table(&#x27;think_user&#x27;) -&gt;alias(&#x27;a&#x27;) -&gt;join([$subsql=&gt; &#x27;w&#x27;], &#x27;a.artist_id = w.artist_id&#x27;) -&gt;select(); 因buildSql返回的语句带有()，所以这里不需要在两端再加上()。 union UNION操作用于合并两个或多个 SELECT 语句的结果集。 使用示例： 12345Db::field(&#x27;name&#x27;) -&gt;table(&#x27;think_user_0&#x27;) -&gt;union(&#x27;SELECT name FROM think_user_1&#x27;) -&gt;union(&#x27;SELECT name FROM think_user_2&#x27;) -&gt;select(); 闭包用法： 123456789Db::field(&#x27;name&#x27;) -&gt;table(&#x27;think_user_0&#x27;) -&gt;union(function($query)&#123; $query-&gt;field(&#x27;name&#x27;)-&gt;table(&#x27;think_user_1&#x27;); &#125;) -&gt;union(function($query)&#123; $query-&gt;field(&#x27;name&#x27;)-&gt;table(&#x27;think_user_2&#x27;); &#125;) -&gt;select(); 或者 1234Db::field(&#x27;name&#x27;) -&gt;table(&#x27;think_user_0&#x27;) -&gt;union([&#x27;SELECT name FROM think_user_1&#x27;,&#x27;SELECT name FROM think_user_2&#x27;]) -&gt;select(); 支持UNION ALL 操作，例如： 12345Db::field(&#x27;name&#x27;) -&gt;table(&#x27;think_user_0&#x27;) -&gt;union(&#x27;SELECT name FROM think_user_1&#x27;,true) -&gt;union(&#x27;SELECT name FROM think_user_2&#x27;,true) -&gt;select(); 或者 1234Db::field(&#x27;name&#x27;) -&gt;table(&#x27;think_user_0&#x27;) -&gt;union([&#x27;SELECT name FROM think_user_1&#x27;,&#x27;SELECT name FROM think_user_2&#x27;],true) -&gt;select(); 每个union方法相当于一个独立的SELECT语句。 注意：UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。 distinct DISTINCT 方法用于返回唯一不同的值 。 例如数据库表中有以下数据 以下代码会返回user_login字段不同的数据 1234Db::table(&#x27;think_user&#x27;) -&gt;distinct(true) -&gt;field(&#x27;user_login&#x27;) -&gt;select(); 生成的SQL语句是： SELECT DISTINCT user_login FROM think_user 返回以下数组 1234567array(2) &#123; [0] =&gt; array(1) &#123; [&quot;user_login&quot;] =&gt; string(7) &quot;chunice&quot; &#125; [1] =&gt; array(1) &#123; [&quot;user_login&quot;] =&gt; string(5) &quot;admin&quot; &#125;&#125; distinct方法的参数是一个布尔值。 lock Lock方法是用于数据库的锁机制，如果在查询或者执行操作的时候使用： 1lock(true); 就会自动在生成的SQL语句最后加上 FOR UPDATE或者FOR UPDATE NOWAIT（Oracle数据库）。 cache cache方法用于查询缓存操作，也是连贯操作方法之一。 cache可以用于select、find、value和column方法，以及其衍生方法，使用cache方法后，在缓存有效期之内不会再次进行数据库查询操作，而是直接获取缓存中的数据，关于数据缓存的类型和设置可以参考缓存部分。 下面举例说明，例如，我们对find方法使用cache方法如下： 1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;id=5&#x27;)-&gt;cache(true)-&gt;find(); 第一次查询结果会被缓存，第二次查询相同的数据的时候就会直接返回缓存中的内容，而不需要再次进行数据库查询操作。 默认情况下， 缓存有效期是由默认的缓存配置参数决定的，但cache方法可以单独指定，例如： 123Db::table(&#x27;think_user&#x27;)-&gt;cache(true,60)-&gt;find();// 或者使用下面的方式 是等效的Db::table(&#x27;think_user&#x27;)-&gt;cache(60)-&gt;find(); 表示对查询结果的缓存有效期60秒。 cache方法可以指定缓存标识： 1Db::table(&#x27;think_user&#x27;)-&gt;cache(&#x27;key&#x27;,60)-&gt;find(); 指定查询缓存的标识可以使得查询缓存更有效率。 这样，在外部就可以通过\\think\\Cache类直接获取查询缓存的数据，例如： 12$result = Db::table(&#x27;think_user&#x27;)-&gt;cache(&#x27;key&#x27;,60)-&gt;find();$data = \\think\\Cache::get(&#x27;key&#x27;); cache方法支持设置缓存标签，例如： 1Db::table(&#x27;think_user&#x27;)-&gt;cache(&#x27;key&#x27;,60,&#x27;tagName&#x27;)-&gt;find(); 缓存自动更新这里的缓存自动更新是指一旦数据更新或者删除后会自动清理缓存（下次获取的时候会自动重新缓存）。 当你删除或者更新数据的时候，可以使用cache方法手动更新（清除）缓存，例如： 1234567Db::table(&#x27;think_user&#x27;) -&gt;cache(&#x27;user_data&#x27;) -&gt;select([1,3,5]);Db::table(&#x27;think_user&#x27;) -&gt;cache(&#x27;user_data&#x27;) -&gt;update([&#x27;id&#x27;=&gt;1,&#x27;name&#x27;=&gt;&#x27;thinkphp&#x27;]);Db::table(&#x27;think_user&#x27;)-&gt;cache(&#x27;user_data&#x27;)-&gt;select([1,5]); 最后查询的数据不会受第一条查询缓存的影响，确保查询和更新或者删除使用相同的缓存标识才能自动清除缓存。 如果使用find方法并且使用主键查询的情况，不需要指定缓存标识，会自动清理缓存，例如： 123456Db::table(&#x27;think_user&#x27;) -&gt;cache(true) -&gt;find(1);Db::table(&#x27;think_user&#x27;) -&gt;update([&#x27;id&#x27;=&gt;1,&#x27;name&#x27;=&gt;&#x27;thinkphp&#x27;]);Db::table(&#x27;think_user&#x27;)-&gt;cache(true)-&gt;find(1); 最后查询的数据会是更新后的数据。 comment COMMENT方法 用于在生成的SQL语句中添加注释内容，例如： 123456Db::table(&#x27;think_score&#x27;) -&gt;comment(&#x27;查询考试前十名分数&#x27;) -&gt;field(&#x27;username,score&#x27;) -&gt;limit(10) -&gt;order(&#x27;score desc&#x27;) -&gt;select(); 最终生成的SQL语句是： 1SELECT username,score FROM think_score ORDER BY score desc LIMIT 10 /* 查询考试前十名分数 */ fetchSql fetchSql用于直接返回SQL而不是执行查询，适用于任何的CURD操作方法。 例如： 1$result = Db::table(&#x27;think_user&#x27;)-&gt;fetchSql(true)-&gt;find(1); 输出result结果为： SELECT * FROM think_user where id = 1 force force 方法用于数据集的强制索引操作，例如： 1Db::table(&#x27;think_user&#x27;)-&gt;force(&#x27;user&#x27;)-&gt;select(); 对查询强制使用user索引，user必须是数据表实际创建的索引名称。 bind bind方法用于手动参数绑定，大多数情况，无需进行手动绑定，系统会在查询和写入数据的时候自动使用参数绑定。 bind方法用法如下： 1234567891011// 用于查询Db::table(&#x27;think_user&#x27;) -&gt;where(&#x27;id&#x27;,&#x27;:id&#x27;) -&gt;where(&#x27;name&#x27;,&#x27;:name&#x27;) -&gt;bind([&#x27;id&#x27;=&gt;[10,\\PDO::PARAM_INT],&#x27;name&#x27;=&gt;&#x27;thinkphp&#x27;]) -&gt;select();// 用于写入Db::table(&#x27;think_user&#x27;) -&gt;bind([&#x27;id&#x27;=&gt;[10,\\PDO::PARAM_INT],&#x27;email&#x27;=&gt;&#x27;thinkphp@qq.com&#x27;,&#x27;name&#x27;=&gt;&#x27;thinkphp&#x27;]) -&gt;where(&#x27;id&#x27;,&#x27;:id&#x27;) -&gt;update([&#x27;name&#x27;=&gt;&#x27;:name&#x27;,&#x27;email&#x27;=&gt;&#x27;:email&#x27;); partition partition 方法用于是数据库水平分表 1234partition($data, $field, $rule);// $data 分表字段的数据// $field 分表字段的名称// $rule 分表规则 注意：不要使用任何 SQL 语句中会出现的关键字当表名、字段名，例如 order 等。会导致数据模型拼装 SQL 语句语法错误。 partition 方法用法如下： 1234567891011121314151617// 用于写入$data = [ &#x27;user_id&#x27; =&gt; 110, &#x27;user_name&#x27; =&gt; &#x27;think&#x27;];$rule = [ &#x27;type&#x27; =&gt; &#x27;mod&#x27;, // 分表方式 &#x27;num&#x27; =&gt; 10 // 分表数量];Db::name(&#x27;log&#x27;) -&gt;partition([&#x27;user_id&#x27; =&gt; 110], &quot;user_id&quot;, $rule) -&gt;insert($data);// 用于查询Db::name(&#x27;log&#x27;) -&gt;partition([&#x27;user_id&#x27; =&gt; 110], &quot;user_id&quot;, $rule) -&gt;where([&#x27;user_id&#x27; =&gt; 110]) -&gt;select(); strict strict方法用于设置是否严格检查字段名，用法如下： 1234// 关闭字段严格检查Db::name(&#x27;user&#x27;) -&gt;strict(false) -&gt;insert($data); 注意，系统默认值是由数据库配置参数fields_strict决定，因此修改数据库配置参数可以进行全局的严格检查配置，如下： 12// 关闭严格检查字段是否存在&#x27;fields_strict&#x27; =&gt; false, 如果开启字段严格检查的话，在更新和写入数据库的时候，一旦存在非数据表字段的值，则会抛出异常。 failException failException设置查询数据为空时是否需要抛出异常，如果不传入任何参数，默认为开启，用于select和find方法，例如： 1234// 数据不存在的话直接抛出异常Db:name(&#x27;blog&#x27;)-&gt;where([&#x27;status&#x27; =&gt; 1])-&gt;failException()-&gt;select();// 数据不存在返回空数组 不抛异常Db:name(&#x27;blog&#x27;)-&gt;where([&#x27;status&#x27; =&gt; 1])-&gt;failException(false)-&gt;select(); 或者可以使用更方便的查空报错 1234// 查询多条Db:name(&#x27;blog&#x27;)-&gt;where([&#x27;status&#x27; =&gt; 1])-&gt;selectOrFail();// 查询单条Db:name(&#x27;blog&#x27;)-&gt;where([&#x27;status&#x27; =&gt; 1])-&gt;findOrFail(); sequence sequence方法用于pgsql数据库指定自增序列名，其它数据库不必使用，用法为： 1Db::name(&#x27;user&#x27;)-&gt;sequence(&#x27;id&#x27;)-&gt;insert([&#x27;name&#x27;=&gt;&#x27;thinkphp&#x27;]);","categories":[{"name":"thinkphp查询","slug":"thinkphp查询","permalink":"https://2486125878.github.io/categories/thinkphp%E6%9F%A5%E8%AF%A2/"}],"tags":[{"name":"php","slug":"php","permalink":"https://2486125878.github.io/tags/php/"}]},{"title":"查询构造器","slug":"查询构造器","date":"2024-03-14T02:58:01.000Z","updated":"2024-03-14T03:17:20.000Z","comments":true,"path":"2024/03/14/查询构造器/","permalink":"https://2486125878.github.io/2024/03/14/%E6%9F%A5%E8%AF%A2%E6%9E%84%E9%80%A0%E5%99%A8/","excerpt":"","text":"查询数据 基本查询查询一个数据使用： 12// table方法必须指定完整的数据表名Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;id&#x27;,1)-&gt;find(); find 方法查询结果不存在，返回 null 查询数据集使用： 1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;status&#x27;,1)-&gt;select(); select 方法查询结果不存在，返回空数组 如果设置了数据表前缀参数的话，可以使用 1Db::name(&#x27;user&#x27;)-&gt;where(&#x27;id&#x27;,1)-&gt;find();Db::name(&#x27;user&#x27;)-&gt;where(&#x27;status&#x27;,1)-&gt;select(); 如果你的数据表没有使用表前缀功能，那么name和table方法的一样的效果。 在find和select方法之前可以使用所有的链式操作方法。 默认情况下，find和select方法返回的都是数组。 使用Query对象或闭包查询或者使用查询对象进行查询，例如： 1$query = new \\think\\db\\Query();$query-&gt;table(&#x27;think_user&#x27;)-&gt;where(&#x27;status&#x27;,1);Db::find($query);Db::select($query); 或者直接使用闭包函数查询，例如： 1Db::select(function($query)&#123; $query-&gt;table(&#x27;think_user&#x27;)-&gt;where(&#x27;status&#x27;,1);&#125;); 值和列查询查询某个字段的值可以用 12// 返回某个字段的值Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;id&#x27;,1)-&gt;value(&#x27;name&#x27;); value 方法查询结果不存在，返回 null 查询某一列的值可以用 1234// 返回数组Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;status&#x27;,1)-&gt;column(&#x27;name&#x27;);// 指定索引Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;status&#x27;,1)-&gt;column(&#x27;name&#x27;,&#x27;id&#x27;); column 方法查询结果不存在，返回空数组 数据集分批处理如果你需要处理成千上百条数据库记录，可以考虑使用chunk方法，该方法一次获取结果集的一小块，然后填充每一小块数据到要处理的闭包，该方法在编写处理大量数据库记录的时候非常有用。 比如，我们可以全部用户表数据进行分批处理，每次处理 100 个用户记录： 123456Db::table(&#x27;think_user&#x27;)-&gt;chunk(100, function($users) &#123; foreach ($users as $user) &#123; //&#125;&#125;); // 或者交给回调方法myUserIterator处理Db::table(&#x27;think_user&#x27;)-&gt;chunk(100, &#x27;myUserIterator&#x27;); 你可以通过从闭包函数中返回false来中止对数据集的处理： 1234Db::table(&#x27;think_user&#x27;)-&gt;chunk(100, function($users) &#123; // 处理结果集... return false;&#125;); 也支持在chunk方法之前调用其它的查询方法，例如： 1234Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;score&#x27;,&#x27;&gt;&#x27;,80)-&gt;chunk(100, function($users) &#123; foreach ($users as $user) &#123; // &#125;&#125;); JSON类型数据查询（mysql V5.0.1）12// 查询JSON类型字段 （info字段为json类型）Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;info$.email&#x27;,&#x27;thinkphp@qq.com&#x27;)-&gt;find(); 添加数据 添加一条数据使用 Db 类的 insert 方法向数据库提交数据 12$data = [&#x27;foo&#x27; =&gt; &#x27;bar&#x27;, &#x27;bar&#x27; =&gt; &#x27;foo&#x27;];Db::table(&#x27;think_user&#x27;)-&gt;insert($data); 如果你在database.php配置文件中配置了数据库前缀(prefix)，那么可以直接使用 Db 类的 name 方法提交数据 1Db::name(&#x27;user&#x27;)-&gt;insert($data); insert 方法添加数据成功返回添加成功的条数，insert 正常情况返回 1 添加数据后如果需要返回新增数据的自增主键，可以使用getLastInsID方法： 12Db::name(&#x27;user&#x27;)-&gt;insert($data);$userId = Db::name(&#x27;user&#x27;)-&gt;getLastInsID(); 或者直接使用insertGetId方法新增数据并返回主键值： 1Db::name(&#x27;user&#x27;)-&gt;insertGetId($data); insertGetId 方法添加数据成功返回添加数据的自增主键 添加多条数据添加多条数据直接向 Db 类的 insertAll 方法传入需要添加的数据即可 123456$data = [ [&#x27;foo&#x27; =&gt; &#x27;bar&#x27;, &#x27;bar&#x27; =&gt; &#x27;foo&#x27;], [&#x27;foo&#x27; =&gt; &#x27;bar1&#x27;, &#x27;bar&#x27; =&gt; &#x27;foo1&#x27;], [&#x27;foo&#x27; =&gt; &#x27;bar2&#x27;, &#x27;bar&#x27; =&gt; &#x27;foo2&#x27;]];Db::name(&#x27;user&#x27;)-&gt;insertAll($data); insertAll 方法添加数据成功返回添加成功的条数 更新数据 更新数据表中的数据1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;id&#x27;, 1)-&gt;update([&#x27;name&#x27; =&gt; &#x27;thinkphp&#x27;]); 如果数据中包含主键，可以直接使用： 1Db::table(&#x27;think_user&#x27;)-&gt;update([&#x27;name&#x27; =&gt; &#x27;thinkphp&#x27;,&#x27;id&#x27;=&gt;1]); update 方法返回影响数据的条数，没修改任何数据返回 0 如果要更新的数据需要使用SQL函数或者其它字段，可以使用下面的方式： 1234Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;id&#x27;, 1)-&gt;update([ &#x27;login_time&#x27; =&gt; [&#x27;exp&#x27;,&#x27;now()&#x27;], &#x27;login_times&#x27; =&gt; [&#x27;exp&#x27;,&#x27;login_times+1&#x27;],]); 更新某个字段的值：1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;id&#x27;,1)-&gt;setField(&#x27;name&#x27;, &#x27;thinkphp&#x27;); setField 方法返回影响数据的条数，没修改任何数据字段返回 0 自增或自减一个字段的值setInc/setDec 如不加第二个参数，默认值为1 12345678// score 字段加 1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;id&#x27;, 1)-&gt;setInc(&#x27;score&#x27;);// score 字段加 5Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;id&#x27;, 1)-&gt;setInc(&#x27;score&#x27;, 5);// score 字段减 1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;id&#x27;, 1)-&gt;setDec(&#x27;score&#x27;);// score 字段减 5Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;id&#x27;, 1)-&gt;setDec(&#x27;score&#x27;, 5); 延迟更新setInc/setDec支持延时更新，如果需要延时更新则传入第三个参数下例中延时10秒，给score字段增加1 1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;id&#x27;, 1)-&gt;setInc(&#x27;score&#x27;, 1, 10); setInc&#x2F;setDec 方法返回影响数据的条数 删除数据 删除数据表中的数据12345// 根据主键删除Db::table(&#x27;think_user&#x27;)-&gt;delete(1);Db::table(&#x27;think_user&#x27;)-&gt;delete([1,2,3]);// 条件删除 Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;id&#x27;,1)-&gt;delete();Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;id&#x27;,&#x27;&lt;&#x27;,10)-&gt;delete(); delete 方法返回影响数据的条数，没有删除返回 0 查询方法 条件查询方法where方法可以使用where方法进行AND条件查询： 1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;name&#x27;,&#x27;like&#x27;,&#x27;%thinkphp&#x27;)-&gt;where(&#x27;status&#x27;,1)-&gt;find(); 多字段相同条件的AND查询可以简化为如下方式： 1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;name&amp;title&#x27;,&#x27;like&#x27;,&#x27;%thinkphp&#x27;)-&gt;find(); whereOr方法使用whereOr方法进行OR查询： 1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;name&#x27;,&#x27;like&#x27;,&#x27;%thinkphp&#x27;)-&gt;whereOr(&#x27;title&#x27;,&#x27;like&#x27;,&#x27;%thinkphp&#x27;)-&gt;find(); 多字段相同条件的OR查询可以简化为如下方式： 1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;name|title&#x27;,&#x27;like&#x27;,&#x27;%thinkphp&#x27;)-&gt;find(); 混合查询where方法和whereOr方法在复杂的查询条件中经常需要配合一起混合使用，下面举个例子： 12345$result = Db::table(&#x27;think_user&#x27;)-&gt;where(function ($query) &#123; $query-&gt;where(&#x27;id&#x27;, 1)-&gt;whereor(&#x27;id&#x27;, 2);&#125;)-&gt;whereOr(function ($query) &#123; $query-&gt;where(&#x27;name&#x27;, &#x27;like&#x27;, &#x27;think&#x27;)-&gt;whereOr(&#x27;name&#x27;, &#x27;like&#x27;, &#x27;thinkphp&#x27;);&#125;)-&gt;select(); 生成的sql语句类似于下面： 1SELECT * FROM `think_user` WHERE (`id` = 1 OR `id` = 2 ) OR (`name` LIKE &#x27;think&#x27; OR `name` LIKE &#x27;thinkphp&#x27; ) 注意闭包查询里面的顺序，而且第一个查询方法用where或者whereOr是没有区别的。 getTableInfo方法使用getTableInfo可以获取表信息，信息类型 包括 fields,type,bind,pk，以数组的形式展示，可以指定某个信息进行获取 12345678// 获取`think_user`表所有信息Db::getTableInfo(&#x27;think_user&#x27;);// 获取`think_user`表所有字段Db::getTableInfo(&#x27;think_user&#x27;, &#x27;fields&#x27;);// 获取`think_user`表所有字段的类型Db::getTableInfo(&#x27;think_user&#x27;, &#x27;type&#x27;);// 获取`think_user`表的主键Db::getTableInfo(&#x27;think_user&#x27;, &#x27;pk&#x27;); 查询语法 查询表达式查询表达式支持大部分的SQL查询语法，也是ThinkPHP查询语言的精髓，查询表达式的使用格式： 12where(&#x27;字段名&#x27;,&#x27;表达式&#x27;,&#x27;查询条件&#x27;);whereOr(&#x27;字段名&#x27;,&#x27;表达式&#x27;,&#x27;查询条件&#x27;); 版本 新增功能 5.0.4 支持对同一个字段多次调用查询方法 表达式不分大小写，支持的查询表达式有下面几种，分别表示的含义是： 表达式 含义 EQ、&#x3D; 等于（&#x3D;） NEQ、&lt;&gt; 不等于（&lt;&gt;） GT、&gt; 大于（&gt;） EGT、&gt;&#x3D; 大于等于（&gt;&#x3D;） LT、&lt; 小于（&lt;） ELT、&lt;&#x3D; 小于等于（&lt;&#x3D;） LIKE 模糊查询 [NOT] BETWEEN （不在）区间查询 [NOT] IN （不在）IN 查询 [NOT] NULL 查询字段是否（不）是NULL [NOT] EXISTS EXISTS查询 EXP 表达式查询，支持SQL语法 &gt; time 时间比较 &lt; time 时间比较 between time 时间比较 notbetween time 时间比较 表达式查询的用法示例如下： EQ ：等于（&#x3D;）例如： 12where(&#x27;id&#x27;,&#x27;eq&#x27;,100);where(&#x27;id&#x27;,&#x27;=&#x27;,100); 和下面的查询等效 1where(&#x27;id&#x27;,100); 表示的查询条件就是 id = 100 NEQ： 不等于（&lt;&gt;）例如： 12where(&#x27;id&#x27;,&#x27;neq&#x27;,100);where(&#x27;id&#x27;,&#x27;&lt;&gt;&#x27;,100); 表示的查询条件就是 id &lt;&gt; 100 GT：大于（&gt;）例如： 12where(&#x27;id&#x27;,&#x27;gt&#x27;,100);where(&#x27;id&#x27;,&#x27;&gt;&#x27;,100); 表示的查询条件就是 id &gt; 100 EGT：大于等于（&gt;&#x3D;）例如： 12where(&#x27;id&#x27;,&#x27;egt&#x27;,100);where(&#x27;id&#x27;,&#x27;&gt;=&#x27;,100); 表示的查询条件就是 id &gt;= 100 LT：小于（&lt;）例如： 12where(&#x27;id&#x27;,&#x27;lt&#x27;,100);where(&#x27;id&#x27;,&#x27;&lt;&#x27;,100); 表示的查询条件就是 id &lt; 100 ELT： 小于等于（&lt;&#x3D;）例如： 12where(&#x27;id&#x27;,&#x27;elt&#x27;,100);where(&#x27;id&#x27;,&#x27;&lt;=&#x27;,100); 表示的查询条件就是 id &lt;= 100 [NOT] LIKE： 同sql的LIKE例如： 1where(&#x27;name&#x27;,&#x27;like&#x27;,&#x27;thinkphp%&#x27;); 查询条件就变成 name like &#39;thinkphp%&#39; [NOT] BETWEEN ：同sql的[not] between查询条件支持字符串或者数组，例如： 1where(&#x27;id&#x27;,&#x27;between&#x27;,&#x27;1,8&#x27;); 和下面的等效： 1where(&#x27;id&#x27;,&#x27;between&#x27;,[1,8]); 查询条件就变成 id BETWEEN 1 AND 8 [NOT] IN： 同sql的[not] in查询条件支持字符串或者数组，例如： 1where(&#x27;id&#x27;,&#x27;not in&#x27;,&#x27;1,5,8&#x27;); 和下面的等效： 1where(&#x27;id&#x27;,&#x27;not in&#x27;,[1,5,8]); 查询条件就变成 id NOT IN (1,5, 8) [NOT] IN查询支持使用闭包方式 [NOT] NULL ：查询字段是否（不）是Null，例如： 123where(&#x27;name&#x27;, null);where(&#x27;title&#x27;,&#x27;null&#x27;);where(&#x27;name&#x27;,&#x27;not null&#x27;); 如果你需要查询一个字段的值为字符串null或者not null，应该使用： 12where(&#x27;title&#x27;,&#x27;=&#x27;, &#x27;null&#x27;);where(&#x27;name&#x27;,&#x27;=&#x27;, &#x27;not null&#x27;); EXP：表达式支持更复杂的查询情况 例如： 1where(&#x27;id&#x27;,&#x27;in&#x27;,&#x27;1,3,8&#x27;); 可以改成： 1where(&#x27;id&#x27;,&#x27;exp&#x27;,&#x27; IN (1,3,8) &#x27;); exp查询的条件不会被当成字符串，所以后面的查询条件可以使用任何SQL支持的语法，包括使用函数和字段名称。","categories":[{"name":"thinkphp查询","slug":"thinkphp查询","permalink":"https://2486125878.github.io/categories/thinkphp%E6%9F%A5%E8%AF%A2/"}],"tags":[{"name":"php","slug":"php","permalink":"https://2486125878.github.io/tags/php/"}]},{"title":"‘mysql数据库’","slug":"‘mysql数据库’","date":"2024-03-13T08:53:49.000Z","updated":"2024-03-13T08:59:04.000Z","comments":true,"path":"2024/03/13/‘mysql数据库’/","permalink":"https://2486125878.github.io/2024/03/13/%E2%80%98mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%99/","excerpt":"","text":"数据库数据库 存储数据的仓库,数据是有组织的进行存储 英文: DataBase,简称DB 数据库管理系统 管理数据库的大型软件 英文: DataBase Management System,简称DBMS SQL 英文: Structured Query Language,简称SQL,结构化查询语言 操作关系型数据库的编程语言 定义操作所有关系型数据库的统一标准 Oracle:收费的大型数据库, Oracle公司的产品 MysQL:开源免费的中小型数据库。后来Sun公司收购了MysQL,而Sun公司又被Oracle收购 SQL Server: MicroSoft公司收费的中型的数据库。c#,net等语言常使用 PostgresQL:开源免,中小型的数据库 DB2: IBM公司的大型收费数据库产品 SQLite:嵌入式的微型数据库,如:作为Android内量数据库 MariaDB:开源免费中小型的数据库 初始化数据库mysqld –initialize-insecure 注册MySQL服务在黑框里敲入mysqld -install,回车。mysgld -install 启动MySQL服务在黑框哩敲入net start mysql ,回车. net start mysql &#x2F;&#x2F;启动mysql服务 net stop mysql &#x2F;&#x2F;停止mysql服务 6,修改默认账户密码在黑框里敲入mysaladmin-u root password 1234,这里的1234就是指默认管理员(即root账户)的密码,可以自行修改成你喜欢的。 mysqladmin -u root password 1234 进入MYSQL mysql -uroot -p123456 退出mysql: exit quit 登录參数: mysql -u用户名-p,密码-h要连接的mysql服务器的ip地址(默认127.0.0.1) -P端口号(默认3306) 五、卸载MysQL如果你想卸载My5QL,也很简单 右键开始菜单,选择命令提示符(管理员),打开黑框。 1.敲入net stop mysql,回车。 net stop mysql 2,再敲入mysqld-remove mysql,回车。 mysqld -remove mysql 最后删除MySQL目录及相关的环境变量。至此, MysQL卸载完成 关系型数据库关系型数据库是建立在关系模型基础上的数据库,简单说,关系型数据库是由多张能互相连接的二维表组成的数据库 优点 1,都是使用表结构,格式一致,易于维护。 2,使用通用的SQL语言操作,使用方便,可用于复杂查询。 3.数据存储在磁盘中,安全。 SQL简介 英文: Structured Query Language,简称SQL 结构化查询语言,一门操作关系型数据库的编程语言 定义操作所有关系型数据库的统一标准 对于同一个需求,每一种数据库操作的方式可能会存在一些不一样的地方,我们称为”方言” SQL通用语法 1, SQL语句可以单行或多行书写,以分号结尾。 2.MySQL数据库的SQL语句不区分大小写,关键字建议使用大写。 3.注释 单行注释:– 注释内容或#注释内容(MysQL特有) 多行注释:&#x2F;注释&#x2F; SQL分类DDL(Data Definition Language)数据定义语言,用来定义数据库对象:数据库,表,列等”. DML(Data Manipulation Language)数据操作语言,用来对数据库中表的数据进行增删改. DQL(Data Query Language)数据查询语言,用来查询数据库中表的记录(数据), DCL(Data Control Language)数据控制语言,用来定义数据库的访问权限和安全级别,及创建用户 DDL:操作数据库,表等 DML:对表中的数据进行增删改 DQL:对表中的数据进行查询 DCL:对数据库进行权限控制 DDL–操作数据库1.查询 SHOW DATABASES; 2.删除 删除数据库 DROP DATABASE数据库名称; 删除数据库(判断,如果存在则删除) DROP DATABASE IF EXISTS数据库名称; 3.创建 创建数据库 CREATE DATABASE数据库名称; 创建数据库(判断,如果不存在则创建) CREATE DATABASE IF NOT EXISTS数据库名称; CREATE DATABASE test1 DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci; 4.使用数据库 查看当前使用的数据库 SELECT DATABASE(); 使用数据库 USE数据库名称; DDL–操作表创建(Create) 查询(Retrieve) 修改(Update) 删除(Delete) 查询表查询当前数据库下所有表名称——-SHOW TABLES; 查询表结构—–DESC表名称; 创建表CREATE TABLE 表名( 字段名1数据类型1, 字段名2数据类型2, ………….. 字段名n 数据类型n）; 注意:最后一行末尾,不能加逗号 数据类型MysQL支持多种类型,可以分为三类: 数值 日期 字符串 删除表1.删除表 DROP TABLE 表名； 2.删除表时判断表是否存在 DROP TABLE IF EXISTS 表名; 修改表1,修改表名 ALTER TABLE表名RENAME To新的表名; 2,修改列名和数据类型 ALTER TABLE表名CHANGE列名新列名新数据类型; 3.添加一列 ALTER TABLE表名ADD列名数据类型; 4.删除列 ALTER TABLE表名DROP列名 5,修改数据类型 ALTER TABLE表名MODIFY列名新数据类型; Navicathttp://www.navicat.com.cn/ DML添加数据1,给指定列添加数据 给所有列添加数据,例名的列表可以省略的 INSERT INTO表名(列名1,列名2,…) VALUES (值1,值2,…); 2.给全部列添加数据 INSERT INTO表名VALUES(值1,值2,..); 3,批量添加数据 INSERT INTO表名(列名1,列名2,.) VALUES (值1,值2,), (值1,值2,..), (值1,值2, ..).. INSERT INTO表名VALUES(值1,值2, .), (值1,值2,), (值1,值2, .).. 修改数据1,修改表数据 UPDATE 表名 SET 列名1-值1,列名2-值2….[WHERE条件] ; 注意:修改语句中如果不加条件,则将所有数据都修改! 如果update语句没有加where条件,则会将表中所有数据全部修改! 删除数据1.删除数据 DELETE FROM表名[WHERE条件] ; 注意:删除语句中如果不加条件,则将所有数据都删除 DQL—-查询查询语法SELECT 字段列表 FROM 表名列表 WHERE 条件列表 GROUP BY 分组字段 HAVING 分组后条件 ORDER BY 排序字段 LIMIT 分页限定 基础查询 条件查询(WHERE) 分组查询(GROUP BY) 排序查询(ORDER BY) 分页查询(LIMIT) 查询所有列的数据,列名的列表可以使用*替代 不要使用! 去除重复记录select DISTINCT address from stu; 查询姓名,数学成绩,英语成绩 select name, math 数学成绩,english as英语成绩from stu; 1.查询多个字段 SELECT 字段列表 FROM 表名; SELECT * FROM表名;–查询所有数据 2.去除重复记录 SELECT DISTINCT 字段列表 FROM表名; 3.起别名 AS: AS也可以省略 条件查询1.条件查询语法 SELECT字段列表FROM表名WHERE条件列表; 8.查询英语成绩为nu11的学员信息注意: nu11值的比较不能使用&#x3D; !&#x3D;。需要使用is is not 分组查询（group by）1,分组查询语法 SELECT 字段列表 FROM 表名「WHERE分组前条件限定] GROUP BY分组字段名「HAVING分组后条件过滤]; 注意:分组之后,查询的字段为聚合函数和分组字段,查询其他字段无任何意义 where和having区别: 执行时机不一样: where是分组之前进行限定,不满足where条件,则不参与分组, 而having是分组之后对结果进行过滤。 可判断的条件不一样: where不能对聚合函数进行判断, having可以. 执行顺序: where &gt;聚合函数&gt; having 排序查询（order by）1,排序查询语法SELECT 字段列表 FROM 表名 ORDER BY 排序字段名1[排序方式1],排序字段名2 [排序方式2] .; 排序方式： ASC:升序排列(默认值) DESC:降序排列 注意:如果有多个排序条件,当前边的条件值一样时,才会根据第二条件进行排序 聚合函数1.概念:将一列数据作为一个整体,进行纵向计算。 2,聚合函数分类: 函散名 功能 count（列名） 统计数量一般选用不为nul的列 max（列名） 最大值 min（列名） 最小值 sun （列名） 求和 avg（列名) 平均值 3,聚合函数语法: SELECT 聚合函数名(列名) FROM表; 注意: null值不参与所有聚合函数教运算 分页查询(LIMIT)分页查询语法 SELECT字段列表FROM表名LINIT 起始索引,查询条目数; 起始索引:从0开始 计算公式:起始索引&#x3D;(当前页码-1) * 每页显示的条数 tips: 分页查询limit是MySQL数据库的方言 Oratle分页查询使用rownumber SQL Server分页查询使用top 起始索引 &#x3D;（当前页面-1）* 每页显示的条数约束约束的概念和分类1约束的概念约束是作用于表中列上的规则,用于限制加入表的数据 约束的存在保证了数据库中数据的正确性、有效性和完整性 2.约束的分类 约束名称 描述 关键字 非空约束 保证列中所有数据不能有null值 NOT NULL 唯一约束 保证列中所有数据各不相同 UNIQUE 主键约束 主键是一行数据的唯一标识,要求非空且唯一 PRIMARY KEY 检查约束 保证列中的值满足某一条件 CHECK 默认约束 保存数据时，未指定值则采用默认值 DEFAULT 外键约束 外键用来让两个表的数据之间建立链接,保证数据的一致性和完整性 FOREIGN KEY Tips: Mysql不支持检查约束 非空约束1.概念 非空约束用于保证列中所有数据不能有NULL值 2,语法 (1)添加约束 –创建表时添加非空约束 CREATE TABLE表名( 列名 数据类型 NOT NULL, –建完表后添加非空约束 ALTER TABLE表名MODIFY字段名数据类型NOT NULL (2)删除约束 ALTER TABLE 表名 MODIFY 字段名 数据类型; 唯一约束1,概念 唯一约束用于保证列中所有数据各不相同 2.语法 (1)添加约束 创建表时添加唯一约束 CREATE TABLE 表名( 列名 数据类型 UNIQUE [AUTO_INCREMENT] –AUTO-INCREMENT:当不指定值时自动增长 ); CREATE TABLE表名( 列名 数据类型, …. [CONSTRAINT] [约束名称] UNIQUE (列名) ); 进完表后添加唯一约束 ALTER TABLE名MODIFY字段型UNIQUE (2)删除约束- ALTER TABLE 表名 DROP INDEX字段名; 主键约束1.概念 主键是一行数据的唯一标识,要求非空且唯一 一张表只能有一个主键 2.语法 (1)添加约束 –创建表时添加主键约束 CREATE TABLE表名( 列名 数据类型 PRIMARY KEY [AUTO-INCREMENT])； CREATE TABLE 表名( 列名 数据类型 [CONSTRAINT] [约東名称] PRIMARY KEY(列名) )； –建完表后添加主键约束 ALTER TABLE 表名ADD PRIMARY KEV (字段名); (2)删除约束 ALTER TABLE 表名DROP PRIMARY KEY; 默认约束1.概念 保存数据时,未指定值则采用默认值 2.语法 (1)添加约束 –创建表时添加默认约束 CREATE TABLE 表名 列名 数据类型 DEFAULT 默认值,…); –建完表后添加默认约束 ALTER TABLE表名ALTER列名SET DEFAULT默认值; 2)删除约束 ALTER TABLE表名ALTER列名DROP DEFAULT; 外键约束1.概念外键用来让两个表的数据之间建立链接,保证数据的一致性和完整性 2．语法 (1)添加约束 –创建表时添加外键约束 CREATE TABLE 表名( 列名 数据类型, [CONSTRAINT] [外键名称] FOREIGN KEY(外键列名) REFERENCES主表(主表列名) –建完表后添加外键约束 ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES主表名称(主表列名称); (2)删除约束 ALTER TABLE表名DROP FOREIGN KEY外键名称; 数据库设计1,软件的研发步骤 2,数据库设计概念 数据库设计就是根据业务系统的具体需求,结合我们所选用的DBMS,为这个业务系统构造出最优的数据存储模型。 建立数据库中的表结构以及表与表之间的关联关系的过程。 有哪些表?表里有哪些字段?表和表之间有什么关系? 3.数据库设计的步骤 ①需求分析(数据是什么?数据具有哪些属性?数据与属性的特点是什么) ②逻辑分析(通过ER图对数据库进行逻辑建模,不需要考虑我们所选用的数据库管理系统) ③物理设计(根据数据库自身的特点把逻辑设计转换为物理设计) ④维护设计(1.对新的需求进行建表; 2.表优化) E-R图 表关系一对一: 如:用户和用户详情 一对一关系多用于表拆分,将一个实体中经常使用的字段放一张表, 不经常使用的字段放另一张表,用于提升查询性能 一对多(多对一): ​ 如:部门和员工 一个部门对应多个员工,一个员工对应一个部门 实现方式:在任意一方加入外键,关联另一方主键,并且设置外键为唯(UNIQUE) 多对多: 商品和订单 一个商品对应多个订单,一个订单包含多个商品 1实现方式:建立第三张中间表,中间表至少包含两个外键,分别关联两方主键 总结1,数据库设计设计什么? 有哪些表表里 有哪些字段 表和表之间是什么关系 2.表关系有哪几种? 一对一 一对多(多对一) 多对多 1.一对多实现方式 在多的一方建立外键关联一的一方主键 2.多对多实现方式 建立第三张中间表 中间表至少包含2个外键,分别关联双方主键 3.—对一实现方式 在任意一方建立外键,关联对方主键,并设置外键唯一 多表查询笛卡尔积:取A,B集合所有组合情况 多表查询:从多张表查询数据 连接查询 内连接: 相当于查询A B交集数据 外连接: 左外连接: 相当于查询A表所有数据和交集部分数据 右外连接:相当于查询B表所有数据和交集部分数据 子查询 内连接1,内连接查询语法 –隐式内连接 SELECT 字段列表 FROM 表1,表2…WHERE 条件; –显示内连接 SELECT 字段列表 FROM表1 [INNER] JOIN 表2 ON 条件; 内连接相当于查询AB交集数据 外连接1,外连接查询语法 –左外连接 SELECT 字段列表 FROM 表1 LEFT [OUTER] JQIN 表2 ON条件; –右外连接 SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON条件; 左外连接:相当于查询A表所有数据和交集部分数据 右外连接:相当于查询B表所有数据和交集部分数据 子查询1.子查询概念: 查询中嵌套查询,称嵌套查询为子查询 2.子查询根据查询结果不同,作用不同: 单行单列 多行单列 多行多列 1,子查询根据查询结果不同,作用不同: 单行单列:作为条件值,使用&#x3D;!&#x3D; &gt;&lt;等进行条件判断 SELECT 字段列表 FROM 表 WHERE 字段名 &#x3D; (子查询); 多行单列:作为条件值,使用in等关键字进行条件判断 SELECT 字段列表 FROM 表 WHERE 字段名 in (子查询); 多行多列:作为虚拟表 SELECT 字段列表 FROM (子查询) WHERE条件; 事务事务简介数据库的事务(Transaction)是一种机制、一个操作序列,包含了一组数据库操作命令 事务把所有的命令作为一个整体一起向系统提交或撤销操作请求,即这一组数据库命令要么同时成功,要么同时失败 事务是一个不可分割的工作逻辑单元 开启事务 START TRANSACTION; 或者 BEGIN; 提交事务COMMIT; 回滚事务ROLLBACK; 事务四大特征原子性(Atomicity) :事务是不可分割的最小操作单位,要么同时成功,要么同时失败 一致性(Consistency) :事务完成时,必须使所有的数据都保持一致状态 隔离性(lsolation) :多个事务之间,操作的可见性 持久性(Durability) :事务一旦提交或回滚,它对数据库中的数据的改变就是永久的 MySQL事务默认自动提交 –查看事务的默认提交方式 SELECT @@autocommit; – 1自动提交0手动提交 -修改事务提交方式 set @@autocommit &#x3D;0;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://2486125878.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://2486125878.github.io/tags/mysql/"}]},{"title":"‘web移动端’","slug":"‘web移动端’","date":"2024-03-13T08:53:33.000Z","updated":"2024-03-13T08:58:24.000Z","comments":true,"path":"2024/03/13/‘web移动端’/","permalink":"https://2486125878.github.io/2024/03/13/%E2%80%98web%E7%A7%BB%E5%8A%A8%E7%AB%AF%E2%80%99/","excerpt":"","text":"web移动端1.2手机屏幕现状移动端设备屏幕尺寸非常多,碎片化严重 Android设备有多种分辨率: 480x800, 480x854, 540x960, 720x1280 , 1080x1920等,还有传说中的2K , 4k屏。 近年来iPhone的碎片化也加剧了,其设备的主要分辨率有: 640x960,640x1136, 750x1334, 1242x2208等。 作为开发者无需关注这些分辨率,因为我们常用的尺寸单位是px. 1.4移动端调试方法1.4总结移动端浏览器我们主要对webkit内核进行兼容 我们现在开发的移动端主要针对手机端开发 现在移动端碎片化比较严重,分辨率和屏幕尺寸大小不一学 会用谷歌浏览器模拟手机界面以及调试 2.视口视口( viewport)就是浏览器显示页面内容 屏幕区域,视口可以分为布局视口、视觉视口和理想视口 2.1布局视口layout viewport一般移动设备的浏览器都默认设置了一个布局视口,用于解决早期的PC端页面在手机上显示的问题。 iOS, Android基本都将这个视口分辨率设置为9dapx ,所以PC上的网页大多都能在手机上呈现,只不 过元素看上去很小,一般默认可以通过手动缩放网页。——不适合了 2.2视觉视口visual viewport字面意思,它是用户正在看到的网站的区域。注意:是网站的区域。 我们可以通过缩放去操作视觉视口,恒不会影响布局视口,布局视口仍保持原来的宽度。 2.3理想视口ideal viewport为了使网站在移动端有最理想的浏览和阅读宽度而设定 理想视口,对设备来讲,是最理想的视口尺寸 需要手动添写meta视口标签通知浏览器操作 meta视口标签的主要目的:布局视口的宽度应该与理想视口的宽度一致,简单理解就是设备有多宽,我们布局的视口就多宽 乔布斯发布一般会用 2.4总结视口就是浏览器显示页面内容的屏幕区域 视口分为布局视口、视觉视口和理想视口 我们移动端布局想要的是理想视口就是手机机屏幕有多宽,我们的布局视口就有多宽 想要理想视口,我们需要给们的移动端页面添加meta视口标签 2.5 meta视口标签&lt;meta name&#x3D;”viewport” content&#x3D;”width-device-width, user-scalable-no, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0. minihum-scale&#x3D;1.0”&gt; 属性 解释说明 width 宽度设置的是viewport宽度,可以设置device-width特殊值 initial-scale 初始缩放比,大于0的数字 maximum-scale 最大缩放比,大于0的数字 minimum-scale 最小缩放比,大于0的数字 user-scalable 用户是否可以缩放, yes或no (1或0) 2.6标准的viewport设置视口宽度和设备保持一致 视口的默认缩放比例1.0 不允许用户自行缩放 最大允许的缩放比例1.0 最小允许的缩放比例1.0 3.二倍图3.1物理像素&amp;物理像素比物理像素点指的是屏幕显示的最小颗粒,是物理真实存在的。这是厂商在出厂时就设置好了,比如苹果6\\78是750*1334 我们开发时候的1px不是一定等于1个物理像素的 PC端页面, 1个px等于1个物理像素的,但是移动端就不尽相同 一个px的能显示的物理像素点的个数,称为物理像素比或屏幕像素比 PC端和早前的手机屏幕&#x2F;普通手机屏幕: 1CSS像素&#x3D; 1物理像素的 Retina (视网膜屏幕)是一种显示技术,可以将把更多的物理像素点压缩至一块屏幕里 从而达到更高的分辨率,并提高屏幕显示的细腻程度。 3.2多倍图对于一张50px*50px的图片,在手机Retina屏中打开,按照刚才的物理像素比会放大倍数,这样会造成图片模糊 在标准的viewport设置中,使用倍图来提高图片质量,解决在高清设备中的模糊问题 通常使用二倍图,因为iPhone 6\\78的影响,但是现在还存在3倍图4倍图的情况,这个看实际开发公司需求 背景图片注意缩放问题 &#x2F;在iphone8下面&#x2F; img{ &#x2F;原始图片100*100px&#x2F; *width: 50px; *height: 50px; ***}** .box{ &#x2F;原始图片100*100px&#x2F; background-size: 50px 50px; } 3.3背景缩放background-sizebackground-size属性规定背景图像的尺寸 background-size:背景图片宽度 背景图片高度; 单位: 长度 百分比 cover I contain; cover把背景图像扩展至足够大,以使背景图像完全覆盖背景区域。 contain把图像图像扩展至最大尺寸,以使其宽度和高度完全适应内容区域 4.移动端开发选择4.2单独移动端页面(主流)“通常情况下,网址域名前面加m(mobile)可以打开移动端。通过判断设备,如果是移动设备打开,则跳到移动端页面。 4.3响应式兼容PC移动端三星电子盲网: www.samsung.com/cn/ ,通过判断屏幕宽度来改变样式,以适应不同终端。 缺点:制作麻烦,需要花很大精力去调兼容性问题 4.4总结现在市场常见的移动端开发有单独制作移动端页面和响应式页面两种方案 现在市场主流的选择还是单独制作移动端页面 5移动端技术解决方案5.1移动端浏览器移动端浏览器基本以webkit内核为主,因此我们就考虑webkit兼容性问题 我们可以放心使用H5标签和CSS3样式。 同时我们浏览器的私梅前缀我们只需要考虑添加webkit即可 5.2 CsS初始化normalize.css移动端CSS初始化推荐使用normalize.css&#x2F; Normalize.css :保护了有价值的默认值 Normalize.css :修复了浏览器的bug Normalize.css :是模换化的 Normalize.css :拥有详细的文档 官网地址: http://necolas.github.io/normalize.css/ 5.3 CSS3盒子模型box-sizing传统模式宽度计算:盒子的宽度&#x3D; CSS中设置的width + border + padding CSS3盒子模型: 盒子的宽度&#x3D; CSS中设置的宽度width里i包含了border和padding 也就是说,我们的CSS3中的盒子模型, padding和border不会撑大盒子了 CSS3盒子模型 box-sizing: border-box; &#x2F;传统盒子模型&#x2F; box-sizing: content-box; 传统or CSS3盒子模型? 移动端可以全部CSS3盒子模型 PC端如果完全需要兼容,我们就用传统模式,如果不考虑兼容性,我们就选择CSS3盒子模型 5.4特殊样式&#x2F;CSS3盒子模型&#x2F; box-sizing: border-box; -webkit-box-sizing: oorder-box; &#x2F;点击高亮我们需要清除清除 设置为transparent完成透明 -webkit-tap-highlight-color: transparent; &#x2F;在移动端浏览箭默认的外观在ios上加上这个属性才能给按钮和输入框自定义样式&#x2F; -webkit-appearance: none; &#x2F;禁用长按页面时的弹出菜单&#x2F; img, a {-webkit-touch-callout: none; } 6.移动端常见布局移动端技术选型移动端布屋和前我们学习的PC端有所区别: 1·单独制作移动端页面(主流) 流式布局（百分比布局） flex弹性布局(强烈推荐) lesstrem+媒体查询布局 混合布局 2,响应式页面兼容移动端(其次) 媒体查询 bootstarp 6.1流式布局(百分比布局)流式布局,就是百分比布局,也称非固定像索布局。 通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸宿,不受固定像素的限制,内容向两侧填充。 流式布局方式是移动web开发使用的比较常见的布局方式 max-width最大宽度(max-height最大高度) min-width 最小宽度(min-height最小高度) 4．常用初始化样式body { margin: 0 auto; min-width: 320px; max-width: 640px; background: #fff; font-size: 14px; font-family:-apple-system, Helvetica, sans-serif; line-height: 1.5; color: #666; 5.二倍精灵图做法在firework里面把精灵图等比例缩放为原来的一半 之后根据大小测量坐标 注意代码里面background-sizet要写:精灵图原来宽度的一半 6.图片格式DPG图片压缩技术 京东自主研发推出DPG图片压缩技术,经测试该技术,可直接节省用户近50%的浏览流量,极大的提升了用户的网页打开速度。能够兼容jpeg,实现全平台、全部浏览器的兼容支持,经过内部和外部上万张图片的人眼浏览测试后发现,压缩后的图片和webp的清晰度对比没有差距。 webp图片格式 谷歌开发的一种自在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2&#x2F;3并能节省大量的服务器宽带资源和数据空间 1.flex布局体验1.1传统布局与flex布局传统布局兼容性好 布局繁琐 局限性,不能再移动端很好的布局 flex弹性布局操作方便,布局极为简单,移动端应用很广泛 PC端浏览器支持情况较差 IE 11或更低版本,不支持或仅部分支持 建议: 1,如果是PC端页面布局,我们还是传统布局。 2.如果是移动端或者不考虑兼容性问题的PC端页面布局,我们还是使用flex弹性布局 2.1布局原理 flex是flexible Box的缩写,意为弹性布局”,用来为盒状模型提供最大的灵活性,任何一个容器都可以指定为flex布局。 当我们为父盒子设为flex布局以后,子元素的float, clear和vertical-align属性将失效。 伸缩布局&#x3D;弹性布局&#x3D;伸缩盒布局&#x3D;弹性盒布局flex布局 采用Flex布局的元素,称为Flex容器( flex container ) ,简称”容器.它的所有子元素自动成为容器成员,称为Flex项目(flexitem ) ,简称”项目”。 体验中div就是flex父容器。 体验中span就是子容器flex项目 子容器可以横向排列也可以纵向排列 总结flex布局原理: 就是通过给父盒子添flex属性,f来控制子盒子的位置和排列方式 3.1常见父项属性以下由6个属性是对父元素设置的 flex-direction :设置主轴的方向 justify-content :设置主轴上的子元素排列方式 flex-wrap:设置子元素是否换行 align-content :设置侧轴上的子元素的排列方式(多行) align-items :设置侧轴上的子元素排列方式(单行) flex-flow :复合属性,相当于同时设置了flex-direction和flex-wrap 3.2 flex-direction设置主轴的方向1,主轴与侧轴 在flex布局中,是分为主轴和侧轴两个方向,同样的叫法有:行和列、x轴和y轴 默认主轴方向就是x轴方向,水平向右 默认侧轴方向就是y轴方向,水平向下 2,属性值 flex-direction属性决定主轴的方向(即项目的排列方向) 注意:主轴和侧轴是会变化的,就看flex-direction设置谁为主轴,剩下的就是侧轴。而我们的子元素是跟着主轴来排列的 属性值 说明 row 默认值从左到右 row-reverse 从右到左 column 从上到下 column-reverse 从下到上 3.3 justify-content设置主轴上的子元素排列方式justify-content属性定义了项目在主轴上的对齐方式 注意:使用这个属性之前一定要确定好主轴是哪个 属性值 说明 flex-start 默认值从头部开始如果主轴是x轴,则从左到右 flex-end 从尾部开始排列 center 在主轴居中对齐(如果主轴是x轴则水平居中) space-around 平分剩余空间 space-between 先两边贴边再平分剩余空间(重要) 3.4 flex-wrap设置子元素是否换行默认情况下,项目都排在一条线(又称”轴线” )上。 flex-wrap属性定义, flex布局中默认是不换行的。 属性值 说明 nowrap 默认值,不换行 wrap 换行 3.5 align-items设置侧轴上的子元素排列方式(单行)该属性是控制子项在侧轴(默认是y轴)上的排列方式在子项为单项的时候使用 属性值 说明 flex-start 从上到下 lex-end 从下到上 center 挤在一起居中(垂直居中) stretch 拉伸(默认值) 3.6 align-content设置侧轴上的子元素的排列方式(多行)设置子项在侧轴上的排列方式并且只能用于子项出现换行的情况(多行) ,在单行下是没有效果的。 属性值 说明 flex-start 默认值在侧轴的头部开始排列 flex-end 在侧轴的尾部开始排列 center 在侧轴中间显示 space-around 子项在侧轴平分剩余空间 space-between 子项在侧轴先分布在两头,再平分剩余空间 stretch 设置子项元素高度平分父元素高度 3.6 align-content和align-items区别align-items适用于单行情况下,只有上对齐、下对齐、居中和拉伸 align-content适应于换行(多行)的情况下(单行情况下无效) ,可以设置上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值 总结就是单行找align-items多行找align-content 3.7 flex-flowflex-flow属性是flex-direction和flex-wrap属性的复合属性 flex-flow: row wrap; flex-direction :设置主轴的方向 justify-content :设置主轴上的子元素排列方式 flex-wrap:设置子元素是否换行 align-content :设置侧轴上的子元素的排列方式(多行) align-items :设置侧轴上的子元素排列方式(单行) flex-flow :复合属性,相当于同时设置了flex-direction和flex-wrap 4.flex布局子项常见属性flex子项目占的份数align-self控制子项自己在侧轴的排列方式 order属性定义子项的排列顺序(前后顺序) 4.1 flex属性flex属性定义子项目分配剩余空间,用flex来表示占多少份数。 .item{ ​ flex: ; &#x2F; default 0&#x2F;** ） 4.2 align-self控制子项自己在侧轴上的排列方式align-self属性允许单个项目有与其他项目不一样的对齐方式,可覆盖align-items属性。 默认值为auto,表示继承父元素的align-items属性,如果没有父元素,则等同于stretch. 4.3 order属性定义项目的排列顺序数值越小,排列越靠前,默认为0。 注意:和z-index不一样。 7.背景线性渐变语法1 : background: linear-gradient (起始方向,颜色1,颜色2, …); background: -webkit-linear-gradient(left, red , blue); background: -webkit-linear-gradient(left top, red , blue); 背景渐变必须添加浏览器私有前缀 起始方向可以是:方位名词或者度数,如果省略默认就是top 1.rem基础rem单位 rem (root em)是一个相对单位,类似于em , em是父元素字体大小。 不同的是rem的基准是相对于htm元素的字体大小。 比如,根元素(html)设置font-size&#x3D;12px;非根元素设置width:2rem;则换成px表示就是24px. 2.1什么是媒体查询媒体查询( Media Query )是CSS3语法。 使用@media查询,可以针对不同的媒体类型定义不同的样式 @media可以针对不同的屏幕尺寸设置不同的样式” 当你重置浏览器大小的过程中,页面也会根据浏览器的宽度和高度重新渲染页面 目前针对很多苹果手机、Android手机,平板等设备都用得到多媒体查询 2.2语法规范@media mediatype and I not I only (media feature) { ​ ss-code; } 用@media开头注意@符号 mediatype媒体类型, 关键字and not only media feature媒体特性必须有小括号包含 1.mediatype查询类型 将不同的终端设备划分成不同的类型,称为媒体类型 值 解释说明 all 用于所有设备 print 用于打印机和打印预览 scree 用于电脑屏幕,平板电脑,智能手机等 2.关键字 关键字将媒体类型或多个媒体特性连接到一起做为媒体查询的条件。 and :可以将多个媒体特性连接到一起,相当于”目”的意思。 not :排除某个媒体类型,相当于“非”的意思,可以省略。 only :指定某个特定的媒体类型,可以省略。 3,媒体特性 每种媒体类型都具体各自不同的特性,根据不同媒体类型的媒体特性设置不同的展示风格。我们暂且了解三个。注意他们要加小括号包含 值 解释说明 width 定义输出设备中页面可见区域的宽度 min-width 定义输出设备中页面最小可见区域密度 max-width 定义输出设备中页面最大可见区域宽度 注意:为了防止混乱,媒体查询我们要按照从小到大或者从大到小的顺序来写,但是我们最喜欢的还是从小到大来写,这样代码更简洁 2.3媒体查询+rem实现元素动态大小变化rem单位是跟着html来走的,有了rem页面元素可以设置不同大小尺寸 媒体查询可以根据不同设备宽度来修改样式 媒体查询+rem就可以实现不同设备宽度,实现页面元素大小的动态变化 2.4引入资源(理解)当样式比较繁多的时候,我们可以针对不同的媒体使用不同stylesheets (样式表) 原理,就是直接在link中判断设备的尺寸,然后引用不同的css文件。 1,语法规范 3.1维护css的弊端CSS是一门非程序式语言,没有变量、函数、SCOPE (作用域)等概念。 CSs需要书写大量看似没有逻辑的代码, CSS冗余度是比较高的。 不方便维护度扩展,不利于复用。 Css没有很好的计算能力非前端开发工程师来讲,往往会因为缺少CsS编写经验而很难写出组织良好且易于维护的CSs代码项目。 3.2 Less介绍Less (Leaner style Sheets的缩写)是一门css扩展语言,也成为CSS预处理器。 做为CSS的一种形式的扩展,它并没有减少CSS的功能,而是在现有的CSs语法上,为CSS加入程序式语言的特性。 它在CSS的语法基础之上,引入了变量, Mixin (混入) ,运算以及函数等功能,大大简化了CSS的编写并且降低了CSS的维护成本,就像它的名称所说的那样, Less可以让我们用更少的代码做更多的事情。 Less中文网址: htt:&#x2F;&#x2F;lesscss.cnz 常见的CSS预处理器: Sass, Less. Stylus 一句话: Less是一门css预处理语言,它扩展了CSS的动态特性。 Less使用我们首先新建一个后缀名为less的文件,在这个less文件里面书写lessi语句。 Less 变量 Less 编译 Less嵌套 Less运算 变量是指没有固定的值,可以改变的。因为我们CSS中的一些颜色和数值等经常使用。 @变量名:值； 变量命名规范必须有@为前缀 不能包含持殊字符 不能以数字开头 大小写敏感 3.5 Less编译本质上, Less包含一套自定义的语法及一个解析器,用户根据这些语法定义自己的样式规则,这些规则最终会通过解析器,编译生成对应的CSS文件。 所以,我们需要把我们的less文件,编译生成为css文件,这样我们的html页面才能使用。 vocode Less插件 Easy LESS插件用来把less件编译为css文件 安装完毕插件,重新加哦下vscode.只要保存一下Less文件,会自动生成CSS文件。 3.6 Less嵌套我们经常用到选择器的嵌套 #header .logo{ ​ width: 300px; ​ } Less嵌套写法 #header{ ​ .logo{ ​ width: 300px; ​ } } 如果遇见(交集 伪类 伪元素选择器) 内层选择器的前面没&amp;符号，则它被解析为父选择器的后代; 如果有&amp;符号,它就被解析为父元素自身或父元素的伪类。 a:hover{ ​ color: red; } Less嵌套写法 a{ ​ &amp;: hover{ ​ color: red; ​ } } 3.7 Less运算★任何数字、颜色或者变呈都可以参与运算。就是Less提供了加(+)、减(-)、乘(*)、除(&#x2F;)算术运算。 less 里面写 @witdh: (10px+5;) div { border: @witdh solid red; 生成的css div{ border: 15px solid red; } less甚至还可以这样 *width: (@width + 5) 2; 注意： 乘号(*)和除号(&#x2F;)的写法 运算符中间左右有个空格隔开1px+5 对于两个不同的单位的值2间的运算,运算结果的值取第一个值的单位 如果两个值之间只有一个值有单位,则运算结果就取该单位 4.1 rem实际开发适配方案1按照设计稿与设备宽度的比例,动态计算并设置html根标签的font-size大小; (媒体查询) 2CSS中,设计稿元素的竞、高、相对位置等取值,按照同等比例换算为rem为单位的值; 4.2 rem适配方案技术使用(市场主流)技术方案1 技术方案2 (推荐) less flexible.js 媒体查询 rem rem 总结: 1.两种方案现在都存在。 2,方案2更简单,现阶段大家无需了解里面的js代码。 1,设计稿常见尺寸宽度 设备 常见宽度 iphone 4.5 640px phone 678 750px Android 常见320px. 360px, 375px, 384px, 400px, 414px 500px,720px大部分4.7~5寸的安卓设备为720px 般情况下,我们以一套或两套效果图适应大部分的屏幕,放弃极端屏或对其优雅降级,牺牲一些效果现在基本以750为准。 2,动态设置html标签font-size大小 1假设设计稿是750px ②假设我们把整个屏幕划分为15等份(划分标准不一可以是20份也可以是10等份) ③每份作为html字体大小,这里就是50px 4那么在320px设备的时候,字体大小为320&#x2F;15就是21.33px ⑤用我们页面元素的大小除以不同的html字体大小会发现他们比例还是相同的。 6比如我们以750为标准设计稿 7一个100100像素的页面元素在750屏幕下,就是100&#x2F;50转换为rem是2rem2rem比例是1比1 8 .320屏幕下, html字体大小为21.33则2rem &#x3D; 42.66px此时宽和高都是42.66但是宽和高的比例还是1比1 9.但是已经能实现不同屏幕下页面元素盒子等比例缩放的效果 3元素大小取值方法1最后的公式:页面元素的rem值&#x3D;页面元素伯(px) &#x2F; (屏幕竞度&#x2F;划分的份数) ②屏幕宽度&#x2F;划分的份数就是html font-size的大小) 或者:页面元素的rem值&#x3D;页面元素值(px) &#x2F; html font-size字体大小 1新建index.less 这里面写首页的样式 2.将刚才设置好的common.less 引入到index.less里面语法如下: &#x2F;&#x2F;在index.less中导入 common.less文件 @import “common” 6.body样式body { ​ min-width: 320px; ​ width: 15rem； ​ margin: o auto; ​ line-height: 1.5; ​ font-family: Arial, Helvetica; ​ background: #F2F2F2； } 1.2响应式布局容器响应式需要一个父级做为布局容器,来配合子级元素来实现变化效果。 原理就是在不同屏幕下,通过媒体查询来改变这个布局容器的大小,再改变里面子元素的排列方式和大小,从而实现不同屏幕下,看到不同的页面布码和样式变化。 2.1 Bootstrap简介Bootstrap来自Twitter (推特) ,是目前最受欢迎的前端框架。 Bootstrap是基于HTML, CSS和JAVASCRIPT的,它简洁灵活,使得Web开发更加快捷。 中文官网: http://www.bootess.com/ 官网: http://gethootstrap.com/ 推荐使用: http://bootstrap.css88.com/ 框架:顾名思义就是一套架构,它有一套比较完整的网页功能解决方案,而且控制权在框架本身,有预制样式库、组件和插件。使用者要按照框架所规定的某种规范进行开发。 2.1 Bootstrap简介1.优点 标准化的html+cs编码规范 提供了一套简洁、直观强悍的组件 有自己的生态圈，不断的更新送代 让开发更简单,提高了开发的效率 2.版本 2xx:停止维护,兼容性好,代码不够管洁,功能不够完善。 3.xx:目前使用最多稳定,但是放弃了IE6-IE7,对IE8支持但是界面效果不好,偏向用于开发响应式布局移动设备优先的WEB项目。 4.xx :最新版,目前还不是很流行 2.2 Bootstrap使用在现阶段我们还没有接触S相关课程,所以我们只考虑使用它的样式库。 控制权在框架本身,使用者要按照框架所规定的某种规范进行开发。 Bootstrap使用四步曲: 1,创建文件夹结构2.创建html骨架结构3.引入相关样式文件4,书写内容 4.书写内容 直接拿Bootstrap预先定义好的样式来使用修改Bootstrap原来的样式, 注意权重问题学好Bootstrap的关键在于知道它定义了哪些样式, 以及这些样式能实现什么样的效果 2.3布局容器Bootstrap需要为页面内容和栅格系统包裹它提供了两个作此用处的类。containe容器, Bootstarp预先定义好了这个类, 叫.container 1.container类 响应式布局的容器固定宽度 大屏(&gt;&#x3D;1200px)宽度定为1170px 中屏（&gt;&#x3D;992px)宽度定为970px 小屏(&gt;&#x3D;768px)宽度定为750px 超小屏(100%) 2.container-fluid类 流式布局容器百分百宽度 占据全部视口( viewport )的容器。 适合于单独做移动端开发 3.1栅格系统简介栅格系统英文为”gridsystems”,也有人翻译为”网格系统” ,它是指将页面布局划分为等宽的列,然后通过列数的定义来模块化页面布局。 Bootstrap提供了一套响应式、移动设备优先的流式栅格系统,随着屏幕或视口(viewport )尺寸的增加系统会自动分为最多12列。 Bootstrap里面container宽度是固定的,但是不同屏幕下, container的宽度不同,我们再把container划分为12等份 3.2栅格选项参数栅格系统用于通过一系列的行( row )与列(column )的组合来创建页面布局,你的内容就可以放入这些创建好的布局中。 ​ 超小屏幕(手机) 小屏设备(平板) 中等屏幕(桌面显示器) 宽屏设备(大桌面显示器) &lt;768px &gt;&#x3D;768px &gt;&#x3D;992px &gt;&#x3D;1200px .container最大宽度 自动(100%) 750px 970px 1170рх 类前缀 .col-xs- col-sm- .col-md- .col-lg- 列(column)数 12 行(row )必须放到container布局容器里面 我们实现列的平均划分需要给列添加类前缀 xs-extra small:超小; sm-small:小; md-medium :中等; Ig-large :大; 列( column)大于12,多余的”列( column )”所在的元素将被作为一个整体另起一行排列 每一列默认有左右15像素的padding 可以同时为一列指定多个设备的类名,以便划分不同份数例如class&#x3D;”col-md-4 col-sm-6” 3.3列嵌套**栅格系统内置的栅格系统将内容再次嵌套。简单理解就是一个列内再分成若干份小列。我们可以通过添加一个新的.row元素和一系列.col-sm-元素到已经存在的.col-sm-元素内。 3.4列偏移*使用.col-md-offset-类可以将列向右侧偏移。这些类实际是通过使用选择器为当前元素增加了左侧的边距(margin ).* 3.6响应式工具为了加快对移动设备友好的页面开发工作,利用媒体查询功能,并使用这些工具类可以方便的针对不同设备展示或隐藏页面内容。 类名 超小屏 小屏 中屏 大屏 .hidden-xs 隐藏 可见 可见 可见 .hidden-sm 可见 隐藏 可见 可见 .hidden-md 可见 可见 隐藏 可见 .hidden-lg 可见 可见 可见 隐藏 与之相反的,是visible-xs visible-sm visible-md visible-lg是显示某个页面内容 一、vw和vh1移动端布局移动端布局—flex布局为了实现可以适配移动端,页面元素可以宽度和高度等比例缩放 需要移动端适配有如下方案: rem市场比较常见: 将来(马上)趋势 1,需要不断修改html文字大小 1,省去各种判断和修改 2,需要媒体查询media 代表：b站.. 3.需要flexible.js 2.vw&#x2F;vh是什么vw&#x2F;vh是一个相对单位(类似em和rem相对单位), vw是: viewport width 视口宽度单位 vh是: viewport height 视口高度单位 相对视口的尺寸计算结果 1vw&#x3D;1&#x2F;100视口宽度 1vh&#x3D;1&#x2F;100视口高度 例如: 当前屏幕视口是375像素,则1ww就是3.75像素,如果当前屏幕视口为414,则1vw 注意事项 和百分比有区别的,百分比是相对于父元素来说的,而vw和vh总是针对于当前视口来说的。 vw&#x2F;vh&#x3D;需要大小元素除以（页面大小除以屏幕比例1&#x2F;100）","categories":[{"name":"前端","slug":"前端","permalink":"https://2486125878.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"https://2486125878.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}]},{"title":"‘HTML标签’","slug":"‘HTML标签’","date":"2024-03-13T08:53:18.000Z","updated":"2024-03-13T08:56:44.000Z","comments":true,"path":"2024/03/13/‘HTML标签’/","permalink":"https://2486125878.github.io/2024/03/13/%E2%80%98HTML%E6%A0%87%E7%AD%BE%E2%80%99/","excerpt":"","text":"HTML标签head的缩写意为头部、标题 标题标签-作为标题使用依据重要性递减一个标题独占一行 段落标签可以将整个网页分为若干个段落文本在一个段落中会根据浏览器窗口的大小自动换行 换行标签 文本格式化标签文字加粗&amp;&amp; 文字倾斜&amp;&amp; 删除线&amp;&amp; 下划线&amp;&amp; 建议使用前面一组的标签 div和span标签1.和是没有语义的，它们就是一个盒子，用来装内容的 2.一行只能放一个盒子独占一行 3.一行可以放多个盒子 图像标签和路径图像标签 src是标签的必须属性的用于指定图像文件的路径和文件名 alt文本属性替换文本，图片不能显示的文字 title文本属性提示文本，鼠标放到图片上，显示的文字 width像素属性设置图像宽度 height像素属性设置图像高度 border像素属性设置图像的边框粗细 属性不分先后但是属性和属性之间要用空格分开 相对路径与绝对路径同一级路径之间写图像名称加后缀名 下一级路径&#x2F;图像路径 上一级路径..&#x2F;图像路径 绝对路径:是指目录下的绝对位置,直接到达目标位置,通常是从盘符开始的路径。 超链接标签标签用于定义超链接，作用从一个页面链接到另一个页面 属性href指定链接目标地址 target属性打开方式_self为默认值，_blank为在新窗口打开方式 链接种类：外部链接http&#x2F;&#x2F;www.baidu.com、内部链接直接写html名称、空链接#、下载链接地址里是一个文件或者一个压缩包会下载这个文件、网页元素链接-文本表格图片音频视频等、锚点链接点击链接,可以快速定位到页面中的某个位置, 在链接文本的href属性中,设置属性值为#名字的形式,如&lt;ahref&#x3D;”#two”&gt;第2集 找到目标位置标签,里面添加一个id属性&#x3D;刚才的名字,如: 第2集介紹 HTML注释和特殊字符html中注释快捷键ctrl+&#x2F; 空格符&amp;nbsp； 小于号&amp;it； 大于号&amp;gt； &amp;和号&amp;amp； 人民币&amp;yen； 版权&amp;copy； 注册商标&amp;reg； 摄氏度&amp;deg； 正负号&amp;plusmn； 乘号&amp;times； 除号&amp;divide； 平方2&amp;sup2； 立方3&amp;sup3； 表格标签表格展示美化后台数据 1.表格标签 2.定义表格中的行必须放在表格标签中 3.用于定义表格中的单元格内容必须嵌套在标签中 4表头单元格标签内容加粗并居中 5 表格结构标签分为标签头部r区域标签主体区域和前面不同区域更大放在最外边 5.1. 6.合并单元格方式： 1.跨行合并：rowspan&#x3D;“合并单元格的个数” 2.跨列合并：colspan&#x3D;“合并单元格的个数” 7.目标单元格：1.跨行：最上侧单元格为目标单元格写合并代码 2.跨列：最左侧单元格为目标单元格写合并代码 合并后删除多余单元格代码 属性名 属性值 描述 align left, center, right 规定表格相对周围元素的对齐方式。 border 1或”” 规定表格单元是否拥有边框,默认为” “,表示没有边框. cellpadding 像素值 规定单元边沿与其内容之间的空白,默认1像素。 cellspacing 像素值 规定单元格之间的空白,默认2像素。 width 像素值象素值像素值或百分比 规定表格的宽度。 列表标签列表分为三大类:无序列表、有序列表、自定义列表 无序列表：可放任何元素内容标签 有序列表：可放任何元素内容标签 自定义列表： 1.和之间只能放不能放其他 表单标签在HTML中一个完整的表单通常由表单域、表单控件（也称为表单元素）和提示信息3个部分构成 表单域是一个包含表单元素的区域 1.标签用于定义表单域，以实现用户信息的收集和传递把信息提交给服务器 2.表单数据 表单控件（元素）1.input输入表单元素 1.1.标签用于绑定一个表单元素当点击标签内文本时浏览器自动将焦点转到对应表单元素上增加用户体验 男 男 2.select下拉表单元素 2.1. 选项1 选项2 ​ 火星 3.textarea文本域元素 标签是用于定义多行文本输入的控件 3.15131312135151654555555555555555555 CSS样式1. 颜色：color：red； 字体大小：font-size:12px;&#x2F;&#x2F;属性加属性值&#x3D;键值对&#x2F;&#x2F;以分号结束 一、样式格式书写： 1紧凑格式： h1{color:deeppink; font-size:20px} 2展开格式 h1{ ​ color:pink; ​ font-size:20px; } 强烈推荐展开型格式 二、格式大小写 推荐全部使用小写字母，特殊情况除外。 三、空格规范 属性值前面，冒号后面，保留一个空格 选择器（标签）和大括号中间保留空格 css基础选择器选择器根据不同需求把不同的标签选出来这就是选择器的作用，就是选择标签用的 做了两件事：1选对人2做对事 选择器分类分为基础选择器和复合选择器两大类 基础选择器1.基础选择器是由单个选择器组成的 2.基础选择器又包括：标签选择器、类选择器、id选择器和通配符选择器 1.标签选择器（元素选择器）：是指用html标签作为选择器，按标签名称分类，为页面中某一类标签指定统一的css样式 作用：可以把一类标签选出比如标签和所有的标签 优点：能快速为页面中的同类型的标签统一设置样式 缺点：不能设计差异化样式。只能选择全部的当前标签 2.类选择器-多类名：可以给一个标签指定多个类名，从而达到更多的选择目的，一个标签有多个名字 **.red {** ​ **width:200px;** ​ **height:100px;** ​ **backgroud-color:red;** **}** **.green {** ​ **width:100px;** ​ **height:100px;** ​ **backgroud-color:green;** **}** **** 1.红色 1,绿色 1.红色 一、多类名使用方法： 1.亚瑟 在标签class属性中写多个类名 多个类名中间必须用空格分开 这个标签就可以分别具有这些类名的样式 二、多类名开发中使用场景 可以把一些标签元素相同的样式（共同的部分）放在一个类里面 这些标签都可以调用这个公共的类，然后在调用自己独有的类 从而节省css代码，统一修改非常方便 3.id选择器：可以为标有特定id的HTML元素指定特定的样式 HTML元素以id属性来设置id选择器，css中id选择器以“#”来定义 #id名{ ​ 属性1：属性值1； ​ …… } 样式#定义，结构id调用，只能调用一次，别人切勿使用 id选择器和类选择器的区别： 1、类选择器好比人名，一个人可以有多个名字，同一个名字可以被多个人使用 2、id选择器好比身份证号码全中国是唯一的不得重复 3、id选择器和类选择器最大不同在于使用次数上 4、类选择器在修改样式中用的最多，id选择器一般用于页面唯一性的元素上，经常和javascript搭配使用 3、通配符选择器：通配符选择器使用“*”定义他表示选取页面中所有元素 ***{** ​ 属性1：属性值1； ​ ……… } 通配符选择器不需要调用，自动就给所有的元素使用样式，特殊情况使用如下 ***{** ​ margin:0; ​ padding:0; } 基础选择器总结基础选择器 作用 特点 使用情况 用法 标签选择器 可以选出所有相同的标签, 不能差异化选择 较多 p{ color: red;} ​ 比如p。 类选择器 可以选出1个或者多个标签 可以根据需求选择 非常多 .nav { color: red;) id选择器 一次只能选择1个标签 ID属性只能在每个HTML 一般和js搭 配 #nav {color:red;} *通配符选择器 选择所有的标签器- 选择的太多,有部分不需要 特殊情况用 (color: red) css字体属性定义字体系列 ：font-family:”微软雅黑”；font-family: ‘ microsoft Yahei ’ , tahoma，arial, ‘Hiragino Sans GB’；依次往后找字体 提倡写英文多个字体用英文逗号分隔尽量使用系统默认自带字体保证用户的浏览器中都能正确显示 字体大小：font-size:20px; px（像素）：大小是网页最常见单位 谷歌浏览器默认文字大小为16px 标题标签特殊需要单独指定文字大小 不同浏览器可能默认显示字号大小不一致尽量给一个明确值大小，不要默认大小 可以给body指定整个页面文字的大小 字体粗细：font-weight：normal（400等同于normal 不加粗）&#x2F;bold&#x2F;bolder&#x2F;数值（数值不跟单位,等价bold加粗&#x2F; lighter（细体）； 实际开发中提倡使用数字标识加粗或变细 文字样式文本风格：font-style：normal（正常）&#x2F;italic（斜体）； 平时很少给文字加倾斜体，反而要给倾斜体标签（em,i）改为不倾斜字体 字体复合属性符合属性：简写方式顺序不能改变各属性用空格隔开 不需要的属性可以省略，但必须保留font-size和font-family属性否则font属性将不起作用 div { ​ font：font-style font-weight font-size&#x2F;line-height font-family； ​ font：italic 700 16px&#x2F;20px ‘Microsoft Yahei ’; ​ } 字体属性总结属性 表示 注意点 font-size 字号 我们通常用的单位是px像素,一定要跟上单位 font-family 字体 实际工作中按照团队约定来写字体 font-weight 字体 粗细记住加粗是700或者bold不加粗是normal或者400记住数字不要跟单位 font-style 字体 样式记住倾斜是italic 不倾斜是normal工作中我们最常用normal font 字体连写 1,字体连写是有顺序的不能随意换位置2.其中字号和字体必须同时出现 文本属性文本属性可定义文本的外观比如文本颜色、对齐文本、文本缩进、行间距等 color属性用于定义文本颜色 表示 属性值 预定义的颜色值 red, green, blue,还有我们的御用色pink 十六进制 #FF0000, FF6600, #29D794 RGB代码 rgb(255,0.0)或rgb(100%,0%,0%) 开发中最常用的是十六进制 对齐文本本质是让h1中的文字水平居中对齐 text-align属性用于设置元素内文本内部的水平对齐方式 属性值 解释 left 左对齐(默认值) right 右对齐 center 居中对齐 装饰文本text-decoration属性规定添加到文本的修饰。可以给文本添加下划线、删除线、上划线等。 属性值 描述 none 默认。没有装饰线(最常用) underline 下划线。链接a自带下划线(常用) overline 上划线。（几乎不用) line-through 删除线。(不常用) 文本缩进text-indent属性用来指定文本的第一行的缩进，通常是将段落的首行缩进 p{ ​ 首行缩进可以未负值，20px为一个字符距离 ​ text-indent:40px; } p{ ​ text-indent：2em；&#x2F;&#x2F;缩进2个文字大小的距离不管字体如何改变 } em是一个相对单位，就是当前元素1个文字的大小，如果当前元素没有设置大小，则会按照父元素的1个文字大小 行间距line-height属性设置用于设置行间的距离（行高）可以控制文字行与行之间的距离 行间距包含：上间距、文本高度、下间距 p{ ​ line-height：26px；上间距5px、+文本高度16px、+下间距5px&#x3D;26px } 量行高：从第一行的最下边量到第二行的最下边 文本属性总结属性 表示 注意点 color 文本颜色 我们通常用十六进制比如而且是简写形式#fff text-align 文本对齐 可以设定文字水平的对齐方式 text-indent 文本缩进 通常我们用于段落首行缩进2个字的距离text-indent: 2em; text-decoration 文本修饰 记住添加下线underline取消下划线none line-height 行高 控制行与行之间的距离 CSS的引入方式css的三种样式表1、内部样式表（内联样式表）是写到html页面内部，是将所有的css代码抽取出来，单独放在一个标签中 1、 div{ color:red; font-size:12px; } 1、标签理论上可以放到HTML文档的任何地方，但一般会放在文档的标签中 1、通过此种方式，可以方便控制当前整个页面中的元素样式设置 1、代码结构清晰，但是没有实现结构与样式完全分离 2、行内样式表（内联样式表）是在元素标签内部的style属性中设定css样式。适合于修改简单样式 2、23432423 2、style其实就是标签的属性 2、在双引号中间，写法要符合css规范 2、可以控制当前的标签设置样式 3、外部样式表：实际开发都是外部样式表，适合于样式比较多的情况，核心是样式单独写到css文件中，之后把css文件引入到HTML页面中使用，通常也被称为外链式或链接式引入 3、第一步新建一个后缀名为.css的样式文件，第二步在HTML页面中使用标签引入css文件 3、 属性 作用 rel 定义当前文档与被链接文档之间的关系,在这里需要指定为”stylesheet”,表示被链接的文档是个样式表文件。 href 定义所链接外部样式表文件的URL,可以是相对路径,也可以是绝对路径。 css引入方式总结样式表 优点 缺点 使用情况 范围控制 行内样式表 书写方便,权重高 结构样式混写 较少 控制一个标签 内部样式表 部分结构和样式相分离 没有彻底分离 较多 控制一个页面 外部样式表 完全实现结构和样式相分离 需要引入 最多,吐血推荐 控制多个页面 Chrome调试工具测试、排错、调试 1.使用调试工具 Ctrl+滚轮可以放大开发者工具代码大小。 左边是HTML元素结构,右边是CSs样式。 右边CSS样式可以改动数值(左右箭头或者直接输入)和查看颜色。 Ctrl+0复原浏览器大小。 如果点击元素,发现右侧没有样式引入,极有可能是类名或者样式引入错误。 如果有样式,但是样式前面有黄色叹号提示,则是样式属性书写错误。 css第二部分内容emmet语法emmet语法前身是Zen coding，它使用缩写来提高html&#x2F;css的编写速度，Vscode内部已经集成该语法 一、快速生成HTML结构语法 1,生成标签直接输入标签名按tab键即可比如div然后tab键,就可以生成 2,如果想要生成多个相同标签加上就可以了比如div3就可以快速生成3个div 3,如果有父子级关系的标签,可以用&gt;比如ul&gt; li就可以了. 4.如果有兄弟关系的标签,用+就可以了比如div+p 5.如果生成带有类名或者id名字的,直接写.demo或者#two tab键就可以了 6,如果生成的div类名是有顺序的,可以用自增符号$ 二、快速生成css结构语法 简写形式 三、快速格式化代码 Vscode 快速格式化代码: shift+alt+f 也可以设置当我们保存页面的时候自动格式化代码: 1)文件 &gt; 【首选项】- [设置】 2)搜索emmet.include; 3)在settingsjson下的【用户】中添加以下语句: editor.iormatonType : true “editor.formatOnSave” true 只需要设置一次即可,以后都可以自动保存格式化代码 css复合选择器选择器分为基础选择器和复合选择器，复合选择器就是建立在基础选择器之上，对基本选择器进行组合成的 复合选择器可以更准确、更高效的选择目标元素(标签) 复合选择器是由两个或多个基础选择器,通过不同的方式组合而成的 常用的复合选择器包括:后代选择器、子选择器、并集选择器、伪类选择器等等 后代选择器（重要）后代选择器又称为包含选择器,可以选择父元素里面子元素。其写法就是把外层标签写在前面,内层标签写在后面,中间用空格分隔。当标签发生嵌套时,内层标签就成为外层标签的后代。 ol li{ ​ color：red； } 语法: 元素1 空格 元素2 {样式声明} 上述语法表示选择元素1里面的所有元素2(后代元素) ul li {样式声明} &#x2F; 选择u1里面所有的1i标签元素&#x2F;** 元素1和元素2中间用空格隔开 元素1是父级,元素2是子级,最终选择的是元素2 元素2可以是儿子，也可以是孙子等,只要是元素1的后代即可 元素1和元素2可以是任意基础选择器 子选择器（重要）子元素选择器(子选择器)只能选择作为某元素的最近一级子元素。简单理解就是选亲儿子元素. 语法: 元素1&gt;元素2{样式声明} 上述语法表示选择元素1里面的所有直接后代(子元素)元素2。 例如: div &gt;p(样式声明} &#x2F; 选择div里面所有最近一级p标签元素&#x2F;** 元素1和元素2中间用大于号隔开 元素1是父级,元素2是子级,最终选择的是元素2 元素2必须是亲儿孔其孙子、重孙之类都不归他管你也可以叫他亲儿子选择器 并集选择器（重要）并集选择器可以选择多组标签，同时为他们定义相同的样式。通常用于集体声明逗号分割元素等于和 div， p， .pig li{ ​ color：pink； } 元素1和元素2中间用逗号隔开 逗号可以理解为和的意思 并集选择器通常用于集体声明 伪类选择器伪类选择器用于向某些选择器添加特殊的效果，比如给链接添加特殊效果，或选择第一个，第n个元素 伪类选择器书写特点用冒号（：）表示，比如 ：hover、：first-child。 a:link 选择所有未被访问的链接 a:visited 选择所有已被访问的链接 a: hover 选择鼠标指针位于其上的链接 a:active 选择活动链接(鼠标按下未弹起的链接) 1、为了确保生效,请按照LVHA的循顺序声明 :link-:visited-:hover -:active.否则效果无效 2、因为a链接在浏览器中具有默认样式,所以我们实际工作中都需要给链接单独指定样式。 :focus伪类选择器:focus伪类选择器用于选取获得焦点的表单元素。 焦点就是光标,一般情况类表单元素才能获取,因此这个选择器也主要针对于表单元素来说。 input:focus { **background-color: yellow;** } 复合选择器总结选择器 作用 特征 使用情 隔开符号及用法 后代选择器 用来选择后代元素 可以是子孙后代 较多 符号是空格.nav a 子代选择器 选择最近一级元素 只选亲儿子 较少 符号是大于.nav&gt;p 并集选择器 元素选择某些相同样式的 可以用于集体 较多 声明符号是逗号.nav,.header 链接伪类选择 选择不同状态的链接 跟链接相关 较多 重点记住a{}和a:hover实际开发的写法 :focus 选择器择 获得光标的表单 跟表单相关 较少 input:focus记住这个写法 css元素显示模式元素显示模式就是元素(标签)以什么方式进行显示,比如自己占一行,比如一行可以放多个. HTML元素一般分为块元素和行内元素两张类型 块元素常见的块元素有~、 、、, , 等,其中标签是最典型的块元素。 块级元素的特点： 1、比较霸道,自己独占一行。 2、高度,宽度、外边距以及内边距都可以控制。 3、宽度默认是容器(父级宽度)的100%。 4、是一个容器及盒子,里面可以放行内或者块级元素。 1、文字类的元素内不能使用块级元素 2、标签主要用于存放文字,因此里面不能放块级元素,特别是不能放 3、同理, ~等都是文字类块级标签,里面也不能放其他块级元素 行内元素常见的行内元素有、、, 、, ,、 、、等,其中标签是最典型的行内元素。有的地方也将行内元素称为内联元素。 行内元素的特点： 1、相邻行内元素在一行上,一行可以显示多个。 2、高、宽直接设置是无效的。 3、默认宽度就是它本身内容的完度。 4、行内元素只能容纳文本或其他行内元素。 链接里面不能再放链接 特殊情况链接里面可以放块级元素,但是给转换一下块级模式最安全 行内块元素在行内元素中有几个特殊的标签-、、 ,它们同时具有块元素和行内元素的特点。,有些资料称它们为行内块元素。 行内块元素的特点: 1、和相邻行内元素(行内块)在一行上,但是他们之间会有空白缝隙。一行可以显示多个(行内元素特点) 2、默认宽度就是它本身内容的宽度(行内元素特点) 3、高度,行高、外边距以及内边距都可以控制(块级元素特点)。 元素显示模式总结元素模式 元素排列 设置样式 默认宽度 包含 块级元素元素 一行只能放一个块级元素 可以设置宽度高度 容器的100% 签容器级可以包含任何标签 行内元素 一行可以放多个行内元素 不可以直接设置宽度 它本身内容的宽度 容纳文本或则其他行内元素 行内块元素 一行放多个行内块元素素 可以设置宽度和高度 它本身内容的宽度 元素显示模式转换特殊情况下,我们需要元素模式的转换,简单理解一个模式的元素需要另外一种模式的特性, 比如想要增加链接的触发范围。 转换为块元素: display:block 转换为行内元素: display:inline; 转换为行内块: display: inline-block; 一个小工具的使用snipasteSnipaste是一个简单但强大的截图工具,也可以让你将截图贴回到屏幕上.常用快捷方式 1、F1可以截图.同时测量大小,设置箭头书写文字等 2、F3在桌面置顶显示3,点击图片,alt可以取色(按下shift可以切换取色模式 3、4.按Fesc取消图片显示 单行文字垂直居中的代码Css没有给我们提供文字垂直居中的代码这里我们可以使用一个小技巧来实现.、 解决方案 让文字的行高等于盒子的高度就可以让文字在当前盒子内垂直居中 简单理解:行高的上空隙和下空隙把文字挤到中间了,是如果行高小于盒子高度,文字会偏上如果行高大于盒子高度则文字偏下 css背景样式背景属性可以设置背景颜色、背景图片、背景平铺、背景图片位置、背景图像固定等 背景颜色一般情况下元素背景颜色默认值是transparent (透明) background-color：transparent；（透明背景） background-color：red； 背景图片background-image属性描述了元素的背景图像。 实际开发常见于logo或者一些装饰性的小图片或者是超大的背景图片,优点是非常便于控制位置(精灵图也是一种运用场景) background-image：none； background-image：url（图片地址）； 参数值 作用 none 无背景图(默认的) url 使用绝对或相对地址指定背景图像 背景平铺如果需要在HTML页面上对背景图像进行平铺,可以使用background-repeat属性。 background-repeat: repeat （纵向和横向平铺）I no-repeat（不平铺） I repeat-x（横向平铺） I repeat-y（纵向平铺） 页面元素既可以添加背景颜色也可以添加背景图片只不过背景图片会压在背景颜色 参数值 作用 repeat 背景图像在纵向和横向上平铺(默认的) no-repeat 背景图像不平铺 repeat-x 背景图像在横向上平铺 repeat-y 背景图像在纵向平铺 背景图片位置利用background-position属性可以改变图片在背景中的位置。 background-position: x y； 参数代表的意思是:x坐标和y坐标。可以使用方位名词或者精确单位 参数值 说明 length 百分数1由浮点数字和单位标识符组成的长度值 position top I center | bottom | left center | right方位名词 1,参数是方位名词 如果指定的两个值都是方位名词,则两个值前后顺序无关,比如left top和top left效果一致 如果只指定了一个方位名词,另一个值省略,则第二个值默认居中对齐 2.参数是精确单位 如果参数值是精确坐标,那么第一个肯定是x坐标,第二个一定是y坐标 如果只指定一个数值,那该数值一定是x坐标,另一个默认垂直居中 3.参数是混合单位 如果指定的两个值是精确单位和方位名词混合使用,则第一个值是x坐标,第二个值是y坐标 背景图像固定（背景附着）background-attachment属性设置背景图片是否固定或者随着页面的其余部分滚动 background-attachment后期可以制作视差滚动的效果 background-attatchment:scroll &#x2F; fixed 参数 作用 scroll 背景图像是随对象内容滚动(默认状态) fixed 背景图像固定 背景复合写法为了简化背景属性的代码,我们可以将这些属性合并简写在同一个属性background中。从而节约代码量。 当使用简写属性时,没有特定的书写顺序,一般习惯约定顺序为: background: 背景颜色 &#x2F; 背景图片地址 &#x2F; 背景平铺 &#x2F; 背景图像滚动 &#x2F; 背景图片位置， 例： body{ ​ background：black（images&#x2F;bj.jpg）no-repeat fixed center top; } background: transparent url (image.jpg) repeat-y fixed top; 这是实际开发中,我们更提倡的写法。 背景色半透明background：rgba（0，0，0，0.3）；0-1之间 或者我们习惯把0.3的0省略掉,写为background:rgba(0,0,0,.3); 最后一个参数是alpha透明度,取值范围在0-1之间 注意:背景半透明是指盒子背景半透明,盒子里面的内容不受影响 背景总结属性 作用 值 background-color 背景颜色 预定义的颜色值十六进制&#x2F;RGB代码 background-image 背景图片 url(图片路径) background-repeat 是否平铺 repeat&#x2F;no-repeat&#x2F;repeat-x&#x2F;repeat-y background-position 背景位置 length&#x2F;position 分别是x和y坐标 background-attachment 背景附着 scroll (背景滚动) &#x2F;fixed (背景固定) 背景简写 书写更简单 背景颜色背景图片地址背景平铺背景滚动背景位置; 背景色半透明 背景颜色半透明 background: rgba(0,0,0,0.3);后面必须是4个值 css的三大特性Css有三个非常重要的三个特性:层叠性、继承性、优先级。 1.层叠性相同选择器给设置相同的样式,此时一个样式就会覆盖(层叠)另一个冲突的样式。层叠性主要解决样式冲突的问题 层叠性原则: 样式中突,遵循的原则是就近原则,哪个样式离结构近,就执行哪个样式 样式不冲突,不会层叠 2.继承性现实中的继承:我们继承了父亲的姓” CSS中的继承子标签会继承父标签的某些样式,如文本颜色和字号。简单的理解就是:子承父业 恰当地使用继承可以简化代码,降低CSS样式的复杂性 子元素可以继承父元素的样式(text-, font-, line-这些元素开头的可以继承,以及color属性) 2.1行高继承行高的继承性body font:12px&#x2F;1.5 Microsoft YaHei; 行高可以跟单位也可以不跟单位 如果子元素没有设置行高,则会继承父元素的行高为1.5 此时子元素的行高是:当前子元素的文字大小 1.5* body行高1.5这样写法最大的优势就是里面子元素可以根据自己文字大小自动调整行高 3.优先级当同一个元素指定多个选择器，就会有优先级的产生。 选择器相同,则执行层量性 选择器不同,则根据选择器权重执行 选择器权重如下表所示。 选择器 选择器权重 继承或者 0.0.0.0* 元素选择器 0,0,0,1 类选择器,伪类选择器 0,0,1,0 ID选择器 0,1,0,0 行内样式style&#x3D;” “ 1,0,0,0 important重要 无穷大 权重依次变大 div { font-size: 14рх; color: red! important; } 优先级注意点: 1.权重是有4组数字组成,但是不会有进位。 2.可以理解为类选择器永远大于元素选择器 id选择器永远大于类选择器,以此类推. 3.等级判断从左向右,如果某一位数值相同,则判断下一位数值。 4,可以简单记忆法:通配符和继承权重为0,标签选择器为1,类(伪类)选择器为10,id选择器100,行内样式表为1000, limportant无穷大. 5继承的权重是0,如果该元素没有直接选中,不管父元素权重多高,子元素得到的权重都是0 权重叠加:如果是复合选择器,则会有权重叠加,需要计算权重。 div ul li———– 0,0,0,3 .nav ul li——- 0,0,12 a:hover——–0.0,1 .nav a——0,0,1,1 盒子模型页面布局要学习三大核心,盒子模型浮动和定位 ，学习好盒子模型能非常好的帮助我们布局页面. 所谓盒子模型:就是把HTML页面中的布局元素看作是一个矩形的盒子,也就是一个盛装内容的容器。 CSS盒子模型本质上是一个盒子,封装周围的HTML元素,它包括:边框、外边距、内边距、和实际内容 1.边框( border )border可以设置元素的边框。边框有三部分组成边框宽度(粗细)边框样式边框颜色 语法:border : border-width II border-style II border-color 属性 作用 border-width 定义边框粗细,单位是px. border-style 边框的样式 border-color 边框颜色 属性值 none: 无边框。与任何指定的border-width值无关 hidden : 隐藏边框。IE不支持 dotted: 在MAC平台上1E4+与WINDOWS和UNIX平台上1E5.5+为点线。否则为实线 dashed: 在MAC平台上IE4+与WINDOWS和UNIX平台上1E5.5+为虚线。否则为实线 solid: 实线边框 double: 双线边框。两条单线与其间隔的和等于指定的border-width值 groove: 根据border-color的值画3D凹槽 ridge: 根据border-color的值画菱形边框 inset: 根据border-color的值画3D凹边 outset: 根据border-color的值画3D凸边 说明：如果提供全部四个参数值,将按上-右-下-左的顺序作用于四个边框。 如果只提供一个，将用于全部的四条边。 如果提供两个,第一个用于上一下,第二个用于左-右。 如果提供三个,第一个用于上,第二个用于左-右,第三个用于下。 要使用该属性,必须先设定对象的height或width属性,或者设定position属性为absolute。 如果border-width不大于0,本属性将失去作用。 1、边框简写Css边框属性允许你指定一个元素边框的样式和颜色。 边框简写：border: 1px solid red; 没有顺序 边框分开写法:border-top: 1px solid red; &#x2F;只设定上边框, 其余同理&#x2F; 表格的细线边框border-collapse属性控制浏览器绘制表格边框的方式。它控制相邻单元格的边框。 语法: border-collapse:collapse; collapse单词是合并的意思 border-collapse: collapse; 表示相邻边框合并在一起 边框会影响盒子实际大小 边框会额外增加盒子的实际大小。 因此我们有两种方案解决. 1,测量盒子大小的时候不量边框. 2.如果测量的时候包含了边框,则需要width&#x2F;height减去边框宽度 内边距( padding)padding属性用于设置内边距,即边框与内容之间的距离。 属性 作用 padding-left 左内边距 padding-right 右内边距 padding-top 上内边距 padding-bottom 下内边距 padding属性(简写属性)可以有一到四个值。 值的个数 表达意思 padding: 5px; 1个值,代表上下左右都有5像素内边距; padding: 5px 10px; 2个值,代表上下内边距是5像素左右内边距是10像素; padding: 5px 10px 20px; 3个值,代表上内边距5像素左右内边距10像素下内边距20像素; padding: 5px 10px 20px 30px; 4个值,上是5像素右10像素下20像素左是30像素顺时针; 当我们给盒子指定padding值之后,发生了2件事情: 1.内容和边框有了距离,添加了内边距。 2.padding影响了盒子实际大小。 也就是说,如果盒子已经有了宽度和高度,此时再指定内边框,会撑大盒子。 解决方案:如果保证盒子跟效果图大小保持一致,则让width&#x2F;height减去多出来的内边距大小即可。 外边距（margin）margin属性用于设置外边距,即控制盒子和盒子之间的距离 属性 作用 margin-left 左外边距 margin-right 右外边距 margin-top 上外边距 margin-bottom 下外边距 margin简写方式代表的意义跟padding完全一致。 外边距典型应用 外边距可以让块级盒子水平居中,但是必须满足两个条件: ①盒子必须指定了宽度(width ). ②盒子左右的外边距都设置为auto. .header{ width: 960px; margin:0 auto;} 常见的写法,以下三种都可以: margin-left: auto; margin-right: auto; margin: auto; margin: 0 auto; 注意:以上方法是让块级元素水平居中,行内元素或者行内块元素水平居中给其父元素添加text-align:center即可 外边距合并使用margin定义块元素的垂直外边距时,可能会出现外边距的合并。 1.相邻块元素垂直外边距的合并当上下相邻的两个块元素(兄弟关系)相遇时,如果上面的元素有下外边距margin-bottom,下面的元素有上外边距margin-top ,则他们之间的垂直间距不是margin-bottom与margin-top之和。取两个值中的较大者这种现象被称为相邻块元素垂直外边距的合井。 解决方案： 尽量只给一个盒子添加margin值。 2.嵌套块元素垂直外边距的塌陷对于两个嵌套关系(父子关系)的块元素,父元素有上外边距同时子元素也有上外边距,此时父元素会塌陷较大的外边距值。 解决方案: ①可以为父元素定义上边框。 ②可以为父元素定义上内边距。 ③可以为父元素添加overflow:hidden. 还有其他方法,比如浮动、固定,绝对定位的盒子不会有場陷问题， 清除内外边距网页元素很多都带有默认的内外边距,而且不同浏览器默认的也不一致。 因此我们在布局前,首先要清除下网页元素的内外边距。 padding:0; &#x2F;清除内边距&#x2F;** margin:0; &#x2F;清除外边距&#x2F; 注意:行内元素为了照顾兼容性,尽量只设置左右内外边距,不要设置上下内外边距。但是转换为块级和行内块元素就可以了 总结1,布局为啥用不同盒子我只想用div? 标签都是有语义的,合理的地方用合理的标签。比如产品标题就用h,大量文字段落就用p 2.为啥用辣么多类名? 类名就是给每个盒子起了一个名字,可以更好的找到这个盒子,选取盒子更容易后期维护也方便。 3.到底用margin还是padding? 大部分情况两个可以混用,两者各有优缺点,但是根据实际情况,总是有更简单的方法实现。 案例新知识点:去掉li前面的项目符号(小圆点)语法：list-style: none; 圆角边框在CSS3中,新增了圆角边框样式,这样我们的盒子就可以变圆角了。 border-radius属性用于设置元素的外边框圆角。 语法:border-radius:length; radius半径(圆的半径)原理: (椭)圆与边框的交集形成圆角效果 参数值可以为数值或百分比的形式 如果是正方形,想要设置为一个圆,把数值修改为高度或者宽度的一半即可,或者直接写为50% 如果是个矩形,设置为高度的一半就可以做 该属性是一个简写属性,可以跟四个值,分别代表左上角、右上角、右下角、左下角 分开写: border-top-left-radius, border-top-right-radius, border-bottom-right-radius和 border-bottom-left-radius 盒子阴影（重点）CSS3中新增了盒子阴影,我们可以使用box-shadow属性为盒子添加阴影。 语法：box-shadow: h-shadow v-shadow blur spread color inset; box-shadow: 10px 10px 10px -4px rgba(0, 0, 0, .3) inset； 值 描述 h-shadow 必需,水平阴影的位置,允许负值。 v-shadow 必需,垂直阴影的位置,允许负值。 blur 可选,模糊距离。 spread 可选,阴影的尺寸。 color 可选,阴影的颜色。 inset 可选,将外部阴影(outset)改为内部阴影。 注意： 1,默认的是外阴影(outset),但是不可以写这个单词,否则导致阴影无效 2,盒子阴影不占用空间,不会影响其他盒子排列。 文字阴影在CSS3中,我们可以使用text-shadow属性将阴影应用于文本。 语法:text-shadow: h-shadow y-shadow blur color; 值 描述 hshadow 必需，水平阴影位置，允许负值。 v-shadow 必需，垂真阴影的位置，允许负值。 blur 可选。模糊的距离。 color 可选。阴影的颜色。 CSS浮动（float）1.传统网页布局的三种方式网页布局的本质—用CSS来摆放盒子。把盒子摆放到相应位置 CSS提供了三种传统布局方式(简单说就是盒子如何进行排列顺序) : 普通流(标准流) 浮动 定位 1.2标准流(普通流&#x2F;文档流)所谓的标准流:就是标签按照规定好默认方式排列. 1,块级元素会独占一行,从上向下顺序排列。 常用元素: div, hr,p, hl-h6, ul,ol, dl, form, table 2,行内元素会按照顺序,从左到右顺序排列,碰到父元素边缘则自动换行。 常用元素: span, a,i,em等 以上都是标准流布局,我们前面学习的就是标准流,标准流是最基本的布局方式。 这三种布局方式都是用来摆放盒子的,盒子摆放到合适位置,布局自然就完成了。 注意:实际开发中,一个页面基本都包含了求三种布局方式 移动端学习新的布局方式 1.3为什么需要浮动?总结:有很多的布局效果,标准流没有办法完成,此时就可以利用浮动完成布局。因为浮动可以改变元素标签默认的排列方式. 浮动最典型的应用:可以让多个块级元素一行内排列显示。 网页布局第一准则：多个块级元素纵向排列找标准流,多个块级元素横向排列找浮动。 **1.4什么是浮动? **float属性用于创建浮动框,将其移动到一边,直到左边缘或右边缘触及包含块或另一个浮动框的边缘语法： 选择器( float:属性值; } 属性值 描述 none 元素不浮动(默认值) left 元素向左浮动 right 元素向右浮动 1.5浮动特性(重难点)一、加了浮动之后的元素,会具有很多特性,需要我们掌握的. 1,浮动元素会脱离标准流(脱标) 2,浮动的元素会一行内显示并且元素部对齐 3,浮动的元素会具有行内块元素的特性 设置了浮动(float )的元素最重要特性: 1,脱离标准普通流的控制(浮)移动到指定位置(动), (俗称脱标) 2.浮动的盒子不再保留原先的位置 二、如果多个盒子都设置了浮动,则它们会按照属性值一行内显示并且顶端对齐排列。 注意:浮动的元素是互相贴靠在一越的(不会有缝隙) ,如果父级宽度装不下这些浮动的盒子,多出的盒子,会另起一行对齐。 三、浮动元素会具有行内块元素特性。 任何元素都可以浮动。不管原先是什么模式的元素,添加浮动之后具有行内块元相似的特性。 如果块级盒子没有设置宽度,默认宽度和父级一样宽,但是添加浮动后,它的大小根据内容来决定 浮动的盒子中间是没有缝隙的,是紧挟着一起的 行内元素同理 1.6浮动元素经常和标准流父级搭配使用 为了约束浮动元素位置,我们网页布局一般采取的策略是： 先用标准流的父元素排列上下位置,之后内部子元素采取浮动排列左右位置,符合网页布局第一准侧 2.2浮动布局注意点1,浮动和标准流的父盒子搭配。 先用标准流的父元素排列上下位置,之后内部子元素采取浮动排列左右位置 2.一个元素浮动了,理论上其余的兄弟元素也要浮动。 一个盒子里面有多个子盒子,如果其中一个盒子浮动了,那么其他兄弟也应该浮动,以防止引起问题。 浮动的盒子只会影响浮动盒子后面的标准流不会影响前面的标准流 3.清除浮动3.1为什么需要清除浮动?由于父级盒子很多情况下,不方便给高度,但是子盒子浮动又不占有位置,最后父级盒子高度为0时,就会影响下面的标准流盒子。 由于浮动元素不再占用原文档流的位置,所以它会对后面的元素排版产生影响 3.2清除浮动本质清除浮动的本质是清除浮动元素造成的影响 如果父盒子本身有高度,则不需要清除浮动 清除浮动之后,父级就会根据浮动的子盒子自动检测高度。父级有了高度,就不会影响下面的标准流了 3.3清除浮动语法： 选择器(clear:属性值;） 属性值 描述 left 不允许左侧有浮动元素(清除左侧浮动的影响) right 不允许右侧有浮动元素(清除右侧浮动的影响) both 同时清除左右两侧浮动的影响 我们实际工作中,几乎只用clear: both; 清除浮动的策略是:闭合浮动 3.4清除浮动方法1,额外标签法也称为隔墙法,是W3C推荐的做法。 2父级添加overflow属性. 3.父级添加after伪元素 4父级添加双伪元素 3.4.1清除浮动—–额外标签法额外标签法也称为隔墙法,是W3C推荐的做法。 额外标签法会在浮动元素未尾添加一个空的标签。例如 ,或者其他签(如等）. 优点：通俗易懂，书写方便 缺点:添加许多无意义的标签,结构化较差 注意：要求这个新的空标签必须是块级元素。 总结:1清除浮动本质是? 清除浮动的本质是清除浮动元素脱离标准流造成的影响 2.清除浮动策略是? 闭合浮动,只让浮动在父盒子内部影响,不影响父盒子外面的其他盒子. 3,额外标签法? 隔墙法，就是在最后一个浮动的子元素后面添加一个额外标签添加清除浮动样式 实际工作可能会遇到,但是不常用 3.4.2清除浮动—-父级添加overflow可以给父级添加overflow属性,将其属性值设置为hidden, auto或scroll 子不教父之过注意是给父元素添加代码 优点：代码简洁 缺点:无法显示溢出的部分 3.4.3清除浮动—–:after伪元素法after方式是额外标签法的升级版。也是给父元素添加 .clearfix:after { ​ content: “”; display: block; height: 0; clear: both; visibility: hidden; } .clearfix{ IE6,7专有 *zoom: 1; } 优点:没有增加标签,结构更简单 缺点：照低版本浏览器 代表网站:百度、淘宝网、网易等 3.4.4清除浮动—双伪元素清除浮动也是给给父元素添加 .clearfix:before, .clearfix: aftert { content:””; display:table; } .clearfix:after { clear:both; } .clearfix { zoom:1; } 优点：代码更简洁 缺点:照顾低版本浏览器 代表网站:小米、腾讯等 3.4.5清除浮动总结为什么需要清除浮动？ 1.父级没高度。 2.子盒子浮动了。 3.影响面布局了,我们就应该清除浮动了。 清除浮动的方式 优点 缺点 额外标签法(隔墙法) 通俗易懂,书写方便 添加许多无意义的标签,结构化较差。 父级overflow:hidden; 书写简单 溢出隐藏 父级after伪元素 结构语义化正确 由于IE6-7不支持:after,兼容性问题 父级双伪元素 结构语义化正确 由于IE6-7不支持:after,兼容性问题 4 CSS属性书写顺序(重点)建议遭循以下顺序: 1,布局定位属性: display &#x2F;position &#x2F; float&#x2F; clear &#x2F; visibility &#x2F; overflow (建议display第一个写,毕竟关系到模式) 2.自身属性: width&#x2F; height&#x2F; margin&#x2F; padding &#x2F;border&#x2F; background 3,文本属性: color&#x2F; font &#x2F; text-decoration &#x2F; text-align&#x2F; vertical-align&#x2F;white-space&#x2F; break-word 4,其他属性(CSS3) : content&#x2F;cursor &#x2F; border-radius&#x2F; box-shadow &#x2F; text-shadow &#x2F; background:linear-gradient… 导航栏注意点：实际开发中,我们不会直接用链接a而是用i包含链接(ita)的做法。 1, lita语义更清晰,一看这就是有条理的列表型内容。 2.如果直接用a,搜索引擎容易辨别为有堆砌关键字嫌疑(故意堆砌关键字容易被搜索引擎有降权的风险)从而影响网站排名 定位1.1为什么需要定位以上效果,标准流或浮动都无法快速实现,此时需要定位来实现。 所以： 1,,浮动可以让多个块级盒子一行没有缝隙排列显示,经常用于横向排列盒子。 2,定位则是可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置,并且可以压住其他盒子。 1.2定位组成定位:将盒子定在某一个位置,所以定位也是在摆放盒子,按照定位的方式移动盒子。 定位&#x3D;定位模式+边偏移。 定位模式用于指定一个元素在文档中的定位方式。边偏移则决定了该元素的最终位置。 1,定位模式定位模式决定元素的定位方式,它通过css的position属性来设置,其值可以分为四个: 值 语义 static 静态定位 relative 相对定位 absolute 绝对定位 fixed 固定定位 2.边偏移边偏移就是定位的盒子移动到最终位置。有top, bottom, left和right 4个属性。 边偏移属性 示例 描述 top top: 80px 顶端偏移量,定义元素相对于其父元素上边线的距离。 bottom bottom: 80px 底部偏移量,定义元素相对于其父元素下边线的距离。 left left: 80px 左侧偏移量,定义元素相对于其父元素左边线的距离。 right right: 80px 右侧偏移量,定义元素相对于其父元素右边线的距离 1.3静态定位static (了解)静态定位是元素的默认定位方式,无定位的意思。 语法：选择器（ position: static; } 静态定位按照标准流特性摆放位置, 它没有边偏移静态定位在布局时很少用到 1.4相对定位relative (重要)相对定位是元素在移动位置的时候,是相对于它原来的位置来说的(自恋型)。 语法： 选择器(position: relative; } 相对定位的特点: (务必记住) 1,它是相对于自己原来的位置来移动的(移动位置的时候参照点是自己原来的位置 2.原来在标准流的位置继续占有,后面的盒子仍然以标准流的方式对待它。(不脱标,继续保留原来位置) 因此,相对定位并没有脱标。它最典型的应用是给绝对定位当爹的。 1.5绝对定位absolute (重要)绝对定位是元素在移动位置的时候,是相对于它祖先元素来说的(拼爹型)。 语法：选择器‘ position: absolute; } 绝对定位的特点： (务必记住) 1,如果没有祖先元素或者祖先元素没有定位,则以浏览器为准定位(Document文档). 2.如果祖先元素有定位(相对、绝对、固定定位) ,则以最近一级的有定位祖先元素为参考点移动位置。 3,绝对定位不再占有原先的位置。(脱标) 1.6子绝父相的由来弄清楚这个口诀,就明白了绝对定位和相对定位的使用场景。 这个“子绝父相”太重要了,是我们学习定位的口诀,是定位中最常用的一种方式这句话的意思是:子级是绝对定位的话,父级要用相对定位. 1、子级绝对定位,不会占有位置,可以放到父盒子里面的任何一个地方,不会影响其他的兄弟盒子。 2、父盒子需要加定位限制子盒子在父盒子内显示。 3、父盒子布局时,需要占有位置,因此父亲只能是相对定位 这就是子绝父相的由来,所以相对定位经常用来作为绝对定位的父级。 总结:因为父级需要占有位置,因此是相对定位,子盒子不需要占有位置,则是绝对定位 1.7固定定位fixed (重要)固定定位是元素固定于浏览器可视区的位置。主要使用场景:可以在浏览器页面滚动时元素的位置不会改变。 语法:选择器（ position: fixed; } 固定定位的特点: (务必记住) 1,以浏览器的可视窗口为参照点移动元素。 固定定位小技巧:固定在版心右侧位置。. 小算法: 1,让固定定位的盒子left 50%,走到浏览器可视区(也可以看做版心)的一半位置。 2.让固定定位的盒子margin-left:版心宽度的一半距离。多走版心宽度的一半位置 就可以让固定定位的盒子贴着版心右侧对齐了。 1.8粘性定位sticky (了解)粘性定位可以被认为是相对定位和固定定位的混合。Sticky粘性的 语法：选择器‘ （position: sticky; top: 10px; } 粘性定位的特点： 1,以浏览器的可视窗口为参照点移动元素(固定定位特点) 2,粘性定位占有原先的位置(相对定位特点) 3.必须添加top. left. right. bottom其中一个才有效 跟页面滚动搭配使用。兼容性较差, IE不支持。 1.9定位的总结定位模式 是否脱标 移动位置 是否常用 static静态定位 否 不能使用边偏移 很少 relative相对定位 否(占有位置) 相对于自身位置移动 常用 absolute绝对定位 是(不占有位置) 带有定位的父级 常用 fixed固定定位 是(不占有位置) 浏览器可视区 常用 sticky粘性定位 否(占有位置) 浏览器可视区 当前阶段少 1,一定记住相对定位、固定定位、绝对定位两个大的特点: 1.是否占有位置(脱标否) 2.以谁为基准点移动位置2学习定位重点学会子绝父相。 1.10定位叠放次序z-index,在使用定位布局时,可能会出现盒子重叠的情况。此时,可以使用z-index来控制盒子的前后次序(Z轴) 语法： 选择器{ z-index: 1; } 数值可以是正整数、负整数或0,默认是auto ,数值越大,盒子越靠上 如果属性值相同,则按照书写顺序,后来居上 “数字后面不能加单位“ 只有定位的盒子才有z-index属性 1.11定位的拓展1·绝对定位的盒子居中加了绝对定位的盒子不能通过margin:0 auto水平居中,但是可以通过以下计算方法实现水平和垂直居中。 left: 50%; :上盒子的左侧移动到父级元素的水平中心位置。 margin-left:100px : 让盒子向左移动自身宽度的一半。 2.定位特殊特性绝对定位和固定定位也和浮动类似 1,行内元素添加绝对或者固定定位,可以直接设置高度和宽度。 2.块级元素添加绝对或者固定定位,如果不给宽度或者高度,默认大小是内容的大小。 3,脱标的盒子不会触发外边距塌陷 浮动元素、绝对定位(固定定位)元素的都不会触发外边距合并的问题。 4·绝对定位(固定定位)会完全压住盒子浮动元素不同,只会压住它下面标准流的盒子,但是不会压住下面标准流盒子里面的文字(图片) 但是绝对定位(固定定位)会压住下面标准流所有的内容。 浮动之所以不会压住文字,因为浮动产生的目的最初是为了做文字环绕效果的。文字会围绕浮动元素 3.网页布局总结通过盒子横型,清楚知道大部分html标签是一个盒子。 通过CSS浮动、定位可以让每个盒子排列成为网页。 一个完整的网页,是标准流、浮动、定位一起完成布局的,每个都有自己的专门用法。 1.标准流 可以让盒子上下排列或者左右排列,垂直的块级盒子显示就用标准流布局。 2浮动 可以让多个块级元素-行显示或者左右对齐盒子,多个块级盒子水平显示就用浮动布局。 3,定位 定位最大的特点是有层叠的概念,就是可以让多个盒子前后叠压来显示。如果元素自由在某个盒子内移动就用定位布局。 元素的显示与隐藏类似网站广告,当我们点击关闭就不见了,但是我们重新刷新页面,会重新出现! 本质:让一个元素在页面中隐藏或者显示出来。 display显示隐藏 visibility显隐藏 overflow溢出显示隐藏 4.1 display属性display属性用于设置一个元素应如何显示。 display: none ;隐藏对象 display : block ;除了转换为块级元素之外,同时还有显示元素的意思 display隐藏元素后,不再占有原来的位置。 后面应用及其广泛,搭配Js可以做很多的网页特效。 4.2 visibility 可见性visibility属性用于指定一个元素应可见还是隐 。 visibility: visible;元素可视 visibility: hidden;元素隐藏 visibility隐藏元素后,继续占有原来的位置。 如果隐藏元素想要原来位置,就用visibility : hidden 如果隐藏元素不想要原来位置,就用display : none (用处更多重点) 4.3 overflow溢出overflow属性指定了如果内容溢出一个元素的框(超过其指定高度及宽度)时,会发生什么。 属性值 描述 visible 不剪切内容也不添加滚动条 hidden 不显示超过对象尺寸的内容,超出的部分隐藏掉 scroll 不管超出内容否,总是显示滚动条 auto 超出自动显示滚动条,不超出不显示滚动条 一般情况下,我们都不想让溢出的内容显示出来,因为溢出的部分会影响布同。 但是如果有定位的盒子,请慎用overflowhidden因为它会隐藏多余的部分。 1.精灵图1.1为什么需要精灵图一个网页中往往会应用很多小的背景图像作为修饰,当网页中的图像过多时,服务器就会频繁地接收和发送请求图片,造成服务器请求压力过大,这将大大降低页面的加载速度。 因此,为了有效地减少服务器接收和发送请求的次数,提高页面的加载速度,出现了CSS精灵技术(也称CSS Sprites, CSs 雪碧)。 核心原理:将网页中的一些小背景图像整合到一张大图中,这样服务器只需要一次请求就可以了。 1.2精灵图( sprites )的使用使用精灵图核心: 1,精灵技术主要针对于背景图片使用。就是把多个小背景图片整合到一张大图片中。 2.这个大图片也称为sprites精灵图或者雪碧图 3,移动背景图片位置,此时可以使用background-position. 4,移动的距离就是这个目标图片的x和y坐标,注意网页中的坐标有所不同 5,因为一般情况下都是往上往左移动,所以数值是负值。 6,使用精灵图的时候需要精确测量,每个小背景图片的大小和位置。 使用精灵图核心总结: 1精灵图主要针对于小的背景图片使用。 2主要借助于背景位置来实现–background-position. 3一般情况下精灵图都是负值。(千万注意网页中的坐标: x轴右边走是正值,左边走是负值, y轴同理。) 2.字体图标1.1字体图标使用场景:主要用于显示网页中通用、常用的一些小图标。 精灵图是有诸多优点的,但是缺点很明显 1.图片文件还是比较大的。 2.图片本身放大和缩小会失真。 3,一旦图片制作完毕想要更换非常复杂 此时,有一种技术的出现很好的解决了以上问题,就是字体图标iconfont. 字体图标可以为前端工程师提供一种方便高效的图标使用方式,展示的是图标,本质属于字体。 2.2字体图标的优点轻量级:一个图标字体要比一系列的图像要小。一旦字体加载了,图标就会马上渲染出来,减少了服务器 请求灵活性:本质其实是文字,可以很随意的改变颜色、产生阴影、透明效果、旋转 等兼容性:几乎支持所有的浏览器,请放心使用 注意:字体图标不能替代精灵技术,只是对工作中图标部分技术的提升和优化。 总结: 1,如果遇到一些结构和样式比较简单的小图标,就用字体图标。 2,如果遇到一些结构和样式复杂一点的小图片,就用精灵图。 2.4字体图标的引入下载完毕之后,注意原先的文件不要删,后面会用。 1,把下载包里面的fonts文件夹放入页面根目录下 2.4.1字体文件格式不同浏览器所支持的字体格式是不一样的,字体图标之所以兼容,就是因为包含了主流浏览器支持的字体文件。 TureTypeltt)格式tt字体是Windows和Mad的最常见的字体,支持这种字体的浏览器有E9+, Firefox3.5+Chrome4+, Safari3+. Opera10+. iOS Mobile, Safari4.2+; Web Open Font Format(wof)格式wof字体,支持这种字体的浏览器有1E9+, Firefox3.5+、Chrome6tSafari3.6+. Operal1.1+ ; Embedded Open Type(eot)格式.eot字体是E专用字体,支持这种字体的浏览器有IE4+ ; SVG(.svg)格式svq字体是基于sVG字体渲染的一种格式,支持这种字体的浏览器有Chrome4+, Safari3.1+Opera10.0+, iOs Mobile Safari3.2+; 2.4字体图标的引入2,在CSS样式中全局声明字体:简单理解把这些字体文件通过css引入到我们页面中。 一定注意字体文件路径的问题。 @font-face { ​ font-family: ‘icomoon’; ​ src: url (‘fonts&#x2F;icomoon.eot?7kkyc2’); ​ src: url (‘ fonts&#x2F;icomoon.eot?7kkvc2#iefix’) format(‘embedded-opentype’), ​ url (‘ fonts&#x2F;icomoon. ttf?7kkyc2’) format (‘truetype’). ​ url (‘fonts&#x2F;icomoon.woff27kkvc2 fommat (‘woff’). ​ url (‘ fonts&#x2F;icomoon.svg27kkyc2 #icomoon’) format (‘gvg’); font-weight: normal; font-style: normal; } 2.5字体图标的追加如果工作中,原来的字体图标不够用了,我们需要添力新的字体图标到原来的字体文件中。 把压缩包里面的selection.json从新上传,然后选中自己想要新的图标,从新下载压缩包,并替换原来的文件即可。 3.CSS三角网页中常见一些三角形,使用CSS直接画出来就可以,不必做成图片或者字体图标。 一张图,你就知道CSS三角是怎么来的了,做法如下: div{ width: 0; height: 0; line-height: 0; font-size:0; border: 50px solid transparent; border-left-color: pink; } 4.css用户界面样式4.0什么是界面样式所谓的界面样式,就是更改一些用户操作样式,以便提高更好的用户体验。· 更改用户的鼠标样式·表单轮廓।防止表单域拖拽 4.1鼠标样式cursorli (cursor: pointer; } 设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。 属性值 描述 default 小白 默认 pointer 小手 move 移动 text 文本 not-allowed 禁止 4.2轮廓线outline给表单添加outline: 0;或者outine: none;样式之后,就可以去掉默认的蓝色边框。 input (outline: none; } 4.3防止拖拽文本域resize实际开发中,我们文本域右下角是不可以拖拽的。 textarea {resize: none;} 5.vertical-align属性应用css的vertical-align属性使用场景:经常用于设置图片或者表单(行内块元素)和文字垂直对齐 官方解释:用于设置一个元素的垂直对齐方式,但是它只针对于行内元素或者行内块元素有效。 语法 vertical-align: baseline I top I middle I bottom 值 描述 baseline 默认。元素放置在父元素的基线上。 top 把元素的顶端与行中最高元素的顶端对齐 middle 把此元素放置在父元素的中部 bottom 把元素的顶端与行中最低的元素的顶端对究。 5.1图片、表单和文字对齐图片、表单都属于行内块元素,默认的vertical-align是基线对齐。 默认文字与图片是基线对齐 此时可以给图片、表单这些行内块元素的vertical-align属性设置为middle就可以让文字和图片垂直居中对齐了。 5.2解决图片底部默认空白缝隙问题bug:图片底侧会有一个空白缝隙,原因是行内块元素会和文字的基线对齐。 主要解决方法有两种: 1,给图片添加vertical-align:middle topl bottom等。(提倡使用的) 2,把图片转换为块级元素display: block 6溢出的文字省略号显示1,单行文本溢出显示省略号 2.多行文本溢出显示省略号 1,单行文本溢出显示省略号-必须满足三个条件1.1先强制一行内显示文本 white-space: nowrap; (默认normal自动换行) 2,1超出的部分隐藏 overflow: hidden; 3.1文字用省略号替代超出的部分 text-overflow: ellipsis; 2.多行文本溢出显示省略号多行文本溢出显示省略号,有较大兼容性问题,适合于webkit浏览器或移动端(移动端大部分是webkit内核) overflow; hidden; text-overflow: ellipsis: &#x2F;弹性伸缩盒子模型显示&#x2F; display: -webkit-box; &#x2F;限制在一个块元素显示的文本的行数&#x2F; -webkit-line-clamp: 2; **&#x2F;设置或检索伸缩盒对象的子元素的排列方式* -webkit-box-orient: vertical; 更推荐让后台人员来做这个效果,因为后台人员可以设置显示多少个字,操作更简单。 7.常见布局技巧巧妙利用一个技术更快更好的布局: 1.margin负值的运用1,让每个盒子margin往左侧移动-1px正好压住相邻盒子边框 2.鼠标经过某个盒子的时候,提高当前盒子的层级即可(如果没有有定位,则加相对定位(保留位置) ,如果有定位,则加z-index) 2.文字围绕浮动元素巧妙运用浮动元素不会压住文字的特性 3.行内块的巧妙运用4.css三角强化代码： width: 0; height: o; border-color: transparent red transparent transparent; border-style: solid； border-width: 22px 8px 0 0; 8.CSS初始化不同浏览器对有些标签的默认值是不同的,为了消除不同浏览器对HTML文本呈斑的差异,照顾浏览器的来·容,我们需要对CSs初始化 简单理解: CSS初始化是指重设浏览器的样式。(也称为CSS reset ) 每个网页都必须首先进行CSS初始化。 Unicode编码字体:把中文字体的名称用相应的Unicode编码来代替,这样就可以有效的避免浏览器解释CSS代码时候出现乱码的问题。 比如: 黑体\\9ED1\\4F53 宋体\\5B8B\\4F53 微软雅黑\\5FAE\\8F6F\\96C5\\9ED1 HTML5和css3提高HTML5的新增特性主要是针对于以前的不足,增加了一些新的标签、新的表单和新的表单属性等 这些新特性都有兼容性问题,基本是IE9+以上版本的浏览器才支持,如果不考虑兼容性问题,可以大呈使用这些制特性。 声明: 1.新特性增加了很多,但是我们专注于开发常用的新特性。 2.基础 我们讲解部分新特性,到了就业班还会继续讲解其他新特性。 1.1 HTML5新增的语义化标签以前布局,我们基本用div来做。 div对于搜索引擎来说,是没有语义的。 1 :头部标签 2 :导航标签 3 :内容标签 4 :定义文档某个区域 5 :侧边栏标签 6 :尾部标签 注意： 这种语义化标准主要是针对搜索引擎的 这些新标签页面中可以使用多次 在IE9中,需要把这些元素转换为块级元素 其实,我们移动端更喜欢使用这些标签 HTML5还增加了很多其他标签,我们后面再慢慢学 1.2 HTML5新增的多媒体标签新增的多媒体标签主要包含两个: 1.音频: 2.视频: 使用它们可以很方便的在页面中嵌入音频和视频,而不再去使用flash和其他浏览器插件。 HTML5在不使用插件的情况下,也可以原生的支持视频格式文件的播放,当然,支持的格式是有限的。 1,视频当前元素支持三种视频格试:尽量使用mp4格式 浏览器 МP4 Webм Ogg Intermet Explorer YES NO NO Chrome YES YES YES Firefox YES从 Firefox YES YES ​ 21版本开始Linux ​ 系统从Firefox 30开始 Safar YES NO NO Opera YES从Opera 25 YES YES ​ 版本开始 语法: 1 &lt;source src&#x3D;”movie.ogg” type&#x3D;”video&#x2F;ogg&gt; 您的浏览器不支持video标签。 1,视频—-常见属性属性 值 描述 autoplay autoplay 视频就绪自动播放(谷歌浏览器需要添加muted来解决自动播放问题) controls controls 向用户显示播放控件 width pixels(像索） 设置播放器宽度 heigh pixels(像素） 设置播放器高度 loop loop 播放完是否继续播放该视频,循环播放 preload auto (预先加载视频) 规定是否预加载视频(如果有了autoplay就忽略该属性 ​ none (不应加载视频) src url 视频url地址 poster Imgurl 加载等待的画面图片 muted muted 静音播放 2·音频当前元素支持三种音频格式: 测试器 МPЗ Wav Ogg Internet Explorer YES NO NO Chrome YES YES YES Firefox YES YES YES Safari YES YES NO Opera YES YES YES 语法 1 &lt; audio controls&#x3D;”controls”&gt; 您的浏览器暂不支持标签。 常见属性 属性 值 描述 autoplay autoplay 如果出现该属性,则音频在就绪后马上播放。 controls controls 如果出现该属性,则向用户显示控件,比如播放按钮。 loop loop 如果出现该属性,则每当音频结束时重新开始播放 src url 要播放的音频的URL. 谷歌浏览器把音频和视频自动播放禁止了 3.多媒体标签总结音频标签和视频标签使用方式基本一致 浏览器支持情况不同 谷歌浏览器把音频和视频自动播放禁止了 我们可以给视频标签添加muted属性来静音播放视频,音频不可以(可以通过JavaScript解决) 视频标签是重点,我们经常设置自动播放,不使用controls控件,循环和设置大小属性 1.3 HTML5新增的input类型属性值 说明 type&#x3D;”email” 限制用户输入必须为Emal类型 type&#x3D;”url 限制用户输入必须URL类型 type&#x3D;”date” 限制用户输入必须为日期类型 types”time” 限制用户输入必须为时间类型 type&#x3D;”month” 限制用户输入必须为月类型 types”week” 限制用户输入必须为周类型 type&#x3D;”number 限制用户输入必须为数字类型 type&#x3D;”tel 手机号码 type&#x3D;”search” 搜索框 type&#x3D;”color” 生成一个颜色选择表单 1.4 HTML5新增的表单属性属性 值 说明 required required 表单拥有该属性表示其内容不能为空,必填 placeholder 提示文本 表单的提示信息,存在默认值将不显示 autofocus autofocus 自动聚焦属性,页面加载完成自动聚焦到指定表单 autocomplete off&#x2F;on 当用户在字段开始键入时,浏览器基于之前键入过的值,应该显示出在字段中填写的选项 ​ 默认已经打开,如autocomplete-“on “,关闭autocomplete &#x3D;”off需要放在表单内, ​ 同时加上name属性,同时成功提交 multiple multiple 可以多选文件提交 可以通过以下设置方式修改placeholder里面的字体颜色: input::placeholder { color: pink； } css3新特性2.1 CSS3的现状 新增的CSS3特性有兼容性问题, ie9+才支持 移动端支持优于PC端 不断改进中 应用相对广泛 现阶段主要学习:新增选择器和盒子模型以及其他特性 CSs3给我们新增了选择器,可以更加便捷,更加自由的选择目标元素。 1.属性选择器 2.结构伪类选择器 3.伪元素选择器 2.2属性选择器属性选择器可以根据元素特定属性的来选择元素。这样就可以不用借助于类或者id选择器。 选择符 简介 E[att] 选择具有att属性的E元素 E[att&#x3D;”val”] 选择具有att属性且属性值等于val的E元素 E[att^&#x3D;”val”] 匹配具有att属性且值以val开头的E元素 E[att$&#x3D;”val’] 匹配具有att属性且值以val结尾的E元素 E[att&#x3D;”val’] 匹配具有att属性且值中含有val的E元素* 注意:类选择器、属性选择器、伪类选择器,权重为10. 权重相同就近原则 2.3结构伪类选择器结构伪类选择器主要根据文档结构来选择器元素,常用于根据父级选择器里面的子元素 选择符 简介 E:first-child 匹配父元素中的第一个子元素E E:last-child 匹配父元素中最后一个E元素 E:nth-child(n) 匹配父元素中的第n个子元素E E:first-of-type 指定类型E的第一个 E:last-of-type 指定类型E的最后一个 E:nth-of-type(n) 指定类型E的第n个 nth-child (n)选择某个父元素的一个或多个特定的子元素 n可以是数字，关键字和公式 n如果是数字,就是选择第n个子元素,里面数字从1开始. n可以是关键字: even偶数, odd奇数 n可以是公式:常见的公式如下(如果n是公式,则从0开始计算,但是第0个元素或者超出了元素的个数会被忽略) 公式 取值 2n 偶数 2n+1 奇数 5n 5,10 15… n+5 从第5个开始(包含第五个)到最后 -n+5 前5个(包含第5个) … nth-child会把所有的盒子都排列序号 执行的时候首先看 :nth-childi)之后回去看前面div nth-of-type会把指定元素的盒子排列序号 执行的时候首先看div指定的元素之后回去看:nth-of-type(1)第几个孩子 区别： 1, nth-child对父元素里面所有孩子排序选择(序号是固定的)先找到第n个孩子,然后看看是否和E匹配 2.nth-of-tpe对父元素里面指定子元素进行排序选择。先去匹配E ,然后再根据E找第n个孩子 小结结构伪类选择器般用于选择父级里面的第几个孩子 nth-child对父元素里面所有孩子排序选择(序号是固定的)先找到第n个孩子,然后看看是否和E匹配 nth-of-type对父元素里面指定子元素进行排序选择。先去匹配E ,然后再根据E找第n个孩子 关于nth-child (n)我们要知道n是从0开始计算的,要记住常用的公式 如果是无序列表,我们肯定用nth-child更多 类选择器、属性选择器、伪类选择器,权重为10. 2.4伪元素选择器(重点)伪元素选择器可以帮助我们利用CSS创建新标签元素,而不需要HTML标签,从而简化HTML结构。 选择符 简介 ::before 在元素内部的前面插入内容 ::after 在元素内部的后面插入内容 注意:before和after创建一个元素,但是属于行内元素 新创建的这个元素在文档树中是找不到的,所以我们称为伪元素 语法: element:before{} before和after必须有content属性 before在父元素内容的前面创建元素, after在父元素内容的后面插入元素 伪元素选择器和标签选择器一样,权重为1 伪元素选择器使用场景1:伪元素字体图标p::before{ ​ position: absolute; ​ right: 20px; ​ top: 10px; ​ content: ‘\\e91e’; ​ font-size: 20px; } 伪元素选择器使用场景2 :仿土豆效果伪元素选择器使用场景3 :伪元素清除浮动1,额外标签法也称为隔墙法,是W3C推荐的做法。 2.父级添加overflow属性 3.父级添加after伪元素 4.父级添加双伪元素 后面两种伪元素清除浮动算是第一种额外标签法的一个升级和优化。 .clearfix:after{ ​ content: “”; 伪元素必须写的属性 ​ display: block; 插入的元素必须是块级 ​ height: 0; 不要看见这个元素 ​ clear: both; 该心代码清除浮动 ​ visibility: hidden; 不要看见这个元素 } .clearfix:before,.clearfix:after { ​ content:””; ​ display:table; 转换为块级元素并且一行显示 .clearfix:after { ​ clear:both; } 2.CSS3的新特性2.5 CSS3盒子模型CSS3中可以通过box-sizing来指定盒模型,有2个值:即可指定为content-box, border-box,这样我们计算盒子大小的方式就发生了改变。 可以分成两种情况: 1. box-sizing: content-box盒子大小为width + padding + border (以前默认的) 2.box-sizing: border-box盒子大小为width 如果盒子模型我们改为了box-sizing: border-box ,那padding和border就不会撑大盒子了 (前提padding和border不会超过width宽度) 2.6 CSS3其他特性(了解)css3滤镜filter:filter CSS属性将模糊或颜色偏移等图形效果应用于元素。 filter: 函数(); 例如: filter:blur(5px); blur模糊处理数值越大越模糊 Css3 calc函数:calc() 此CSS函数让你在声明CSS属性值时执行一些计算。 width: calc(100%-80px); 括号里面可以使用+-*&#x2F;来进行计算。 2.7 CsS3过渡(重点)过渡(transition)是CSS3中具有颠覆性的特征之一,我们可以在不使用Flash动画或JavaScript的情况下,当元素从一种样式变换为另一种样式时为元素添加效果 过渡动画:是从一个状态渐渐的过渡到另外一个状态 可以让我们页面更好看,更动感十足,虽然低版本浏览器不支持(ie9以下版本)但是不会影响页面布局。 我们现在经常和:hover一起搭配使用。 2.7 css3过渡(重点)transition:要过渡的属性 花费时间 运动曲线 何时开始; 1·属性:想要变化的css属性,宽度高度背景颜色内外边距都可以。如果想要所有的属性都变化过渡，写一个all就可以。 2.花时间:单位是秒(必须写单位)比如0.5s 3.运动曲线:默认是ease (可以省略) 4.何时开始：单位是秒(必须写单位)可以设置延迟触发时间默认是Os (可以省略) 记住过渡的使用口诀:谁做过渡给谁加 广义的HTML51.广义的 HTML5是HTML5身+ CSS3 + JavaScript. 2.这个集合有时称为HTML5和朋友,通常缩写为HTML5. 3,虽然HTML5的一些特性仍然不被某些浏览器支持,但是它是一种发展趋势。 4.HTML5 MDN介绍:https://developer.mozillaorg/zh-CN/docs/Web/Guide/HTML/HTML LOGO SEO优化1.logo里面首先放一个h1标签,目的是为了提权,告诉搜索引擎,这个地方很重要。 2.h1里面再放一个链接,可以返回首页的,把logo的背景图片给链接即可。 3.为了搜索引擎收录我们,我们链接里面要放文字(网站名称) ,但是文字不要显示出来。 方法1 : text-indent移到盒子外面( text-indent:-9999px) ,然后overflow:hidden ,淘宝的做法。 方法2 :直接给font-size:0;就看不到文字了,京东的做法。 4,最后给链接一个title属性,这样鼠标放到logo上就可以看到提示文字了。","categories":[{"name":"前端","slug":"前端","permalink":"https://2486125878.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://2486125878.github.io/tags/HTML/"}]},{"title":"‘HTML高级’","slug":"‘HTML高级’","date":"2024-03-13T08:53:07.000Z","updated":"2024-03-13T08:57:14.000Z","comments":true,"path":"2024/03/13/‘HTML高级’/","permalink":"https://2486125878.github.io/2024/03/13/%E2%80%98HTML%E9%AB%98%E7%BA%A7%E2%80%99/","excerpt":"","text":"高级部分4.2D转换转换(transform )是CSS3中具有颠覆性的特征之一,可以实现元素的位移、旋转、缩放等效果 转换(transform)你可以简单理解为变形 移动: translate 旋转: rotate 缩放: scale 4.1二维坐标系2D转换是改变标签在二维平面上的位置和形的一种技术,先来学习二维坐标系 4.2 2D转换之移动translate2D移动是2D转换里面的一种功能,可以改变元素在页面中的位置,类似定位。 1.语法 transform: translate(x, y);或者分开写 tansform: translatex(n); transform: translaterY (n); 2.重点 定义2D转换中的移动,沿着X和Y轴移动元素 translate最大的优点:不会影响到其他元素的位置 translate中的百分比单位是相对于自身元素的translate:(50%,50%); 对行内标签没有效果 我们tranlate面的参数是可以用% 如果里面的参数是%移动的距离是盒子自身的宽度或者高度来对比的 4.3 2D转换之旋转rotate2D旋转指的是让元素在2维平面内顺时针旋转或者逆时针旋转。 1.语法 transform:rotate (度数) 2.重点rotate里面跟度数,单位是deg比如rotate(45deg) 角度为正时,顺时针,负时,另逆时针 默认旋转的中心点是元素的中心点 4.4 2D转换中心点transform-origin我们可以设置元素转换的中心点 1,语法 transform-origin: x y; 2.重点 注意后面的参数x和y用空格隔开 x y默认转换的中心点是元素的中心点(50% 50%) 还可以给x y设置像素或者方位名词(top bottom left right center) 4.5 2D转换之缩放scale缩放,顾名思义,可以放大和缩小。只要给元素添加上了这个属性就能控制它放大还是缩小。 1.语法 transform:scale(x,y); 2.注意 注意其中的x和y用逗号分隔 transform:scale(1,1) :宽和高都放大一倍,相对于没有放大 transform:scale(2,2) :宽和高都放大了2倍 transform:scale(2) :只写一个参数,第二个参数则和第一个参数一样,相当于scale(2,2) transform:scale(0.5,0.5) :缩小 sacle缩放最大的优势:可以设置转换中心点缩放,默认以中心点缩放的,而且不影响其他盒子 4.6 2D转换综合写法注意： 1,同时使用多个转换,其格式为: transform: translate0 rotate0 scale（）… 2,其顺序会影转换的效果。(先旋转会改变坐标轴方向) 3,当我们同时有位移和其他属性的时候,记得要将位移放到最前 4.7 2D转换总结转换transform我们简单理解就是变形有2D和3D之分 我们暂且学了三个分别是位移旋轼和缩放 2D移动translate(x，y)最大的优势是不影响其他盒子,里面参数用% ,是相对于自身宽度和高度来计算的 可以分开写比如translatex(x)和translateY(y) 2D旋转rotate(度数) 可以实现旋转元素度数的单位是deg 2D缩放sacle(x,y) 里面参数是数字不跟单位 可以是小数 最大的优势不影响其他盒子 设置转换中心点transform-origin : x y; 参数可以百分比、像索或者是方位名词 当我们进行综合写法,同时有位移和其他属性的时候,记得要将位移放到最前 5.动画5.1动画的基本使用制作动画分为两步: 1.先定义动画 2.再使用(调用)动画 1,用keyframes定义动画(类似定义类选择器)@keyframes动画名{ ​ 0%{ ​ width: 100px; ​ } ​ 100%{ ​ width: 200px; ​ } } 动画序列0%是动画的开始, 100%是动画的完成。这样的规则就是动画序列。 在@keyframes中规定某项CSS样式,就能创建由当前样式逐渐改为新样式的动画效果。 动画是使元素从一种样式逐渐变化为另一种样式的效果。您可以改变任意多的样式任意多的次数。 请用百分比来规定变化发生的时间,或用关键词”from”和”to”,等同于0%和100% 2.元素使用动画div{ ​ width: 200px; ​ height: 200px; ​ background-color: aqua; ​ margin: 100px auto; ​ &#x2F;调用动画&#x2F; ​ animation-name:动画名称; ​ &#x2F;持续时间&#x2F; ​ animation-duration:持续时间; ​ } 5.2动画常用属性属性 描述 @keyframes 规定动画。 animation 所有动画属性的简写属性,除了animation-play-state属性, animation-name 规定@keyframes动画的名称。(必须的) animation-duration 规定动画完成一个周期所花费的秒或毫秒,默认是0, (必须的) animation-timing-function 规定动画的速度曲线,默认是”ease” animation-delay 规定动画何时开始,默认是0。 animation-iteration-count 规定动画被播放的次数,默认是1,还有infinite animation-direction 规定动画是否在下一周期逆向播放,默认是”normal “,alternate逆播放 animation-play-state 规定动画是否正在运行或暂停。默认是running,还有pause” animation-fill-mode 规定动画结束后状态,保持forwards回到起始backwards 5.3动画简写属性animation :动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 动画起始或者结束的状态 animation: myfirst 5s linear 2s infinite alternate; 简写属性里面不包含animation-play-state 暂停动画: animation-play-state: puased;经常和鼠标经过等其他配合使用, 想要动画走回来,而不是直接跳回来: animation-direction : alternate 盒子动画结束后,停在结束位置: animation-fill-mode : forwards 5.4速度曲线细节animation-timing-function :规定动画的速度曲线,默认是”ease” 值 描述 linear 动画从头到尾的速度是相同的。匀速 ease 默认。动画以低速开始,然后加快,在结束前变慢。 ease-in 动画以低速开始。 ease-out 动画以低速结束。 ease-in-out 动以低速开始和结束。 steps（） 指定了时间函数中的间隔数量(步长) 6.3D转换我们生活的环境是3D的,照片就是3D物体在2D平面呈现的例子。 有什么特点 近大远小 物体后面遮挡不可见 当我们在网页上构建3D效果的时候参考这些特点就能产出3D效果。 6.1三维坐标系三维坐标系其实就是指立体空间,立体空间是由3个轴共同组成的。 x轴:水平向右 注意: x右边是正值,左边是负值 y轴:垂直向下 注意: y下面是正值,上面是负值 z轴:垂直屏幕 注意:往外面是正值,往里面是负值 6.2 3D移动translate3d3D移动在2D移动的基础上多加了一个可以移动的方向,就是Z轴方向。 translform:translatex(100px) :仅仅是在x轴上移动 translform:translateY(100px) :仅是在Y轴上移动 translform:translateZ(100px) :仅仅是在Z轴上移动(注意: translateZ-般用px单位) transform:translate3d(x,y,z) :其中x、y、z分别指要移动的轴的方向的距离 6.3透视perspective在2D平面产生近大远小视觉立体,但是只是效果一维的 如果想要在网页产生3D效果需要透视(理解成3D物体投影在2D平面内). 模拟人类的视觉位置,可认为安排一只跟睛去看 透视我们也称为视距:视距就是人的眼睛到屏幕的距离, 距离视觉点越近的在电脑平面成像越大,越远成像越小 透视的单位是像素 透视写在被观察元素的父盒子上面的 d:就是视距,视距就是一个距离人的眼睛到屏幕的距离。 z:就是z轴,物体距离屏幕z的距离,z轴越大(正值)我们看到的物体就越大. 6.4 translateZtranslform:translatez(100px) :仅仅是在Z轴上移动。 有了透视,就能看到translatez引起的变化了 6.5 3D旋转rotate3d3D旋转指可以让元素在三维平面内沿着x轴, y轴,z轴或者自定义轴进行旋转。 语法 transform:rotatex(45deg) :沿着x轴正方向旋转45底 transform.rolateY(45deg) :沿看y轴正方向旋转45deg transform:rotate (45deg) :沿着Z轴正方向旋转45deg transform:rotate3d(x.y.z deg) :沿着自定义轴旋转deg为角度(了解即可) xyz是表示旋转轴的矢量,是标示你是否希望沿着该轴旋转,最后一个标示旋转的角度。 左手准则 左手的手拇指指向x轴的正方向 其余手指的弯曲方向就是该元素沿着x轴旋转的方向 左手准则 左手的手拇指指向y轴的正方向 其余手指的弯曲方向就是该元素沿着y轴旋转的方向(正值) transform:rotate3d(1,0,0,45deg)就是沿着x轴旋转45deg transform:rotate3d(1,1,0,45deg)就是沿着对角线旋转45deg 6.6 3D呈现transfrom-style控制子元素是否开启三维立体环境 transform-style: flat子元素不开启3d立体空间默认的 transform-style: preserve-3d:子元素开启立体空间 代码写给父级,但是影响的是子盒子 这个属性很重要,后面必用 7.浏览器私有前缀浏览器私有前缀是为了兼容老版本的写法,比较新版本的浏览器无须添加。 1.私有前缀-moz-:代表firefox浏览器私有属性 -ms-:代表ie浏览器私有属性 -webkit-:代表safari, chrome私有属性 -0-:代表Opera私有属性 2.提倡的写法-moz-border-radius: 10px; -webkit-border-fadius: 10px; -o-border-radius: 10px; border-radius: 10px;","categories":[{"name":"前端","slug":"前端","permalink":"https://2486125878.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://2486125878.github.io/tags/HTML/"}]},{"title":"SSM","slug":"SSM","date":"2024-03-13T07:40:53.000Z","updated":"2024-03-13T08:22:50.000Z","comments":true,"path":"2024/03/13/SSM/","permalink":"https://2486125878.github.io/2024/03/13/SSM/","excerpt":"","text":"1.Spring简介1.1 Spring是什么Spring是分层的Java SE&#x2F;EE应用full-stack轻量级开源框架,以loc ( Inverse Of Control :反转控制)和AOP (Aspect Oriented Programming :面向切面编程)为内核。 提供了展现层SpringMVC和持久层Spring JDBCTemplate以及业务层事务管理等众多的企业级应用技术还能整合开源世界众多著名的第三方框架和类库,逐渐成为使用最多的JavaEE企业应用开源框架。 1.2 Spring发展历程1997年, IBM提出了EjB的思想 1998年, SUN制定开发标准规范EjB1.0 1999年, EJB1.1发布 2001年, EJB2.0发布 2003年, EJB2.1发布 2006年, EJB3.0发布 Rod Johnson (Spring之父)Expert One-to-One J2EE Design and Development(2002)阐述yJ2EE使用EJB开发设计的优点及解决方案 Expert One-to-One J2EE Development without EJB(2004)阐述了J2EE开发不使用EJB的解决方式(Spring雏形) 2017年9月份发布了Spring的最新版本Spring5.0通用版(GA) 1.3 Spring的优势1)方便解耦,简化开发Spring提供的loC容器,可以将对象间的依赖关系交由Spring进行控制,避免硬编码所造成的过度耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码,可以更专注于上层的应用。 2) AOP编程的支持通过Spring的AOP功能,方便进行面向切面编程,许多不容易用传统OOP实现的功能可以通过AOP轻松实现。 3)声明式事务的支持可以将我们从单调烦闷的事务管理代码中解脱出来,通过声明式方式灵活的进行事务管理,提高开发效率和质量。 4)方便程序的测试可以用非容器依赖的编程方式进行几乎所有的测试工作,测试不再是昂贵的操作,而是随手可做的事情。 5)方便集成各种优秀框架Spring对各种优秀框架(Struts, Hibernate, Hessian、 Quart等)的支持。 6)降低JavaEE API的使用难度Spring对JavaEE API (如JDBC、 JavaMail、远程调用等)进行了薄薄的封装层,使这些API的使用难度大为降低。 7.Java源码是经典学习范例Spring的源代码设计精妙、结构清晰、匠心独用,处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。它的源代码无意是Java技术的最佳实践的范例。 1.4 Spring的体系结构 2.Spring快速入门2.1 Spring程序开发步骤 导入Spring开发的基本包坐标 编写Dao接口和实现类 创建Spring核心配置文件 在Spring配置文件中配置UserDaolmpl 使用Spring的API获得Bean实例 Spring的开发步骤@导入坐标 ②创建Bean ③创建applicationContext.xml在配置文件中进行配置 ⑤创建ApplicationContext对象getBean 3.Spring配置文件3.1 Bean标签基本配置用于配置对象交由Spring来创建。 默认情况下它调用的是类中的无参构,函散,如果没有无参构造函数则不能创建成功。 基本属性 id: Bean实例在Spring器中的唯一标识 class: Bean的全限定名称 3.2 Bean标签范围配置scope:指对象的作用范围,取值如下: 取值范围 说明 singleton 默认值,单例的 prototype 多例的 request WEB项目中, Spring创建一个Bean的对象,将对象存入到request域中 session WEB项目中, Spring创建一个Bean的对象,将对象存入到session域中 global session WEB项目中,应用在Portlet环境,如果没有Portlet环境那么globalSession相当于session 1)当scope的取值为singleton时 Bean的实例化个数: 1个 Bean的实例化时机:当Spring核心文件被加时,实例化配置的Bean实例 Bean的生命周期: ​ 对象创建:当应用加载,创建容器时,对象就被创建了 ​ 对象运行：只要容器在,对象一直活着 ​ 对象销毁:当应用卸载,销毁容器时,对象就被销毁了 2)当scope的取值为prototype时 Bean的实例化个数:多 Bean的实例化时机:当调用getBean0方法时实例化Bean ​ 对象创建:当使用对象时,创建新的对象实例 ​ 对象运行:只要对象在使用中,就一直活着 ​ 对象销毁:当对象长时间不用时,被Java的垃圾回收器回收了 3.3 Bean生命周期配置init-method:指定类中的初始化方法名称 destroy-method:指定类中销毁方法名称 3.4 Bean实例化三种方式无参构造方法实例化 工厂静态方法实例化 工厂实例方法实例化 3.6 Bean的依赖注入分析目前UserService实例和UserDao实例都存在与Spring容器中,当前的做法是在容器外部获得UserService实例和UserDao实例,然后在程序中进行结合。 因为UserService和UserDao都在Spring容器中,而最终程序直接使用的是UserService,所以可以在Spring容器中,将UserDao设置到UserService内部。 3.7 Bean的依赖注入概念依赖注入(Dependency Injection) :它是Spring框架核心lOC的具体实现。 在编写程序时,通过控制反转,把对象的创建交给了Spring,但是代码中不可能出现没有依赖的情况。 lOC解耦只是降低他们的依赖关系,但不会消除。例如:业务层仍会调用持久层的方法。 那这种业务层和持久层的依赖关系,在使用Spring之后,就让Spring来维护了简单的说,就是坐等框架把持久层对象传入业务层,而不用我们自己去获取。 3.7 Bean的依赖注入方式怎么将UserDao怎样注入到Userservice内部呢? 构造方法 set方法 3.7 Bean的依赖注入方式1.set方法注入 p命名空间注入本质也是set方法注入,但比起上述的set方法注入更加防便,主要体现在配置文件中,如下:首先,需要引入P命名空间: xmlns:p&#x3D;”http://www.springframework.org/schema/p 其次,需要修改注入方式 3.8 Bean的依赖注入的数据类型上面的操作,都是注入的引用Bean,除了对象的引用可以注入,普通数据类型,集合等都可以在容器中进行注入 注入数据的三种数据类型 普通数据类型 引用数据类型 集合数据类型 3.9引入其他配置文件(分模块开发)实际开发中, Spring的配置内容非常多,这就导致Spring配置很繁杂目体积很大,所以,可以将部分配置拆解到其他配置文件中,而在Spring主配置文件通过import标签进行加载 3.6知识要点Spring的重点配置 标签 id属性:在容器中Bean实例的唯一标识,不允许重复 class属性:要实例化的Bean的全限定名 scope属性:Bean的作用范围,常用是singleton (默认)和prototype 标签:属性注入 name属性:属性名称 value属性:注入的普通属性值 ref属性:注入的对象引用值 标签 1.标签 标签 标签 标签:导入其他的Spring的分文件 4.Spring相API4.1 ApplicationContext继承体系applicationContext:接口类型,代表应用上下文,可以通过其实例获得Spring容器中的Bean对象 4.2 ApplicationContext的实现类ClassPathXmlApplicationContext 它是从类的根路径下加载配置文件推荐使用这种 FileSystemXmlApplicationContext 它是从磁盘路径上加载配置文件,配置文件可以在磁盘的任意位置。 AnnotationConfigApplicationContext 当使用注解配置容器对象时,需要使用此类来创健spring容器。它用来读取注解。 4.3 getBean()方法使用123456789获取id形式public object getBean(string name) throws BeansException &#123; assertBeanEactorvactive (); return getBeanFactory().getBean(name);&#125;public &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException &#123; assertBeanFactorvActive(); return getBeanFactory().getBean (requiredType);&#125; 其中,当参数的数据类型是字符串时,表示根据Bean的id从容器中获得Bean实例,返回是Object,需要强转。当参数的数据类型是Class类型时,表示根据类型从容器中匹配Bean实例,当容器中相同类型的Bean有多个时则此方法会报错。 4.4知识要点Spring的重点API123ApplicationContext app = new classpathxmlApplicationContext (&quot;xml文件&quot;) app.getBean (&quot;id&quot;) app.getBean (Class) 1.Spring配置数据源1.1数据源(连接池)的作用数据源(连接池)是提高程序性能如出现的 事先实例化数据源,初始化部分连接资源 使用连接资源时从数据源中获取 使用完毕后将连接资源还给数据源 常见的数据源(连接池): DBCP, C3P0, BoneCP, Druid等 1.1数据源的开发步骤导入数据源的坐标和数据库驱动坐标 创建数据源对象 设置数据源的基本连接数据 使用数据源获取连接资源和归还连接资源 1.2数据源的手动创建12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class DataSouceTest &#123; @Test //测试手动创建c3p0数据源(加载properties配置文件) public void test3() throws Exception&#123; //读取配置文件 ResourceBundle rb = ResourceBundle.getBundle(&quot;jdbc&quot;); String driver= rb.getString(&quot;jdbc.driver&quot;); String url=rb.getString(&quot;jdbc.url&quot;); String username=rb.getString(&quot;jdbc.username&quot;); String password= rb.getString(&quot;jdbc.password&quot;); //创建数据源对象 ComboPooledDataSource dataSource=new ComboPooledDataSource(); dataSource.setDriverClass(driver); dataSource.setJdbcUrl(url); dataSource.setUser(username); dataSource.setPassword(password); Connection connection = dataSource.getConnection(); System.out.println(connection); connection.close(); &#125; @Test //测试手动创建druid数据源 public void test2() throws Exception&#123; DruidDataSource dataSource=new DruidDataSource(); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/db1&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;123456&quot;); DruidPooledConnection connection = dataSource.getConnection(); System.out.println(connection); connection.close(); &#125; @Test //测试手动创建c3p0数据源 public void test1() throws PropertyVetoException, SQLException &#123; ComboPooledDataSource dataSource=new ComboPooledDataSource(); dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/db1&quot;); dataSource.setUser(&quot;root&quot;); dataSource.setPassword(&quot;123456&quot;); Connection connection=dataSource.getConnection(); System.out.println(connection); connection.close(); &#125;&#125; 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/db1jdbc.username=rootjdbc.password=123456 1.3 Spring配置数据源可以将DataSource的创建权交由Spring容器去完成 12345678910public class DataSouceTest &#123; @Test //测试spring容器去产生数据源对象 public void test4() throws Exception&#123; ApplicationContext app=new ClassPathXmlApplicationContext(&quot;applicationContent.xml&quot;); DataSource dataSource = app.getBean(DataSource.class); Connection connection = dataSource.getConnection(); System.out.println(connection); connection.close(); &#125; 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;dataSouce&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/db1&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 1.4抽取jdbc配置文件applicationContext.xml加载jdbc.properties配置文件获得连接信息。 首先,需要引入context命名空间和约束路径: 命名空间: xmlns:context&#x3D;”http://www.springframework.org/schema/context“ 约束路径: http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd 1234567&lt;context:property-placeholder location=&quot;classpath: jdbc.properties&quot;/&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource &quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property names&quot;jdbaUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdba.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt; 1.5知识要点Spring容器加载properties文件 12&lt;context :property-placeholder location=&quot;xx.properties&quot;/&gt; &lt;property name=&quot;&quot; value=&quot;$&#123;key&#125;&quot;/&gt; 2.Spring注解开发2.1 Spring原始注解Spring是轻代码而重配置的框架,配置比较繁重,影响开发效率,所以注解开发是一种趋势,注解代替xml配置文件可以简化配置,提高开发效率。 Spring原始注解主要是替代的配置 注解 说明 @Component 使用在类上用于实例化Bean @Controller 使用在web层类上用于实例化Bean @Service 使用在service层类上用于实例化Bean @Repository 使用在dao层类上用于实例化Bean @Autowired 使用在字段上用于根据类型依赖注入 @Qualifier 结合@Autowired一起使用用于根据名称进行依赖注入 @Resource 相当于@Autowired+@Qualifier,按照名称进行注入 @Value 注入普通属性 @Scope 标注Bean的作用范围 @PostConstruct 使用在方法上标注该方法是Bean的初始化方法 @PreDestroy 使用在方法上标注该方法是Bean的销毁方法 注意:使用注解进行开发时,需要在applicationContext.xml中配置组件扫描,作用是指定哪个包及其子包下的Bean需要进行扫描以便识别使用注解配置的类、字段和方法。 123&lt;!--注解的组件扫描--&gt;&lt;context :component-scan base-package=&quot;com.itheima&quot;&gt; &lt;/context:component-scan&gt; 2.Spring注解开发2.2 Spring新注解使用上面的注解还不能全部替代xml配置文件,还需要使用注解替代的配置如下: 非自定义的Bean的配置: 加载properties文件的配置:context:property-placeholder **组件扫描的配置: context:component-scan** 引入其他文件: ​ 注解 说明 @Configuration 用于指定当前类是一个Spring配置类,当创建容器时会从该类上加载注解 @ComponentScan 用于指定Spring在初始化容器时要扫描的包。 ​ 作用和在Spring的xml配置文件中的 ​ &lt;context:component-scan base-package&#x3D;”com.itheima’&#x2F;&gt;一样 @Bean 使用在方法上,标注将该方法的返回值存储到Spring容器中 @PropertySource 用于加载.properties文件中的配置 @lmport 用于导入其他配置类 3.Spring集成Junit3.1原始Junit测试Spring的问题在测试类中,每个测试方法都有以下两行代码: 12ApplicationContext app=new AnnotationConfigApplicationContext(&quot;bean.xml&quot;); UserService userService = app.getBean(&quot;accountService&quot;,IAccountService.class); 这两行代码的作用是获取容器,如果不写的话,直接会提示空指针异常。所以又不能轻易删掉 3.2上述问题解决思路让SpringJunit负责创建Spring容器,但是需要将配置文件的名称告诉它 将需要进行测试Bean直接在测试类中进行注入 3.3 Spring集成Junit步骤导入spring集成Junit的坐标 使用@Runwith注解替换原来的运行期 使用@ContextConfiguration指定配置文件或配置类 使用@Autowired注入需要测试的对象 创建测试方法进行测试 1.Spring集成web环境1.1 ApplicationContext应用上下文获取方式应用上下文对象是通过new ClasspathXmlApplicationContext(spring配置文件)方式获取的,但是每次从容器中获得Bean时都要编写new ClasspathXmlApplicationContext(spring配置文件),这样的弊端是配置文件加载多次,应用上下文对象创建多次。 在Web项目中,可以使用ServletContextListener监听Web应用的启动,我们可以在Web应用启动时,就加载Spring的配置文件,创建应用上下文对象ApplicationContext,在将其存储到最大的域servletContexttd中,这样就可以在任意位置从域中获得应用上下文ApplicationContext对象了。 1.2 Spring提供获取应用上下文的工具上面的分析不用手动实现, Spring提供了一个监听器ContextLoaderListener就是对上述功能的封装,该监听器内部加载Spring配置文件,创建应用上下文对象,并存储到ServletContext域中,提供了一个客户端工具WebApplicationContextUtils供使用者获得应用上下文对象。 所以我们需要做的只有两件事: ① 在web.xml中配置ContextLoaderListener监听器(导入spring-web坐标) ② 使用WebApplicationContextUtils获应用上下文对象ApplicationContext 1.3导入Spring集成web的坐标12345&lt;dependenoy&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; 1.4 配置ContextLoaderListener监听器1234567891011&lt;!--全局参数--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationcontext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!--Spring的监听器--&gt;&lt;listener&gt; &lt;listener-class&gt; org. springframework.web.context.Context LoaderListener &lt;/listener-class&gt;&lt;/listener&gt; 1.5通过工具获得应用上下文对象12ApplicationContext applicationContext =webapplicationcontextutils.getwebApplicationContext(servletcontext);Object obj = applicationContext.getBean (&quot;id&quot;); 1.5知识要点Spring集成web环境步骤 ①配置GontextLoaderListener监听器 ②使用WebApplicationContextUtils获得应用上下文 2.SpringMVC 简介2.1 SpringMVC概述SpringMVC是一种基于Java的实现MVC设计模型的请求驱动类型的轻量级Web框架,属于SpringFrameWork的后续产品,已经融合在Spring Web Flow中。 模型-视图-控制 SpringMVC已经成为目前最主流的MVC框架之一,并且随着Spring3.0的发布,全面超越Struts2,成为最优秀的MVC框架。它通过一套注解,让一个简单的Java类成为处理请求的控制器,而无须实现任何接口。同时它还支持RESTful编程风格的请求。 2.3 SpringMVC快速入门需求:客户端发起请求,服务器端接收请求,执行逻辑并进行视图跳转。 开发步骤: ①导入SpringMVC相关坐标 ② 配置SpringMVC核心控制器DispathcerServlet 3.创建Controller类和视图页面 4.使用注解配置Controller类中业务方法的映射地址 5.配置SpringMVC核心文件spring-mvc.xml 6.客户端发起请求测试 3.SpringMVC 组件解析3.1 SpringMVC的执行流程①用户发送请求至前端控制器DispatcherServlet, ② DispatcherServlet收到请求调用HandlerMapping处理器映射器。 ③处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找),生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet, 4.DispatcherServlet调用HandlerAdapter处理器适配器。 5.HandlerAdapter经过适配调用具体的处理器(Controller, 也叫后端控制器)。 6 Controller执行完成返回ModelAndView. 7.HandlerAdaptercontroller执行结果ModelAndView返回给DispatcherServlet. 8.DispatcherServletModelAndView传给ViewReslover视图解析器。 9.ViewReslover解析后返回具体View. 10.DispatcherServlet根据View进行演染视图(即将模型数据填充至视图中) .DispatcherServlet响应用户。 3.3 SpringMVC注解解析@RequestMapping 作用:用于建立请求URL和处理请求方法之间的对应关系 位置:. 类上,请求URL的第一级访问目录。此处不写的话,就相当于应用的根目录. 方法上,请求URL的第二级访问目录,与类上的使用@ReqquestMapping标注的一级目录一起组成访问虚拟路径属性: .value:用于指定请求的URL.它和path属性的作用是一样的 .method:用于指定请求的方式 .params:用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和(value必须和配置的一模一样 params &#x3D; [“accountName”), 表示请求参数必须有accountName params &#x3D; [“moeny!100”), 表示请求参数中money不能是100 1.mvc命名空间引入 命名空:xmlns: context&#x3D;”http://www.springframework.org/schema/context&quot;xmlns:mvc=&quot;http://www.springframework.org/schema/mvo“ 约束地址: http://www. springframework. org&#x2F;schema&#x2F;contexthttp: &#x2F;&#x2F;www. springframework.org&#x2F;schema&#x2F;aontext&#x2F;spring-aontext. xsdhttp: &#x2F;&#x2F;www.springframework. org&#x2F;schema&#x2F;mvahttp://www.apringframework.org/schema/mvo/spring-mva. xad 2.组件扫描 springMvc基于spring容器,所以在进行springMVc操作时,需要将controller存储到spring容器中,如果使用econtroller注解标注的话,就需要使用 &lt;context:component-scan basepackage&#x3D;”com. itheima. controller”&#x2F;&gt;进行组件扫描。 3.4 SpringMVC的XML配置解析1.视图解析器 SpringMVc有默认组件配置,默认组件都是DispatcherServlet.properties配置文件中配置的,该配置文件地址org&#x2F;springframework&#x2F;web&#x2F;servlet&#x2F;DispatcherServlet.properties,该文件中配置了默认的视图解析器,如下: 1org.springframework.web.servlet. ViewResolver=org.springframework. web.servlet.view.InternalResourceViewResolver 翻看该解析器源码,可以看到该解析器的默认设置,如下: 1234REDIRECT_URL_PREFIX = &quot;redireat:&quot; --重定前缀FORWARD_URL_PREFIx = &quot;forward:&quot; --转发前缀(默认值)prefix = &quot;&quot;; --视图名称前缀suffix =&quot;&quot;;--视图名称后缀 3.5 知识要点1234567891011121314SpringMVC的相关组件前端控制器: DispatcherServlet处理器映射器: HandlerMapping处理器适配器: HandlerAdapter处理器: Handler视图解析器: View Resolver视图: ViewSpringMVC的注解和配置请求映射注解: @RequestMapping视图解析器配置:REDIRECT_URL_PREFIX = &quot;redirect:&quot;FORWARD_URL_PREFIX = &quot;forward:&quot;prefix= &quot;&quot;suffix= &quot;&quot; 1.SpringMVC的数据响应1.1 SpringMVC的数据响应方式1)页面跳转. 直接返回字符串 通过ModelAndView对象返回 2)回写数据 直接返回字符串 返回对象或集合 1.2页面跳转1.返回字符串形式直接返回字符串:此种方式会将返回的字符串与视图解析器的前后缀拼接后跳转。 1234@RequestMapping (&quot;/quiak&quot;)publia string quickMethod ()&#123; return &quot;index&quot;;&#125; 12&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INE/views/&quot; /&gt;&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; 转发资源地址: &#x2F;WEB-INE&#x2F;views&#x2F;index.jsp 返回带有前缀的字符串: 转发: forward:&#x2F;WEB-INE&#x2F;views&#x2F;index. jsp 重定向: redirect:&#x2F;index. jsp 2.返回ModelAndView对象 123456789101112131415161718192021222324252627282930313233343536373839404142@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(value = &quot;/quick4&quot;) public String save4(Model model)&#123; model.addAttribute(&quot;username&quot;,&quot;博学谷&quot;); return &quot;success&quot;; &#125; @RequestMapping(value = &quot;/quick3&quot;) public ModelAndView save3(ModelAndView modelAndView)&#123; //设置模型数据 modelAndView.addObject(&quot;username&quot;,&quot;itheima555&quot;); //设置视图名称 modelAndView.setViewName(&quot;success&quot;); return modelAndView; &#125; @RequestMapping(value = &quot;/quick2&quot;) public ModelAndView save2()&#123;// Model:模型作用封装数据// view:作用展示数据 ModelAndView modelAndView= new ModelAndView(); //设置模型数据 modelAndView.addObject(&quot;username&quot;,&quot;itcat&quot;); //设置视图名称 modelAndView.setViewName(&quot;success&quot;); return modelAndView; &#125; //请求映射 请求地址http://local:8080/user/quick @RequestMapping(value = &quot;/quick&quot;,method = RequestMethod.GET,params = &#123;&quot;username&quot;&#125;) public String save()&#123; System.out.println(&quot;controller save running web&quot;); return &quot;success&quot;; &#125;&#125; 1.3回写数据1.直接返回字符串 Web基础阶段,客户端访问服务器端,如果想直接回写字符串作为响应体返回的话,只需要使用response.getWriter().print( “hello world” )即可,那么在Controller中想直接回写字符串该怎样呢? 通过SpringMVC框架注入的response对象,使用response.getWriterO.print( “hello world” )回写数据,此时不需要视图跳转,业务方法返回值为void. 1234@RequestMapping (&quot;/quick4&quot;)public void quickMethod4 (Httpserfletresponse response) throwsIOException&#123; response.getwriter().print (&quot;hello world&quot;);&#125; 将需要回写的字符串直接返回,但此时需要通过@ResponseBody注解告知SpringMVC框架,方法返回的字符串不是跳转是直接在http响应体中返回。 12345@RequestMapping (&quot;/quick5&quot;)@ResponseBodypublic string quickMethod5 () throws IOException&#123; return &quot;hello springMVC!!!&quot;;&#125; 2.返回对象或集合 通过SpringMVC帮助我们对对象或集合进行json字符串的转换并回写,为处理器适配器配置消息转换参数,指定使用jackson进行对象或集合的转换,因此需要在spring-mvc.xml中进行如下配置: 1234567&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt; &lt;property name=&quot;messageConverters&quot;&gt; &lt;list&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;&lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 在方法上添加@ResponseBody就可以返回json格式的字符串,但是这样配置比较麻烦,配置的代码比较多,因此,我们可以使用mvc的注解驱动代替上述配置。 12&lt;!--mvc的注解驱动--&gt;&lt;mvc: annotation-driven/&gt; 在SpringMVC的各个组件中,处理器映射器、处理器适配器、视图解析器称为SpringMVC的三大组件。使用mvc:annotation-driven自动加载 RequestMappingHandlerMapping (处理映射器)和RequestMappingHandlerAdapter (处理适配器),可用在Spring-xml.xml配置文件中使用mvc:annotation-driven替代注解处理器和适配器的配置。同时使用mvc:annotation-driven默认底层就会集成jackson进行对象或集合的json格式字符串的转换。 1.4 知识要点SpringMVC的数据响应方式 1)页面跳转 .直接返回字符 .通过ModelAndView对象返回 2)回写数据 .直接返回字符串 .返回对象或集合 2.SpringMVC 获得请求数据2.1获得请求参数客户端请求参数的格式是: name&#x3D;value&amp;name&#x3D;value…… 服务器端要获得请求的参数,有时还需要进行数据的封装, SpringMVC可以接收如下类型的参数: 基本类型参数 POJO类型参数 数组类型参数 集合类型参数 2.2获得基本类型参数Controller中的业务方法的参数名称要与请求参数的name一致,参数值会自动映射匹配。 http://localhost:8080/itheima_springmvcl/quick9?username=zhangsan&amp;age=12 123456@RequestMapping (&quot;/quick9&quot;)@ResponseBodypublic void quickMethod9 (String username, int age) throws IOException &#123; System.out.println (username); System.out.println (age);&#125; 2.3 获得POJO类型参数Controller中的业务方法的POJO参数的属性名与请求参数的name一致,参数值会自动映射匹配。 http;&#x2F;&#x2F;loca1host: 8080&#x2F;itheima springmvc1&#x2F;quick9?cname&#x3D;zhangsan&amp;age&#x3D;12 1234567891011public class User &#123; private String username; private int age; getter/setter... &#125;@RequestMapsing (&quot;/quick10&quot;)@ResponseBodypublic void quickMethod10 (User user) throws IOException &#123; System.out.println (user);&#125; 2.4获得数组类型参数Controller中的业务方法数组名称与请求参数的name致,参数值会自动映射匹配。 http://localhost:8080/itheima_springmvc1/quick11?strs=111&amp;strs=222&amp;strs=333 12345@RequestMapping (&quot;/quick11&quot;)@ResponseBodypublic void quickMethod11 (String [] strs) throws IOException &#123; System.out.println (Arrays.asList (strs));&#125; 2.5获得集合类型参数获得集合参数时,要将集合参数包装到一个POJO中才可以。 当使用ajax提交时,可以指定contentType为json形式,那么在方法参数位置使用@RequestBody可以直接接收集合数据而无需使用POJO进行包装。 12345678910111213 &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/js/jqury.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var userList=new Array(); userList.push(&#123;username:&quot;zhangsan&quot;,age:&quot;18&quot;&#125;) userList.push(&#123;username:&quot;lisi&quot;,age:&quot;30&quot;&#125;); $.ajax(&#123; type:&quot;post&quot;, url:&quot;$&#123;pageContext.request.contextPath&#125;/user/quick15&quot;, data:JSON.stringify(userList), contentType:&quot;application/json;charset=utf-8&quot; &#125;)&lt;/script&gt; 2.6请求数据乱码问题当post请求时,数据会出现乱码,我们可以设置一个过滤器来进行编码的过滤。 123456789101112&lt;filter&gt; &lt;filter-name&gt;Characterencodingrilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web. filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 2.7 参数定注解@requestParam当请求的参数名称与Controller的业务方法参数名称不一致时,就需要通过@RequestParam注解显示的绑定。 1234&lt;form action=&quot;$(pageContext.request.contextPath]/quick14&quot; method= &quot;post&quot;&gt; &lt;input type=&quot; text&quot; name=&quot; name &quot;&gt;&lt;br&gt; &lt;input type=&quot; submit&quot; value=&quot;提交&quot;&gt;&lt;br&gt;&lt;/form&gt; 12345@RequestMapping (&quot;/quick14&quot;)@ResponseBodypublic void quickMethod14 (@RequestParam (&quot;name&quot;) String username) throws IOException &#123; System.out.println (username);&#125; 注解@RequestParam还有如下参数可以使用: .value:与请求参数名称 .required:此在指定的请求参数是否必须包括,默认是true,提交时如果没有此参数则报错 .defaultValue:当没有指定请求参数时,则使用指定的默认值赋值 1@RequestMapping (&quot;/quick14&quot;)@ResponseBodypublic void quickMethod14 (@RequestParam (value=&quot;name&quot;, required= false, defaultvalue = &quot;itcast&quot;) string username) throws IOException &#123; System.out.println (username);&#125; 2.8 获得Restful风格的参数Restful是一种软件架构风格、设计风格,而不是标准,只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件,基于这个风格设计的软件可以更简洁,更有层次,更易于实现缓存机制等。 Restful风格的请求是使用”url+请求方式”表示一次请求目的的,HTTP协议里面四个表示操作方式的动词如下: .GET:用于获取资源 .POST:用于新建资源 .PUT:用于更新资源 .DELETE:用于删除资源 例如: &#x2F;user&#x2F;1 GET: 得到id &#x3D; 1的user &#x2F;user&#x2F;1 DELETE: 删除id &#x3D; 1的user &#x2F;user&#x2F;1 PUT: 更新id &#x3D; 1的user &#x2F;user&#x2F;1 POST: 新增user 上述url地址&#x2F;user&#x2F;1中的1就是要获得的请求参数,在SpringMVC中可以使用占位符进行参数绑定。地址&#x2F;user&#x2F;1可以写成&#x2F;user&#x2F;(id),占位符(id对应的就是1的值。在业务方法中我们可以使用@PathVariable注解进行占位符的匹配获取工作。 1234567http://localhost: 8080/itheima_springmvc1/quick19/zhangsan@RequestMapping (&quot;/quick19/&#123;name&#125;&quot;)@ResponseBody public void quickMethod19 (@Pathvariable (value=&quot;name &quot;required = true) string name) &#123; System.out.println(name); &#125; 2.9自定义类型转换器SpringMVC默认已经提供了一些常用的类型转换器,例如客户端提交的字符串转换成int型进行参数设置。 但是不是所有的数据类型都提供了转换器,没有提供的就需要自定义转换器,例如:日期类型的数据就需要自定义转换器。 自定义类型转换器的开发步骤: ①定义转换器类实现Converter接口 ②在配置文件中声明转换器 ③在中引用转换器 2.10 获得Servlet相关APISpringMVC支持使用原始ServletAPI对象作为控制器方法的参数进行注入,常用的对象如下:. HttpServletRequest. HttpServletResponse HttpSession 1234567@RequestMapping (&quot; /quick16&quot;)@ResponseBodypublic void quickMethod16 (HttpservletRequest request, HttpservletResponse response,Httpsession session) &#123;System.out.println (request) ; System.out.println (response); System. out.println (session); &#125; 2.11获得请求头1.@RequestHeader 使用@RequestHeader可以获得请求头信息,相当于web阶段学习的request.getHeader(name) @RequestHeader注解的属性如下: value:请求头的名称 required:是否必须携带此请求头 12345@RequestMapping (&quot;/quick17&quot;)@ResponseBodypublic void quickMethod17(@RequestHeader (value = &quot;User-Agent&quot;, required = false) String headervalue) &#123; System.out.println (headervalue);&#125; 2.@CookieValue 使用@CookieValue可以获得指定Cookie的值 @CookieValue注解的属性如下: .value:指定cookie的名称 .required: 是否必须携带此cookie 123456@RequestMapping (&quot;/quick18&quot;)@ResponseBodypublic void quickMethod18( @cookievalue (value = &quot;JSESSIONID&quot;, required= false) string jsessionid)&#123; system.out.println (jsessiqgid); 2.12 文件上传1.文件上传客户端三要素 表单项type&#x3D; “file” 表单的提交方式是post 表单的enctype属性是多部分表单形式,及enctype&#x3D; “multipart&#x2F;form-data” 12345&lt;form action=&quot;$[pagecontext.request.contextPath]/quick20&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 名称: &lt;input type=&quot;text&quot; name=&quot;name &quot;&gt;&lt;br&gt; 文件: &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;&lt;br&gt; &lt;input type=&quot; submit&quot; value=&quot;提交&quot;&lt;br&gt;&lt;/form&gt; 2.文件上传原理 .当form表单修改为多部分表单时,request.getParameterO将失效。 .enctype&#x3D; “application&#x2F;x-www-form-urlencoded” 时, form表单的正文内容格式是:key&#x3D;value&amp;key&#x3D;value&amp;key&#x3D;value. 当form表单的enctype取值为Mutilpart&#x2F;form-data时,请求正文内容就变成多部分形式: 2.13 单文件上传步骤① 导入fileupload和io坐标 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactid&gt;commons-fileupload&lt;/artifactid&gt; &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactid&gt;commons-io&lt;/artifactid&gt; &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt; ②配置文件上传解析器 123456789&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart. commons. CommonsMultipartResolver&quot;&gt; &lt;!--上传文件总大小--&gt; &lt;property name=&quot;maxuploadSize&quot; value=&quot;5242800&quot;/&gt; &lt;!--上传单个文件的大小--&gt; &lt;property name=&quot;maxuploadsizePerFile&quot; value=&quot;5242800&quot;/&gt; &lt;!--上传文件的编码类型--&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt;&lt;/bean&gt; ③编写文件上传代码 123456789@RequestMapping (&quot;/quick20&quot;)@ResponseBodypublic void quickMethod20 (string name, MultipartFile uploadFile) throws IOException &#123; //获得文件名称 string originalFilename = uploadFile. getoriginalFilename (); //保存文件 uploadFile.transferTo (new File(&quot;C:\\\\upload\\\\&quot;+originalFilename));&#125; 2.15多文件上传实现文件上传,只需要将页面修改为多个文件上传项,将方法参数MultipartFile类型修改为MultipartFile[]即可 1&lt;h1&gt;多文件上传测试&lt;/h1&gt; &lt;form action=&quot;$(pageContext.request.contextPath)/quick21&quot; method= &quot;post&quot;enctype=&quot;multipart/form-data&quot;&gt; 名称: &lt;input type=&quot;text&quot; name=&quot;name &quot;&gt;&lt;br&gt; 文件1: &lt;input type=&quot;file&quot; name=&quot;upladFiles&quot;&gt;&lt;br&gt; 文件2: &lt;input type=&quot;file&quot; name=&quot;uploadFiles&quot;&gt;&lt;br&gt; 文件3: &lt;input type=&quot;file&quot; name=&quot;uploadFiles&quot;&gt;&lt;br&gt; &lt;input type=&quot; submit&quot; value=&quot;提交&quot;&gt;&lt;br&gt; &lt;/form&gt; 1234567@RequestMapping (&quot; /quick21&quot;)@ResponseBodypublic void quickMethod21 (string name, Multipartrile [] uploadFiles) throws IOException &#123; for (MultipartFile uploadFile : uploadFiles) &#123; string originalFilename = uploadFile.getoriginalFilename (); uploadFile.transferTo (new File (&quot;C:\\\\upload\\\\&quot;+originalFilename)); &#125; 2.14 知识要点MVC实现数据请求方式 基本类型参数. POJO类型参数. 数组类型参数. 集合类型参数 MVC获取数据细节 .中文乱码问题 @RequestParam和 @Pathvariable 自定义类型转换器 获得Servlet相关API @RequestHeader 和@Cookievalue 文件上传 1.spring JdbcTemplate基本使用1.1 JdbcTemplate概述它是spring框架中提供的一个对象,是对原始繁琐的JdbcAPI对象的简单封装。spring框架为我们提供了很多的操作模板类。例如:操作关系型数据的JdbcTemplate和HibernateTemplate,操作nosql数据库的RedisTemplate,操作消息队列的JmsTemplate等等。 1.2 JdbcTemplate开发步骤① 导入spring-jdbc和spring-tx坐标 ②创建数据库表和实体 ③创建JdbcTemplate对象 ④执行数据库操作 1.4 Spring产生JdbcTemplate对象我们可以将JdbcTemplate的创建权交给Spring,将数据源DataSource的创建权也交给Spring,在Spring容器内部将数据源DataSource注入到JdbcTemplate模版对象中,配置如下: 1234567891011&lt;!--数据源DataSource--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2. c3p0. Combo PooledDataSource &quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot; com. mysql. jdbo.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot; jdboUrl&quot; value=&quot; jdba :mysql:///test&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&lt;/property&gt;&lt;/bean&gt;&lt;!--JdbcTemplate--&gt;&lt;bean id=&quot;jdbeTemplate&quot; class=&quot;org. springframework. jdbc. core.JdbeTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&lt;/property&gt;&lt;/bean&gt; 1.6知识要点1.导入spring-jdbc和spring-tx坐标 2.创建数据库表和实体 3.创建JdbcTemplate对象 Jdbctemplate jdbctemplate &#x3D; new Jdbctemplate () ; jdbcTemplate.setDatasource (datasource); 4.执行数据库操作 更新操作: jdbctemplate. update (sql, params) 查询操作: jdbctemplate.query (sql, Mapper, params) jdbctemplate.queryForobject (sql, Mapper, params) 1.Spring练习环境搭建1.1 Spring环境搭建步骤① 创建工程(Project&amp;Module) ② 导入静态页面(见资料jsp页面) ③ 导入需要坐标(见资料中的pom.xml) ④创建包结构(controller, service, dao, domain, utils) ⑤导入数据库脚本(见资料testsql) 6.创建POJO类(见资料User.java和Role.java) 7.创建配置文件(applicationContext.xml, spring-mvc.xml, jdbc.properties, log4j.properties) 2.角色列表的展示和添加操作2.2角色列表的展示步骤分析点击角色管理菜单发送请求到服务器端(修改角色管理菜单的url地址) 创建RoleController和showListO方法 创建RoleService和showListO方法 创建RoleDao和findAlIO方法 使用JdbcTemplate完成查询操作 将查询数据存储到Model中 转发到role-list.jsp页面进行展示 2.4角色添加的步骤分析 ①点击列表页面新建按钮跳转到角色添加页面 ②输入角色信息,点击傑存按钮,表单数据提交服务器 ③编写RoleController的save0方法 ④编写RoleService的save0方法 ⑤编写RoleDao的saveO方法 6使用JdbcTemplate保存Role数据到sys_role 7跳转回角色列表页面 1.SpringMVC拦截器1.1 拦截器(interceptor)的作用Spring MVC的拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。 将拦截器按一定的顺序联结成一条链,这条链称为拦截器链(Interceptor Chain).在访问被拦截的方法或字段时,拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是AOP思想的具体实现。 1.2拦截器和过滤器区别区别 过滤器(Filter) 拦截器(Interceptor) 使用范围 是servlet规范中的一部分,任何Java Web 工程都可以使用 是SpringMVC 框架自己的,只有使用了SpringMVC 框架的工程才能用 *拦截范围 在url-pattern中配置了&#x2F;之后,可以对所有要访问的资源拦截 在&lt;mvc:mapping path&#x3D; “” &#x2F;&gt;中配置了&#x2F;“之后,可 以多所有资源进行拦截,但是可以通以对所有要访问 资源拦截过&lt;mvc:exclude-mapping path&#x3D; “”&#x2F;&gt;标签 排除不需要拦截的资源 1.3拦截器是快速入门自定义拦截器很简单,只有如下三步: 创建拦截器类实现Handlerlnterceptor接口 配置拦截器 测试拦截器的拦截效果 1.5拦截器方法说明方法名 说明 preHandle 方法将在请求处理之前进行调用,该方法的返回值是布尔值Boolean类型的。 ​ 当它返回为false时,表示请求结束,后续的Interceptor和Controller都不会再执行: ​ 当返回值为true时就会继续调用下一个Interceptor的preHandle方法 postHandle 该方法是在当前请求进行处理之后被调用,前提是preHandle方法的返回值为true 时才能 ​ 被调用,且它会在DispatcherServlet进行视图返回演染之前被调用,所以我们可以在这个 ​ 方法中对Controller处理之后的ModelAndView对象进行操作 afterCompletion() 该方法将在整个请求结束之后,也就是在DispatcherServlet這染了对应的视图之后执行 ​ ,前提是preHandle方法的返回值为true时才能被调用 1.6 知识要点自定义拦截器步骤 创建拦截器类实现Handlerlnterceptor接口 ②配置拦截器 ③测试拦截器的拦截效果 1.SpringMVC异常处理1.1异常处理的思路系统中异常包括两类:预期异常和运行时异常RuntimeException,前者通过捕获异常从而获取异常信息,后者主要通过规范代码开发、测试等手段减少运行时异常的发生。 系统的Dao, Service, Controller出现都通过throws Exception向上抛出,最后由SpringMVC前端控制器交由异常处理器进行异常处理,如下图: 客户端 —— 前端控制器 —- Controller ——– Service ——- Dao ​ HandlerExceptionResolver ​ 异常处理器 1.2异常处理两种方式.使用Spring MVC提供的简单异常处理器SimpleMappingExceptionResolver 实现Spring的异常处理接口HandlerExceptionResolver自定义自己的异常处理器 1.3 简单异常处理器SimpleMappingExceptionResolverSpringMVC已经定义好了该类型转换器,在使用时可以根据项目情况进行相应异常与视图的映射配置 12345678910&lt;!--配置简单映射异常处理器--&gt;&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;property name&quot;defaultErrorView&quot; value=&quot;error&quot;/&gt;//默认错误视图 &lt;property name=&quot;exoeptionMappings&quot;&gt; &lt;map&gt;//异常类型错误视图 &lt;entry key=&quot;com. itheima. exception. MyException&quot; value=&#x27;error&quot;/&gt; &lt;entry key=&quot;java.lang. ClassCastException&quot; value=&quot;error&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; 1.4 自定义异常处理步骤创建异常处理器类实现HandlerExceptionResolver 配置异常处理器 编写异常页面 测试异常跳转 1.5知识要点异常处理方式 .配置简单异常处理器SimpleMappingExceptionResolver. 自定义异常处理器 自定义异常处理步骤 ①创建异常处理器类实现HandlerExceptionResolver 2.配置异常处理器 ③编写异常页面 ④测试异常跳转 1.Spring 的AOP 简介1.1 什么是AOPAOP 为Aspect Oriented Programming的缩写,意思为面向切面编程,是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 AOP是 OOP的延续,是软件开发中的一个热点,也是Spring框架中的一个重要内容,是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离,从而使得业务逻辑各部分之间的耦合度降低,提高程序的可重用性,同时提高了开发的效率。 1.2 AOP 的作用及其优势作用:在程序运行期间,在不修改源码的情况下对方法进行功能增强 优势:减少重复代码,提高开发效率,并且便于维护 1.3 AOP 的底层实现实际上,AOP的底层是通过Spring提供的的动态代理技术实现的。在运行期间, Spring通过动态代理技术动态的生成代理对象,代理对象方法执行时进行增强功能的介入,在去调用目标对象的方法,从而完成功能的增强。 1.4 AOP 的动态代理技术常用的动态代理技术 JDK代理:基于接口的动态代理技术 cglib代理:基于父类的动态代理技术 1.5 JDK 的动态代理1.6 cglib 的动态代理1.7 AOP 相关概念Spring的 AOP实现底层就是对上面的动态代理的代码进行了封装,封装后我们只需要对需要关注的部分进行代码编写,并通过配置的方式完成指定目标的方法增强。 在正式讲解AOP的操作之前,我们必须理解AOP的相关术语,常用的术语如下: .Target (目标对象) :代理的目标对象 Proxy (代理) :一个类被AOP织入增强后,就产生一个结果代理类 Joinpoint (连接点) :所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点 Pointcut (切入点) :所谓切入点是指我们要对哪些Joinpoint进行拦截的定义 Advice (通知&#x2F;增强) :所谓通知是指拦截到Joinpoint之后所要做的事情就是通知 Aspect (切面):是切入点和通知(引介)的结合 Weaving (织入) :是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入,而Aspect&#x2F;采用编译期织入和类装载期织入 1.8 AOP 开发明确的事项1.需要编写的内容 编写核心业务代码(目标类的目标方法) 编写切面类,切面类中有通知(增强功能方法) 在配置文件中,配置织入关系,即将哪些通知与哪些连接点进行结合 2.AOP 技术实现的内容 Spring框架监控切入点方法的执行。一旦监控到切入点方法被运行,使用代理机制,动态创建目标对象的代理对象,根据通知类别,在代理对象的对应位置,将通知对应的功能织入,完成完整的代码逻辑运行。 3.AOP 底层使用哪种代理方式 在spring中,框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。 1.9 知识要点aop:面向切面编程 aop底层实现:基于JDK的动态代理和基于Cglib的动态代理 aop的重点概念: Pointcut (切入点) :被增强的方法 Advice (通知&#x2F;增强) :封装增强业务逻辑的方法 Aspect (切面) :切点+通知 Weaving (织入) :将切点与通知结合的过程 开发明确事项: 谁是切点(切点表达式配置) 谁是通知(切面类中的增强方法) 将切点和通知进行织入配置 2.基于XML的AOP开发2.1快速入门① 导入AOP相关坐标 ②创建目标接口和目标类(内部有切点) ③创建切面类(内部有增强方法) ④将目标类和切面类的对象创建权交给spring 5.在applicationContext.xml中配置织入关系 6测试代码 2.2 XML 配置AOP 详解1.切点表达式的写法 表达式语法: execution([修饰符]返回值类型包名.类名.方法名(参数)) 访问修饰符可以省略 返回值类型、包名、类名、方法名可以使用星号*代表任意 包名与类名之间一个点.代表当前包下的类,两个点..表示当前包及其子包下的类 参数列表可以使用两个点..表示任意个数,任意类型的参数列表 12345execution (public void com. ithe ima. aop. Target.method ())execution (void com.itheima.aop.Target.* (..))execution (* com.itheima.aop. *.* (..))execution (* com. itheima. aop..*.* (..))execution (* *..*.* (..)) 2.通知的类型 通知的配置语法: &lt;aop:通知类型method&#x3D; “切面类中方法名” pointcut&#x3D; “切点表达式”&gt;&lt;&#x2F;aop:通知类型&gt; 名称 标签 说明 前置通知 aop:before 用于配置前置通知。指定增强的方法在切入点方法之前执行 后置通知 aop:after-returning 用于配置后置通知。指定增强的方法在切入点方法之后执行 环绕通知 aop:around 用于配置环绕通知。指定增强的方法在切入点方法之前和之后都执行 异常抛出通知 aop:throwing 用于配置异常抛出通知。指定增强的方法在出现异常时执行 最終通知 aop:after 用于配置最终通知。无论增强方式执行是否有异常都会执行 3.切点表达式的抽取 当多个增强的切点表达式相同时,可以将切点表达式进行抽取,在增强中使用pointcut-ref属性代替pointcut属性来引用抽取后的切点表达式。 12345678&lt;aop:config&gt;&lt;!--引用myAspect的Bean为切面对象--&gt; &lt;aop : aspeat ref=&quot;myAspeat&quot;&gt; &lt;aop :pointcut id=&quot;myPointcut&quot; expression=&quot;execution (* com.itheima.aop.*.*(..)) &quot;/&gt; &lt;aop :before method=&quot;before&quot; pointcut-ref=&quot;myPointcut&quot;&gt; &lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 2.3 知识要点 .aop织入的配置 12345&lt;aop:config&gt; &lt;aop: aspect ref=&quot;切面类&quot;&gt; &lt;aop: before method=&quot;通知方法名称&quot; pointcut=&quot;切点表达式&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:aonfig&gt; 通知的类型:前置通知、后置通知、环绕通知、异常抛出通知、最终通知. 切点表达式的写法: execution([修饰符]返回值类型包名.类名.方法名(参数)) 3.基于注解的AOP开发3.1快速入门基于注解的aop开发步骤: ①创建目标接口和目标类(内部有切点) ②创建切面类(内部有增强方法) ③将目标类和切面类的对象创建权交给spring ④在切面类中使用注解配置织入关系 ⑤在配置文件中开启组件扫描和AOP的自动代理 6.测试 3.2注解配置AOP 详解1.注解通知的类型 通知的配置语法:@通知注解(“切点表达式”) 注解aop开发步骤 ①使用@Aspect标注切面类 ②使用@通知注解标注通知方法 ③在配置文件中配置aop自动代理&lt;aop: aspectj-autoproxy&#x2F;&gt; 名称 注解 说明 前置通知 @Before 用于配置前置通知。指定增强的方法在切入点方法之前执行 后置通知 @AfterReturning 用于配置后置通知。指定增强的方法在切入点方法之后执行 环绕通知 @Around 用于配置环绕通知。指定增强的方法在切入点方法之前和之后都执行 异常抛出通知 @AfterThrowing 用于配置异常抛出通知。指定增强的方法在出现异常时执行 最终通知 @After 用于配置最终通知。无论增强方式执行是否有异常都会执行 2.切点表达式的抽取 同xml配置aop一样,我们可以将切点表达式抽取。抽取方式是在切面内定义方法,在该方法上使用@Pointcut注解定义切点表达式,然后在在增强注解中进行引用。具体如下: 12345678910@Component (&quot;myAspeat&quot;)@Aspectpublic class MyAspect &#123; @Before (&quot;MyAspect.myPoint () &quot;) public void before ()&#123; System.out.println (&quot;前置代码增强....&quot;); &#125; @Pointcut (&quot;exeoution (* com.itheima.aop.*.* (..))&quot;) publio void myPoint () &#123;&#125;&#125; 1.编程式事务控制相关对象1.1 PlatformTransactionManagerPlatformTransactionManager 接口是spring 的事务管理器,它里面提供了我们常用的操作事务的方法。 平台事务管理器 方法 说明 Transactionstatus 获取事务的状态信息 getTransaction (TransactionDefination defination) ​ void commit (Transactionstatus status) 提交事务 void rollback (Transactionstatus status) 回滚事务 注意: PlatformTransactionManager 是接口类型,不同的Dao层技术则有不同的实现类, **例如: ** Dao层技术是jdbc或mybatis 时: org.springframework.jdbc.datasource. DatasourcetransactionManager Dao 层技术是hibernatel: org.springframework.orm.hibernate5.HibernateTransactionManager 1.2 TransactionDefinitionTransactionDefinition是事务的定义信息对象,里面有如下方法: 事务定义 方法 说明 int getIsolationLevel () 获得事务的隔离级别 int getPropogationBehavior () 获得事务的传播行为 int gettimeout () 获得超时时间 boolean isReadOnly() 是否只读 1.事务隔离级别 设置隔离级别,可以解决事务并发产生的问题,如脏读、不可重复读和虚读。 ISOLATION_DEFAULT ISOLATION_READ_UNCOMMITTED ISOLATION_READ_COMMITTED ISOLATION_REPEATABLE_READ ISOLATION_SERIALIZABLE 2.事务传播行为 REQUIRED:如果当前没有事务,就新建一个事务,如果已经存在一个事务中,加入到这个事务中。一般的选择(默认值). SUPPORTS:支持当前事务,如果当前没有事务,就以非事务方式执行(没有事务) MANDATORY:使用当前的事务,如果当前没有事务,就抛出异常. REQUERS_NEW:新建事务,如果当前在事务中,把当前事务挂起。. NOT SUPPORTED:以非事务方式执行操作,如果当前存在事务,就把当前事务挂起. NEVER:以非事务方式运行,如果当前存在事务,抛出异常. NESTED:如果当前存在事务,则在嵌套事务内执行。如果当前没有事务,则执行REQUIRED类似的操作 超时时间:默认值是-1,没有超时限制。如果有,以秒为单位进行设置 是否只读:建议查询时设置为只读 1.3 TransactionStatusTransactionStatus接口提供的是事务具体的运行状态,方法介绍如下。 方法 说明 boolean hassavepoint () 是否存储回滚点 boolean iscompleted () 事务是否完成 boolean isNewrransaction () 是否是新事务 boolean isRollbackonly () 事务是否回滚 1.4知识要点编程式事务控制三大对象 PlatformTransactionManager 接口只定义行为 TransactionDefinition 封装事务参数 TransactionStatu 被动封装状态信息 2.基于XML的声明式事务控制2.1什么是声明式事务控制Spring的声明式事务顾名思义就是采用 声明的方式来处理事务 。这里所说的声明,就是指在配置文件中声明用在Spring配置文件中声明式的处理事务来代替代码式的处理事务。 声明式事务处理的作用事务管理不侵入开发的组件。具体来说,业务逻辑对象就不会意识到正在事务管理之中,事实上也应该如此,因为事务管理是属于系统层面的服务,而不是业务逻辑的一部分,如果想要改变事务管理策划的话,也只需要在定义文件中重新配置即可 在不需要事务管理的时候,只要在设定文件上修改一下,即可移去事务管理服务,无需改变代码重新编译,这样维护起来极其方便 注意: Spring声明式事务控制底层就是AOP 2.2声明式事务控制的实现声明式事务控制明确事项:. 谁是切点?. 谁是通知?. 配置切面? 2.3切点方法的事务参数的配置1234567&lt;!--事务增强配置--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot; transactionManager &quot;&gt; &lt;tx:attributes&gt; &lt;tx:me thod name=&quot;*&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 其中,tx:method代表切点方法的事务参数的配置,例如: 1&lt;tx:method name=&quot; transfer&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; timeout=&quot;-1&quot;read-only=&quot;false&quot;/&gt; name:切点方法名称 isolation:事务的离级别 propogation: 事务的传播行为 timeout:超时时间 read-only: 是否只读 2.4知识要点声明式事务控制的配置要点 平台事务管理器配置. 事务通知的配置. 事务aop织入的配置 3.基于注解的声明式事务控制3.2注解配置声明式事务控制解析①使用@Transactional在需要进行事务控制的类或是方法上修饰,注解可用的属性同xml配置方式,例如隔离级别、传播行为等。 ②注解使用在类上,那么该类下的所有方法都使用同一套注解参数配置。 3.在方法上,不同的方法可以采用不同的事务参数配置。 ④ Xml配置文件中要开启事务的注解驱动&lt;tx: annotation-driven &#x2F;&gt; 3.3知识要点注解声明式事务控制的配置要点. 平台事务管理器配置(xml方式). 事务通知的配置(@Transactional注解配置). 事务注解驱动的配置&lt;tx: annotation-driven&#x2F;&gt; 1.Mybatis简介1.1原始jdbc操作(查询数据)12345678910111213141516171819202122//注册驱动Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//获得连接Connection connection = DriverManager.getConnection(url: &quot;jdbc: mysql:///test&quot;, user: &quot;root&quot;, password: &quot;root&quot;);//获得statementPreparedStatement statement = connection.prepareStatement( sql: &quot;select id, username, password from user&quot;);//执行查询ResultSet resultSet= statement.executeQuery();//遍历结果集while(resultSet.next())&#123; //封装实体 User user = new User(); user.setId(resultSet.getInt( columnLabel: &quot;id&quot;)); user.setUsername (resultSet.getString( columnLabel: &quot;username&quot;)); user.setPassword(resultSet.getString( columnLabel: &quot;password&quot;)); //user实体封装完毕 System.out.println(user);&#125;//释放资源resultSet.close();statement.close();connection.close(); 1.1原始jdbc操作(插入数据)1234567891011121314151617181920//模拟实体对象User user = new User();user.setId(2);user.setUsername(&quot;tom&quot;);user, setPassword(&quot;lucy&quot;) //注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//获得连接Connection connection = DriverManager.getConnection( url: &quot;jdbc:mysql:///test&quot;, user: &quot;root&quot;, password: &quot;root&quot;);//获得statementPreparedStatement statement = connection.prepareStatement( sgl: &quot;insert into user(id, username, password) values(?,?,?)&quot;);//设置占位符参数statement. setInt( parameterlndex: 1, user-getId());statement. setString( parameterlndex: 2,user.getUsername());statement,setString( parameterlndexc: 3,user.getPassword());//执行更新操作statement.executeUpdate();//释放资源statement.close();connection.close(); 1.2原始jdbc操作的分析原始jdbc开发存在的问题如下: ①数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能 ② sql 语句在代码中硬编码,造成代码不易维护,实际应用sql变化的可能较大, sql变动需要改变java代码。 ③查询操作时,需要手动将结果集中的数据手动封装到实体中。插入操作时,需要手动将实体的数据设置到sql语句的占位,符位置 应对上述问题给出的解决方案: ①使用数据库连接池初始化连接资源 ②将sql语句抽取到xml配置文件中 ③使用反射、内省等底层技术,自动将实体与表进行属性与字段的自动映射 1.3 什么是Mybatis. mybatis 是一个优秀的基于java的持久层框架,它内部封装了jdbc,使开发者只需要关注sql语句本身,而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 . mybatis通过xml或注解的方式将要执行的各种statement配置起来,并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。 .最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题,对jdbc进行了封装,屏蔽了jdbcapi底层访问细节,使我们不用与jdbcapi打交道,就可以完成对数据库的持久化操作。 2.Mybatis的快速入门2.1 MyBatis开发步骤MyBatis官网地址: http://www.mybatis.org/mybatis-3/ MyBatis开发步骤: ①添加MyBatis的坐标 ②创建user数据表 ③编写User实体类 ④编写映射文件UserMapper.xml ⑤编写核心文件SqlMapConfig.xml 6.编写测试类 2.2 环境搭建1.导入MyBatis的坐标和其他相关坐标 1234567891011121314151617181920212223242526//mybatis坐标&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.27&lt;/version&gt; &lt;/dependency&gt;//mysql驱动坐标 &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt; &lt;/dependency&gt;&lt;!--单元测试坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--日志坐标--&gt;&lt;dependenoy&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifaatId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; 2.2环境搭建2.创建user数据表 3.编写User实体 123456public class User &#123; private int id; private String username; private String password;//省略get个set方法&#125; 4.编写UserMapper映射文件 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.itheima.domain.User&quot;&gt; select * from User &lt;/select&gt;&lt;/mapper&gt; 5.编写MyBatis核心文件 123456789101112131415&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///test&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;/configuration&gt; 2.3编写测试代码123456789101112//加载核心配置文件InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);//获得sqlSession 工厂对象SqlSessionFactory sqlSessionFactry = new SqlSessionFactoryBuilder().build(resourceAsStream);//获得sqlSession对象SqlSession sqlSession = sqlSessionFactory.openSession();//执行sql语句List&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;);//打印结果System.out.println(userList);//释放资源sqlSession.close(); 2.4知识小结MyBatis开发步骤: ①添加MyBatis的坐标 ②创建user数据表 ③编写User实体类 ④编写映射文件UserMapper.xml ⑤编写核心文件SqlMapConfig.xml 6编写测试类 4.MyBatis的增删改查操作4.1 MyBatis的插入数据操作3.插入操作注意问题 插入语句使用insert标签 在映射文件中使用parameterType属性指定要插入的数据类型 Sql语句中使用#[实体属性名)方式引用实体中的属性值 插入操作使用的API是sqlSession.insert( “命名空间.id”,实体对象); 插入操作涉及数据库数据变化,所以要使用sqlSession对象显示的提交事务,即sqlSession.commit) 4.2 MyBatis的修改数据操作1.编写UserMapper映射文件 12345&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;update id=&quot;update&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt; update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; 2.编写修改实体User的代码 12345678910111213//获得核心配置文件 InputStream resourceAsStream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);//获得session工厂对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); //获得session会话对象 SqlSession sqlSession=sqlSessionFactory.openSession(); //执行操作 参数：namespace+id sqlSession.update(&quot;userMapper.update&quot;,user); //mybatis执行更新操作 除了查询都需要提交事务 sqlSession.commit(); //释放资源 sqlSession.close(); &#125; 3.修改操作注意问题 修改语句使用update标签 修改操作使用的API是sqlSession.update( “命名空间.id”,实体对象); 4.3 MyBatis的删除数据操作3.删除操作注意问题 删除语句使用delete标签 Sql语句中使用#(任意字符串)方式引用传递的单个参数 删除操作使用的API是sqlSession.delete(“命名空间.id” ,Object); 4.4知识小结增删改查映射配置与API:12345678910111213141516171819查询数据:List&lt;User&gt; userList = sqlsession.selectList (&quot;userMapper.findAll&quot;); &lt;seleat id=&quot;findAll&quot; resultType=&quot;com.itheima. domain.User&quot;&gt; select * from User &lt;/select&gt;添加数据: sqlsession.insert (&quot;userMapper.add&quot;, user); &lt;insert id=&quot;add&quot; parameterType=&quot;com.itheima, domain. User&quot;&gt; insert into user values (#(id), #(username), #[password)) &lt;/insert&gt;修改数据: sqlSession.update (&quot;userMapper. update&quot;, user); &lt;update id=&quot;update&quot; parameterType=&quot; com.itheima. domain.User&quot;&gt; update user set username=# &#123;username&#125;, password=# &#123;password&#125; where id=#&#123;id&#125; &lt;/update&gt;删除数据: sqlsession.delete (&quot;userMapper.delete&quot;,3); &lt;delete id=&quot;delete&quot; parameterType=&quot;java.lang. Integer&quot;&gt; delete from user where id=# &#123;id&#125; &lt;/delete&gt; 5.1 MyBatis核心配置文件层级关系configuration 配置 。properties 属性 。settings设置 。typeAliases 类型别名 。typeHandlers 类型处理器 。objectFactory 对象工厂plugins 插件 。environments 环境 ​ ..environment 环境变量 ​ …transactionManager 事务管理器 ​ …dataSource数据源 。databaseldProvider数据库厂商标识 。mappers 映射器 5.2 MyBatis常用配置解析1.environments标签 数据库环境的配置,支持多环境配置 12345678910111213&lt;!-- 配置数据源的环境 --&gt; &lt;environments default=&quot;development&quot;&gt; //指定默认的环境名称 &lt;environment id=&quot;development&quot;&gt; //指定当前环境的名称 &lt;transactionManager type=&quot;JDBC&quot;/&gt; //指定事务管理类型是jdbc &lt;dataSource type=&quot;POOLED&quot;&gt; //指定当前数据源类型是连接池 //数据源配置的基本参数 &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; 其中,事务管理器(transactionManager)类型有两种: JDBC:这个配置就是直接使用了JDBC的提交和回滚设置,它依赖于从数据源得到的连接来管理事务作用域。 MANAGED:这个配置几乎没做什么。它从来不提交或回滚一个连接,而是让容器来管理事务的整个生命周期(比如JEE应用服务器的上下文) 。默认情况下它会关闭连接,然而一些容器并不希望这样,因此需要将closeConnection属性设置为false来阻止它默认的关闭行为。 其中,数据源(dataSource)类型有三种: UNPOOLED:这个数据源的实现只是每次被请求时打开和关闭连接。 POOLED:这种数据源的实现利用“池”的概念将JDBC连接对象组织起来。 JNDI:这个数据源的实现是为了能在如EJB或应用服务器这类容器中使用,容器可以集中或在外部配置数据源,然后放置一个JNDI上下文的引用。 2.mapper标签 该标签的作用是加载映射的,加载方式有如下几种: 使用相对类路径的资源引用,例如: 使用完全限定资源定位符(URL) ,例如: 使用映射器接口实现类的完全限定类名,例如: 将包内的映射器接口实现全部注册为映射器,例如: 3.Properties标签 实际开发中,习惯将数据源的配置信息单独抽取成一个properties文件,该标签可以加载额外配置的properties文件 1234567891011121314&lt;!--加载外部proponties--&gt;&lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt;&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc, password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 5.2 MyBatis常用配置解析4.typeAliases标签 类型别名是为Java类型设置一个短的名字。原来的类型名称配置如下 123&lt;select id=&quot;findAll&quot; resultType=&quot;com.itheima.domain.User&quot;&gt; select * from User &lt;/select&gt; //User全限定名称 配置typeAliases, 为com.itheima.domain.User定义別名为user 123&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.itheima.domain.User&quot; alias=&quot;user&quot;&gt;&lt;/typeAlias&gt;&lt;/typeAliases&gt; 123&lt;selectid=&quot;findAll&quot; resultType=&quot;user&quot;&gt; select * from User&lt;/select&gt; //user为别名 4.typeAliases标签 上面我们是自定义的别名, mybatis框架已经为我们设置好的一些常用的类型的别名 别名 数据类型 string String long Long int Integer double Double boolean Boolean 5.3知识小结核心配置文件常用配置: 1.properties标签:该标签可以加载外部的properties文件 1&lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt; 2.typeAliases标签:设置类型别名 1&lt;typeAlias type=&quot;com.itheima.domain.User&quot; alias=&quot;user&quot;&gt;&lt;/typeAlias&gt; 3.mappers标签:加载映射配置 1&lt;mapper resource=&quot; com/itheima/mapper/UserMapper.xml&quot;&gt;&lt;/mapper&gt; 核心配置文件常用配置: 4, environments标签:数据源环境配置标签 1234567891011&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc, password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 6.MyBatis相应API6.1 SqlSessionI厂构建器SqlSessionFactoryBuilder常用API: SqlSessionFactory build(InputStream inputStream) 通过加载mybatis的核心文件的输入流的形式构建一个SqISessionFactory对象 1234string resource = &quot;org/mybatis/builder/mybatis-config.xml&quot;;Inputstream inputStream = Resources.getResourceAsStream (resource);SqlsessionFactoryBuilder builder = new SqlSessionFactoryBuilder ();SqlsessionFactory factory = builder.build (inputstream); 其中, Resources T具类,这个类在org.apache.ibatis.io包中。Resources类帮助你从类路径下、文件系统或一个web URL中加载资源文件。 6.2 SqlSession工厂对象SqlSessionFactorySqlSessionFactory有多个个方法创建SqlSession实例。常用的有如下两个: ​ 方法 解释 openSession() 会默认开启一个事务,但事务不会自动提交,也就意味着需要手动提交该事务,更新操作数据才会持久化到数据库中 openSession(booleanautoCommit) 参数为是否自动提交,如果设置为true,那么不需要手动提交事务 6.3 SqlSession会话对象SqlSession实例在MyBatis中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。执行语句的方法主要有: 12345&lt;T&gt; T selectone (string statement, Object parameter)&lt;E&gt; List&lt;E&gt; selectList (String statement, Object parameter) int insert (String statement, Object parameter) int update (String statement, Object parameter) int delete (String statement, Object parameter) 操作事务的方法主要有; 12void commit()void rollback() 1.Mybatis的Dao层实现1.1传统开发方式 123451.编写UserDao接口 public interface UserDao&#123; List&lt;User&gt; find11 () throws IOException;&#125; 1.2代理开发方式1.代理开发方式介绍 采用Mybatis的代理开发方式实现DAO层的开发,这种方式是我们后面进入企业的主流。 Mapper接口开发方法只需要程序员编写Mapper接口(相当于Dao接口) ,由Mybatis框架根据接口定义创建接口的动态代理对象,代理对象的方法体同上边Dao接口实现类方法。 Mapper接口开发需要遵循以下规范: 1.Mapper.xml文件中的namespace与mapper接口的全限定名相同 2.Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 3.Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同 4.Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 2.编写UserMapper接口 123456public interface UserDao&#123; User findById(int id) ;&#125; 123456&lt;mapper namespace=&#x27;com.itheima.mapper.UserMapper&#x27;&gt;&lt;select id=findById parameterType=&#x27;int&#x27; resultType=user&gt; select * from User where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 3.测试代理方式1234567891011@Testpublic void testProxyDao() throws IOException&#123; InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); //获得MyBatis框架生成的UserMapper接口的实现类 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.findByld(1); System.out.println(user); sqlSession.close();&#125; 1.3知识小结mybatis的Dao层实现的两种方式:. 手动对Dao进行实现:传统开发方式. 代理方式对Dao进行实现: UserMapper userMapper &#x3D; sqlSession.getMapper (UserMapper.class); 1.MyBatis映射文件深入 1.1 动态sql语句 1.动态sql语句概述 Mybatis的映射文件中,前面我们的SQL都是比较简单的,有些时候业务逻辑复杂时,我们的SQL是动态变化的,此时在前面的学习中我们的SQL就不能满足要求了。参考的官方文档,描述如下: if choose(when ,otherwise) trim(where ,set) foreach 1.MyBatis映射文件深入 2.动态SQL之 我们根据实体类的不同取假,使用不同的SQL语句来进行查询。比如在id如果不为空时可以根据id查询,如果username不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。 1234567891011&lt;select id=&quot;findByCondition&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt; select * from User &lt;where&gt; &lt;if test=&quot;id!=0&quot;&gt; and id=#[id) &lt;/if&gt; &lt;if test=&quot;username!=null&quot;&gt; and username=#(username) &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 3.动态 SQL 之 循环执行sql的拼接操作,例如: SELECT FROM USER WHERE id IN (1,2,5),* 12345678&lt;select id=&quot; findByIds&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt; select * from User &lt;where&gt; &lt;foreach colleation=&quot;array&quot; open=&quot;id in(&quot; close=&quot;) &quot; item=&quot;id&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 1.2 SQL片段抽取sql中可将重复的sql 提取出来,使用时用include引用即可,最终达到sql重用的目的 12345678910111213&lt;!--抽取sql片段简化编写--&gt;&lt;sql id=&quot;selectUser&quot; select * from User&lt;/sql&gt;&lt;select id=&quot;findByld&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;&gt;&lt;/include&gt;where id=#(id) &lt;/select&gt;&lt;selectid=&quot;findBylds&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;&gt;&lt;/include&gt; &lt;where&gt; &lt;foreach collection=&quot;array&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt; #(id) &lt;/foreach&gt; &lt;/where&gt; &lt;/select&gt; 1.3知识小结 MyBatis映射文件配置: 12345678&lt;select&gt;:查询 &lt;insert&gt; :插入 &lt;update&gt;:修改 &lt;delete&gt;:删除 &lt;where&gt;: where条件 &lt;if&gt;: if判断 &lt;foreach&gt;:循环 &lt;sql&gt;: sql片段抽取 1.MyBatis核心配置文件深入1.1 typeHandlers标签无论是MyBatis在预处理语句(PreparedStatement)中设置一个参数时,还是从结果集中取出一个值时,都会用类型处理器将获取的值以合适的方式转换成Java类型。下表描述了一些默认的类型处理器(截取部分)。 类型处理器 Java 类型 JDBC 类型 BooleanTypeHandler Java. lang. Boolean, boolean 数据库兼容的BOOLEAN ByteTypeHandler java. lang. Byte.byte 数据库兼容的NUMERIC或BYTE ShortTypeHandler Java. lang.Short,short 数据库兼容的NUMERIC 或 SHORT INTEGER IntegerTypeHedler java.lang.integer,int 数据库兼容的NUMERIC 或INTEGER LongTypeHeer Java. lang. Long, long 数据库兼容的NULERIC 或 LONG INTEGER 你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。具体做法为:实现org.apache.ibatis.type.TypeHandler 接口,或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler, 然后可以选择性地将它映射到一个JDBC类型。例如需求:一个Java中的Date数据类型,我想将之存到数据库的时候存成一个1970年至今的毫秒数,取出来时转换成jäva的Date, 即java的Date与数据库的varchar毫秒值之间转换。 开发步骤: ①定义转换类继承类BaseTypeHandler ②覆盖4个未实现的方法,其中setNonNullParameter为java程序设置数据到数据库的回调方法, getNullableResult为查询时mysql的字符串类型转换成java的Type类型的方法 ③在MyBatis核心配置文件中进行注册 ④测试转换是否正确 1.2 plugins标签MyBatis可以使用第三方的插件来对功能进行扩展,分页助手PageHelper是将分页的复杂操作进行封装,使用简单的方式即可获得分页的相关数据 开发步骤: ①导入通用PageHelper的坐标 ② 在mybatis核心配置文件中配置PageHelper插件 ③测试分页数据获取 1.3知识小结MyBatis核心配置文件常用标签: 1.properties标签:该标签可以加载外部的properties文件 2.typeAliases标签:设置类型别名 3.environments标签:数据源环境配置标签 4.typeHandlers标签:配置自定义类型处理器 5.plugins标签:配置MyBatis的插件 1.Mybatis多表查询1.1一对一查询1.一对一查询的模型 用户表和订单表的关系为,一个用户有多个订单,一个订单只从属于一个用户一对一查询的需求:查询一个订单,与此同时查询出该订单所属的用户 ordersuser id: int ordertime: varchar(255) total: double uid: int id: int user username: varchar(50) password: varchar(50) birthday: varchar(50) 1.2一对多查询1.一对多查询的模型 用户表和订单表的关系为,一个用户有多个订单,一个订单只从属于一个用户一对多查询的需求:查询一个用户,与此同时查询出该用户具有的订单 1.3多对多查询1.多对多查询的模型 表和角色表的关系为,一个用户有多个角色,一个角色被多个用户使用多对多查询的需求:查询用户同时查询出该用户的所有角色 user id: int usermame: varchar(50) password: varchar(50) birthday: varchar(50) user_role user_id: int role_id: int role id: int rolename: varchar(255) 1.4知识小结MyBatis多表配置方式: 一对一配置:使用做配置 一对多配置:使用+做配置 多对多配置:使用+做配置 1.Mybatis的注解开发1.1 MyBatis的常用注解这几年来注解开发越来越流行, Mybatis也可以使用注解开发方式,这样我们就可以减少编写Mapper映射文件了。我们先围绕一些基本的CRUD来学习,再学习复杂映射多表操作。 @Insert:实现新增 @Update:实现更新 @Delete:实现删除 @Select:实现查询 @Result:实现结果集封装 @Results:可以与 @Result一起使用,封装多个结果集 @One:实现一对一结果集封装 @Many:实现一对多结果集封装 1.2 MyBatis的增删改查我们完成简单的user表的增删改查的操作 private UserMapper userMapper; @Before public void before () throws IOException{ Inputstream resourceAsStream &#x3D; Resources.getResourceAsStream(“SqlMapconfig.xml”); SglsessionFactory sqlsessionFactory &#x3D; newSqlsessionFactoryBuilder (). build (resourceAsstream); Sqlsession sqlsession &#x3D; sqlsessionFactory. opensession (true); userMapper &#x3D; sqlSession. getMapper (UserMapper.class); } 1.3 MyBatis的注解实现复杂映射开发实现复杂关系映射之前我们可以在映射文件中通过配置来实现,使用注解开发后,我们可以使用@Results注解@Result注解, @One注解, @Many注解组合完成复杂关系的配置 注解 说明 @Results(一对多) 代替了标签,是多表查询的关键,在注解中用来指定子查询返回单一对象。 ​ @One注解属性介绍: ​ select:指定用来多表查询的sqlmapper ​ 使用格式: @Result(column&#x3D;’”.property&#x3D;”,one&#x3D;@One(select&#x3D;”“)) @Many (多对一) 代替了标签 是是多表查询的关键,在注解中用来指定子查询返回对象集合。 ​ 使用格式: @Result(property&#x3D;”.column&#x3D;””.many&#x3D;@Many(select&#x3D;”“)) 1.6多对多查询1.多对多查询的模型 用户表和角色表的关系为,一个用户有多个角色,一个角色被多个用户使用多对多查询的需求:查询用户同时查询出该用户的所有角色 user id: int username: varchar(50) password: varchar(50) birthday: varchar(50) user_role user_id: int role_id: int role id: int rolename: varchar(255) 1.SSM框架整合1.1准备工作1.原始方式整合 123456create database ssm;create table account( id int primary key auto_increment, name varchar (100), money double (7,2));","categories":[{"name":"后端","slug":"后端","permalink":"https://2486125878.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://2486125878.github.io/tags/JAVA/"}]},{"title":"JavaWeb","slug":"JavaWeb","date":"2024-03-13T07:40:02.000Z","updated":"2024-03-13T08:20:54.000Z","comments":true,"path":"2024/03/13/JavaWeb/","permalink":"https://2486125878.github.io/2024/03/13/JavaWeb/","excerpt":"","text":"1.1Junit单元测试:测试分类:1.黑盒测试:不需要写代码,给输入值,看程序是否能够输出期望的值。 2.白盒测试:需要写代码的。关注程序具体的执行流程。 Junit使用:白盒测试 Junit使用:白盒测试步骤: 1.定义一个测试类(测试用例) 建议: 测试类名: 被测试的类名Test calculatorTest 包名: xxx.xxx.xx.test cn.itcast.test 2.定义测试方法:可以独立运行 建议: 方法名:test测试的方法名 testAdd() 返回值: void 参数列表: 空参 3.给方法加@Test 4.导入junit依赖环境 判定结果: 红色:失败 绿色:成功 一般我们会使用断言操作来处理结果 1Assert.assertEquals(期望的结果,运算的结果); 补充: @Before:修饰的方法会在测试方法之前被自动执行 @After:修饰的方法会在测试方法执行之后自动被执行。 反射:框架设计的灵魂框架:半成品软件。可以在框架的基础上进行软件开发,简化编码 反射:将类的各个组成部分封装为其他对象,这就是反射机制 好处: 1.可以在程序运行过程中,操作这些对象。 2.可以解耦,提高程序的可扩展性。 Java代码 在计算机中经历的阶段:三个阶段源代码阶段 : javac 编译–字节码文件加载到内存：成员变量，构造方法，成员方法— Class类对象阶段：类加载器 对象描述 class类对象：成员变量Field[ ]fields，构造方法constructor[ ]cons，成员方法Method[ ] methods 运行时阶段 获取Class对象的方式:**1.Class.forName(“全类名”); 将字节码文件加载进内存,返回class对象 ** 多用于配置文件 将类名定义在配置文件中。读取文件,加载类 **2.类名.class: 通过类名的属性class获取 ** 多用于参数的传递 3.对象.getclass(): getclass()方法在object类中定义着。 多用于对象的获取字节码的方式 结论:同一个字节码文件(*.class)在一次程序运行过程中,只会被加载一次,不论通过哪一种方式获取的class对象都是同一个。 Class对象功能获取功能: **1,获取成员变量们 ** **Field[] getFields() 获取所有public修饰的成员变量 ** Field getField(String name) 获取指定名称的bublic修饰的成员变量 Field[] getDeclaredFields() Field getDeclaredField(String name) 2.获取构造方法们 Constructor&lt;?&gt;[] getConstructors() Constructor getconstructor(类&lt;?&gt;…. parameterTypes) Constructdr getDeclaredConstructor (类&lt;?&gt;… parameterTypes) Constructor&lt;?&gt;[] getDeclaredConstructors() 3.获取成员方法们 Method[] getMethods() Method getMethod(String name, 类&lt;?&gt;… parameterTypes) Method[] getDeclaredMethods() Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes) 4.获取类名 string getName() Field :成员变量 操作: 1.设置值 void set(Object obj, Object value) 2.获取值 get(object obj) 3.忽略访问权限修饰符的安全检擦 1setAccessible(true);//暴力反射 Constructor:构造方法 创建对象: T newInstance(Object…. initargs) 如果使用空参数构造方法创建对象,操作可以简化: class对象的newInstance方法 Method : 方法对象 执行方法: Object invoke(Object obj, object… args) 获取方法名称: string getName 案例: 需求: 写一个”框架”,不能改变该类的任何代码的前提下,可以帮我们创建任意类的对象,并且执行其中任意方法 实现: 1.配置文件 2.反射 步骤: 1,将需要创建的对象的全类名和需要执行的方法定义在配置文件中 2,在程序中加载读取配置文件 3.使用反射技术来加载类文件进内存 4.创建对象 5.执行方法 注解概念:说明程序的。给计算机看的 注释:用文字描述程序的。给程序员看的 定义:注解(Annotation),也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性,与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面,用来对这些元素进行说明,注释。 概念描述: JDK1.5之后的新特性 说明程序的 使用注解:@注解名称 作用分类: @编写文档:通过代码里标识的注解生成文档【生成文档doc文档】 @代码分析:通过代码里标识的注解对代码进行分析【使用反射】 @编译检查:通过代码里标识的注解让编译器能够实现基本的编译检查【override】 JDK中预定义的一些注解 @override：检测被该注解标注的方法是否是继承自父类(接口)的 @Deprecated：将该注解标注的内容,已过时 @Suppresswarnings：压制警告 一般传递参数all@Suppresswarnings(“all”) 自定义注解 格式: 元注解 public @interface 注解名{ 属性列表； } 本质:注解本质上就是一个接口,该接口默认继承Annotation接口 public interface MyAnno extends java.lang. annotation. Annotation{ } 属性:接口中的抽象方法 要求: 1.属性的返回值类型有下列取值 基本数据类型 string 枚举 注解 以上类型的数组 2.定义了属性,在使用时需要给属性赋值 2.1.如果定义属性时,使用default关键字给属性默认初始化值,则使用注解时,可以不进行属性的赋值。 2.2如果只有一个属性需要赋值,并且属性的名称是value,则value可以省略,直接定义值即可 2.3数组赋值时,值使用包裹。如果数组中只有一个值,则分省略 元注解:期于描述注解的注解 @Target :描述注解能够作用的位置 ElementType取值: TYPE:可以作用于类上 METHOD :可以作用于方法上 FIELD:可以作用于成员变量上 @Retention :描述注解被保留的阶段 ​ @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解,会保留到class字节码文件中,并被JVM读取到 @Documented :描述注解是否被抽取到api文档中 @Inherited:描述注解是否被子类继承 在程序使用(解析)注解:获取注解中定义的属性值 1.获取注解定义的位置的对象 (class, Method, Field) 2.获取指定的注解 *** getAnnotation(class)** 其实就是在内存中生成了一个该注解接口的子类实现对象 12345678public class ProImpl implement Pro&#123; String className()&#123; return &quot;cn.itcast.annotation.Demo1&quot;;&#125; String methodName()&#123; return &quot;show&quot;; &#125;&#125; 3.调用注解中的抽象方法获取配置的属性值 小结: 1.以后大多数时候,我们会使用注解,而不是自定义注解 2.注解给谁用? 1.编译器 2.给解析程序用 3.注解不是程序的一部分,问以理解为注解就是一个标签 javaweb1.数据库什么数据库? 用于存储和管理数据的仓库。 数据库的特点: 1,持久化存储数据的。其实数据库就是一个文件系统 2.方便存储和管理数据 3.使用了统一的方式操作数据库。 1.什么是SQL? Structured oWery Language : 结构化查询语 其实就是定义了操作所有关系型数据库的规则。 每一种数据库操作的方式存在不一样的地方,称为“方言” 3.SQL分类1.DDL(Data Definition Language)数据定义语言用来定义数据库对象:数据库,表,列等。关键字: create, drop,alter等 2.DML(Data Manipulation Language)数据操作语言用来对数据库中表的数据进行增删改。关键字:insert, delete, update等 3.DQL(Data Query Language)数据询语言用来查询数据库中表的记录(数据)。关键字: select, where等 4.DCL (Data Control Language)数据控制语言(了解)用来定义数据库的访问权限和安全级别,及创建用户。关键字: GRANT,REVOKE 等 1,操作数据库: CRUD1.C(Create) :创建 创建db4数据库,判断是否存在,并制定字符集为gbk create database if not exists db4 character set gbk; 2.R(Retrieve) :查询 ​ 查询所有数据库的名称: show databases;* ​ 查询某个数据库的字符集:查询某个数据库的创建语句 ​ show create database 数据库名称; 3.U(Update) :修改 修改数据库的字符集 alter database 据库名character set 字符集名称; 4.D(Delete) :删除 修改数据库的字符集 drop database 据库名 判断数据库存在,存在再删除 drop database if exists 数据库名称; 5.使用数据库 查询当前正在使用的数据库名称 select database(); 使用数据库 use 数据库名称; 2.操作表1.C(Create):创建 CREATE TABLE student( id int,…); 2.R(Retrieve) :查询 查询某个数据库中所有的表名称 *** show tables;** 查询表结构 *desc表名; 3.U(Update) :修改 *** update表名set 列名1 &#x3D;值1,列名2 &#x3D;值2,… [where条件];** 4.D(Delete) :删除 delete from表名; TRUNCATE TABLE 表名; DQL:查询表中的记录select * from 表名; 1.语法: select字段列表 from表名列表 where条件列表 group by分组字段 having分组之后的条件 order by排序 limit分页限定 基础查询 1,多个字段的查询 SELECT NAME, age FROM student; SELECT * FROM student; 2.去除重复 distinct SELECT DISTINCT address FROM student; 3.计算列 一般可以使用四则运算计算一些列的值。(一般只会进行数值型的计算) SELECT NAME, math, english, math + english FROM student; 如果有null参与的一般可以使用四则运算计算一些列的值。(一般只会进行数值型的计算),计算结果都为null SELECT NAME, math, english, math + IF NULL (english, 0) FROM student; 4.起别名 as可省略 SELECT NAME, math, english, math + IF NULL (english, 0) AS总分 FROM student; SELECT NAME, math, english, math + IF NULL (english, 0) 总分 FROM student; 条件查询 where子句后跟条件 运算符 &gt;、&lt; 、&lt;&#x3D; .&gt;&#x3D;. &#x3D; .&lt;&gt; BETWEEN…AND IN(集合) LIKE 模糊查询—–占位符: _:单个任意字符 %:任意多字符 IS NULL and 或&amp;&amp; or 或|| not 或 ! 1,修改表名 alter table 表名 rename to 新的表名; 2.修改表的字符集 alter table表名 character set 字符集名称; 3.添加一列 alter table 表名 add列名 数据类型; 4,修改列名称类型 alter table 表名 change 列名 新列 新数据类型; alter table 表名 modify 列名 新数据类型; 5.删除列 alter table 表名 drop名; DML:增删改表中数据1.添加数据:语法: insert into 表名(列名1,列名2,列名n) values(值1,值2,.值n); 除了数字类型,其他类型需要使用引号(单双都可以)引起来, 2.删除数据: delete from 表名[where 条件] TRUNCATE TABLE stu；——–删除表,然后再创建一个一模一样的空表 3.修改数据: update 表名 set 列名1 &#x3D;值1,列名2 &#x3D; 值2,… [where条件]; DQL:查询语句1.排序查询 按照数学成绩排名,如果数学成绩一样,则按照英语成绩排名 SELECT FROM student ORDER BY math ASC , english ASC; 语法: order by 子句 order by 排序字段1排序方式1, 排序字段2排序方式2…· 排序方式: ASC:升序,默认的。 DESC : 降序。 注意:如果有多个排序条件,则当前边的条件值一样时,才会判断第二条件。 2.聚合查询 1.count :计算不数 BELECT COUNT (If NULL (engliah, 01) FROM atudent; 2.max:计算最大值 SELECT MAX (math) FROM student; SELECT MIN (math) FROM atudent; 3.min:计算最小值 4.sum :计算和 SELECT COUNT (id) PROM student; 5.avg:计算平均值 SELECT AVG (math) PROM student; 注意:聚合函数的计算,排除null值。 解决方案: 1.选择不包含非空的列进行计算 2. IFNULL函数 3.分组查询 group by分组字段; 按照性别分组,分别查询男、女同学的平均分 SELECT sex,avg(math) FROM student GROUP BY sex: 按照性别分组,分别查询男、女同学的平均分,人数 SELECT sex,avg(math),count(id) FROM student GROUP BY sex: 接照性别分超,分别查询男、文同学的平均分,人数要求:分数低于70分的人,不参与分组 SELECT sex,AVG (math).count (id) FROM student WHERE math &gt; 70 GROOP BY sex: 接照性别分超,分别查询男、文同学的平均分,人数要求:分数低于70分的人,不参与分组分组之后要大于2个人 SELECT sex,AVG (math).count (id) FROM student WHERE math &gt; 70 GROOP BY sex having count(id)&gt;2; SELECT sex,AVG (math).count (id) 人数 FROM student WHERE math &gt; 70 GROOP BY sex having 人数&gt;2; 分组之后查询的字段:分组字段、聚合函数 where 和having 的区别? 1. where 在分组之前进行限定,如果不满足条件,则不参与分组。having在分组之后进行限定,如果不满足结果,则不会被查询出来、 2.where后不可以跟聚合函数, having可以进行聚合函数的判断。 4,分页查询 语法limit 开始的索引,每页查询的条数; 每页品示3条记录 SELECT * FROM student LIMIT 0，3； *公式:开始的案引&#x3D;(当前的页码-1) 每页显示的条数 limit操作是一个mysql的”方言” 约束概念: 对表中的数据进行限定,保证数据的正确性、有效性和完整性。 分类: 主键约束: primary key 1.1,含义:非空且唯一 1.2.一张表只能有一个字段为主键 删除主键 ALTER TABLE Btu DROP PRIMARY KEY; 自动增长: 概念:如果某一列是数值类型的,使用auto_increment可以来完成值得自动增长 INSERT INTO atu VALUES (null, ‘ccc’): AITER TABLE stu MODIFY id INT auto_increment; 删除自动增长 AITER TABLE stu MODIFY id INT; 1.3.主键就是表中记录的唯一标识 非空约束: not null -删除name的非空約東 ALTER TABLE atu MODIFY NAME VARCHAR (20) ; –创建表完后,添加非空约束 ALTER TABLE stu MODIFY NAME VARCHAR (20) NOT NUll; 3.唯一约束: unique ​ 注意:唯一约束可以有NULL值,但是只能有一条记录为null ​ 删除唯一约束 ​ ALTER TABLE Stu DROP INDEX phone_number; 4.外键约束: foreign key 1.在创建表时,可以添加外键 语法: create table 表名( …. 外键列 constraint 外键名称 foreign key （外键列名） references 主表名称(主表列名称) ); 2.删除外键 ALTER TABLE 表名 DROP FOREIGN KEY 外键名称； 3.创建表之后,添加外键 TABLE 表名ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称)； 4.添加外键,设置级联更新 ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称 (主表列名称) ON UPDATE CASCADE –添加外键,设置级联更新,设置级联删除 ALTER TABLE employee ADD CONSTRAINT emp_dept_fk FOREIGN KEY(dep id) REFERENCES department (id) ON UPDATE CASCADE ON DELETE CASCADE 2.分类: 1,级联更新: ON UPDATE CASCADE 2.级联删除: ON DELETE CASCADE 数据库的设计 1,多表之间的关系 1.一对一(了解): 如:人和身份证 分析:一个人只有一个身份证,一个身份证只能对应一个人 2.一对多(多对一): 如:部门和员工 分析:一个部门有多个员工,一个员工只能对应一个部门 3,多对多: 如:学生和课程 分析:一个学生可以选择很多门课程,一个课程也可以被很多学生选择 2,实现关系: 1.一对多(多对一): 如:部门和员工 实现方式:在多的一方建立外键,指向一的一方的主键。 2.多对多关系 多对多关系实现需要借助第三张中间表。中间表至少包含两个字段,这两个字段作为第三张表的外健,分别指向两张表的主健 3.一对一(了解): 如:人和身份证 实现方式:一对一关系实现,可以在任意一方添加唯一外键指向另一方的主键。 数据库设计的范式 *概念:设计数据库时,需要遵循的一些规范。 设计关系数据库时,遵从不同的规范要求,设计出合理的关系型数据库,这些不同的规范要求被称为不同的范式,各种范式呈递次规范,越高的范式数据库冗余越小。 目前关系数据库有六种范式:第一范式(1NF)、第二随式(2NF)、第三范式(3NF)、巴斯-科德范式(BCNF)、第四范式(4NF)和第五范式(5NF,又称完美范式)。 分类: 1.第一范式(1NF):每一列都是不可分割的原子数据项, 2.第二范式(2NF):在1NF的基础上,非码属性必须完全依赖于候选码(在1NF基础上消除非主属性对主码的部分函数依赖) 几个概念: 1.函数依赖:A–&gt;B,如果通过A属性(属性组)的值,可以确定唯一B属性的值。则称B依赖于A 例如:学号–&gt;姓名。(学号,课程名称) –&gt;分数 2.完全函数依赖:A–&gt;B,如果A是一个属性组,则B属性值得确定需要依赖于A属性组中所有的属性值。 例如:(学号,课程名称) –&gt;分数 3.部分函数依赖:A–&gt;B,如果A是一个属性组,则B属性值得确定只需要依赖于A属性组中某一些值即可。 例如:(学号,课程名称) –&gt;姓名 4.传递函数依赖:A–&gt;B, B –&gt;C.如果通过A属性(属性组)的值,可以确定唯一B属性的值,在通过B属性(属性组)的值可以确定唯一属性的值,则称C传递函数依赖于A 例如:学号–)系名,系名–&gt;系主任 5.码:如果在一张表中,一个属性或属性组,被其他所有属性所完全依赖,则称这个属性(属性组)为该表的码 例如:该表中码为:(学号,课程名称) 主属性:码属性组中的所有属性 非主属性:除过码属性组的属性, 3.第三范式(3NF):在2NF基础上,任何非主属性不依赖于其它非主属性(在2NF基础上消除传递依赖) 笛卡尔积:”有两个集合A,B,取这两个集合的所有组成情况。 要完成多表查询,需要消除无用的数据 多表查询的分类:隐式内连接:使用where条件消除无用数据 1,内连接查询: -查询所有员工信息和对应的部门信息 SELECT * FROM emp, dept WHERE emp. ‘dept_id’ &#x3D; dept. ‘id’ -查询员工表的名称,性别,部门表的名称SELECT emp. name, emp. gender, dept.name FRoM emp, dept wHERe emp. ‘dept id’ &#x3D; dept. ‘id’; 2.显式内连接: 语法:select 字段列表 from表名1 inner join表名2 on条件 SELECT * FROM emp INNER JOIN dept oN emp. ‘dept_id’&#x3D; dept. ‘id’; 2.外链接查询: 左外连接: *语法: select 字段列表from表1 left [outer] join 表2 on条件; SELECT t1.*,t2. ‘name’ FROM emp t1 LEFT JOIN dept t2 ON t1. ‘dept_id’ &#x3D; t2. ‘id’; 查询的是左表所有数据以及其交集部分。 右外连接: 语法: select 字段列表from 表1 right [outer] join表2 on条件; 查询的是右表所有数据以及其交集部分。 3.子查询: 概念:查询中嵌套查询,称嵌套查询为子查询 SELECT * FROM omp WHERE emp. ‘salary’ &#x3D; (SELECT MAX (salary) FROM emp) ; 事务的基本介绍 1.概念: *如果一个包含多个步骤的业务操作,被事务管理,那么这些操作要么同时成功,要名同时失败。 2.操作: 1.1开启事务: start transaction; 2.1回滚: rollback; 3.1提交: commit; 4.1MySQL数据库中事务默认自动提交 事务提交的两种方式: 自动提交: mysq1就是自动提交的 一条DML(增删改)语句会自动提交一次事务。 手动提交: Oracle 数据库默认是手动提交事务 需要先开启事务,再提交 修改事务的默认提交方式: 查看事务的默认提交方式: SELECT @@autocommit;–1 代表自动提交 0代表手动提交 修改默认提交方式: set @@autocommit &#x3D; 0; 2.事务的四大特征 1.原子性:是不可分割的最小操作单位,要么同时成功,要么同时失败。 2.持久性:当事务提交或回滚后,数据库会持久化的保存数据。 3.隔离性:多个事务之间。相互独立。 4.一致性:事务操作前后,数据总量不变 3.事务的隔离级别(了解) 概念:多个事务之间隔离的,相互独立的。但是如果多个事务操作同一批数据,则会引发一些问题,设置不同的隔离级别就可以解决这些问题。 存在问题: 1.脏读:一个事务,读取到另一个事务中没有提交的数据 2,不可重复读(虚读):在同一个事务中,两次读取到的数据不一样。 3.幻读:一个事务操作(DML)数据表中所有记录,另一个事务添加了一条数据,则第一个事务查询不到自己的修改。 隔离级别: 1.read uncommitted :读未提交 产生的问题:脏读、不可重复读、幻读 2.pread committed :读已提交（oracle） 产生的问题:不可重复读、幻读 3.repeatable read : 可重复读(mysql默认) 产生的问题:幻读 4.serializable :串行化 可以解决所有的问题 注意:隔离级别从小到大安全性越来越高,但是效率越来越低 数据库查询隔离级别: select @@tx_isolation; 数据库设置隔离级别: set global transaction isolation level 级别字符串; JDBC*概念: Java DataBase Connectivity Java数据库连接, Java语言操作数据库 JDBC:定义了一套操作所有关系型数据库的规则（接口） JDBC本质:其实是官方(sun公司)定义的一套操作所有关系型数据库的规则,即接口。各个数据库厂商去实现这套接口,提供数据库驱动jar包。我们可以使用这套接口(JDBC)编程,真正执行的代码是驱动jar包中的实现类 2.快速入门: *步骤: 1.导入驱动jar包mysql-connector-java-5.1.37-bin.jar 1.1复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下 1.2.右键–&gt;Add As Liblary 2.注册驱动 3.获取数据库连接对象Connection 4,定义sql 5,获取执行sq1语句的对象Statement 6.执行sql,接受返回结果 7,处理结果 8.释放资源 123456789101112131415161718192021public class JdbcDemo1&#123; public static void main(String[] args) throws Exception&#123; //1.导入驱动jar包 //2.注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //3.获取数据库连接对象 Connection conn = DriverManager.getConnection( url: &quot;jdbe:mysql://localhost:3306/db3&quot;, &quot;root&quot;,&quot;password&quot;); //4.定义sql语句 String sql= &quot;update account set balance = 500 where id = 1&quot;; //5.获取执行sql的对象Statement Statement stmt = conn.createStatement (); //6.执行sql int count= stmt.executeUpdate(sq1); //7.处理结果 System. out.println(count); //8.释放资源 stmt.close(); conn.close(); &#125; &#125; 3,详解各个对象:1.DriverManager :驱动管理对象 功能: 1.注册驱动:告近程序该使用哪一个数据库驱动jar static void registerpriver(Driver driver) :注册与给定的驱动程序 DriverManager. 写代码使用: class.forName(“com.mysql.jdbc.Driver); 通过查看源码发现:在com.mysql.jdbc.Driver类中存在静态代码块 注意:mysq15之后的驱动jar包可以省略注册驱动的步骤。 2,获取数据库连接 方法: static Connection getConnection(String url, String user, string password) 参数: url:指定连接的路径 语法: jdbc:mysql:&#x2F;&#x2F;ip地址(域名):端口号&#x2F;数据库名称 例子: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db3 细节:如果连接的是本机mysql服务器,并且mysql服务默认端口是3306,则url可以简写为:jdbc:mysql:&#x2F;&#x2F;gb1数据库名称 user :用户名 password :密码 2.connection :数据库连接对象 1,功能: 1,获取执行sql的对象 statement createstatement() Preparedstatement preparestatement (String sql) 2.管理事务: 开启事务: setAutoCommit (boolean autoCommit) :调用该方法设置参数为false,即开启事务 提交事务:commit() 回滚事务: rollback() 3.Statement :执行sql的对象 执行sql 1.boolean execute(String sql) :可以执行任意的sql了解 2.int executeUpdate(String sql) :执行DML (insert, update, delete)、DDI(create, alter, drop)语句 返回值:影响的行数,可以通过这个影响的行数判断DML语句是否执行成功返回值&gt;0的则执行成功,反之,则失败。 3.Resultset executeQuery(String sqI) :执行DQL (select)语句 4.Resultset :结果集对象 封装查询结果 boolean next():游标向下移动一行,判断当前行是否是最后一行末尾(是否有数据）如果是,则返回false,如果不是则返回true getxxx(参数):获取数据 Xxx:代表数据类型 如: int getInt() , String getstring() 参数: 1.int :代表列的编号,从1开始 如: getstring(1) **2.String :代表列名称如: getDouble(“**balance”) 12345678while (rs.next())&#123; //循环判断游标是否是最后一行末尾。 // 获取数据 int id = rs.getInt(1); String name = rs.getString(&quot;name&quot;); double balance = rs.getDouble(3); System.out.println(id+&quot;---&quot;+name+&quot;---&quot;+balance); &#125; 5. Preparedstatement :执sql的对象 1. SQL注入问题:在拼接sql时,有一些sql的特殊关键字参与字符申的拼接。会造成安全性问题 1.输入用户随便,输入密码: a’ or ‘a’ &#x3D; ‘a 2. sql: select * from user where username&#x3D; ‘fhdsjkf’ and password &#x3D; ‘a’ or ‘a’ &#x3D; ‘a’ 2.解决sql注入问题:使用Preparedstatement对象来解决 3.预编译的SQL:参数使用?作为占位符 4.步骤: 1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 2.注册驱动 3.获取数据库连接对象Connection 4,定义sql *注意: sql的参数使用?作为占位符。如: select * from user where username &#x3D; ? and password &#x3D; ?; 5. 获取执行sq1语句的对象 Preparedstatement Connection.preparestatement (String sql) 6,给?赋值: 方法: setXxx(参数1,参数2) 参数1:?的位置编号 从1开始 参数2:?的值 7.执行sql,接受返回结果,不需要传递sql语句 8.处理结果 9,释放资源 5.注意:后期都会使用Preparedstatement来完成增删改查的所有操作 1.可以防止sQL注入 2.效率更高 抽取JDBC工具类: JDBCUtils 目的:简化书写分析: 1,注册驱动也抽取 2.抽取一个方法获取连接对象 需求:不想传递参数(麻烦),还得保证工具类的通用性。 解决:配置文件 jdbc.properties url&#x3D; user&#x3D; password&#x3D; 抽取一个方法释放资源 JDBC控制事务: 1.事务:一个包含多个步骤的业务操作。如果这个业务操作被事务管理,则这多个步骤要么同时成功,要么同时失败。 2.操作: 1.开启事务 2.提交事务 3.回滚事务 3.使用Connection对象来管理事务 开启事务: setAltoCommit(boolean autoCommit) :调用该方法设置参数为false,即开后事务 在执行sql之前开启事务, 提交事务:commit() 当所有sql都执行完提交事务 回滚事务: rollback() 在catch中回滚事务 数据库连接池概念:其实就是一个容器(集合),存放数据库连接的容器。 1当系统初始化好后,容器被创建,容器中会申请一些连接对象,当用户来访问数据库时,从容器中获取连接对象,用户访问完之后,会将连接对象归还给容器。 好处: 1.节约资源 2.用户访问高效 3.实现: 1.标准接口: DataSource javax.sql包下的 1.方法: 获取连接: getConnection() 归还连接:Connection.close()如果连接对象cdnnection是从连接池中获取的,那么调用Connection.close()方法,则不会再关闭连接了。而是归还连接 2.一般我们不去实现它,有数据库厂商来实现 1.C3PO :数据库连接池技术 2.Druid :数据库连接池实现技术，由阿里巴巴提供的 C3PO:数据库连接池技术步骤:1. 导入jar包(两个) c3pe-0.9.5.2.jar mchange-commons-java-0.2.12.jar 2,定义配置文件: 名称: c3p0.properties或者c3p0-config.xml 路径:直接将文件放在src目录下即可。 3.创建核心对象 数据库连接池对象ComboPooledDataSource 4.获取连接: getConnection 5.Druid :数据库连接池实现技术,由阿里巴巴提供的 步骤: 1.导入jar包 druid-1.0.9.jar 2.定义配置文件: 是properties形式的 可以叫任意名称,可以放在任意目录下 3,加载配置文件。Properties 4.获取数据库连接池对象:通过工厂来来获取 DruidDatasourceFactory 5.获取连接 2.定义工具类 1.定义一个类JDBcutils 2.提供静态代码块加载配置文件,初始化连接池对象 3.提供方法 1.获取连接方法:通过数据库连接池获取连接 2.释放资源 3.联取连接池的方法 Spring JDBCSpring框架对JDBC的简单封装 提供了一个JDBCTemplate对象简化JDBC的开发 步骤: 1.导入jar包 2.创建]dbcTemplate对象。依赖于数据源DataSource JdbcTemplate template &#x3D; new JdbcTemplate(ds); 3.调用JdbcTemplate的方法来完成CRUD的操作 1.1update():执行DML语句。增、删、改语句 **1.2queryForMap():查询结果将结果集封装为map集合 ** 将列名作为key,将值作为value将这条记录封装为一个map集合 注意,这个方法查询的结果集长度只能是1 1.3queryForList():查询结果将结果集封装为list集合 将每一条记录封装为一个Map集合,再将Map集合装载到List集合中 1.4query():查询结果,将结果封装为JavaBean对象 query的参数: RowMapper 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 new BeanPropertyRowMapper&lt;类型&gt;(类型.class) 1.5queryForobject :查询结果,将结果封装为对象 一般用于聚合函数的查询 junit单元测试可以让方法独立执行 web概念概述 Javaweb:使用Java语言开发基于互联网的项目软件架构: 1. C&#x2F;S: client&#x2F;Server 客户端&#x2F;服务器端 在用户本地有一个客户端程序,在远程有一个服务器端程序 如:QQ,迅雷. 优点:1.用户体验好 缺点:1.开发、安装,部署,维护麻烦 2.B&#x2F;S: Browser&#x2F;Server浏览器&#x2F;服务器端 只需要一个浏览器,用户通过不同的网址(URL),客户访问不同的服务器端程序 优点: 1.开发、安装,部署,维护简单 缺点: 1.如果应用过大,用户的体验可能会受到影响 2、对硬件要求过高 B&#x2F;S架构详解 资源分类: 1.静态资源: 使用静态网页开发技术发布的资源。 特点: 所有用户访问,得到的结果是一样的。 如:文本,图片,音频、视频, HTML,CSS, Javascript 如果用户请求的是静态资源,那么服务器会直接将静态资源发送给浏览器。 浏览器中内置了静态资源的解析引擎,可以展示静态资源 2.动态资源: 使用动态网页及时发布的资源。 特点: 所有用户访问,得到的结果可能不一样。 如: jsp&#x2F;servlet,php, asp… 如果用户请求的是动态资源,那么服务器会执行动态资源,转换为静态资源,再发送给浏览器 XML:1. 概念: Extensible Markup Language 可扩展标记语言 可扩展:标签都是自定义的。 2,功能 存储数据1.配置文件2.在网络中传输 3.xml与tml的区别 properties 1.xml标签都是自定义的, html标签是预定义。 2.xml的语法严格, html语法松散 W3c:万维网联盟 2.语法: 基本语法: 1.xml文档的后缀名.xml 2.xml第一行必须定义为文档声明 3.xml文档中有且仅有一个根标签 4.属性值必须使用引号(单双都可)引起来 5.标签必须正确关闭 6.xml标签名称区分大小写 快速入门: 组成部分: 1.文档声明 1.1. 格式: 2.属性列表; version :版本号 encoding :编码方式 告知解析引擎当前文档使用的字符集,默认值: ISO-8859-1 standalone :是否独立—-取值: yes :不依赖其他文件 no:依赖其他文件 2.指令 结合css的 3标签 标签名称自定义的 名称可以包含字母、数字以及其他的字符 名称不能以数字或者标点符号开始 名称不能以字母xml(或者XML、Xml等等)开始 名称不能包含空格 4.属性 id属性值唯一 5.文本 CDATA区:在该区域中的数据会被原样展示 谁编写xml?-用户,软件使用者 谁解析xml?-软件 约束 说明文档：规定xml文档的书写规则—约束文档 作为框架的使用者(程序员): 1.能够在xml中引入约東文档 2.能够简单的读懂约束文档 分类: 1.DTD:一种简单的约束技术 2.Schema:一种复杂的约束技术 123456&lt;!ELEMENT students (student*) &gt; &lt;!ELEMENT student (name, age, sex)&gt;&lt;!ELEMENT name (#PCDATA)&gt;&lt;!ELEMENT age (#PCDATA)&gt;&lt;!ELEMENT sex (#PCDATA)&gt;&lt;!ATTLIST student number ID #REQUIRED&gt; DTD 引入dtd文档到xml文档中 内部dtd:将约束规则定义在xml文档中 外部dtd:将约束的规则定义在外部的dtd文件中 本地: 网络: 1.填写xml文档的根元素 2.引入xsi前 xmlns:xsi&#x3D;”http://www.w3.org/2001/XMLSchema-instance“ 3.引入xsd文件命名空间. xsi:schemaLocation&#x3D;”http://www.itcast.cn/xml student.xsd” 4.为每一个xsd约束声明一个前级,作为标识 xmlns&#x3D;”http://www.itcast.cn/xml“ 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/xMLSchema-instance&quot; xmlns:context=&quot;http://www. springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www. springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www. springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/mvchttp://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; 3.解析:操作xml文档,将文档中的数据读取到内存中 操作xml文档 1.解析(读取):将文档中的数据读取到内存中 2.写入:将内存中的数据保存到xml文档中。持久化的存储 解析xml的方式: 1.DOM:将标记语言文档一次性加载进内存,在内存中形成一颗dom树 优点:操作方便,可以对文档进行CRUD的所有操作 缺点:占内存 2.SAX:逐行读取,基于事件驱动的。 优点:不占内存。 缺点:只能读取,不能增删改 xml常见的解析器: 1.JAXP: sun公司提供的解析器,支持dom和sax两种思想 2.DOM4j:一款非常优秀的解析器 3.jsoup: jsoup是一款Java 的HTML解析器,可直接解析某个URL地址、”HTML文本内容。它提供了一套非常省力的API,可通过DOM, Css以及类似于jQuery的操作方法来取出和操作数据。 4.PÜLL : Android操作系统内置的解析器, sax方式的。 快速入门: 步骤:1. 导入jlar包 2,获取Document对象 3.获取对应的标签Element对象 4,获取数据 对象的使用: 1.Jsoup :工具类,可以解析html或xml文档,返回Document parse :解析html或xml文档,返回Document parse(File in, string charsetName) :解析xml或html文件的。 parse(String html):解析xml或html字符串 parse(URL url, int timeoutMillis) :通过网络路径获取指定的html或xml的文档对象 2.Document :文档对象。代表内存中的dom树 获取Element对象 getElementById(String id) :根据id属性值获取唯一的element对象 getElementsByTag(String tagName):根据标签名称获取元素对象集合 getElementsByAttribute(String key) :根据属性名称获取元素对象集合 getElementsByAttributeValue(String key, String value) :根据对应的属性名和属性值获取元素对象集合 3.Elements :元素Element对象的集合。可以当做ArrayList来使用 4.Element :元素对象 获取子元素对象 getElementById(stying id) :根据id属性值获取唯一的element对象 getElementsByTag(String tagName) :根据标签名称获取元素对象集合 getElementsByAttribute(String key):根据属性名称获取元素对象集合 getelementsByAttributevalue(String key, String value) :根据对应的属性名和属性值获取元素对象集合 2.获取属性值 string attr(String key) :根据属性名称获取属性值 3.获取文本内容 string text() :获取文本内容 String html():获取标签体的所有内容(包括字标签的字符串内容) 5.Node :节点对象 是Document和Element的父类 快捷查询方式: 1.selector:选择器 使用的方法: Elementsselect(String cssQuery) 语法:参考selector类中定义的语法 2.XPath:XPath即为XML路径语言,它是一种用来确定XML(标准通用标记语言的子集)文档中某部分位置的语言 使用]soup的Xpath需要额外导入jar包。 查询w3cshool参考手册,使用xpath的语法完成查询 web相关概念回顾 1.软件架构 1.C&#x2F;S 客户端&#x2F;服务器端 2.B&#x2F;S 浏览器&#x2F;服务器端 2.资源分类 1 ,静态资源 所有用户访问后,得到的结果都是一样的,称为静态资源,静态资源可以直接被浏览器解析 2,动态资源 每个用户访问相同资源后,得到的结果可能不一样。称为动态资源。动态资源被访问后,需要先转换为静态资源,在返回给浏览器 3.网络通信三要素 1.IP 电子设备(计算机)在网络中的唯一标识。 2.端口 应用程序在计算机中的唯一标识 0-65536 3.传输协议 ·规定了数据传输的规则 基础协议: tcp:安全协议,三次握手。速度稍慢 udp:不安全协议。速度快 Servlet server applet 概念:运行在服务器端的小程序Servlet就是一个接口、定义了Java类被浏览器访问到(tomcat识别)的规则 将来我们自定义一个类,实现Servlet接口,复写方法 快速入门: 1.创建JavaEE项目 2.定义一个类,实现servlet接口 3.实现接口中的抽象方法 4.配置Servlet 在web.xml里面 123456789&lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 执行原理: 1当服务器接受到客户端浏览器的请求后,会解析请求URL路径,获取访问的Servlet的资源路径 2.查找web,xml文件,是否有对应的标签体内容。 3.如果有,则在找到对应的全类名 4.tomcat会将字节码文件加载进内存,并且创建其对象 5.调用其方法 Servlet中的生命周期 1被创建 执行init方法,只执行一次 Servlet什么时候被创建? 默认情况下,第一次被访问时, Servlet被创建 12345在&lt;servlet&gt;标签下配置第一次被访问时创建 &lt;load-on-startup&gt;的值为负值在服务器启动时创建&lt;load-on-startup&gt;的值为0或正数 servlet的init方法,只执行一次,说明一个Servlet在内存中只存在一个对象, Servlet是单例的 多个用户同时访问时,可能存在线程安全问题。 解决:尽量不要在Servlet中定义成员变量。即使定义了成员变量,也不要对修改值 2.提供服务 执行service方法,执行多次 每次访问Servlet时, Service方法都会被调一次。 3.被销毁 执行destroy方法,只执行一次 Servlet被销毁时执行。服务器关闭时, Servlet被销毁 只有服务器正常关闭时,才会执行destroy方法。 destroy方法在servlet被销毁之前执行,一般用于释放资源 servlet3.0: 好处:支持注解配置。可以不需要web.xml了。 步骤: 1.创建JavaEE项目,选择Servlet的版本3.0以上,可以不创建web.xml 2.定义一个类,实现Servlet接口 3.复写方法 4.在类上使用@Webservlet注解,进行配置 @WebServlet(“资源路径”) IDEA与tomcat的相关配置 1. IDEA会为每一个tomcat部署的项目单独建立一份配置文件 查看控制台的log : Using CATALINA_BASE: “C: \\UsersIfay). IntelliJIdea2018.1)system)tomcat_itcast” 2.工作空间项目 和tomcat部署的web项目 tomcat真正访问的是”tomcat部署的web预目”,”tomcat部署的web项目”对应着”工作空间项目”的web目录下的所有资源 WEB-INF目录下的资源不能被测览器直接访问。 3.断点调试:使用”小虫子”启动dubug启动 6. Servlet的体系结构 **Servlet –接口 ** | GenericServlet –抽象类 | HttpServlet –抽象类 GenericServlet :将Servlet接口中其他的方法做了默认空实现,只将service()方法作为抽象 将来定义servlet类时,可以继承GedericServlet,实现service()方法即可 ettpServlet:对http协议的一种封装,简化操作 1,定义类继承Httpservlet 2.复写doGet&#x2F;doPost方法 7.Servlet相关配置 1.urlpartten: Servlet访问路径 一个servlet可以定义多个访问路径@WebServlet({“&#x2F;d4”,”&#x2F;dd4”,”&#x2F;ddd4”}) 2.路径定义规则: 1. &#x2F;xxx 2. &#x2F;xxx&#x2F;xxx *3. .doi HTTP : 概念: Hyper Text Transfer Protocol超文本传输协议 传输协议:定义了,客户端和服务器端通信时,发送数据的格式 特点: 1.基于TCP&#x2F;IP的高级协议 2.默认端口号:80 3.基于请求&#x2F;响应模型的:一次请求对应一次响应 4.无状态的:每次请求之间相互独立 历史版本: 1.0:每一次请求响应都会建立新的连接 1.1:复用连接 请求消息数据格式 1.请求行 请求方式 请求url请求协议&#x2F;版本 **GET &#x2F;login.html HTTP&#x2F;1.1 ** 请求方式:HTTP协议有7中请求方式,常用的有2种 GET: 1.请求参数在请求行中,在url后。 2.请求的url长度有限制的 3.不太安全 POST: 1.请求参数在请求体中 2.请求的url长度没有限制的 3.相对安全 2.请求头 客户端浏览器告诉服务器一些信息 请求头名称:请求头值 常见的请求头: 1. User-Agent :浏览器告诉服务器,我访问你使用的浏览器版本信息 可以在服务器端获取该头的信息,解决浏览器的兼容性问题 2. Referer: http://localhost/login.html 告诉服务器,我(当前请求)从哪里来? 作用:1.防盗链:2.统计工作: 3.请求空行 空行 就是用于分割POST请求的请求头,和请求体的。 4,请求体（正文） 封装POST请求消息的请求参数的 字符串格式: GET &#x2F;login.html HTTP&#x2F;1.1 Host: localhost User-Agent: Moz[lla&#x2F;5.0 (windows NT 6.1; win64; x64; rv:60.0) Gecko&#x2F;20100101 Firefox&#x2F;60.0 *Accept: text&#x2F;html, application&#x2F;xhtml+xml, application&#x2F;xml;q&#x3D;0.9, &#x2F;;q&#x3D;0.8* Accept-Language: zh-CN, zh; q&#x3D;0.8, zh-TW; q&#x3D;0.7, zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3, en;q&#x3D;0.2 Accept-Encoding: gzip, deflate Connection: keep-alive Upgrade-Insecure-Requests: 1 响应消息数据格式 Request 1.request对象和response对象的原理 1.2.request和response对象是由服务器创建的。我们来使用它们 1.3.request对象是来获取请求消息, response对象是来设置响应消息 2. request :获取请求消息 2.1request对象继承体系结构: ServletRequest -接口 | 继承 HttpServletRequest -接口 | 实现 org.apache.catalina.connector.RequestFacade 类（tomcat） **3. request 功能: ** 1.获取请求消息数据 ​ 1.获取请求行数据 ​ GET &#x2F;day14&#x2F;demo1?name&#x3D;zhangsan HTTP&#x2F;1.1 ​ 方法: ​ 1,获取请求方式:GET ​ String getMethod() ​ 2.(*)获取虚拟目录:&#x2F;day14 ​ String getContextPath() ​ 3. 获取Servlet路径: &#x2F;demo1 ​ string getServletPath() ​ 4. 获取get方式请求参数: name&#x3D;zhangsan ​ String getQueryString() ​ 5.(*)获取请求URI: &#x2F;day14&#x2F;demo1 ​ string getRequestURI():&#x2F;day14&#x2F;demo1 ​ stringBuffer getRequestURL() http://localhost/day14/demo1 ​ URL:统资源定位符:http://localhost/day14/demo1 中华人民某和国 ​ URI统一资源标识符:&#x2F;day14&#x2F;demo1 共和国 ​ 6.获取协议及版本: HTTP&#x2F;1.1 ​ string getProtocol() ​ 7.获取客户机的IP地址: ​ string getRemoteAddr() ​ 2.获取请求头数据 ​ 方法: ​ **String getHeader(String name):通过请求头的名称获取请求头的值 ** ​ EnumerationgetHeaderNames():获取所有的请求头名称 3,获取请求体数据 ​ 请求体:只有POST请求方式,才有请求体,在请求体中封装了POST请求的请求参数 步骤: 1.获取流对象 BufferedReader getReader() 获取字符输入流,只能操作字符数据 ServletInputStream getInputStream() :获取字节输入流,可以操作所有类型数据 在文件上传知识点后讲解 2.再从流对象中拿数据 2.其他功能 1.获取请求参数通用方式 无论get还是post请求方式都可以使用下列方法来获取请求参数 1.1.String getParameter(String name) :根据参数名称获取参数值 username&#x3D;zs&amp;password&#x3D;123 1.2.String[ ] getParameterValues(String name) :根据参数名称获取参数值的数组 hobby&#x3D;xx&amp;hobby&#x3D;game 1.3.Enumeration getParameterNames ():获取所有请求的参数名称 1.4.Map&lt;string, String[]&gt; getParameterMap():获取所有参数的map集合 中文乱码问题: get方式: tomcat 8 已经将get方式乱码问题解决了 post方式会乱码 *解决:在获取参数前,设置request的编码request.setCharacterEncoding(“utf-8”); 2.请求转发: 一种在服务器内部的资源跳转方式 1.步骤: 1.通过request对象获取请求转发器对象: RequestDispatcher getRequestDispatcher(String path) 2. 使用RequestDispatcher对象来进行转: forward(ServletRequest request, ServletResponse response) 2.特点: 1.浏览器地址栏路径不发生变化 2.只能转发到当前服务器内部资源中。 3.转发是一次请求 3.共享数据 域对象:一个有作用范围的对象,可以在范国内共享数据 request域:代表一次请求的范围,一股用于请求转发的多个资源中共享数据 方法: 1. void setAttribute(String name,object obj) :存储数据 2. object getattitude(String name) :通过健获取值 3. void removeAttribute(String name):通过键移除健值对 4.获取ServletContext Servletcontext getservletContext() 1. tomcat服务器会根据请求url中的资源路径,创建对应的ServletDemol的对象。 2. tomcat服务器,会创建reguest和response对象, request对象中封装请求消息数据。 3. tomcat将reauest和response两个对象传递给service方法,并且调用service方法。 4,程序员(我们),可以通过request对象获取请求消息数据,通过通过,response对象设置响应消息数据 5,服务器在给浏览器做出响应之前,会从response对象中拿程序员设置的响应消息数据。 Beanutils工具类,简化数据封装 用于封装JavaBean的 1. JavaBean : 标准的Java类 1.要求: 1.类必须被public修饰 2.必须提供空参的构造器 3.成员变量必须使用private修饰 4.提供公共setter和getter方法 2.功能:封装数据 2.概念: 成员变量: 属性: setter和getter方法截取后的产物 例如: getusername() –&gt; Username–&gt; username 3.方法: 1. setProperty() 2. getproperty() **3. populate(object obj , Map map):将map集合的键值对信息,封装到对应的JavaBean对象中 ** HTTP协议: 1.请求消息:客户端发送给服务器端的数据 数据格式: 1.请求行 2.请求头 3.请求空行 4.请求体 2,响应消息:服务器端发送给客户端的数据 数据格式: 1.响应行 ​ 1.组成:协议&#x2F;版本响应状态码 状态码描述 ​ 2.响应状态码:服务器告诉客户端浏览器本次请求和响应的一个状态。 ​ 1,状态码都是3位数字 ​ 2.分类: ​ 1. 1xx：服务器就收客户端消息,但没有接受完成,等待一段时间后,发送1xx多状态码, ​ 2. 2xxI：成功 代表: 200 ​ 3. 3xx:重定向。代表: 302(重定向) 304(访问缓存) ​ 4. 4xx：客户端错误。 ​ 代表: ​ 404(请求路径没有对应的资源) ​ 405:请求方式没有对应的doxxx方法 ​ 5. 5xx:服务器端错误 服务器端错误。代表:500(服务器内部出现异常)。 2.响应头 1.格式:头名称:值 2.常见的响应头: 1. Content-Type:服务器告诉客户端本次响应体数据格式以及编码格式, 2.Content-disposition :服务器告诉客户端以什么格式打开响应体数据 值: in-line:默认值,在当前页面内打开 attachment；filename&#x3D;xxx :以附件形式打开响应体 文件下载 3.响应空行 4.响应体 响应字符串格式 HTTP&#x2F;1.1 200 OK Content-Type: text&#x2F;html; charset&#x3D;UTF-8 Content-Length: 101 Date: wed, 06 Jun 2018 07:08:42 GMT 12345&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello World! respones&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; Response对象 功能:设置响应消息 1,设置响应行 1. 格式: HTTP&#x2F;1.1 200 ok 2.设置状态码: setsifaltus(int sc) 2.设置响应头 setHeader(String name, String value) 3.设置响应体 使用步骤: 1.获取输出流 字符输出流: Printwriter getwriter() 字节输出流: ServletoutputStream getoutputStream() 2.使用输出流,将数据输出到客户端浏览器 案例: 1.完成重定向 重定向：资源跳转的方式 代码实现 123456//访问responseDemo1自动跳转到Demo2资源 //1.设置状态码为302// resp.setStatus(302); //2.设置响应头location// resp.setHeader(&quot;location&quot;,&quot;/day15/responseDemo2&quot;); resp.sendRedirect(&quot;/day15/responseDemo2&quot;); 重定向的特点 redirect 1,地址栏发生变化 2.重定向可以访问其他站点(服务器)的资源 3,重定向是两次请求 转发的特点:forward 1.转发地址栏路径不变 2.转发只能访问当前服务器下的资源 3.转发是一次请求 可以使用request对象来共享数据 forward和 redirect区别 路径写法: 1.路径分类 1.1,相对路径:通过相对路径不可以确定唯一资源 如:.&#x2F;index.html 不以&#x2F;开头,以,开头路径 规则:找到当前资源和目林资源之间的相对位置关系 .&#x2F;:当前目录 ..&#x2F;:后退一级目录 1.2.绝对路径:通过绝对路径可以确定唯一资源 如: http://localhost/day15/responseDemo2 &#x2F;day15&#x2F;responseDemo2 以&#x2F;开头的路径 规则:判断定义的路径是给谁用的?判断请求将来从哪儿发出 给客户端浏览器使用:需要加虚拟目录(项目的访问路径) 建议虚拟目录动态获取: request.getcontextPath() , 重定向… 给服务器使用:不需要加虚拟目录 转发路径 2.服务器输出字符数据到浏览器 步骤: 1.获取字符输出流 2.输出数据 注意: 乱码问题: 1. Printwriter pw&#x3D; response.getwriter();获取的流的默认编码是IS0-8859-1 2.设置该流的默认编码 3.告诉浏览器响应体使用的编码 &#x2F;&#x2F;简单的形式,设置编码,是在获取流之前设置 response.setcontentType(“text&#x2F;html;charset&#x3D;utf-8”); 3.服务器输出字节数据到浏览器 步骤: 1.获取字节输出流 2.输出数据 4.验证码 1.本质:图片 2.目的:防止恶意表单注册 servletContext对象 1.概念:代表整个web应用,可以和程序的容器(服务器)来通信 2.获取: 1.通过request对象获取 request.getservletcontext(); 2. 通过HttpServlet获取 this.getServletcontext(); 3.功能: 1,获取MIME类型: MIME类型:在互联网通信过程中定义的一种文件数据类型 格式:大类型&#x2F;小类型 text&#x2F;html image&#x2F;jpeg 获取: String getMimeType(String file) 2.域对象:共享数据 1. setAttribute(String name, Object value) 2. getattribute(String name) 3. removeAttribute(string name) Servletcontext对象范围:所有用户所有请求的数据 3.获取文件的真实(服务器)路径 1. 方法: string getRealPath(Strihg path) 会话技术1.会话:一次会话中包含多次请求和响应。 一次会话:浏览器第一次给服务器资源发送请求,会话建立,直到有一方断开为止 2.功能:在一次会话的范围内的多次请求间,共享数据 3.方式: 1,客户端会话技术:Cookie 2.服务器端会话技术: Sesslion Cookie:1.概念:客户端会话技术,将数据保存到客户端 2.快速入门: 使用步骤: 1.创建cookie对象,绑定数据 new Cookie(String name, String value) 2.发送Cookie对象 response.addCookie(Cookie cookie) 3.获取Cookie,拿到数据 **Cookie[ ] request.getcookies () ** 3.实现原理 基于响应头set-cookie和请求头cookie实现 4. cookie的细节 1.一次可不可以发送多个cookie? 可以 可以创建多个Cookie对象,使用response调用多次addcookie方法发送cookie即可。 2. cookie在浏览器中保存多长时间? 1.默认情况下,当浏览器关闭后, cookie数据被销毁 2.持久化存储: setMaxAge (int seconds) 1,正数:将cookie数据写到硬盘的文件中。持久化存储。cookie存活时间。 2.负数:默认值 3.零:删除cookie信息 3. cookie能不能存中文? 在tomcat 8之前cookie中不能直接存储中文数据。 需要将中文数据转码–一般采用URL编码(%E3) 在tomcat 8之后,cookie支持中文数据。 4. cookie共享问题? 假设在一个tomcat服务器中,部署了多个web项目,那么在这些web项目中cookie能不能共享? 默认情况下cookie不能共享 setPath(String path):设置cookie的获取范围。默认情况下,设置当前的虚拟目录 如果要共享,则可以将path设置为”&#x2F;“ 2.不同的tomcat服务器间cookie共享问题? setDomain(String path):如果设置一级域名相同,那么多个服务器之间cookie可以共享 setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中cookie可以共享 5. cookie的特点和作用 1. cookie存储数据在客户端浏览器 2.浏览器对于单个cookie 的大小有限制(4kb)以及 对同一个域名下的总cookie数量也有限制(20个)* 作用: 1. cookie一般用于存出少量的不太敏感的数据 2,在不登录的情况下,完成服务器对客户端的身份识别 6.案例:记住上一次访问时间 1.需求: 1.访问一个Servlet,如果是第一次访问,则提示:您好,欢迎您首次访问。 2.如果不是第一次访问,则提示:欢迎回来,您上次访问时间为:显示时间字符申 2.分析: 1,可以采用cookie来完成 2,在服务器中的Servlet判断是否有一个名为lastTime的cookie 1,有:不是第一次访问 1.响应数据:您好,欢迎您首次访问 2.写回cookie: lastTime&#x3D;2018年6月10日11:50:01 2,没有:是第一次访问, 1.响应数据:您好,欢迎您首次访问 2.写回cookie: lastTime&#x3D;2018年6月10日11:50:01 JSP:入门学习1,概念: Java Server Pages: java服务器端页面 可以理解为:一个特殊的页面,其中既可以指定定义html标签,又可以定义java代码 用于简化书写!!! 2.原理 JSP本质上就是一个Servlet 3. JSP的脚本: JSP定义Java代码的方式 1.&lt;% 代码 %&gt;:定义的java代码,在service方法中。service方法中可以定义什么,该脚本中就可以定义什么。 2.&lt;%!代码%&gt;:定义的java代码,在jsp转换后的java类的成员位置。 3.&lt;%&#x3D;代码 %&gt;:定义的java代码,会输出到页面上。输出语句中可以定义什么,该脚本中就可以定义什么。 4. JSP的内置对象 在jsp页面中不需要获取和创建,可以直接使用的对象 jsp一共有9个内置对象。 今天学习3个: request response out :字符输出流对象。可以将数据输出到页面上。和response.getwriter()类似 response.getwriter)和out.write()的区别: Session:1.概念:服务器端会话技术,在一次会话的多次请求间共享数据,将数据保存在服务器端的对象中。Httpsession 2.快速入门: 1.1获取Httpsession对象: Httpsession session &#x3D; request.getSession(); 1.2使用HttpSession对象: Httpsession对象:object getattribute(String name) void setAttribute(String name, object value) void removeAttribute(String name)i 3.原理 Session的实现是依赖于cookie的。 4.细节: 1.当客户端关闭后,服务器不关闭,两次获取session是否为同一个? 默认情况下。不是。 如果需要相同,则可以创建cookie,键为JSESSIONID,设置最大存活时间,让cookie持久化保存。 Cookie c &#x3D; new Cookie(“JSESSIONID”, session.getId()); C.setMaxAge(60*60); response.addCookie(c); 2.客户端不关闭,服务器关闭后,两次获取的session是同一个吗? 不是同一个但是要确保数据不丢失 session的顿化: 在服务器正常关闭之前,将session对象系列化到硬盘上 session的活化: 在服务器启动后,将session文件转化为内存中的session对象即可。 3. session的失效时间? 1,服务器关闭 2. session对象调用invalidate() . 3. session默认失效时间30分钟选择性配置修改 30 5. session的特点 1. session用于存储一次会话的多次请求的数据,存在服务器端 2. session可以存储任意类型,任意大小的数据 session与cookie的区别: 1. session存储数据在服务器端, Cookie在客户端 2. session没有数据大小限制, cookie有 3. session数据安全, cookie相对于不安全 JSP: 1.指令 作用:用于配置JSP页面,导入资源文件 格式:&lt;%@指令名称 属性名1&#x3D;属性值1属性名2&#x3D;属性值2 …%&gt; 分类: 1. page:配置JSP页面的 contentType :等同Fresponse.setContentType() 1.1设置响应体的mime类型以及字符集 1.2.设置当前jsp页面的编码(只能是高级的IDE才能生效,如果使用低级工具,则需要设置pageEncoding属性设置当前页面的字符集 import : 导包errorPage:当前页面发生异常后,会自动跳转到指定的错误页面 isErrorPage:标识当前也是是否是错误页面。 true :是,可以使用内置对象exception false :否。默认值。不可以使用内置对象exception 2. include :页面包含的。导入页面的资源文件 &lt;%@include file&#x3D;”top.jsp”%&gt; 3. taglib : 导入资源 &lt;%@ taglib prefix&#x3D;”c” uri&#x3D;”http://java.sun.com/jsp/jstl/core“ % prefix :前缀,自定义的 2.注释 1. html注释::只能注释html代码片段 2. jsp注释:推荐使用&lt;%– –%&gt; :可以注释所有 3.内置对象 在jsp页面中不需要创建,直接使用的对象 一共有9个: 变量名 真实类型 作用 pageContext PageContext 当前页面共享数据 request HttpservletRequest 一次请求访问的多个资源(转发) session Httpsession 一次会话的多个请求间 application Servletcontext 所有用户间共享数据 response HttpservletResponse 响应对象 page object 当前页面(Servlet)的对象 this out jspwriter 输出对象,数据输出到页面上 **config ** Servletconfig Servlet的配置对象 **exception ** Throwable 异常对象 MVC:开发模式1. jsp演变历史 1.早期只有servlet,只能使用response输出标签数据,非常麻烦 2.后来又jsp,简化了Servlet的开发,如果过度使用jsp,在jsp中即写大量的java代码,有写html表,造成难于维护,难于分工协作 3.再后来, java的web开发,借鉴vc开发模式,使得程序的设计更加合理性 2. MVC: 1. M: Model, 模型 JavaBean 完成具体的业务操作,如:查询数据库,封装对象 2. v: View,视图 JSP 展示数据 3. C: Controller, 控制器 Servlet 获取用户的输入 调用模型 将数据交给视图进行展示 优缺点: 1,优点: 1.耦合性低,方便维护,可以利于分工协作 2.重用性高 2.缺点: 1.使得项目架构变得复杂,对开发人员要求高 EL表达式1.概念 Expression Language表达式语言 2.作用:替换和简化jsp页面中java代码的编写 3.语法:${表达式} 4.注意: jsp默认支持el表达式的。如果要忽略el表达式 1.设置jspPpage指令中:isELIgnored&#x3D;”true”忽略当前jsp页面中所有的el表达式 2. ${表达式}:忽略当前这个el表达式 5.使用: 1.运算 运算符: 1. 算数运算符: + - * &#x2F; (div) % (mod) 2.比较运算符:&gt;&lt;&gt;&#x3D; &lt;&#x3D; &#x3D;&#x3D;!&#x3D; 3. 逻辑运算符: &amp;&amp;(and) II(or) !(not) 4,空运算符: empty 功能:用于判断字符串、集合、数组对象是否为null或者长度是否为0 ${empty list}：判断字符申!集合、数组对象是否为null或者长度为0 ${not empty str}:表示判断字符串、集合、数组对象是否不为null并目长度&gt;0 2.获取值 1. el表达式只能从域对象中获取值 2.语法: 1. ${域名称,键名}:从指定域中获取指定键的值 域名称: 1. pagescope–&gt; pageContext 2. requestscope–&gt; request 3. sessionScope –&gt; session 4. applicationScope –&gt; application (Servletcontext) 举例:在request域中存储了name&#x3D;张三 获取: ${requestscope. name} 2.${键名}:表示依次从最小的域中查找是否有该键对应的值,直到找到为止。 3.获取对象、List集合、Map集合的值 1.对象:${域名称,键名,属性名} 本质上会去调用对象的getter方法 2. List集合: ${域名称.键名[索引]} 3. Map集合: ${域名称.键名.key名称} ${域名称,键名[“key名称”]} 3.隐式对象: el表达式中有11个隐式对象 pageContext: 获取jsp其他八个内置对象 ${pageContext.request.contextPath}: 动态获取虚拟目录 JSTL 1.概念: JavaServer Pages Tag Library JSP标准标签库 是由Apache组织提供的开源的免费的jsp标签 &lt;标签&gt; 2.作用:用于简化和替换jsp页面上的java代码 3.使用步骤: 1. 导入jstl相关jar包 2. 引入标签库: taglib指令: &lt;%@ taglib %&gt; 3.使用标签 4.常用的JSTL标签 1. if： 相当于java代码的if语句 1.属性:test必须属性,接受boolean表达式 如果表达式为true,则显示if标签体内容,如果为false,则不显示标签体内容 一般情况下, test属性值会结合el表达式一起使用 2.注意:c:if标签没有else情况,想要else情况,则可以在定义一个c:if标签 2. choose：相当于java代码的switch语句 1.使用choose标签声明相当于switch声明 2.使用when标签做判断相当于case 1.使用choose标签声明相当于switch声明 2.使用when标签做判断相当于case 3.使用otherwise标签做其他情况的声明相当于default 3.使用otherwise标签做其他情况的声明相当于default 3. foreach：相当于java代码的for语句 1,完成重复的操作 属性: begin:开始值 end:结束值 var:临时变量 step:步长 varStatus:循环状态对象 index:容器中元素的索引,从0开始 count:循环次数,从1开始 2.遍历容器 List list; for(User user: list){} 属性: items :容器对象 var:容器中元素的临时变量 三层架构:软件设计架构 1.界面层(表示层):用户看的得界面。用户可以通过界面上的组件和服务器进行交互, 2.业务逻辑层:处理业务逻辑的。 数据访问层:操作数据存储文件。 Filter:过滤器1.概念:生活中的过滤器:净水器,空气净化器,土匪、 web中的过滤器:当访问服务器的资源时,过滤器可以将请求拦截下来,完成一些特殊的功能。 过滤器的作用: 一般用于完成通用的操作。如:登录验证、统一编码处理、敏感字符过滤. 2.快速入门: 1,步骤: 1.定义一个类,实现接口Filter 2.复写方法 3.配置兰截路径 3.过滤器细节: 1.web.xml配置 12345678&lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;cn.itcast.web.filer.FilterDemo1&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 2.过滤器执行流程 1.执行过滤器 2.执行放行后的资源 3、回来执行过滤器放行代码下边的代码, 3.过滤器生命周期方法 1. init:在服务器启动后,会创建Filter对象,然后调用init方法。只执行一次。用于加载资源 2. doFilter:每一次请求被拦截资源时,会执行。执行多次 3. destroy:在服务器关闭后, Filter对象被销段。如果服务器足正常关闭,只会执行destrov方法。只执行一次。用工释放资源。 4,过滤器配置详解 拦載路径配置: 1.具体资源路径: &#x2F;index.jsp 只有访问index.jsp资源时,过滤器才会被执行 2.拦截目录:&#x2F;user&#x2F; 访问&#x2F;user下的所有资源时,过滤器都会被执行拦截方式配置:* *3.后缀名拦截: .jsp 访问所有后缀名为jsp资源时,过滤器都会被执行 4,拦截所有资源:&#x2F; 访问所有资源时,付滤器都会被执行* 5.过滤器链(配置多个过滤器) 拦截方式配置:资源被访问的方式 注解配置:设置dispatcherTypes属性 1. REQUEST :默认值。浏览器直接请求资源 2. FORWARD :转发访问资源 3. INCLUDE : 包含访问资源 4. ERROR:错误跳转资源 5. ASYNC :异步访问资源 web.xml配置 设置标签即可 5.过滤器链(配置多个过滤器) 执行顺序:如果有两个过滤器:过滤器1和过滤器2 1.过滤器1 2.过滤器2 3.资源执行 4,过滤器2 5.过滤器1 过滤器先后顺序问题: 1.注解配置:按照类名的字符串比较规则比较,值小的先执行 如:AFilter 和BFilter, Afilter就先执行了。 2. web. xml配置:谁定义在上边,谁先执行 增强对象的功能: 设计模式:一些通用的解决固定问题的方式 1,装饰模式 2.代理模式 概念: 1,真实对象:被代理的对象 2.代理对象: 3.代理模式:代理对象代理真实对象,达到增强真实对象功能的目的 实现方式: 1.静态代理:有一个类文件描述代理模式 2,动态代理:在内存中形成代理类 实现步骤: 1.代理对象和真实对象实现相同的接口 2. 代理对象 &#x3D; Proxy.newInstance(); 3.使用代理对象调用方法。 4,增强方法 增强方式: 1.增强参数列表 2.增强返回值类型 3.增强方法体执行逻辑 Listener :监听器 概念:web的三大組件之一。 事件监听机制 事件 :一件事情 事件源:事件发生的地方 监听器:一个对象 **注册监听:将事件、事件源、监听器绑定在一起。当事件源上发生某个事件后,执行监听器代码 ** ServletContextListener:监听servletcontext对象的创建和销毁 void contextDestroyed(ServletContextEvent sce):Servletcontext对象被销毁之前会调用该方法 void contextInitialized(ServletContextEvent sce):Servletcontext对象创建后会调用该方法 步骤: 1.定义一个类,实现ServletcontextListener接口 2.复写方法 3.配置 1. web.xml cn.itcast.web.listener.ContextLoaderListener 2.注解: 指定初始化参数 @webListener AJAX:1. 概念: ASynchronous JavaScript And XML 异的Javascript 和XML 1.异步和同步:客户端和服务器端相互通信的基础上 客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。 客户端不需要等待服务器端的响应。在服务器处理请求的过程中,客户端可以进行其他的操作。 Ajax是一种在无需重新加载整个网页的情况下,能够更新部分网页的技本 通过在后台与服务器进行少量数据交换,Ajax可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下,对网页的某部分进行更新。传统的网页(不使用Ajax)如果需要更新内容,必须重载整个网页页面。 2.实现方式: 1,原生的Js现方式 2. JQeury实现方式 1. $.ajax() 12345678910111213141516语法:S.ajax(&#123;键值对&#125;);//使用$.ajax()发送异步请求$.ajax(&#123;url: &quot;ajaxServlet1111&quot; , // 请求路径type: &quot;POST&quot; , //请求方式//data: &quot;username=jack&amp;age=23&quot;,//请求参数data: &#123;&quot;username&quot;: &quot;jack&quot;, &quot;age&quot; :23&#125;,success: function (data) &#123;alert(data);&#125;,//响应成功后的回调函数error: function () &#123;alert(&quot;出错啦...&quot;)&#125;,//表示如果请求响应出现错误,会执行的回调函数datatype: &quot;text&quot;//设置接受到的响应数据的格式&#125;); 2. $.get()发送get请求 12语法: $.get(url, [data], [callback], [type])参数:* url :请求路径* data :请求参数*callback :回调函数*type:响应结果的类型 3. $.post()发送post请求 JSON:1.概念: Javascript object NotationJavascript对象表示法 12345Person p = new Person();p.setName(&quot;张三&quot;);p.setAge(23);p.setGender(&quot;男&quot;);var p = &#123;&quot;name&quot;:&quot;张三&quot;, &quot;age&quot;:23, &quot;gender&quot; :&quot;男&quot;&#125;; JSON : JavaScript 对象表示法( JavaScript Object Notation) JSON 是存储和交换文本信息的语法。 类似XML,JSON 比 XML 更小、更快,更易解析。 2.语法: 1.基本规则 数据在名称&#x2F;值对中:json数据是由键值对构成的 键用引号(单双都行)引起来,也可以不使用引号 值得取值类型: 1.数字(整数或浮点数) 2.字符串(在双引号中) 3.逻辑值(true或false) 4,数组(在方括号中) {persons”:[{},{}]} 5&#x2F;对象(在花括号中) {“address”:{“province” :”陕西”….}} null 数据由逗号分隔:多个键值对由逗号分隔 花括号保存对象:使用{}定义json格式 方括号保存数组[ ] 2.获取数据 1. json对象,键名 2. json对象[“键名”] 3.数组对象[索引] 12345678910111213141516171819&lt;script&gt; var person=&#123;&quot;name&quot;:&quot;张三&quot;,age:23,&#x27;gender&#x27;:true&#125; var ps=[&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:true&#125;,&#123;&quot;name&quot;:&quot;张2&quot;,&quot;age&quot;:24,&quot;gender&quot;:true&#125;,&#123;&quot;name&quot;:&quot;张0&quot;,&quot;age&quot;:25,&quot;gender&quot;:false&#125;]; // for (var key in person)&#123; // alert(key+&quot;:&quot;+person[key]); // &#125; for (var i=0;i&lt;ps.length;i++)&#123; var p=ps[i]; for (var key in p)&#123; alert(key+&quot;:&quot;+p[key]); &#125; &#125; &lt;/script&gt; 3. JSON数据和Java对象的相互转换 JSON解析器: 常见的解析器: Jsonlib, Gson, fastjson, jackson 1. JSON转为Java对象 2. Java对象转JSON 1.使用步骤: 1. 导入jackson的相关jar包 2.创建Jackson核心对象 objectMapper 3.调用objectMapper的相关方法进行转换 1. readvalue(ison字符串数据,class) 1.转换方法: writevalue(参数1, obj): 参数1: File :将obj对象转换为JSON字符串,并保存到指定的文件中 Writer :将obj对象转换为JSON字符串,并将json数据填充到字符输出流中 Outputstream :将obj对象转换为JSON字符串,并将json数据填充到字节输出流中 writeValueAsstring(obj):将对象转为json字符串 2.注解: **1. @Jsonignore :排除属性。 ** 2. @JsonHormat:属性值得格式化 @JsonFormat(pattern &#x3D; “yyyy-MM-dd”) 3.复杂java对象转换 1. List：数组 2. Map：对象格式一致","categories":[{"name":"后端","slug":"后端","permalink":"https://2486125878.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://2486125878.github.io/tags/JAVA/"}]},{"title":"数据可视化","slug":"数据可视化","date":"2024-03-13T07:19:21.000Z","updated":"2024-03-13T08:23:52.000Z","comments":true,"path":"2024/03/13/数据可视化/","permalink":"https://2486125878.github.io/2024/03/13/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/","excerpt":"","text":"数据可视化1.什么是数据可视化1.1数据可视化数据可视化主要目的:借助于图形化手段,清晰有效地传达与沟通信息。 数据可视化可以把数据从冰冷的数字转换成图形,揭示蕴含在数据中的规律和道理。 1.2数据可视化的场景目前互联网公司通常有这么几大类的可视化需求: 通用报表 移动端图表 大屏可视化 图编辑&amp;图分析 地理可视化 1.3常见的数据可视化库D3.js 目前Web端评价最高的Javascript可视化工具库(入手难) ECharts.js百度出品的一个开源Javascript数据可视化库 Highcharts.js国外的前端数据可视化库,非商用免费,被许多国外大公司所使用 AntV蚂蚁金服全新一代数据可视化解决方案 等等 Highcharts和 Echarts 就像是office和WPS的关系 2.数据可视化项目概述市场需求: 应对现在数据可视化的趋势,越来越多企业需要在很多场景(营销数据,生产数据,用户数据)下使用,可视化图表来展示体现数据,让数据更加直观,数据特点更加突出 2.3项目技术HTMLS+ CSs3布局 css3动画、渐变 jQuery+原生Javascript flex布局和rem适配方案 图片边框border-image ES6模板字符 ECharts可视化库等等 3.ECharts简介ECharts是一个使用JavaScript实现的开源可视化库,可以流畅的运行在PC和移动设备上,兼容当前绝大部分浏览器(1E8&#x2F;9&#x2F;10&#x2F;11, Chrome, Firefox, Safari等) ,底层依赖矢量图形库ZRender,提供直观,交互丰富,可高度个性化定制的数据可视化图表。 官网地址:https://echarts.apache.org/zh/index.html 丰富的可视化类型 多种数据格式支持 流数据的支持 移动端优化 跨平台使用 绚丽的特效 详细的文档说明 ECharts能满足绝大多数可视化图表实现,使用方便,功能强大,是实现数据可视化的最优选择之一 4.ECharts的基本使用4.1 ECharts使用五步曲步骤1:下载并引入echarts.js文件——————图表依赖这个js库 步骤2:准备一个具备大小的DOM容器———–生成的图表会放入这个容器内 步骤3 :初始化echarts实例对象——————–实例化echarts对象 步骤4:指定配置项和数据(option)—————–根据具体需求修改配置选项 步骤5:将配置项设置给echarts实例对象——–让echarts对象根据修改好的配置生效 4.3相关配置讲解title :标题组件 tooltip :提示框组件 legend :图例组件 toolbox:工具栏 grid :直角坐标系内绘图网格 XAxis :直角坐标系grid中的x轴 yAxis :直角坐标系grid中的y轴 series:系列列表。每个系列通过type决定自己的图表类型(什么类型的图标) color :调色盘颜色列表 series:系列列表 type:类型(什么类型的图表)比如line是折线bar柱形等 name:系列名称,用于tooltip的显示, legend的图例筛选变化 stack:数据堆叠。如果设置相同值,则会数据堆叠。 数据堆叠: 第二个数据值&#x3D;第一个数据值+第二个数据值 第三个数据值&#x3D;第二个数据值+第三个数据值….依次叠加 如果给stack指定不同值或者去掉这个属性则不会发生数据堆叠 06-REM适配设计稿是1920px PC端适配:宽度在1024-1920之间页面元素宽高自适应 1.flexible.js把屏幕分为24等份. 2.cssrem插件的基准值是80px 插件-配置按钮一配置扩展设置-Root Font Size里面设置 但是别忘记重启vscode软件保证生效 3,要把屏幕宽度约束在1024-1920之间有适配,实现代码: &#x2F;&#x2F;实现rem适配 @media screen and (max-width: 1024px) { html { font-size: 42.66px !important; } } @media screen and (min-width: 1920px) { html { font-size: 80px limportant; } } 保存自动刷新浏览器插件 Preview on Web Server 2.2边框图片1,边框图片的使用场景 盒子大小不一,但是边框样式相同,此时就需要边框图片来完成 为了实现丰富多彩的边框效果,在CS3中,新增了border-image属性,这个新属性允许指定一幅图像作为元素的边框。 2.边框图片的切图原理 把四个角切出去(九宫格的由来) ,中间部分可以铺排、拉伸或者环绕。 按照上右下左顺序切割 3.边框图片语法规范 属性 描述 border-image-source 用在边框的图片的路径。(那个图片? ) border-image-slice 图片边框向内偏移。(裁剪的尺寸,一定不加单位,上右下左顺序) border-image-width 图片边框的宽度(需要加单位) (不是边框的宽度是边框图片的宽度 border-image-repeat 图像边框是否应平铺(repeat)、铺满(round)或拉伸(stretch)默认拉伸 2.4通过类名调用字体图标HTML页面引入字体图标中css文件。 2标签直接调用图标对应的类名即可。(类名在css文件中标注)","categories":[{"name":"前端","slug":"前端","permalink":"https://2486125878.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"数据可视化","slug":"数据可视化","permalink":"https://2486125878.github.io/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"}]},{"title":"Vue","slug":"Vue","date":"2024-03-13T07:18:25.000Z","updated":"2024-03-13T08:23:34.000Z","comments":true,"path":"2024/03/13/Vue/","permalink":"https://2486125878.github.io/2024/03/13/Vue/","excerpt":"","text":"Vue基础webpack 的学习目标 ①理解什么是前端工程化 转变对前端开发的认知 ② 了解webpack的基本用法 为后面Vue和React课程的学习做技术储备 ③不强制要求大家能手动配置webpack. 一定要知道webpack在项目中有什么作用 清楚webpack中的核心概念 前端工程化1.小白眼中的前端开发vs实际的前端开发小白眼中的前端开发: 会写HTML + CSS + JavaScript 就会前端开发 需要美化页面样式,就搜一个bootstrap过来 需要操作DOM 或发起Ajax请求,再搜一个jQuery过来 需要快速实现网页布局效果,就搜一个Layui过来 实际的前端开发: 模块化 (js的模块化、CSS的模块化、资源的模块化) 组件化 (复用现有的UI结构、样式、行为) 规范化 (目录结构的划分、编码规范化、接口规范化、文档规范化、Git分支管理) 自动化 (自动化构建、自动部署、自动化测试) 2.什么是前端工程化前端工程化指的是:在企业级的前端项目开发中,把前端开发所需的工具、技术、流程、经验等进行规范化、标准化。 企业中的Vue项目和React项目,都是基于工程化的方式进行开发的。 好处:前端开发自成体系,有一套标准的开发方案和流程。 3.前端工程化的解决方案早期的前端工程化解决方案: grunt ( https://www.gruntjs.net/) gulp ( https://www.gulpjs.com.cn/) 目前主流的前端工程化解决方案: webpack ( https://www.webpackjs.com/) parcel ( https://zh.parceljs.org/) webpack 的基本使用1. 什么是webpack概念: webpack是前端项目工程化的具体解决方案。 主要功能:它提供了友好的前端模块化开发支持,以及代码压缩混滑、处理浏览器端JavaScript的兼容性、性能优化等强大的功能。 好处:让程序员把工作的重心放到具体功能的实现上,提高了前端开发效率和项目的可维护性。 2.创建列表隔行变色项目①新建项目空白目录,并运行npm init-y 命令,初始化包管理配置文件 package.json ②新建src源代码目录 ③新建src-&gt; index.html 首页和src-&gt; index.js脚本交件 ④初始化首页基本的结构5 运行 npm install jquery -S O令,安装 jQuery 6通过ES6模块化的方式导入jQuery,实现列表隔行变色效果 3.在项目中安装webpack在终端运行如下的命令,安装webpack相关的两个包: npm install &#x77;&#101;&#98;&#x70;&#x61;&#x63;&#x6b;&#64;&#53;&#x2e;&#x34;&#x32;&#x2e;&#49; &#x77;&#101;&#x62;&#x70;&#x61;&#99;&#x6b;&#45;&#99;&#108;&#x69;&#64;&#x34;&#x2e;&#x37;&#46;&#x32; -D -S是–save的简写 -D是–save-dev的简写 Install with npm: npm install –save-dev webpack Install with yarn: yarn add webpack –dev 4.在项目中配置webpack① 在项目根目录中,创建名为webpack.config.js的webpack配置文件,并初始化如下的基本配置: 123module.exports =&#123; mode: &#x27;development&#x27; // mode用来指定构建模式,可选值有development和production&#125; ②在package.json 的scripts 节点下,新增dev脚本如下: 123&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack&quot; //script 节点下的脚本,可以通过 npm run执行,例如npm run dev&#125; ③在终端中运行npm run dev 命令,启动webpack进行项目的打包构建 4.3 webpack 中的默认约定在webpack 4.x和5.的版本中,有如下的默认约定: ① 默认的打包入口文件为src -&gt; index.js ②默认的输出文件路径为 dist-&gt; main.js 注意:可以在webpack.config.js中修改打包的默认约定 4.4自定义打包的入口与出口在webpack.config.js 配置文件中,通过entry节点指定打包的入口。通过output节点指定打包的出口。示例代码如下: 1234567const path= require(&#x27;path&#x27;) // 导入 node.js 中专门操作路径的模块module.exports = &#123; entry: path.join(__dirname, &#x27;./src/index.js&#x27;), // 打包入口文件的路径 output: &#123; path:path.join(__dirname, &#x27;./dist&#x27;), // 输出文件的存放路径。 filename: &#x27;bundle.js&#x27; //输出文件的名称 &#125; VSCode中智能提示node.js代码解决 12npm install -g typingstypings install dt~node --global --save webpack 中的插件1. webpack 插件的作用 通过安装和配置第三方的插件,可以拓展webpack的能力,从而让webpack用起来更方便。最常用的webpack 插件有如下两个: ①webpack-dev-server. 类似于node.js阶段用到的nodemon工具. 每当修改了源代码,webpack会自动进行项目的打包和构建 2.html-webpack-plugin webpack 中的HTML 插件(类似于一个模板引擎插件) 可以通过此插件自定制index.html页面的内容 2.1 安装 webpack-dev-server运行如下的命令,即可在项目中安装此插件: 1npm install webpack-dev-server@3.11.2 -D 2.2 配置 webpack-dev-server①修改package.json-&gt;scripts 中的dev命令如下: 123&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack serve&quot;, // script 节点下的脚本,可以通过npm run执行&#125; ②再次运行npm run dev命令,重新进行项目的打包 ③在浏览器中访问http://localhost:8080地址,查看自动打包效果 注意: webpack-dev-server 会启动一个实时打包的http服务器 3.1 安装 html-webpack-plugin运行如下的命令,即可在项目中安装此插件: 1npm install html-webpack-plugin@5.3.2 -D 3.2 配置 html-webpack-plugin1234567891011//1,导入HTML播件,得到一个构造函数const HtmlPlugin = require(&#x27;html-webpack-plugin&#x27;)//2.创建HTML提件的实例对象const htmlPlugin = new HrmlPlugin(&#123; template: &#x27;./src/index.html&#x27;, //指定原文件的存放路径 filename: &#x27;./index.html&#x27;, //指定生成的文件的存放路径&#125;)nodule.exports =&#123; mode: &#x27;development&#x27;, plugins: [htmlPlugin], // 3.通过 plugins 点,使htmlPlugin播件生效&#125; 4. devServer 节点在webpack.config.js配置文件中,可以通过devServer节点对webpack-dev-server插件进行更多的配置,示例代码如下: 12345devServer:&#123; open: true, //初次打包完成后,自动打开浏览器 host: &#x27;127.0.0.1&#x27;, //实时打包所使用的主机地址 port: 80, //实时打包所使用的端口号&#125; 注意:凡是修改了webpack.config.js配置文件,或修改了package.json配置文件,必须重启实时打包的服务器,否则最新的配置文件无法生效! 1. webpack 插件的作用通过安装和配置第三方的插件,可以拓展webpack的能力,从而让webpack用起来更方便。 最常用的webpack 插件有如下两个: webpack-dev-server . 类似于node.js阶段用到的nodemon工具.每当修改了源代码, webpack会自动进行项目的打包和构建 html-webpaçk-plugin . webpack 中的HTML插件(类似于一个模板引擎插件).可以通过此插件自定制index.html页面的内容 1. loader 概述在实际开发过程中,webpack默认只能打包处理以.js后缀名结尾的模块。其他非.js后缀名结尾的模块,webpack默认处理不了,需要调用loader加载器才可以正常打包,否则会报错! loader加载器的作用:协助webpack打包处理特定的文件模块。比如: css-loader 可以打包处理.CSS相关的文件. less-loader 可以打包处理.less 相关的文件 babel-loader 可以打包处理webpack无法处理的高级JS语法 3.打包处理css文件 ①运行npm i &#115;&#x74;&#121;&#x6c;&#101;&#x2d;&#x6c;&#111;&#97;&#100;&#x65;&#x72;&#64;&#51;&#x2e;&#x30;&#46;&#x30; &#x63;&#115;&#115;&#x2d;&#x6c;&#x6f;&#x61;&#100;&#101;&#x72;&#x40;&#53;&#x2e;&#50;&#x2e;&#x36; -D 命令, 安装处理 CSs 文件的 loader ② 在webpack.config.js 的module-&gt; rules 数组中,添加 loader规则如下: 12345module: &#123; //所有第三方文件模块的匹配规则rules: [ //文件后缀名的匹配规则&#123; test: /\\.css$/,use: [&#x27;style-loader&#x27; , &#x27;css-loader &#x27;] &#125;]&#125; 其中，test表示匹配的文件类型,use表示对应要调用的 loader 注意:use数组中指定的 loader顺序是固定的 多个loader的调用顺序是:从后往前调用 1. webpack默认只能打包处理.js结尾的文件，处理不了其它后缀的文件 2.由于代码中包含了index.css 这个文件，因此 webpack 默认处理不了 3.当webpack 发现某个文件处理不了的时候，会查找webpack.config.js 这个配置文件，module.rules数组中，是否配置了对应的loader 加载器。 4. webpack把index.css 这个文件，先转交给最后一个loader进行处理（先转交给css-loader) .5.当css-loader处理完毕之后，会把处理的结果，转交给下一个loader(转交给style-loader)6.当style-loader处理完毕之后，发现没有下一个loader了，于是就把处理的结果，转交给了webpack7.webpack 把 style-loader处理的结果，合并到&#x2F;dist&#x2F;bundle.js[中，最终生成打包好的文件。 4.打包处理less文件运行 npm i &#x6c;&#101;&#115;&#115;&#45;&#108;&#x6f;&#x61;&#x64;&#101;&#114;&#x40;&#x31;&#x30;&#x2e;&#48;&#46;&#49; &#116;&#x65;&#x73;&#115;&#64;&#x34;&#x2e;&#49;&#x2e;&#49; -D命令 在webpack.config.js 的 module -&gt; rules数组中，添加loader 规则如下: 12345module: &#123;//所有第三方文忤模块的匹配规则rules: [ //文件后缀名的匹配规则 &#123;test:/\\.less$,use: [&#x27;style-loader&#x27; , &#x27;css-loader&#x27;, &#x27;less-loader &#x27;]&#125;, ]&#125; 5.打包处理样式表中与url路径相关的文件运行npm i &#x75;&#x72;&#108;&#x2d;&#x6c;&#x6f;&#x61;&#x64;&#x65;&#114;&#64;&#52;&#x2e;&#49;&#46;&#49; &#x66;&#105;&#108;&#x65;&#45;&#108;&#111;&#97;&#x64;&#101;&#114;&#64;&#54;&#x2e;&#x32;&#46;&#48; -D命令在webpack.config.js 的 module -&gt; rules数组中，添加 loader 规则如下: 123456madule: &#123; //所有第三方文件模块的匹配规则rulcs: [//文件后缀名的匹配规则&#123; test: /\\.jpg|png|gif$l,use: &#x27;ur1-1oader?limit=22229&#x27;&#125;, ]&#125; 其中?之后的是loader的参数项: limit 用来指定图片的大小，单位是字节( byte) 只有≤limit大小的图片，才会被转为base64格式的图片 6.打包处理js文件中的高级语法webpack 只能打包处理一部分高级的JavaScript 语法。对于那些webpack无法处理的高级js语法,需要借助于babel-loader进行打包处理。例如webpack无法处理下面的JavaScript代码: 12345678910//1.定义了名为info的装饰等function info(target) &#123; //2.为目标添加静态属性info target.info = &#x27;Person info&#x27;&#125;//3.为Person类应用info装饰器@infoclass Person &#123;&#125;//4.打印Person的静高属性infoconsole, log( Person, info) 6.1 安装 babel-loader 相关的包运行如下的命令安装对应的依赖包:npm i &#x62;&#x61;&#x62;&#x65;&#108;&#x2d;&#108;&#x6f;&#x61;&#100;&#101;&#x72;&#x40;&#56;&#x2e;&#x32;&#46;&#x32; @babel&#x2F;&#x63;&#x6f;&#x72;&#x65;&#x40;&#x37;&#x2e;&#49;&#52;&#x2e;&#54; @babel&#x2F;&#112;&#x6c;&#117;&#x67;&#105;&#x6e;&#x2d;&#112;&#x72;&#111;&#x70;&#111;&#115;&#x61;&#x6c;&#x2d;&#x64;&#101;&#x63;&#x6f;&#x72;&#x61;&#116;&#111;&#x72;&#115;&#64;&#x37;&#x2e;&#49;&#x34;&#x2e;&#x35; -D 在webpack.config.js的module-&gt; rules数组中,添加 loader规则如下: 12//注意:必须使用exclude指定推除项,因为node_modules 日录下的第三方包不需要被打包&#123; test: /\\.js$/, use: &#x27;babel-loader&#x27;, exclude: /nodc_modules/&#125; 6.2 配置babel-loader在项目根目录下,|创建名为babel.config.js的配置文件,定义Babel的配置项如下: 1234module. exports = &#123; //声明babel可用的插件 plugins: [[&#x27;@babel/plugin-proposal-decorators&#x27;, &#123; legacy: true &#125;]]&#125; 2.配置webpack的打包发布在package.json文件的scripts节点下,新增build命令如下: 12345&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack serve&quot;, //开发环境中,运行dev命令 &quot;build&quot;: &quot;webpack --mode production&quot; //项目发布时,运行build 命令&#125; –model 是一个参数项,用来指定webpack的运行模式。production代表生产环境,会对打包生成的文件进行代码压缩和性能优化。 注意:通过–model指定的参数项,会覆盖webpack.config.js 中的model 选项。 5.自动清理dist目录下的旧文件为了在每次打包发布时自动清理掉dist目录中的旧文件,可以安装并配置clean-webpack-plugir插件: 安装插件npm install –save-dev clean-webpack-plugin 1234567//1.安装清理dist 目录的webpack播件npm install clean-webpack-plugin3.0.0 -D//2.按需导入插件、得到插件的构造函数之后,创建播件的实例对象const &#123;CleanwebpackPlugin&#125; = require(&#x27;clean-webpack-plugin&#x27;)const cleanPlugin = new CleanlebpackPlugin()//3.把创建的cleanPlugin插件实例对象,挂载到plugins节点中plugins: [htmlPlugin, cleanPlugin], //1 挂載插件 Source Map2. 什么是Source MapSource Map就是一个信息文件,里面储存着位置信息。也就是说,Source Map文件中存储着压缩混滑后的代码,所对应的转换前的位置。 有了它,出错的时候,除错工具将直接显示原始代码,而不是转换后的代码,能够极大的方便后期的调试。 3.1默认Source Map 的问题开发环境下默认生成的Source Map,|记录的是生成后的代码的位置。会导致运行时报错的行数与源代码的行数不一致的问题。 开发环境下,推荐在webpack.config.js中添加如下的配置,即可保证运行时报错的行数与源代码的行数保持一致: 123456module.exports =&#123;mode: &#x27;development&#x27;，// eval-source-map仅限在&quot;开发模式&quot;下使用,不建议在&quot;生产模式&quot;下使用。//此选项生成的Source Map能够保证&quot;运行时报错的行数&quot;与&quot;源代码的行数&quot;保持一致devtool: &#x27;eval-source-nap&#x27;,&#125; 4. webpack 生产环境下的 Source Map在生产环境下,如果省略了devtool选项,则最终生成的文件中不包含Source Map。这能够防止原始代码通过Source Map的形式暴露给别有所图之人。 4.1只定位行数不暴露源码在生产环境下|如果只想定位报错的具体行数,且不想暴露源码。此时可以将devtool的值设置为nosources-source-map。 4.2定位行数且暴露源码 在生产环境下,如果想在定位报错行数的同时,展示具体报错的源码。此时可以将devtool的值设置为source-map。不推荐使用 采用此选项后:你应该将你的服务器配置为,不允许普通用户访问source map文件! 5. Source Map 的最佳实践①开发环境下: 建议把 devtool 的值设置为 eval-source-map 好处:可以精准定位到具体的错误行 ②生产环境下: 建议关闭 Source Map或将devtool 的值设置为nosources-source-map. 好处:防止源码泄露,提高网站的安全性 实际开发中需要自己配置webpack 吗? 答案:不需要!· 实际开发中会使命令行工具(俗称CLI)一键生成带有webpack的项目 ·开箱即用,所有webpack配置项都是现成的! .我们只需要知道webpack中的基本概念即可! Vue简介1.什么是vue官方给出的概念:Vue (读音&#x2F;vju:&#x2F;,类似于view)是一套用于构建用户界面的前端框架 1.构建用户界面 。用vue 往html页面中填充数据,非常的方便 2.框架 。框架是一套现成的解决方案,程序员只能道守框架的规范,去编写自己的业务功能! 。要学习vue,就是在学习Vue框架中规定的用法! 。vue的指令、组件(是对UI结构的复用)、路由、Vuex 2. vue的特性vue框架的特性主要体现在如下两方面: 1.数据驱动视图 **数据的变化会驱动视图自动更新 ** 好处:程序员只管把数据维护好,那么页面结构会被vue自动演染出来! 2. 双向数据绑定 在网页中, form表单负责采集数据,Ajax负责提交数据。 js数据的变化,会被自动演染到页面上 页面上表单采集的数据发生变化的时候,会被vue 自动获取到,并更新到js数据中 2.1数据驱动视图在使用了vue的页面中,vue会监听数据的变化,从而自动重新渲染页面的结构。示意图如下: 页面结构—-（自动渲染）—–vue监听数据变化—–（变化）——页面所依赖的数据 ​ 数据驱动视图 好处:当页面数据发生变化时,页面会自动重新渲染! 注意:数据驱动视图是单向的数据绑定。 2.2 双向数据绑定在填写表单时,双向数据绑定可以辅助开发者在不操作DOM的前提下,自动把用户填写的内容同步到数据源中。示意图如下: 页面结构—–（自动填充）——（值发送变化）——–vue——-（变化）——–（自动同步）——–（页面所依赖的数据） ①好处:开发者不再需要手动操作 DOM元素,来获取表单元素最新的值! 2.3 MVVMMVVM 是vue 实现数据驱动视图和双向数据绑定的核心原理。MVVM指的是Model, View 和ViewModel,它把每个HTML页面都拆分成了这三个部分,如图所示: 在MVVM概念中: Model 表示当前页面宣染时所依赖的数据源。 View 表示当前页面所宣染的DOM结构。 ViewModel 表示vue 的实例,它是MVVM的核心。 2.4 MVVM 的工作原理ViewModel 作为MVVM 的核心,是它把当前页面的数据源(Model)和页面的结构(View)连接在了一起。 view—-（自动更新）———（监听dom变化）——-viewmodel———-（监听数据源变化）——–（自动同步）———-model 当数据源发生变化时,会被ViewModel监听到,VM会根据最新的数据源自动更新页面的结构 当表单元素的值发生变化时,也会被VM监听到,VM会把变化过后最新的值自动同步到Model数据源中 注意:数据驱动视图和双向数据绑定的底层原理是MVVM (Mode数据源、View视图、ViewModel就是vue的实例) vue 的基本使用1.基本使用步骤 1.导入vue.js 的script脚本文件 ②在页面中声明一个将要被vue所控制的DOM区域 ③创建vm实例对象(vue实例对象) 123456789101112131415161718&lt;body&gt; &lt;!--2.在页面中声明一个将要被vue所控制的DOM区域--&gt; &lt;div id=&quot;app&quot;&gt;&#123;&#123;username&#125;&#125;&lt;/div&gt; &lt;!--1. 导入vue.js的script脚本文件--&gt; &lt;script src=&quot;./lib/vue-2.6.12. js&quot;&lt;/script&gt; &lt;script&gt;//3.创建vm实例对象(vue实例对象)const vm = new Vue(&#123;//3.1指定当前vm实例要控制页面的哪个区域el: &#x27;#app&#x27;,// 3.2指定Model数据源data: &#123;username: &#x27;zs&#x27;&#125;&#125;)&lt;/script&gt;&lt;/body&gt; vue 的指令与过滤器指令(Directives)是vue 为开发者提供的模板语法,用于辅助开发者宣染页面的基本结构。 vue中的指令按照不同的用途可以分为如下6大类: ① 内容宣染指令 ② 属性绑定指令 ③事件绑定指令 ④ 双向绑定指令 ⑤ 条件宣染指令 6.列表宣染指令 注意:指令是vue开发中最基础、最常用、最简单的知识点。 1.1内容宣染指令内容宣染指令用来辅助开发者渲染DOM元素的文本内容。常用的内容宣染指令有如下3个: .v-text———-会覆盖元素内部原有的内容! 12345&lt;!--把username对应的值,宣染到第一个p标签中--&gt;&lt;p v-text=&quot;username&quot;&gt;&lt;/p&gt;&lt;!--把gender 对应的值,宣染到第二个p标签中--&gt;&lt;!--注意:第二个p标签中,默认的文本“性别”会被gender 的值覆盖掉--&gt;&lt;p v-text=&quot;gender&quot;&gt;性别&lt;/p&gt; 123456&#123;&#123;&#125;&#125;vue提供的[)语法,专门用来解决v-text会覆盖默认文本内容的问题。这种&#123;&#123;&#125;&#125;语法的专业名称是插值表达式(英文名为:Mustache)&lt;!--使用&#123;&#123;&#125;&#125;插值表达式,将对应的值渲染到元素的内容节点中,--&gt;&lt;!--同时保留元素自身的默认值--&gt;&lt;p&gt;姓名: &#123;&#123;username&#125;&#125;&lt;/p&gt;&lt;p&gt;性别: &#123;&#123;gender&#125;&#125;&lt;/p&gt; 1234&#123;&#123;&#125;&#125;插值表达式:在实际开发中用的最多,只是内容的占位符,不会覆盖原有的内容!.v-htmlv-text指令和插值表达式只能渲染纯文本内容。如果要把包含HTML标签的字符串渲染为页面的HTML元素,则需要用到v-html这个指令: 123456789101112131415&lt;div v-html=&quot;info&quot;&gt;&lt;/div&gt; &lt;script&gt; const vm = new Vue(&#123; el: &#x27;#app&#x27;, // el指向的选择器就是view视图区域 data: &#123; username: &#x27;zs&#x27;, // data指向的对象就是model数据源 gender: &#x27;女&#x27;, info: &#x27;&lt;h4 style=&quot;color:red; font-weight:hold&quot;&gt;欢迎您学习vue&lt;/h4&gt;&#x27; &#125; &#125;) //new vue()构造函数得到的vm实例对象就是viewmodel &lt;/script&gt; v-html指令的作用:可以把带有标签的字符串,渲染成真正的HTML内容! 2.属性绑定指令注意:插值表达式只能用在元索的内容节点中,不能用在元索的属性节点中! 1.2属性绑定指令如果需要为元素的属性动态绑定属性值,则需要用到v-bind属性绑定指令。用法示例如下: 在vue中,可以使用v-bind:指令,为元系的属性动态绑定值; 简写是英文的冒号 使用Javascript 表达式在vue提供的模板宣染语法中,除了支持绑定简单的数据值之外,还支持Javascript表达式的运算,例如: 1234&#123;&#123;number + 1&#125;&#125;&#123;&#123;ok ? &#x27;YES&#x27; : &#x27;NO&#x27;&#125;&#125;&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)&#125;&#125;&lt;div v-bind:id=&quot;&#x27;list-&#x27;+ id&quot;&gt;&lt;/div&gt; 在使用v-bind属性绑定期间,如果绑定内容需要进行动态拼接,则字符串的外面应该包裹单引号 1.3事件绑定指令vue提供了v-on事件绑定指令,用来辅助程序员为DOM元素绑定事件监听。语法格式如下: 123&lt;h3&gt;count的值为: &#123;&#123;count&#125;&#125;&lt;/h3&gt;&lt;!--语法格式为v-on:事件名称=&quot;事件处理函数的名称”.--&gt;&lt;button v-on:click=&quot;addCount&quot;&gt;+1&lt;/button&gt; 注意:原生DOM 对象有 onclick, oninput, onkeyup 等原生事件,替换为vue的事件绑定形式后,分别为:v-on:click, v-on:input, v-on:keyup 事件修饰符 在事件处理函数中调用 event.preventDefault() 或 event.stopPropagation()是非常常见的需求。因此,vue提供了事件修饰符的概念,来辅助程序员更方便的对事件的触发进行控制。常用的5个事件修饰符如下: 事件修饰符 说明 .prevent 阻止默认行为(例如:阻止a连接的跳转、阻止表单的提交等) .stop 阻止事件冒泡 .capture 以捕获模式触发当前的事件处理函数 .once 绑定的事件只触发1次 .self 只有在event.target是当前元素自身时触发事件处理函数 3.事件绑定1. v-on:简写是@ 2.语法格式为: 12345678&lt;button @click=&quot;add&quot;&gt;&lt;/button&gt;methods: &#123;add() &#123;//如果在方法中要修改data中的数据,可以通过this访问到this.count += 1&#125;&#125; 3. Sevent的应用场景:如果默认的事件对象e被覆盖了,则可以手动传递一个$event. 12345678&lt;button @click=&quot;add(3),$event&quot;&gt;&lt;/button&gt;methods: &#123;add(n,e) &#123;//如果在方法中要修改data中的数据,可以通过this访问到this.count += 1&#125;&#125; 4.事件修饰符:.prevent 1&lt;a @click.prevent=&quot;xxx&quot;&gt;链接&lt;/a&gt; .stop 1&lt;button @click.stop=&quot;xxx&quot;&gt;按钮&lt;/button&gt; 按键修饰符 在监听键盘事件时,我们经常需要判断详细的按键。此时,可以为键盘相关的事件添加按键修饰符,例如: 1234&lt;!--只有在&quot;key&#x27;&#x27;Enter&#x27;时调用&quot;vm.submit()&#x27;--&gt;&lt;input @keyup.enter=&quot;submit&quot;&gt;&lt;!-只有在&quot;key&quot;或‘Esc&#x27;时用&#x27;vm.clearinput()&#x27; --&gt; &lt;input @keyup.esc=&quot;clearinput&quot;&gt; 1.4双向绑定指令vue 提供了 v-model 双向数据绑定指令,用来辅助开发者在不操作DOM的前提下,快速获取表单的数据。 123456789&lt;p&gt;用户名是: &#123;&#123;username&#125;&#125;&lt;/p&gt;&lt;input type=&quot;text&quot; V-model=&quot;username&quot; /&gt;&lt;p&gt;选中的省份是: &#123;&#123;province&#125;&#125;&lt;/p&gt;&lt;select v-model=&quot;province&quot;&gt; &lt;option value=&quot;&quot;&gt;请择&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;河北&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;黑龙江&lt;/option&gt;&lt;/select&gt; 4. v-model 指令1. input 输入框 type&#x3D;”radio” **type&#x3D;”checkbox” ** type&#x3D;”xxxx” 2. textarea 3. select v-model指令的修饰符为了方便对用户输入的内容进行处理, vue 为v-model指令提供了3个修饰符,分别是: 修饰符 作用 示例 .number 自动将用户的输入值转为数值类型 .trim 自动过用户输入的首尾空白字符 .lazy 在”change”时而非 “input” 时更新 1.5条件宣染指令条件宣染指令用来辅助开发者按需控制DOM的显示与隐藏。条件宣染指令有如下两个,分别是: •v-if •v-show 1234&lt;div id=&quot;app&quot;&gt; &lt;p v-if=&quot;networkState === 200&quot;&gt;请求成功被v-if控制&lt;/p&gt; &lt;p v-show&quot;networkState === 200&quot;&gt;请求成功被v-show控制&lt;/p&gt;&lt;/div&gt; 1. v-show 的原理是:动态为元素添加或移除display: none样式,来实现元素的显示和隐織 如果要频繁的切换元素的显示状态,用v-show性能会更好 2. v-if 的原理是:每次动态创建或移除元素,实现元素的显示和隐服 如果刚进入页面的时候,某些元素默认不需要被展示,而且后期这个元素很可能也不需要被展示出来,此时v-if性能更好 3.在实际开发中,绝大多数情况,不用考虑性能问题,直接使用v-if就好了 v-else v-if可以单独使用,或配合v-else指令一起使用: 123456&lt;div v-if=&quot;Math.random() &gt; 0.5&quot;&gt; //随机数大于0.5&lt;/div&gt;&lt;div v-else&gt; 随机数小于或等于0.5&lt;/div&gt; 注意:v-else指令必须配合v-if指令一起使用,否则它将不会被识别! 1.6列表宣染指令vue提供了v-for列表演染指令,用来辅助开发者基于一个数组来循环渲染一个列表结构。v-for指令需要使用item in items形式的特殊语法,其中: •items是待循环的数组 • item是被循环的每一项, 12345678910data:&#123;list: [ //列表数据&#123;id: 1, name: &#x27;zs&#x27;&#125;,&#123;id: 2, name: &#x27;ls&#x27;&#125;]&#125;&lt;ul&gt; &lt;li v-for=&quot;item in list&quot;&gt;姓名是: &#123;&#123;item.name&#125;&#125;&lt;/1i&gt;&lt;/ul&gt; v-for中的索引 v-for指令还支持一个可选的第二个参数,即当前项的索引,语法格式为(item, index) in items,示例代码如下: 12345678data:&#123;list: [//列表数据&#123;id: 1, name: &#x27;zs&#x27;&#125; ,&#123;id: 2, name: &#x27;1s&#x27;&#125;,//----------------------------------------------分割线&lt;ul&gt; &lt;li v-for=&quot;(item, index) in list&quot;&gt;索引是: &#123;&#123;index&#125;&#125;,姓名是: &#123;&#123;item.name&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 注意: v-for指令中的item项和index索引都是形参,可以根据需要进行重命名。例如(user, i) in userlist key 的注意事项① key 的值只能是字符串或数字类型 ② key的值必须具有唯一性(即:key的值不能重复) ③建议把数据项id属性的值作为key的值(因为id属性的值具有唯一性) ④ 使用index的值当作key的值没有任何意义(因为index的值不具有唯一性) ⑤建议使用v-for指令时一定要指定key的值(既提升性能、又防止列表状态素乱) 总结①能够知道vue的基本使用步骤. .导入vue.js文件 .new Vue()构造函数,得到vm实例对象 .声明el和data数据节点 .MVVM的对应关系 ②掌握vue中常见指令的基本用法 插值表达式、v-bind, v-on,v-if和v-else v-for 和:key, v-model ③掌握vue 中过滤器的基本用法 vue 的指令与过器2.过滤器过滤器(Filters)是vue为开发者提供的功能,常用于文本的格式化。过滤器可以用在两个地方:插值表达式和v-bind属性绑定。 过滤器应该被添加在JavaScript表达式的尾部,由“管道符”进行调用,示例代码如下: 12345&lt;!--在双花括号中通过&quot;管道符&quot;调用capitalize 过速器,对message的值进行格式化--&gt;&lt;p&gt;&#123;&#123;message | capitalize&#125;&#125;&lt;/p&gt;&lt;!--在v-bind中通过“管道符&quot;调用formatId过滤器,对rawId的值进行格式化--&gt;&lt;div v-bind=&quot;rawId | formatId&quot;&gt;&lt;/div&gt; 过滤器过滤器的注意点1.要定义到filters节点下,本质是一个函数 2.在过滤器函数中,一定要有return值 3.在过滤器的形参中,就可以获取到”管道符”前面待处理的那个值 4.如果全局过滤器和私有过滤器名字一致I此时按照”就近原则”,调用的是”私有过滤器” watch 侦听器侦听器的格式1.方法格式的侦听器。 ​ 缺点:无法在刚进入页面的时候,自动触发!!! ​ 缺点2:如果侦听的是一个对象,如果对象中的属性发生了变化,不会触发侦听器!! 2.对象格式的侦听器 ​ 好处:可以通过immediate选项,让侦听器自动触发!! ​ 好处2:可以通过deep选项,让侦听器深度监听对象中每个属性的变化!!! 2.2私有过滤器和全局过滤器在filters节点下定义的过滤器,称为“私有过滤器”,因为它只能在当前vm实例所控制的el区域内使用。如果希望在多个vue实例之间共享过滤器,则可以按照如下的格式定义全局过滤器: 1234567//全局过滤器-独立于每个vm实例之外// Vue.filter()方法接收两个参数://第1个参数,是全局过滤器的&quot;名字&quot;//第2个参数,是全局过滤器的&quot;处理函数&quot;Vue. filter(&#x27;capitalize&#x27;, (str) =&gt; &#123;return str.charAt(0).toUpperCase() + str.slice(1) + &#x27;~~&#x27;&#125;) 2.3连续调用多个过滤器过滤器可以串联地进行调用,例如: 1234&lt;!--把message的值,交给filterA进行处理--&gt;&lt;!--把filterA处理的结果,再交给filterB进行处理--&gt;&lt;!--最终把filterB处理的结果,作为最终的值谊染到页面上--&gt;“&#123;&#123;message | filterA | filterB&#125;&#125; 过滤器的本质是JavaScript函数,因此可以接收参数,格式如下: 12345678&lt;!-- arg1 和arg2 是传递给filterA的参数--&gt;&lt;p&gt;&#123;&#123; message | filterA(arg1, arg2)&#125;&#125; &lt;/p&gt;//过滤器处理函数的形参列表中://第一个参数:永远都是&quot;管道符&quot;前面待处理的值// 从第二个参数开始,才是调用过滤器时传递过来的arg1和arg2参数Vue.filter(&#x27;filterA&#x27;, (msg, arg1, arg2) =&gt; &#123;//过滤器的代码逻辑....&#125;) 2.5过滤器的兼容性过滤器仅在vue 2.x和1.x中受支持,在vye 3.x的版本中剔除了过滤器相关的功能。 在企业级项目开发中:●如果使用的是2.x版本的vue,则依然可以使用过滤器相关的功能 ·如果项目已经升级到了3.x版本的vue,官方建议使用计算属性或方法代替被剔除的过滤器功能 watch侦听器1.什么是watch侦听器watch侦听器允许开发者监视数据的变化,从而针对数据的变化做特定的操作。语法格式如下: 1234567891011const vm new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; username:&#x27;&#x27;&#125;,watch:&#123;//监听username值的变化// newVal是&quot;变化后的新值&quot;, oldVal是&quot;变化之前的旧值”username(newval, oldVal)&#123;console.log(newVal, oldVal)&#125;&#125;&#125;) 2.使用watch检测用户名是否可用监听username值的变化,并使用axios发起Ajax请求,检测当前输入的用户名是否可用: 123456789watch: &#123;//监听 username值的变化async username(newVal) &#123;if (newVal=== &#x27;&#x27;) return//使用axios发起请求,判断用户名是否可用const &#123; data: res &#125;= await axios.get(&#x27;https://www.escook.cn/api/finduser/&#x27; + newVal)console. log(res)&#125;&#125; watch侦听器3.immediate 选项默认情况下,组件在初次加载完毕后不会调用watdh侦听器。如果想让watch侦听器立即被调用,则需要使用immediate选项。示例代码如下: 1234567891011watch: &#123;username:&#123;handle:async function(newVal) &#123;if (newVal=== &#x27;&#x27;) returnconst &#123; data: res &#125;= await axios.get(&#x27;https://www.escook.cn/api/finduser/&#x27; + newVal)console. log(res)&#125;,immediate:true&#125;&#125; watch侦听器4.deep 选项如果watch侦听的是一个对象,如果对象中的属性值发生了变化,则无法被监听到。此时需要使用deep选项,代码示例如下: 1234567891011121314const vm = new Vue(&#123;el: &#x27;#app&#x27;,data:&#123; info:&#123; username: &#x27;admin&#x27; &#125;&#125;,watch:&#123;info: &#123;handler(newVal)&#123;console.log(newVal.username)&#125;,deep: true&#125;&#125;)&#125; 5.监听对象单个属性的变化如果只想监听对象中单个属性的变化,则可以按照如下的方式定义watch侦听器: 12345678910111213const vm= new Vue&#123;el: &#x27;#app&#x27;,data:&#123;info:&#123;username: &#x27;admin&#x27;&#125;&#125;,watch: &#123; &#x27;info.username&#x27;:&#123; handler(newVal)&#123; console.log(newWal)&#125; &#125;&#125;)&#125; 侦听器的格式1.方法格式的侦听器。 缺点1:无法在刚进入页面的时候,自动触发!!! 缺点2:如果侦听的是一个对象,如果对象中的属性发生了变化,不会触发侦听器!!! 2.对象格式的侦听器。 好处1:可以通过immediate选项,让侦听器自动触发!!!。 好处2:可以通过deep选项,让侦听器深度监听对象中每个属性的变化!!! 计算属性1.什么是计算属性计算属性指的是通过一系列运算之后,最终得到一个属性值。 这个动态计算出来的属性值可以被模板结构或methods方法使用。示例代码如下: 1234567891011121314var vm = new Vue(&#123;el: &#x27;#app&#x27;,data:&#123; r: 0, g: 0, b: 0&#125;,computed:&#123;rgb() &#123;return &#x27;rgb($&#123;this.r&#125;, $&#123;this.g&#125;, $&#123;this.b&#125;)&#x27;&#125;&#125;,methods:&#123; show() &#123; console.log(this.rgb)&#125;,&#125;) 计算属性特点:1.定义的时候,要被定义为“方法” 2.在使用计算属性的时候,当普通的属性使用即可 好处: 1.实现了代码的复用 2.只要计算属性中依赖的数据源变化了,则计算属性会自动重新求值!","categories":[{"name":"前端","slug":"前端","permalink":"https://2486125878.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://2486125878.github.io/tags/vue/"}]},{"title":"nodeJs","slug":"nodeJs","date":"2024-03-13T07:17:22.000Z","updated":"2024-03-13T08:22:08.000Z","comments":true,"path":"2024/03/13/nodeJs/","permalink":"https://2486125878.github.io/2024/03/13/nodeJs/","excerpt":"","text":"NODE.JS1.初识Node.js 1.2 Node.js 简介 1. 什么是Node.js Node.js@ is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js 是一个基于Chrome V8 引擎的JavaScript 运行环境。 Node.js官网地址: https://nodejs.org/zh-cn/ 2. Node.js 中的 JavaScript 运行环境 注意: ①浏览器是JavaScript的前端运行环境。 ② Node.js 是 JavaScript的后端运行环境。 ③ Node.js 中无法调用DOM和BOM等浏览器内置API。 3. Node.js 可以做什么 Node.js作为一个JavaScript的运行环境,仅仅提供了基础的功能和API。然而,基于Node.js提供的这些基础能,很多强大的工具和框架如雨后春笋,层出不穷,所以学会了Node.js,可以让前端程序员胜任更多的工作和岗位: ① 基于Express 框架(http://www.expressjs.com.cn/),可以快速构建Web应用 ② 基于Electron框架(https://electronjs.org/),可以构建跨平台的桌面应用 ③ 基于restify 框架(http://restify.com/),可以快速构建API接口项目 ④读写和操作数据库、创建实用的命令行工具辅助前端开发、etc… 总之: Node.js是大前端时代的“大宝剑“,有了Node.js这个超级buff的加持,前端程序员的行业竞争力会越来越强! Node.js 的学习路径:JavaScript 基础语法+ Node.js 内置API 模块(fs, path, http等) +第三方API 模块(express, mysql 等) 1.4在Node.js 环境中执行JavaScript代码1.终端中的快捷键 在Windows 的 powershell 或 cmd终端中,我们可以通过如下快捷键,来提高终端的操作效率: ①使用1键,可以快速定位到上一次执行的命令 ②使用tab键,能够快速补全路径 ③使用esc键,能够快速清空当前已输入的命令 ④输入cls命令,可以清空终端 2. fs文件系统模块 2.1什么是fs文件系统模块fs模块是Node.js官方提供的、用来操作文件的模块。它提供了一系列的方法和属性,用来满足用户对文件的操作需求。 例如: fs.readFile0方法,用来读取指定文件中的内容. fs.writeFile0方法,用来向指定的文件中写入内容 如果要在JavaScript代码中,使用fs模块来操作文件,则需要使用如下的方式先导入它: 1const fs =require(&#x27;fs&#x27;) 2.2读取指定文件中的内容1.fs.readFile()的语法格式 使用fs.readFile()方法,可以读取指定文件中的内容,语法格式如下: 1fs.readFile(path[, options], callback) 参数解读: 参数1:必选参数,字符串,表示文件的路径。 参数2:可选参数,表示以什么编码格式来读取文件。 参数3:必选参数,文件读取完成后,通过回调函数拿到读取的结果。 2. fs.readFile()的示例代码以utf8的编码格式,读取指定文件的内容,并打印 err和dataStr的值: 123456const fs = require(&#x27;fs&#x27;)fs.readFile(&#x27;./files/11.txt&#x27;, &#x27;utf8&#x27;, function(err, dataStr) &#123; console.log(err) console.log(&#x27;----&#x27;) console.log(dataStr)&#125;) 3.判断文件是否读取成功可以判断err对象是否为null,从而知晓文件读取的结果: 1234567const fs = require(&#x27;fs&#x27;) fs.readFile(&#x27;./files/1.txt&#x27;, &#x27;utf8&#x27;, function(err, result) &#123; if (err) &#123; return console.log(&#x27;文件读取失!&#x27;+ err.message) &#125; console.log(&#x27;文件读取成功,内容是: &#x27;+ result)&#125;) 2.3向指定的文件中写入内容1. fs.writeFile()的语法格式 使用fs.writeFile)方法,可以向指定的文件中写入内容,语法格式如下: 1fs.writeFile(file, data[, options], callback) 参数解读: 参数1:必选参数,需要指定一个文件路径的字符串,表示文件的存放路径。 参数2:必选参数,表示要写入的内容。 参数3:可选参数,表示以什么格式写入文件内容,默认值是utf8。 参数4:必选参数,文件写入完成后的回调函数。 1234const fs = require(&#x27;fs&#x27;)fs.writeFile(&#x27;./files/2.txt&#x27;, &#x27;Hello Node.js!&#x27;, function(err)&#123; console.log(err)&#125;) 3.判断文件是否写入成功 可以判断err对象是否为null,从而知晓文件写入的结果: 1234567const fs = require(&#x27;fs&#x27;)fs.writeFile(&#x27;F:/files/2.txt&#x27;, &#x27;Hello Node.js!&#x27;, function(err) &#123; if (err) &#123; return console.log(&#x27;文件写入失!&#x27;+ err.message) &#125; console.log(&#x27;文件写入成功! &#x27;)&#125;) 2.6 fs模块-路径动态拼接的问题在使用fs模块操作文件时,如果提供的操作路径是以&#x2F;或&#x2F;开头的相对路径时,很容易出现路径动态拼接错误的问题。 原因:代码在运行的时候,会以执行node命令时所处的目录,动态拼接出被操作文件的完整路径。 解决方案:在使用fs模块操作文件时,直接提供完整的路径,不要提供.&#x2F;或..&#x2F;开头的相对路径,从而防止路径动态拼接的问题。 1234567891011fs.readFile(__dirname + &#x27;/files/1.txt&#x27;, &#x27;utf-8&#x27;, function(err, datastr) &#123; if (err) &#123; return console.log(&#x27;读取文件失败&#x27; + err.message); &#125; console.log(&#x27;读取文件成功&#x27; + datastr);&#125;)fs.readFile(__dirname + &#x27;/files/1.txt&#x27;, &#x27;utf-8&#x27;, function(err, datastr) &#123; if (err) &#123; return console.log(&#x27;读取文件失败&#x27; + err.message); &#125; console.log(&#x27;读取文件成功&#x27; + datastr);&#125;) 3. path 路径模块3.1什么是path 路径模块path模块是 Node.js 官方提供的、用来处理路径的模块。它提供了一系列的方法和属性,用来满足用户对路径的处理需求。 例如: **path.join0方法,用来将多个路径片段拼接成一个完整的路径字符串. ** path.basename0 方法,用来从路径字符串中,将文件名解析出来 如果要在JavaScript代码中,使用path模块来处理路径,则需要使用如下的方式先导入它: 1const path require(&#x27;path&#x27;) 3.2 路径拼接1.path.join() 的语法格式 使用path.join0方法,可以把多个路径片段拼接为完整的路径字符串,语法格式如下: 1path.join([...paths]) 参数解读: …paths 路径片段的序列 返回值: 2. path.join()的代码示例 使用path.join0方法,可以把多个路径片段拼接为完整的路径字符串: 1234const pathStr = path.join(&#x27;/a&#x27;, &#x27;/b/c&#x27;, &#x27;../&#x27;,&#x27;./d&#x27;, &#x27;e&#x27;)console.log(pathStr) // 输 \\a\\b\\d\\econst pathStr2 path.join(__dirname, &#x27;./files/1.txt&#x27;)console.log(pathStr2) // 输出 当前文件所处目录\\files\\1.txt 注意:今后凡是涉及到路径拼接的操作,都要使用path.join0方法进行处理。不要直接使用+进行字符串的拼接。 3.3获取路径中的文件名1. path.basename()的语法格式 使用 path.basename0方法,可以获取路径中的最后一部分,经常通过这个方法获取路径中的文件名,语法格式如下: 1path.basename(path[, ext]) 参数解读: **path 必选参数,表示一个路径的字符串. ** ext 可选参数,表示文件扩展名. 返回: 表示路径中的最后一部分 2. path.basename() 的代码示例 使用 path.basename0方法,可以从一个文件路径中,获取到文件的名称部分: 12345const fpath = &#x27;/a/b/c/index.html&#x27; // 文件的存放路径var fullName = path. basename(path)console.log(fullName) // 输 index.htmlvar namewithoutExt = path.basename(fpath, &#x27;.html&#x27;)console.log(namewithoutExt) // 输 index 3.4 获取路径中的文件扩展名 1. path.extname()的语法格式 使用path.extname()方法,可以获取路径中的扩展名部分,语法格式如下: 1path.extname(path) 参数解读: path 必选参数,表示一个路径的字符串. 返回: 返回得到的扩展名字符串 2. path.extname() 的代码示例 使用path.extname()方法,可以获取路径中的扩展名部分: 123const fpath = &#x27;/a/b/c/index.html&#x27; // 路径字符串const fext = path.extname(fpath)console.log(fext) // 输.html 3.5综合案例-时钟案例3.步骤1-导入需要的模块并创建正则表达式 123456789//1.1 导入 fs文件系统模块const fs = require(&#x27;fs&#x27;)//1.2导入 path路径处理模块const path = require(&#x27;path&#x27;)//1.3匹配&lt;style&gt;&lt;/style&gt;标签的正则//其中\\s表示空白字符; \\S表示非空白字符; *表示匹配任意次const regStyle = /&lt;style&gt;[\\s\\S]*&lt;\\/style&gt;///1.4 匹配&lt;script&gt;&lt;/script&gt;标签的正则const regScript = /&lt;script&gt;[\\s\\S]*&lt;\\/script&gt; 3.步骤2-使用fs模块读取需要被处理的html文件 123456789// 2.1读取需要被处理的HTML文件fs.readFile(path.join(__dirname, &#x27;../素才/index.html&#x27;), &#x27;utf8&#x27;, (err, dataStr) =&gt;&#123; //2.2 读取HTML文件失败 if (err) return console.log(&#x27;读取HTML文件失!&#x27; + err.message) // 2.3 读取HTML文件成功后,调用对应的方法,拆解出css.js 和html文件 resolveCSS(dataStr) resolveJS(dataStr) resolveHTML(dataStr)&#125;) 3.步骤3-自定义resolveCSS方法 12345678910111213//3.1处理CSS样式function resolveCSS(htmlStr)&#123;//3.2使用正则提取页面中的&lt;style&gt;&lt;/style&gt;标签 const r1 regStyle.exec(htmlStr)//3.3将提取出来的样式字符串,做进一步的处理 const newCSS = r1[0].replace(&#x27;&lt;style&gt;&#x27;, &#x27;&#x27;).replace(&#x27;&lt;/style&gt;&#x27;, &#x27;&#x27;)// 3.4将提取出来的CSS样式,写入到index.css文件中 fs.writeFile(path.join(dirname, &#x27;./clock/index.css&#x27;), newCSS, err =&gt;&#123; if (err) return console.log(&#x27;写入 CSS 样式失!&#x27;+ err.message) console.log(&#x27;写入CSS 样式成功!&#x27;) &#125;)&#125; 3.步骤4-自定义resolveJS方法 123456789101112//4.1处理js脚本function resolveJS(htmlStr)&#123;//4.2使用正则提取页面中的&lt;script&gt;&lt;/script&gt;标签 const r2 =regScript.exec(htmlStr)//4.3将提取出来的脚本字符串,做进一步的处理 const newJS = r2[0].replace(&#x27;&lt;script&gt;&#x27;, &#x27;&#x27;).replace(&#x27;&lt;/script&gt;&#x27;, &#x27;&#x27;)//4.4将提取出来的js脚本,写入到index.js文件中 fs.writeFile(path.join(_dirname, &#x27;./clock/index.js&#x27;), newJS, err =&gt;&#123; if (err) return console.log(&#x27;写入 JavaScript脚本 失败!&#x27;+ err.message) console.log(&quot;写入JS 脚本成功!&#x27;) &#125;) &#125; 3.步骤5-自定义resolveHTML方法 123456789101112//5.处理html文件function resolveHTML(htmlStr)&#123;//5.1使用字符事的replace方法,把内嵌的&lt;style&gt;和&lt;script&gt;标签,替换为外联的&lt;link&gt;和&lt;script&gt;标签 const newHTML htmlStr .replace(regStyle, &#x27;&lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;/&gt;&#x27;) .replace(regScript, &#x27;&lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;&#x27;) //5.2将替换完成之后的html代码,写入到index.html文件中 fs.writeFile(path.join(dirname, &#x27;./clock/index.html&#x27;), newHTML, err =&gt;&#123; if (err) return console.log(&#x27;写入HTML文件失败!&#x27;+ err.message) console.log(&#x27;写入HTML页面成功! &#x27;) &#125;)&#125; 4.案例的两个注意点 ① fs.writeFile0方法只能用来创建文件,不能用来创建路径 ② 重复调用fs.writeFile0 写入同一个文件,新写入的内容会覆盖之前的旧内容 4. http模块4.1 什么是http模块回顾:什么是客户端、什么是服务器? 在网络节点中,负责消费资源的电脑,叫做客户端; 负责对外提供网络资源的电脑,叫做服务器。 http 模块是Node.js官方提供的、用来创建web服务器的模块。通过http模块提供的http.createServer()方法,就能方便的把一台普通的电脑,变成一台Web服务器,从而对外提供Web资源服务。 如果要希望使用http模块创建Web服务器,则需要先导入它: 1const http = require(&#x27;http&#x27;) 4.2进一步理解http模块的作用服务器和普通电脑的区别在于,服务器上安装了web服务器软件,例如: IIS,Apache等。通过安装这些服务器软件,就能把一台普通的电脑变成一台web服务器。 在Node.js 中,我们不需要使用IS, Apache等这些第三方web服务器软件。因为我们可以基于Node.js提供的http模块,通过几行简单的代码,“就能轻松的手写一个服务器软件,从而对外提供web服务。 4.3服务器相关的概念1. IP 地址IP地址就是互联网上每台计算机的唯一地址,因此IP地址具有唯一性。如果把“个人电脑”比作“一台电话”,那么”IP地址”就相当于“电话号码”,只有在知道对方IP地址的前提下,才能与对应的电脑之间进行数据通信。 IP地址的格式:通常用“点分十进制”表示成(a.b.c.d)的形式,其中,a,b,c,d都是0~255之间的十进制整数。例如:用点分十进表示的IP地址(192.168.1.1) 注意: ①互联网中每台Web服务器,都有自己的IP地址,例如:大家可以在Windows的终端中运行ping www.baidu.com命令,即可查看到百度服务器的IP地址。 ②在开发期间,自己的电脑既是一台服务器,也是一个客户端,为了方便测试,可以在自己的浏览器中输入127.0.0.1这个IP地址,就能把自己的电脑当做一台服务器进行访问了。 2.域名和域名服务器 尽管IP地址能够唯一地标记网络上的计算机,但IP地址是一长串数字,不直观,而且不便于记忆,于是人们又发明了另一套字符型的地址方案,即所谓的域名(Domain Name)地址。 IP地址和域名是–对应的关系,这份对应关系存放在一种叫做域名服务器(DNS, Domain name server)的电脑中。使用者只需通过好记的域名访问对应的服务器即可,对应的转换工作由域名服务器实现。因此,域名服务器就是提供IP地址和域名之间的转换服务的服务器。 注意: ①单纯使用IP地址,互联网中的电脑也能够正常工作。但是有了域名的加持,能让互联网的世界变得更加方便。 ②在开发测试期间, 127.0.0.1 对应的域名是 localhost,它们都代表我们自己的这台电脑,在使用效果上没有任何区别。 3.端口号 计算机中的端口号,就好像是现实生活中的门牌号一样。通过门牌号,外卖小哥可以在整栋大楼众多的房间中,准确把外卖送到你的手中。 同样的道理,在一台电脑中,可以运行成百上干个web服务。每个web服务都对应一个唯一的端口号。客户端发送过来的网络请求,通过端口号,可以被准确地交给对应的web服务进行处理。 注意: ①每个端口号不能同时被多个web服务占用。 ②在实际应用中,URL中的80端口可以被省略。 1.创建web服务器的基本步骤 ① 导入http模块 ②创建web服务器实例 ③为服务器实例绑定request事件,监听客户端的请求 ④启动服务器 4.4 创建最基本的web服务器 2.步骤3-为服务器实例绑定request事件 为服务器实例绑定request事件,即可监听客户端发送过来的网络请求 12345//使用服务器实例的.on()方法,为服务器绑定一个request事件 server.on(&#x27;request&#x27;. (req. res) =&gt;&#123; //只要有客户端来请求我们自己的服务器,就会触发request事件,从而调用这个事件处理函数 console.log(&#x27;Someone visit our web server&#x27;) &#125;) 2.步骤4-启动服务器 调用服务器实例的.listen0方法,即可启动当前的web服务器实例: 1234//调用 server.listen(端口号, cb回调)方法,即可启动web服务器server.listen(80, () =&gt;&#123; console.log(&#x27;http server running at http://127.0.0.1&#x27;)&#125;) 3. req请求对象只要服务器接收到了客户端的请求,就会调用通过server.on0为服务器绑定的request事件处理函数。 如果想在事件处理函数中,访问与客户端相关的数据或属性,可以使用如下的方式: 1234567server.on(&#x27;request&#x27;. (req) =&gt;&#123; //req 是请求对象,它包合了与客户端相关的数据和属性,例如: // req.url是客户端请求的URL地址 // req.method是客户的method请求类型 const str = &quot;Your request url is $(req.url), and request method is $&#123;req.method&#125; console.log(str)&#125;) 4. res 响应对象在服务器的request事件处理函数中,如果想访问与服务器相关的数据或属性,可以使用如下的方式: 12345678server.on(&#x27;request&#x27;, (req, res) =&gt;&#123; // res 是响应对象,它包含了与服务器相关的数据和属性,例如: //要发送到客户端的字符串 const str= &#x27;Your request url is $&#123;req.url&#125;, and request method is $&#123;req.method&#125;` // res.end()方法的作用: //向客户端发送指定的内容,并结束这次请求的处理过程 res.end(str)&#125;) 5.解决中文乱码问题当调用res.end0方法,向客户端发送中文内容的时候,会出现乱码问题,此时,需要手动设置内容的编码格式: 12345678server.on(&#x27;request&#x27;, (req, res) =&gt;&#123; //发送的内容包含中文 const str=`您请求的ur1地址是$&#123;req.url&#125;,请求的method 类型是 $&#123;req.method&#125;` //为了防止中文显示乱码的问题,需要设置响应头Content-Type的值为text/html; charset=utf-8 res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;) //把包含中文的内容,响应给客户端 res.end(str)&#125;) 4.5 根据不同的url响应不同的html内容1.核心实现步骤 ①获取请求的url地址 ②设置默认的响应内容为404 Not found ③判断用户请求的是否为&#x2F;或&#x2F;index.html首页 ④判断用户请求的是否为&#x2F;about.html关于页面 ⑤设置Content-Type 响应头,防止中文乱码 6使用res.end()把内容响应给客户端 2.动态响应内容 1234567891011121314151617server.on(&#x27;request&#x27;, function(req, res) &#123; const url=req.url // 1.获取请求的url地址 let content&#x27;&lt;h1&gt;404 Not found!&lt;/h1&gt;&#x27; // 2. 设置认的内容为404 Not found if (url ===&#x27;/&#x27; || url ===&#x27;/index.html&#x27;)&#123; content =&#x27;&lt;h1&gt;首页&lt;/h1&gt; //3.用户请求的是首页 &#125;else if (url ===&#x27;/about.html&#x27;) &#123; content = &#x27;&lt;h1&gt;关于页&lt;/h1&gt;&#x27; &#125; //4.用户请求的是关于页面 res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;) // 5. 设置Content-Type 响应头,防止中文乱研 res.end(content)&#125;) //6.把内容发送给客户端 1.核心思路把文件的实际存放路径,作为每个资源的请求url地址。 2.实现步骤 ① 导入需要的模块 ②创建基本的web服务器 ③将资源的请求url地址映射为文件的存放路径 ④读取文件内容并响应给客户端 ⑤优化资源的请求路径 3.步骤1-导入需要的模块 123456// 1.1 导入 http模块const http = require(&#x27;http&#x27;)//1.2 导入 fs文件系统模块const fs = require(&#x27;fs&#x27;)// 1.3 导入path路径处理模块const path = require(&#x27;path&#x27;) 3.步骤2-创建基本的web服务器 12345678//2.1创建web服务器const server = http.createServer()// 2.2 监听web服务器的request事件server.on(&#x27;request&#x27;, function(req, res) &#123;&#125;)//2.3 启动web服务器server.listen(80, function() &#123; console.log(&#x27;server listen at http://127.0.0.1&#x27;)&#125;) 3.步骤3-将资源的请求url地址映射为文件的存放路径 1234// 3.1获取到客户端请求的url地址const url req.url// 3.2把请求的url地址,映射为本地文件的存放路径const fpath = path.join(__dirname, url) 3.步骤4-读取文件的内容并响应给客户端 1234567//4.1根据“映射“过来的文件路径读取文件fs.readFile(fpath, &#x27;utf8&#x27;, (err, dataStr) =&gt;&#123; // 4.2读取文件失败后,向客户端响应同定的“错误消息” if(err) return res.end(&#x27;404 Not fount. &#x27;) // 4.3 读取文件成功后,将&quot;读取成功的内容”响应给客户端 res.end(dataStr)&#125;) 1.模块化的基本概念1.1什么是模块化模块化是指解决一个复杂问题时,自顶向下逐层把系统划分成若干模块的过程。对于整个系统来说,模块是可组合、分解和更换的单元。 2.编程领域中的模块化 编程领域中的模块化,就是遵守固定的规则,把一个大文件拆成独立并互相依赖的多个小模块。 把代码进行模块化拆分的好处: ①提高了代码的复用性 ②提高了代码的可维护性 ③可以实现按需加载 1.2模块化规范 模块化规范就是对代码进行模块化的拆分与组合时,需要遵守的那些规则。 例如: 使用什么样的语法格式来引用模块 在模块中使用什么样的语法格式向外暴露成员 模块化规范的好处:大家都遵守同样的模块化规范写代码,降低了沟通的成本,极大方便了各个模块之间的相互调用,利人利己。 2. Node.js中的模块化2.1 Node.js 中模块的分类Node.js中根据模块来源的不同,将模块分为了3大类,分别是:. 内置模块(内置模块是由Node.js官方提供的,例如fs, path, http等). 自定义模块(用户创建的每个.js文件,都是自定义模块)· 第三方模块(由第三方开发出来的模块,并非官方提供的内置模块,也不是用户创建的自定义模块,使用前需要先下载) 2.2加载模块使用强大的require0方法,可以加载需要的内置模块、用户自定义模块、第三方模块进行使用。例如: 123456// 1.加载内置的fs模块const fs = requireC&#x27;fs&#x27;)// 2.加载用户的自定义模块const custom = require(&#x27;./custom.js&#x27;)// 3.加载第三方模块const moment =require(&#x27;moment&#x27;) 注意:使用requireO方法加载其它模块时,会执行被加载模块中的代码。 2.3 Node.js 中的模块作用域1.什么是模块作用域和函数作用域类似,在自定义模块中定义的变量、方法等成员,只能在当前模块内被访问,这种模块级别的访问限制,叫做模块作用域。 2.模块作用域的好处 防止了全局变量污染的问题 2.4 向外共享模块作用域中的成员1. module 对象 在每个.js自定义模块中都有一个module对象,它里面存储了和当前模块有关的信息,打印如下: 123456789Module &#123; id: &#x27;.&#x27;, path: &#x27;D:\\\\node&#x27;, exports: &#123;&#125;, filename: &#x27;D:\\\\node\\\\17演示module对象.js&#x27;, loaded: false, children: [], paths: [ &#x27;D:\\\\node\\\\node_modules&#x27;, &#x27;D:\\\\node_modules&#x27; ]&#125; 2. module.exports 对象 在自定义模块中,可以使用module.exports对象,将模块内的成员共享出去,供外界使用。 外界用require0方法导入自定义模块时,得到的就是module.exports所指向的对象。 3.共享成员时的注意点 使用require0方法导入模块时,导入的结果,永远以module.exports指向的对象为准。 4.exports 对象 由于module.exports单词写起来比较复杂,为了简化向外共享成员的代码,Node提供了exports对象。默认情况下, exports 和module.exports指向同一个对象。最终共享的结果,还是以module.exports指向的对象为准。 4. exports 和 module.exports 的使用误区 时刻谨记, requireO模块时,得到的永远是module.exports指向的对象: 123456exports.username =&#x27;zs&#x27;module.exports = &#123; gender: &#x27;男&#x27;, age: 22&#125;&#123;gender: &#x27;男&#x27;, age: 22&#125; 123456module.exports.username = &#x27;zs&#x27;exports = &#123; gender: &#x27;男&#x27;, age: 22&#125;&#123;username: &#x27;zs&#x27;&#125; 123exports.username= &#x27;zs&#x27;module.exports.gender = &#x27;男&#x27;&#123; username: &#x27;zs&#x27;, gender: &#x27;男&#x27;&#125; 1234567exports = &#123; username: &#x27;zs&#x27;, gender: &#x27;男&#x27;&#125;module.exports = exportsmodule.exports.age = &#x27;22&#x27;&#123; username: &#x27;zs&#x27;, gender: &#x27;男&#x27;, age: &#x27;22&#x27;&#125; 注意:为了防止混乱,建议大家不要在同一个模块中同时使用 exports 和module.exports 3. npm与包3.1包1.什么是包 Node.js中的第三方模块又叫做包。 就像电脑和计算机指的是相同的东西,第三方模块和包指的是同一个概念,只不过叫法不同。 2.包的来源 不同于Node.js中的内置模块与自定义模块,包是由第三方个人或团队开发出来的,免费供所有人使用。 注意: Node.js中的包都是免费且开源的,不需要付费即可免费下载使用。 3.为什么需要包 由于Node.js的内置模块仅提供了一些底层的API,导致在基于内置模块进行项目开发的时,效率很低。 包是基于内置模块封装出来的,提供了更高级、更方便的API,极大的提高了开发效率。 包和内置模块之间的关系,类似于jQuery和浏览器内置API之间的关系。 4.从哪里下载包 国外有一家IT公司,叫做npm, Inc.这家公司旗下有一个非常著名的网站: https://www.npmjs.com/,它是全球最大的包共享平台,你可以从这个网站上搜索到任何你需要的包,只要你有足够的耐心! 到目前位置,全球约1100 多万的开发人员,通过这个包共享平台,开发并共享了超过120多万个包 供我们使用。 npm, Inc. 公司提供了一个地址为hps:&#x2F;&#x2F;registry.npmjs.org&#x2F;的服务器,来对外共享所有的包,我们可以从这个服务器上下载自己所需要的包。 注意: .从https://www.npmjs.com/网站上搜索自己所需要的包 .从https://registry.npmjs.org/ 服务器上下载自己需要的包 5.如何下载包 npm, Inc.公司提供了一个包管理工具,我们可以使用这个包管理T具,从https://registry.npmjs.org/服务器把需要的包下载到本地使用。 这个包管理工具的名字叫做Node Package Manager(简称npm包管理工具),这个包管理T具随着Node.js的安装包一起被安装到了用户的电脑上。 3.2 npm 初体验1.格式化时间的传统做法 ①创建格式化时间的自定义模块 ②定义格式化时间的方法 ③创建补零函数 ④从自定义模块中导出格式化时间的函数 ⑤导入格式化时间的自定义模块 6调用格式化时间的函数 2.格式化时间的高级做法 ①使用npm包管理T具,在项目中安装格式化时间的包moment ②使用requireO导入格式化时间的包 ③参考moment的官方API文档对时间进行格式化 3.在项目中安装包的命令 如果想在项目中安装指定名称的包,需要运行如下的命令: 1npm install 包的完整名称 1npm i 完整的包名称 4.初次装包后多了哪些文件 初次装包完成后,在项目文件夹下多一个叫做node_modules的文件夹和package-lock.json的配置文件。 其中: node_modules文件夹用来存放所有已安装到项目中的包。 requireO导入第三方包时,就是从这个目录中查找并加载包。 package-lock.json配置文件用来记录 node_modules 目录下的每一个包的下载信息,例如包的名字、版本号、下载地址等。 注意:程序员不要手动修改node_modules 或 package-lock.json文件中的任何代码,npm包管理工具会自动维护它们。 5.安装指定版本的包默认情况下,使用npm install 命令安装包的时候,会自动安装最新版本的包。如果需要安装指定版本的包,可以在包名之后,通过@符号指定具体的版本,例如: 1npm i moment@2.22.2 6.包的语义化版本规范 包的版本号是以“点分十进制”形式进行定义的,总共有三位数字,例如2.24.0其中每一位数字所代表的的含义如下: 第1位数字:大版本 第2位数字:功能版本 第3位数字: Bug修复版本 版本号提升的规则:只要前面的版本号增长了,则后面的版本号归零。 3.3包管理配置文件 npm规定,在项目根目录中,必须提供一个叫做 package.json的包管理配置文件。用来记录与项目有关的一些配置信息。例如: .项目的名称、版本号、描述等. 项目中都用到了哪些包. 哪些包只在开发期间会用到 .那些包在开发和部署时都需要用到 整个项目的体积是30.4M 第三方包的体积是 28.8M 项目源代码的体积1.6M 遇到的问题:第三方包的体积过大,不方便团队成员之间共享项目源代码。 解决方案:共享时剔除node_modules 2.如何记录项目中安装了哪些包 在项目根目录中,创建一个叫做package.json的配置文件,即可用来记录项目中安装了哪些包。从而方便剔除node_modules 目录之后,在团队成员之间共享项目的源代码。 注意:今后在项目开发中,一定要把node_modules文件夹,添加到.gitignore忽略文件中。 3. 快速创建 package.jsonnpm包管理工具提供了一个快捷命令,可以在执行命令时所处的目录中,快速创建 package.json这个包管理配置文件: 12//作用:在执行命令所处的目录中,快速新建package.json文件npm init -y 注意:①上述命令只能在英文的目录下成功运行!所以,项目文件夹的名称一定要使用英文命名,不要使用中文,不能出现空格。 ②运行npm install 命令安装包的时候, npm包管理工具会自动把包的名称和版本号,记录到package.json中。 4. dependencies 节点 package.json文件中,有一个 dependencies 节点,专门用来记录您使用npm install命令安装了哪些包。 5.一次性安装所有的包当我们拿到一个剔除了node_modules的项目之后,需要先把所有的包下载到项目中,才能将项目运行起来。否则会报类似于下面的错误: 12//由于项目运行依赖于moment这个包,如果没有提前安装好这个包,就会报如下的错误:Error: Cannot find module &#x27;moment&quot; 5.一次性安装所有的包 可以运行npm install 命令(或 npm i)一次性安装所有的依赖包: 123// 执行npm install 命令时, npm包管理工具会先读取package.json 中的dependencies 节点//读取到记录的所有依赖包名称和版本号之后,npm包管理工具会把这些包一次性下载到项目中npm install 6.卸载包 可以运行npm uninstall 命令,来卸载指定的包: 12//使用npm uninstall 具体的包名 来卸载包npm uninstall moment 注意: npm uninstall 命令执行成功后,会把卸载的包,自动从package.json的dependencies中移除掉。 7. devDependencies 节点 如果某些包只在项目开发阶段会用到,在项目上线之后不会用到,则建议把这些包记录到devDependencies节点中。 与之对应的,如果某些包在开发和项目上线之后都需要用到,则建议把这些包记录到dependencies节点中。 您可以使用如下的命令,将包记录到devDependencies节点中: 1234//安装指定的包,并记录到devDependencies 节点中npm i 包名 -D//注意:上述命令是简写形式,等价于下面完整的写法:npm install 包名 --save-dev 3.4 解决下包速度慢的问题 1.为什么下包速度慢 在使用npm下包的时候,默认从国外的https://registry.npmjs.org/服务器进行下载,此时,网络数据的传输需要经过漫长的海底光缆,因此下包速度会很慢。 2.淘宝NPM 镜像服务器 淘宝在国内搭建了一个服务器,专门把国外官方服务器上的包同步到国内的服务器,然后在国内提供下包的服务。从而极大的提高了下包的速度。 扩展:镜像(Mirroring)是一种文件存储形式,一个磁盘上的数据在另一个磁盘上存在一个完全相同的副木即为镜像。 3.切换npm的下包镜像源 下包的镜像源,指的就是下包的服务器地址。 123456//查看当前的下包镜像源npm config get registry//将下包的镜像源切换为淘宝镜像源npm config set registry=https://registry.npm.taobao.org///检查镜像源是否下载成功npm config get registry 4. nrm 为了更方便的切换下包的镜像源,我们可以安装nrm这个小工具,利用nrm提供的终端命令,可以快速查看和切换下包的镜像源。 123456//通过npm包管理器,将nrm安装为全局可用的工具npm i nrm -g//查看所有可用的镜像源nrm 1s//将下包的镜像源切换为taobao镜像nrm use taobao 3.5包的分类使用npm包管理工具下载的包,共分为两大类,分别是:·项目包.全局包 项目包又分为两类,分别是:. 开发依赖包(被记录到devDependencies节点中的包,只在开发期间会用到) 核心依赖包(被记录到dependencies节点中的包,在开发期间和项目上线之后都会用到) 12npm i 包名 -D //开发依赖包(会被记录到 devDependencies 节点下)&quot;npm i 包名 //核心依赖包(会被记录到dependencies节点下) 2.全局包 在执行npm install 命令时,如果提供了-g参数,则会把包安装为全局包。 全局包会被安装到 C:Usersl用e目录AppDatalRoaming\\npmlnode_modules 目录下。 12npm i 包名 -g //全局安装指定的包npm uninstall 包名 -g //载全局安装的包 ①只有工具性质的包,才有全局安装的必要性。因为它们提供了好用的终端命令。 ②判断某个包是否需要全局安装后才能使用,可以参考官方提供的使用说明即可。 3. i5ting_toc iSting_toc 是一个可以把md文档转为html页面的小工具,使用步骤如下: 1234//将i5ting_toc安装为全局包npm install -g i5ting_toc//调用i5ting_toc,轻松实现md转html的功能i5ting_toc -f 要转换的md文件路径 -o 3.6规范的包结构 在清楚了包的概念、以及如何下载和使用包之后,接下来,我们深入了解一下包的内部结构。 一个规范的包,它的组成结构,必须符合以下3点要求: ①包必须以单独的目录而存在 ②包的顶级目录下要必须包含package.json这个包管理配置文件 ③ package.json 中必须包含name, version, main这三个属性,分别代表包的名字、版本号、包的入口。 注意:以上3点要求是一个规范的包结构必须遵守的格式,关于更多的约束,可以参考如下网址: https://yarnpkg.com/zh-Hans/docs/package-json 3.7开发属于自己的包1.需要实现的功能格式化日期 ①格式化日期 2.转义HTML中的特殊字符 ③还原HTML中的特殊字符 123456// 1.导入自己的包const itheima = require(&#x27;itehima-utils&#x27;)//-功能1:格式化日期…const dt = itheima.dateFormat(new Date())//输出2020-01-20 10:09:45console.log(dt) 1234567//1.导入自己的包const itheima= require(&#x27;itehima-utils&#x27;)//----功能2:转义HTML中的特殊字符const htmlStr = &#x27;&lt;h1 style=&quot;color: red; &quot;&gt;你好! &amp;copy; &lt;span&gt;小黄! &lt;/span&gt;&lt;/h1&gt;&#x27;const str= itheima.htmlEscape(htmlStr)// &amp;lt;h1 style=&amp;quot; color: red; &amp;quot;&amp;gt:你好! &amp;amp; copy: &amp;lt; span&amp;gt;小黄! &amp;lt;/span&amp;gt; &amp;lt;/h1&amp;gt;console.log(str) 123456//1.导入自己的包const itheima = require(&#x27;itehima-utils&#x27;)//功能3:还原HTML中的特殊字符const rawHTML = itheima.htmlUnEscape(str)//输出&lt;h1 style=&quot;color: red; &quot;&gt;你好! &amp;copy;&lt;span&gt;小黄! &lt;/span&gt;&lt;/h1&gt;console.log(rawHTML) 3.7 开发属于自己的包2.初始化包的基本结构 ①新建itheima-tools文件夹,作为包的根目录 ②在itheima-tools文件夹中,新建如下三个文件: package.json (包管理配置文件) index.js (包的入口文件) README.md (包的说明文档) 3. 初始化 package.json 12345678&#123; &quot;name&quot;: &quot;itheima-tools&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;description&quot;: &quot;提供了格式化时间, HTMLEscape的功能&quot;, &quot;keywords&quot;: [&quot;itheima&quot;, &quot;dateFormat&quot;, &quot;escape&quot;], &quot;license&quot;: &quot;ISC&quot;&#125; 关于更多license许可协议相关的内容,可参考https://www.jianshu.com/p/86251523e898 4. 在index.js中定义格式化时间的方法 123456789//格式化时间的方法function dateFormat (dateStr) &#123; /*省略其余代码*/ &#125; //补零的方法 function padZero(n) &#123; return n &gt; 9 ? n : &#x27;0&#x27; +n &#125; module.exports =&#123; dateFormat &#125; 5. 在index.js中定义转义HTML的方法 1234567891011121314function htmlEscape(htmlStr) &#123; return htmlStr.replace(/&lt;|&gt;|&quot;|&amp;/g, (match) =&gt;&#123; switch (match) &#123; case &#x27;&lt;&#x27;: return &#x27;&amp;lt;&#x27; case &#x27;&gt;&#x27;: return &#x27;&amp;gt;&#x27; case &#x27;:&#x27;: return &#x27;&amp;quot;&#x27; case &#x27;&amp;&#x27;: return &#x27;&amp;amp;&#x27; &#125; &#125;)&#125; 6. 在index.js中定义还原HTML的方法 12345678910111213141516function htmlUnEscape(str) &#123; return str.replace(/&amp;lt;|&amp;gt;|&amp;quot;|&amp;amp;/g, (math) =&gt; &#123; switch (math) &#123; case &#x27;&amp;lt;&#x27;: return &#x27;&lt;&#x27; case &#x27;&amp;gt;&#x27;: return &#x27;&gt;&#x27; case &#x27;&amp;quot;&#x27;: return &#x27;&quot;&#x27; case &#x27;&amp;amp;&#x27;: return &#x27;&amp;&#x27; &#125; &#125;)&#125; 7.将不同的功能进行模块化拆分 ① 将格式化时间的功能,拆分到src-&gt;dateFormat.js中 ②将处理HTML字符串的功能,拆分到src-&gt; htmlEscape.js中 ③在index.js中,导入两个模块,得到需要向外共享的方法 ④在index.js 中,使用module.exports把对应的方法共享出去 8.编写包的说明文档 包根目录中的README.md文件,是包的使用说明文档。通过它,我们可以事先把包的使用说明,以markdown的格式写出来,方便用户参考。 README文件中具体写什么内容,没有强制性的要求;只要能够清晰地把包的作用、用法、注意事项等描述清楚即可。 我们所创建的这个包的README.md文档中,会包含以下6项内容:安装方式、导入方式、格式化时间、转义HTML中的特殊字符、还原HTML中的特殊字符、开源协议 3.8 发布包1.注册npm账号 ①访问https://www.npmjs.com/网站,点击sign up按钮,进入注册用户界面 ②填写账号相关的信息: Full Name, Public Email, Username, Password ③点击Create an Account按钮,注册账号 2.登录npm账号 npm账号注册完成后,可以在终端中执行npm login命令,依次输入用户名、密码、邮箱后,即可登录成功。 3.把包发布到npm上 将终端切换到包的根目录之后,运行npm publish命令,即可将包发布到npm上(注意:包名不能雷同)。 1C: Userslliulongbin(Desktoplitheima-utilsl)npm publish 4.删除已发布的包 运行npm unpublish 包名–force 命令,即可从npm删除已发布的包。 1C:\\Users\\liulongbin\\Desktop\\itheima-utilsl&gt;npm unpublish itheima-utils --force 注意: ① npm unpublish 命令只能删除72 小时以内发布的包 ② npm unpublish 删除的包,在24 小时内不允许重复发布 ③发布包的时候要慎重,尽量不要往npm上发布没有意义的包 4.模块的加载机制4.1优先从缓存中加载模块在第一次加载后会被缓存。这也意味着多次调用require0不会导致模块的代码被执行多次。 注意:不论是内置模块、用户自定义模块、还是第三方模块,它们都会优先从缓存中加载,从而提高模块的加载效率。 4.2内置模块的加载机制内置模块是由Node.js官方提供的模块,内置模块的加载优先级最高。 例如, require(‘fs’)始终返回内置的fs模块,即使在node_modules目录下有名字相同的包也叫做fs。 4.3 自定义模块的加载机制使用require0加载自定义模块时,必须指定以.&#x2F;或..&#x2F;开头的路径标识符。在加载自定义模块时,如果没有指定&#x2F;或..&#x2F;这样的路径标识符,则node会把它当作内置模块或第三方模块进行加载。 同时,在使用requireO导入自定义模块时,如果省略了文件的扩展名,则Node.js会按顺序分别尝试加载以下的文件: ①按照确切的文件名进行加载 ②补全.js扩展名进行加载 ③补全.json扩展名进行加载 ④补全.node扩展名进行加载 ⑤加载失败,终端报错 4.4 第三方模块的加载机制 如果传递给require0的模块标识符不是一个内置模块,也没有以’&#x2F;‘或’.&#x2F;开头,则Node.js会从当前模块的父目录开始,尝试从&#x2F;node_modules文件夹中加载第三方模块。 例如,假设在’C:AUserslitheimalprojectlfoos’文件里调用了require(‘tools’),则Node.js会按以下顺序查找: **①CAUserslitheimalprojectlnode_modulesltgols ** **② CUserslitheimalnode_modules(tools ** 3.CUsersInode modules)tools ④C:Inode modulesltools 4.5目录作为模块 当把目录作为模块标识符,传递给requireO进行加载的时候,有三种加载方式: ①在被加载的目录下查找一个叫做package.json的文件,并寻找main属性,作为require0加载的入口 ②如果目录里没有package.json文件,或者main入口不存在或无法解析,则Node.js将会试图加载目录下的index.js文件。 ③如果以上两步都失败了,则Node.js 会在终端打印错误消息,报告模块的缺失: Error: Cannot find module ‘xxx’ 1. 初识Express1.1 Express 简介1. 什么是Express 官方给出的概念:Express是基于Node.js平台,快速、开放、极简的Web开发框架。 通俗的理解: Express的作用和Node.js内置的http模块类似,是专门用来创建Web服务器的。 Express 的本质:就是一个npm上的第三方包,提供了快速创建Web服务器的便捷方法。 Express 中文官网: http://www.expressjs.com.cn/ 2. 进一步理解Express 思考:不使用Express能否创建Web服务器? 答案:能,使用Node.js提供的原生http模块即可。 思考:既生瑜何生亮(有了http内置模块,为什么还有用Express) ? 答案: http内置模块用起来很复杂,开发效率低:Express是基于内置的http模块进一步封装出来的,能够极大的提高开发效率。 思考: http内置模块与Express是什么关系? 答案:类似于浏览器中Web API和jQuery的关系。后者是基于前者进一步封装出来的。 3. Express 能做什么 对于前端程序员来说,最常见的两种服务器,分别是: Web网站服务器:专门对外提供Web网页资源的服务器。 API接口服务器:专门对外提供API接口的服务器。 使用Express,我们可以方便、快速的创建Web网站的服务器或API接口的服务器。 1.2 Express 的基本使用1.安装 在项目所处的目录中,运行如下的终端命令,即可将express安装到项目中使用: npm i &#101;&#120;&#x70;&#x72;&#x65;&#115;&#115;&#64;&#x34;&#46;&#x31;&#55;&#x2e;&#x31; 2.创建基本的Web服务器 1. 导入 express const express &#x3D;”require(‘express’) &#x2F;&#x2F; 2.创建web服务器 const app &#x3D; express() &#x2F;&#x2F; 3.调用app.listen(端口号,启动成功后的回调函数),启动服务器 app.listen(80, () &#x3D;&gt; { console.log(‘express server running at http://127.0.0.1‘) }) 3.监听GET请求 通过app.geto方法,可以监听客户端的GET请求,具体的语法格式如下: 12345//参数1:客户端请求的URL地址//参数2:请求对应的处理函数//req:请求对象(包含了与请求相关的属性与方法)//res:响应对象(包含了与响应相关的属性与方法)app.get(&#x27;请求URL&#x27;, function(req, res) &#123;/*处理数*/ &#125;) 4.监听POST 请求 通过app.post0方法,可以监听客户端的POST请求,具体的语法格式如下: 12345//参数1:客户端请求的URL地址//参数2:请求对应的处理函数//req:请求对象(包含了与请求相关的属性与方法)//res:响应对象(包含了与响应相关的属性与方法)app.post(&#x27;请求URL&#x27;, function(req, res) &#123;/*处理数*/ &#125;) 5.把内容响应给客户端 通过res.send(0)方法,可以把处理好的内容,发送给客户端: 1234567app.get(&#x27;/user&#x27;. (req, res) =&gt; &#123; //向客户端发送JSON对象 res.send(&#123; name: &#x27;zs&#x27;, age: 20, gender: &#x27;男&#x27; &#125;)app.post(&#x27;/user&#x27;, (req, res) =&gt; &#123; //向客户端发送文本内容 res.send(&quot;请求成功&#x27;) &#125;) 6.获取URL中携带的查询参数 通过req.query对象,可以访问到客户端通过查询字符串的形式,发送到服务器的参数: 1234567app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; // req.query 默认是一个空对象 // 客户端使用?name=zs&amp;age=20 这种查询字符串形式,发送到服务器的参数 //可以通过req.query对象访问到,例如: //req.query.name req.query.age console.log(req.query)&#125;) 7.获取URL中的动态参数 通过req.params对象,可以访问到URL中,通过:匹配到的动态参数: 123456// URL地址中,可以通过:参数名的形式,匹配动态参数值app.get(&#x27; /user/:id&#x27;, (req, res) =&gt; &#123; // req.params 默认是一个空对象 //里面存放着通过:动态匹配到的参数值 console.log(req.params)&#125;) 1.3托管静态资源1. express.static() express提供了一个非常好用的函数,叫做express.static0,通过它,我们可以非常方便地创建一个静态资源服务器, 例如,通过如下代码就可以将public目录下的图片、CSS文件、JavaScript文件对外开放访问了: 1app.use(express.static(&#x27;public&#x27;)) 现在,你就可以访问public目录中的所有文件了: http://localhost:3000/images/bg.jpg http://localhost:3000/css/style.css http://localhost:3000/js/login.js 注意: Express在指定的静态目录中查找文件,并对外提供资源的访问路径。因此,存放静态文件的目录名不会出现在URL中。 2.托管多个静态资源目录 如果要托管多个静态资源目录,请多次调用express.static0函数: 12app.use(express.static(&#x27;public&#x27;))app.use(express.static(&#x27;files&#x27;)) 访问静态资源文件时, express.static0函数会根据目录的添加顺序查找所需的文件。 3.挂载路径前缀 如果希望在托管的静态资源访问路径之前,挂载路径前缀,则可以使用如下的方式: 1app.use(&#x27;/public&#x27;, express.static(&#x27;public&#x27;)) 现在,你就可以通过带有&#x2F;public前缀地址来访问public目录中的文件了: **http://localhost:3000/public/images/kitten.jpg ** http://localhost:3000/public/css/style.css http://localhost:3000/public/js/app.js 1.4 nodemon 1.为什么要使用nodemon 在编写调试 Node.js项目的时候,如果修改了项目的代码,则需要频繁的手动close掉,然后再重新启动,非常繁琐。 现在,我们可以使用nodemon (https://www.npmjs.com/package/nodemon)这个工具,它能够监听项目文件的变动,当代码被修改后,nodemon会自动帮我们重启项目,极大方便了开发和调试。 2. 安装 nodemon在终端中,运行如下命令,即可将nodemon安装为全局可用的工具: 1npm install -g nodemon 管理员power开启权限set-ExecutionPolicy RemoteSigned 3. 使用nodemon 当基于Node.js编写了一个网站应用的时候,传统的方式,是运行node app.js命令,来启动项目。这样做的坏处是:代码被修改之后,需要手动重启项目。 现在,我们可以将node命令替换为nodemon命令,使用nodemon app.js来启动项目。这样做的好处是:代码被修改之后,会被nodemon监听到,从而实现自动重启项目的效果。 2. Express 路由2.1路由的概念2.现实生活中的路由 在这里,路由是按键与服务之间的映射关系 3. Express 中的路由 在Express中,路由指的是客户端的请求与服务器处理函数之间的映射关系。 Express中的路由分3部分组成,分别是请求的类型、请求的URL地址、处理函数,格式如下: 12app.METHOD(PATH, HANDLER) 123456789101112131415164. Express 中的路由的例子//匹配GET请求,且请求URL为/app.get(&#x27;/&#x27;, function (req, res) &#123; res.send( &#x27;Hello World!&#x27;)&#125;)//匹配POST请求,且请求URL为/app.post(&#x27;/&#x27;, function (req, res) &#123; res. send(&#x27;Got a POST request&#x27;)&#125;) 5.路由的匹配过程 每当一个请求到达服务器之后,需要先经过路由的匹配,只有匹配成功之后,才会调用对应的处理函数。 在匹配时,会按照路由的顺序进行匹配,如果请求类型和请求的URL同时匹配成功,则Express会将这次请求,转交给对应的function函数进行处理。 路由匹配的注意点: ①按照定义的先后顺序进行匹配 ②请求类型和请求的URL同时匹配成功,才会调用对应的处理函数 2.2路由的使用1.最简单的用法在Express中使用路由最简单的方式,就是把路由挂载到app上,示例代码如下: 12345678const express = require(&#x27;express&#x27;)//创建Web服务器,命名为appconst app=express()//挂载路由app.get(&#x27;/&#x27;,(req, res) =&gt; &#123;res,send(&#x27;Hello World. &#x27;) &#125;) app.post(&#x27;/&#x27;, (req, res) =&gt;&#123; res. send( &#x27;Post Request. &#x27;)&#125;)//启动Web服务器app.listen(80, () =&gt; &#123; console.log(&#x27;server running at http://127.0.0.1&#x27;) &#125;) 2.模块化路由 为了方便对路由进行模块化的管理, Express不建议将路由直接挂载到app上,而是推荐将路由抽离为单独的模块。将路由抽离为单独模块的步骤如下: ① 创建路由模块对应的.js文件 ②调用express.Router()函数创建路由对象 ③向路由对象上挂载具体的路由 ④使用module.exports 向外共享路由对象 ⑤使用app.use0函数注册路由模块 3.创建路由模块12345678910111213var express = require(&#x27;express&#x27;)var router = express. Router()// 1. 导入 express//2.创建路由对象router.get(&#x27;/user/list&#x27;, function (req, res) &#123; //3,挂载获取用户列表的路由 res.send(&#x27;Get user list.&#x27;)&#125;)router.post(&#x27;/user/add&#x27;, function (req, res) &#123; // 4.挂载添加用户的路由 res.send(&#x27;Add new user.&#x27;)&#125;)module.exports = router //5.向外导出路由对象 4.注册路由模块 1234//1.导入路由模块const userRouter = require(&#x27;./router/user.js&#x27;)//2.使用app.use()注册路由模块app.use(userRouter) 5.为路由模块添加前缀类似于托管静态资源时,为静态资源统一挂载访问前缀一样,路由模块添加前缀的方式也非常简单: 1234//1.导入路由模块const userRouter = require(&#x27;./router/user.js&#x27;)// 2.使用app.use()注册路由模块,并添加统一的访问前缀/apiapp.use(&#x27;/api&#x27;, userRouter) 3. Express 中间件3.1中间件的概念1.什么是中间件 中间件(Middleware),特指业务流程的中间处理环节。 2.现实生活中的例子 在处理污水的时候,一般都要经过三个处理环节,从而保证处理过后的废水,达到排放标准。 处理污水的这三个中间处理环节,就可以叫做中间件。 3. Express 中间件的调用流程当一个请求到达Express的服务器之后,可以连续调用多个中间件,从而对这次请求进行预处理。 4. Express 中间件的格式Express的中间件,本质上就是一个function处理函数, Express中间件的格式如下: 123456var express= require(&#x27;express&#x27;);var app = express();app.get(&#x27;/&#x27;, function(req, res, next)&#123; next();&#125;)app.listen(3000); 注意:中间件函数的形参列表中,必须包含next参数。而路由处理函数中只包含req和res。 5. next 函数的作用next函数是实现多个中间件连续调用的关键,它表示把流转关系转交给下一个中间件或路由。 3.2 Express 中间件的初体验1.定义中间件函数 可以通过如下的方式,定义一个最简单的中间件函数: 1234567//常量mw所指向的,就是一个中间件函数const mw= function (req, res, next)&#123; console.log(&#x27;这是一个最简单的中间件&#x27;)//注意:在当前中间件的业务处理完毕后,必须调用next()函数 //表示把流转关系转交给下一个中间件或路由 next()&#125; 2.全局生效的中间件 客户端发起的任何请求,到达服务器之后,都会触发的中间件,叫做全局生效的中间件。 通过调用app.use(中间件函数),即可定义一个全局生效的中间件,示例代码如下: 1234567//常量mw所指向的,就是一个中间件函数const mw= function (reg, res, next) &#123; console.log(&quot;这是一个最简单的中间件函数&quot;) next ()&#125;//全局生效的中间件app.use(mw) 3.定义全局中间件的简化形式 12345//全局生效的中间件app.use(furction (req, res, next)&#123; console.log(&#x27;这是一个最简单的中间件函数&#x27;)next()&#125;) 4.中间件的作用 多个中间件之间,共享同一份req和res。基于这样的特性,我们可以在上游的中间件中,统一为req 或 res对象添加自定义的属性或方法,供下游的中间件或路由进行使用。 5.定义多个全局中间件 可以使用app.use()连续定义多个全局中间件。客户端请求到达服务器之后,会按照中间件定义的先后顺序依次进行调用,示例代码如下: 12345678910111213app.use(function(req, res, next) &#123;// 第1个全局中间件 console.log(&quot;调用了第1个全局中间件&#x27;) next()&#125;)app.use(function(req, res, next) &#123; //1 第2个全局中间件 console.log(&quot;调用了第2个全局中间件&#x27;) next()&#125;)app.get(&#x27;/user&#x27;, (req, res) =&gt;&#123; //请求这个路由,会依次触发上述两个全局中间件 res.send(&#x27;Hone page.&#x27;)&#125;) 6.局部生效的中间件 不使用app.use0定义的中间件,叫做局部生效的中间件,示例代码如下: 123456789101112//定义中间件图数mwconst mw1 function(req, res, next)&#123; console.log(&quot;这是中间件函数&#x27;) next()// mw1这个中间件只在&quot;当前路由中生效”,这种用法属于&quot;局部生效的中间件&quot; app.get(&#x27;/&#x27;, mw1, function(req, res)&#123; res.send(&#x27;Home page.&#x27;) &#125;)// mw1这个中间件不会影响下面这个路由 app.get(&#x27;/user&#x27;, function(req. res) &#123; res.send( &#x27;User page. &#x27;) &#125;) 7.定义多个局部中间件 可以在路由中,通过如下两种等价的方式,使用多个局部中间件: 12345//以下两种写法是&quot;完全等价&quot;的,可根据自己的喜好,选择任意一种方式进行使用app.get(&#x27;/&#x27;, mw1, mw2(req, res) =&gt; &#123; res.send( &#x27;Home page. &#x27;) &#125;)app.get(&#x27;/&#x27;. [mw1, mw2], (req, res) =&gt; &#123; res.send(&#x27;Home page.&#x27;) &#125;) 8.了解中间件的5个使用注意事项 一定要在路由之前注册中间件 客户端发送过来的请求,可以连续调用多个中间件进行处理 执行完中间件的业务代码之后,不要忘记调用next()函数 为了防止代码逻辑混乱,调用next0函数后不要再写额外的代码 连续调用多个中间件时,多个中间件之间,共享req和res对象 3.3中间件的分类 为了方便大家理解和记忆中间件的使用,Expres把常见的中间件用法,分成了5大类,分别是: ①应用级别的中间件 2.路由级别的中间件 ③错误级别的中间件 4.Express 内置的中间件 5.第三方的中间件 3.3中间件的分类1.应用级别的中间件 通过app.use()或 app.get()或 app.post().绑定到app实例上的中间件,叫做应用级别的中间件,代码示例如下: 12345678//应用级别的中间件(全局中间件)app.use((reg, res, next) =&gt; &#123; next()&#125;)//应用级别的中间件(局部中间件)app.get(&#x27;/&#x27;, mw, (req, res) =&gt; &#123; res.send(&#x27;Home page.&#x27;)&#125;) 2.路由级别的中间件 绑定到express.Router0实例上的中间件,叫做路由级别的中间件。它的用法和应用级别中间件没有任何区别。只不过,应用级别中间件是绑定到app实例上,路由级别中间件绑定到router实例上,代码示例如下: 12345678910var app=express()var router =express.Router()//路由级别的中间件router.use(function (req, res, next)&#123; console.log(&#x27;Time:&#x27;, Date.now()) next()&#125;)app.use(&#x27;/&#x27;, router) 3.错误级别的中间件 错误级别中间件的作用:专门用来捕获整个项目中发生的异常错误,从而防止项目异常崩溃的问题。 格式:错误级别中间件的function处理函数中,必须有4个形参,形参顺序从前到后,分别是(err, req, res, next) 12345678910app.get(&#x27;/&#x27;, function (req, res) &#123; // 1. 路由 throw new Error(&#x27;服务器内部发生了错误! &#x27;) // 1.1抛出一个自定义的错误 res.send(&#x27;Home Page. &#x27;)&#125;)app.use(function (err, req, res, next) &#123; // 2.错误级别的中间件 console.log(&#x27;发生了错误:&#x27;+ err.message)// 2.1 在服务器打印错误消息 res.send(&#x27;Error! &#x27;+ err.message)//2.2 向客户端响应错误相关的内容&#125;) 注意:错误级别的中间件,必须注册在所有路由之后! 4. Express内置的中间件 自Express 4.16.0 版本开始, Express内置了3个常用的中间件,极大的提高了Express项目的开发效率和体验: express.static快速托管静态资源的内置中间件,例如: HTML文件、图片、CSS样式等(无兼容性) express.json 解析 JSON 格式的请求体数据(有兼容性,仅在4.16.0+版本中可用) express.urlencoded 解析 URL-encoded 格式的请求体数据(有兼容性,仅在4.16.0+版本中可用) 1234//配置解析 application/json格式数据的内置中间件app.use(express.json())//配置解析 application/x-www-form-urlencoded格式数据的内置中间件app.use(express.urlencoded(&#123; extended: false &#125;)) 5.第三方的中间件 非Express官方内置的,而是由第三方开发出来的中间件,叫做第三方中间件。在项目中,大家可以按需下载并配置第三方中间件,从而提高项目的开发效率。 例如:在&#101;&#x78;&#112;&#x72;&#x65;&#x73;&#x73;&#64;&#x34;&#46;&#x31;&#x36;&#x2e;&#48; 之前的版本中,经常使用body-parser这个第三方中间件,来解析请求体数据。使用步骤如下: ① 运行npm install body-parser安装中间件 ②使用require导入中间件 ③调用app.use()注册并使用中间件 注意: Express内置的express.urlencoded 中间件,就是基于body-parser这个第三方中间件进一步封装出来的。 3.4 自定义中间件1.需求描述与实现步骤 自己手动模拟一个类似于express.urlencoded这样的中间件,来解析POST提交到服务器的表单数据。 实现步骤: ①定义中间件 ②监听req 的data事件 3.监听 req的end 事件 ④使用querystring模块解析请求体数据 5. 将解析出来的数据对象挂载为req.body 6将自定义中间件封装为模块 2.定义中间件 使用app.use()来定义全局生效的中间件,代码如下: 123app.use(function(req, res, next)&#123; //中间件的业务逻辑&#125;) 3.监听req 的data 事件 在中间件中,需要监听req对象的data事件,来获取客户端发送到服务器的数据。 如果数据量比较大,无法一次性发送完毕,则客户端会把数据切割后,分批发送到服务器。所以data事件可能会触发多次,每一次触发data事件时,获取到数据只是完整数据的一部分,需要手动对接收到的数据进行拼接。 1234567//定义变量,用来存储客户端发送过来的请求体数据let str =&#x27;&#x27;//监听req对象的data事件(客户端发送过来的新的请求体数据)req.on(&#x27;data&#x27;, (chunk) =&gt;&#123; //拼接请求体数据,险式转换为字符串 str+= chunk&#125;) 4.监听 req 的end事件 当请求体数据接收完毕之后,会自动触发req的end事件。 因此,我们可以在req的end事件中,拿到并处理完整的请求体数据。示例代码如下: 123456//监听req对象的end事件(请求体发送完毕后自动触发)req.on(&#x27;end&#x27;, () =&gt;&#123; //打印完整的请求体数据 console.log(str) // TODO:把字符串格式的请求体数据,解析成对象格式&#125;) 5.使用querystring模块解析请求体数据 Node.js 内置了一个 querystring模块,专门用来处理查询字符甲。通过这个模块提供的parse()函数,可以轻松把查询字符串,解析成对象的格式。示例代码如下: 1234//导入处理 querystring的Node.js内置模块const qs = require(&#x27;querystring&#x27;)//调用qs.parse()方法,把查询字符串解析为对象const body = qs.parse(str) 6.将解析出来的数据对象挂载为req.body 上游的中间件和下游的中间件及路由之间,共享同一份req 和res。因此,我们可以将解析出来的数据,挂载为req的自定义属性,命名为req.body,供下游使用。示例代码如下: 1234567req.on(&#x27;end&#x27;, () =&gt;&#123; const body = qs.parse(str) //调用qs.parse()方法,把查询字符串解析为对象 req.body = body //将解析出来的请求体对象,挂载为req.body属性 next()&#125;) //最后,一定要调用next()函数,执行后续的业务逻辑&#125;) 7.将自定义中间件封装为模块 为了优化代码的结构,我们可以把自定义的中间件函数,封装为独立的模块,示例代码如下: 123456789// custom-body-parser.js 模块中的代const qs=require(&#x27;querystring&#x27;)function bodyParser(req, res, next) &#123;/*其它代 *&#125;module.exports= bodyParser // 向外导出解析请求体数据的中间件通数-------------------------------------------------------------//1.导入自定义的中问件模块const myBodyParser= require(&#x27;custom-body-parser&#x27;)//2.注册自定义的中间件模块app.use(myBodyParser) 4.使用Express写接口4.1创建基本的服务器123456789// 导入 express 模块const express = require(&#x27;express&#x27;)//创建 express的服务器实例const app = express()// write your code here...//调用app.listen方法,指定端口号并启动web服务器app.listen(80, function () &#123; console.log(&#x27;Express server running at http://127.0.0.1&#x27;)&#125;) 4.2 创建API 路由模块123456789// apiRouter.js 【路由模块】const express = require(&#x27;express&#x27;)const apiRouter= express.Router()// bind your router here...module.exports = apiRouter------------------------------------// app.js 【导入并注册路由模块】const apiRouter = require(&#x27;./apiRouter.js&#x27;)app.use(&#x27;/api&#x27;, apiRouter) 4.3编写GET接口12345678910apiRouter.get(&#x27;/get&#x27;, (req, res) =&gt; &#123; //1.获取到客户端通过查询字符串,发送到服务器的数据const query= req.query// 2.调用res.send()方法,把数据响应给客户端res.send(&#123; status: 0, //状态,0表示成功,1表示失败 msg: &#x27;GET请求成功! &#x27;, //状态描述 data: query //需要响应给客户端的具体数据&#125;)&#125;) 4.4编写POST接口12345678910apiRouter.post(&#x27;/post&#x27;, (req, res) =&gt;&#123; //1.获取客户端通过请求体,发送到服务器的URL-encoded数据 const body = req.body // 2.调用res.send()方法,把数据响应给客户端 res.send(&#123; status: 0, //状态,0表示成功,1表示失败 msg: &#x27;POST请求成功! &#x27;, //状态描述消息 data: body //需要响应给客户端的具体数据 &#125;)&#125;) 注意:如果要获取URL-encoded 格式的请求体数据,必须配置中间件 app.use(express.urlencoded({ extended: false })) 4.5 CORS 跨域资源共享1.接口的跨域问题 刚才编写的GET和POST接口,存在一个很严重的问题:不支持跨域请求。 解决接口跨域问题的方案主要有两种: CORS (主流的解决方案,推荐使用) JSONP (有缺陷的解决方案:只支持GET请求) 2.使用cors中间件解决跨域问题 cors是Express的一个第三方中间件。通过安装和配置cors中间件,可以很方便地解决跨域问题。 使用步骤分为如下3步: ①运行npm install cors安装中间件 ② 使用 const cors &#x3D; require(‘cors’) 导入中间件 ③在路由之前调用app.use(cors0)配置中间件 3.什么是 CORS CORS (Cross-Origin Resource Sharing,跨域资源共享)由一系列HTTP 响应头组成,这些HTTP响应头决定浏览器是否阻止前端JS代码跨域获取资源。 浏览器的同源安全策略默认会阻止网页“跨域”获取资源。但如果接口服务器配置了CORS相关的HTTP 响应头,就可以解除浏览器端的跨域访问限制。 4. CORS 的注意事项 ① CORS主要在服务器端进行配置。客户端浏览器无须做任何额外的配置,即可请求开启了CORS的接口。 2.CORS在浏览器中有兼容性。只有支持XMLHttpRequest Level2的浏览器,才能正常访问开启了CORS的服务端接口(例如: IE10+、 Chrome4+, FireFox3.5+) . 5. CORS 响应头部 - Access-Control-Allow-Origin 响应头部中可以携带一个Access-Control-Allow-Origin字段,其语法如下: 1Access-Control-Allow-Origin: &lt;origin&gt; | * 其中,origin参数的值指定了允许访问该资源的外域URL 例如,下面的字段值将只允许来自http://itcast.cn的请求: 1res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;http://itcast.cn&#x27;) 如果指定了Access-Control-Allow-Origin字段的值为通配符,表示允许来自任何域的请求,示例代码如下:* 1res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;) 6. CORS 响应头部 - Access-Control-Allow-Headers 默认情况下,CORS 仅支持客户端向服务器发送如下的9个请求头: Accept, Accept-Language, Content-Language. DPR, Downlink, Save-Data, Viewport-Width, WidthContent-Type (限 text&#x2F;plain, multipart&#x2F;form-data, application&#x2F;x-www-form-urlencoded 三者之一) 如果客户端向服务器发送了额外的请求头信息,则需要在服务器端,通过Access-Control-Allow-Headers对额外的请求头进行声明,否则这次请求会失败! 123// 允许客户端额外向服务器发送Content-Type 请求头和X-Custom-Header请求头//注意:多个请求头之问使用英文的豆号进行分割res.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;Content-Type, X-Custom-Header&#x27;) 7. CORS 响应头部 - Access-Control-Allow-Methods 默认情况下, CORS仅支持客户端发起GET, POST, HEAD请求。 如果客户端希望通过PUT、 DELETE等方式请求服务器的资源,则需要在服务器端,通过Access-Control-Alow-Methods来指明实际请求所允许使用的HTTP方法。 1234//只允许POST, GET、 DELETE, HEAD 请求方法res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;POST, GET, DELETE, HEAD&#x27;)//允许所有的HTTP 请求方法res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;*&#x27;) 8. CORS请求的分类客户端在请求 CORS接口时,根据请求方式和请求头的不同,可以将CORS的请求分为两大类,分别是: ①简单请求 ②预检请求 9.简单请求同时满足以下两大条件的请求,就属于简单请求: 1.请求方式: GET, POST, HEAD 三者之一 2.HTTP 头部信息不超过以下几种字段:无自定义头部字段、Accept. Accept-Language, Content-Language, DPR.Downlink, Save-Data, Viewport-Width, Width, Content-Type (只有三个值application&#x2F;x-www-formurlencoded, multipart&#x2F;form-data, text&#x2F;plain) 10.预检请求只要符合以下任何一个条件的请求,都需要进行预检请求: ①请求方式为GET, POST, HEAD 之外的请求Method类型 2.请求头中包含自定义头部字段 ③向服务器发送了 application&#x2F;json格式的数据 在浏览器与服务器正式通信之前,浏览器会先发送OPTION请求进行预检,以获知服务器是否允许该实际请求,所以这一次的OPHON 请求称为“预检请求”。服务器成功响应预检请求后,才会发送真正的请求,并且携带真实数据。 11.简单请求和预检请求的区别 简单请求的特点:客户端与服务器之间只会发生一次请求。 预检请求的特点:客户端与服务器之间会发生两次请求, OPTION预检请求成功之后,才会发起真正的请求。 4.6 JSONP 接口1.回顾JSONP的概念与特点 概念:浏览器端通过标签的src属性,请求服务器上的数据,同时,服务器返回一个函数的调用。这种请求数据的方式叫做JSONP。 特点: ① JSONP 不属于真正的Ajax请求,因为它没有使用XMLHttpRequest这个对象。 ② JSONP仅支持GET请求,不支持POST, PUT, DELETE等请求。 2.创建JSONP接口的注意事项 如果项目中已经配置了CORS跨域资源共享,为了防止冲突,必须在配置CORS 中间件之前声明JSONP的接口。否则USONP接口会被处理成开启了 CORS的接口。示例代码如下: 123456//优先创建JSONP接口【这个接口不会被处理成CORS接口】app.get(&#x27;/api/jsonp&#x27;, (req, res) =&gt; &#123;&#125;)//再配置CORS中间件【后续的所有接口,都会被处理成CORS接口】app.use(cors())//这是一个开启了CORS的接口app.get(&#x27;/api/get&#x27;. (req, res) =&gt; &#123;&#125;) 4.6 JSONP 接口3.实现JSONP接口的步骤 ①获取客户端发送过来的回调函数的名字 ② 得到要通过JSONP形式发送给客户端的数据 ③根据前两步得到的数据,拼接出一个函数调用的字符串 ④把上一步拼接得到的字符串,响应给客户端的标签进行解析执行 4.实现JSONP接口的具体代码 12345678910app.get(&#x27;/api/jsonp&#x27;. (req, res) =&gt;&#123; //1.获取客户端发送过来的回调通数的名字 const funcName = req.query.callback //2.得到要通过JSONP形式发送给客户端的数据 const data = &#123;name: &#x27;zs&#x27;, age: 22 &#125; //3.根据前两步得到的数据,拼接出一个函数调用的字符串 const scriptStr = &#x27;$&#123;funcName&#125;($&#123;JSON.stringify(data)&#125;)&#x27; //4.把上一步拼接得到的字符串,响应给客户端的&lt;script&gt;标签进行解析执行 res.send(scriptStr)&#125;) 5.在网页中使用jQuery发起JSONP 请求 调用$.ajax()函数,提供JSONP的配置选项,从而发起JSONP请求,示例代码如下: 12345678910$(&#x27;#btnJSONP&#x27;).on(&#x27;click&#x27;, function () &#123; $.ajax(&#123; method: &#x27;GET&#x27;, url: &#x27;http://127.0.0.1/api/jsonp&#x27;, dataType: &#x27;jsonp&#x27;, //表示要发起JSONP的请求 success: function (res)&#123; console.log(res) &#125; &#125;)&#125;) 4.在项目中操作MySQL 4.1在项目中操作数据库的步骤 ① 安装操作MySQL数据库的第三方模块(mysql) ②通过mysql 模块连接到MySQL数据库 ③通过mysql 模块执行SQL语句 1. 安装mysql 模块 mysql 模块是托管于npm上的第三方模块。它提供了在Node.js项目中连接和操作MySQL数据库的能力。 1npm install mysql 2.配置mysql 模块在使用mysql 模块操作MySQL数据库之前,必须先对mysql 模块进行必要的配置,主要的配置步骤如下: 123456789//1.导入mysql模块const mysql = require(&#x27;mysql&#x27;)// 2.建立与MySQL数据库的连接const db = mysql.createPool(&#123; host: &#x27;127.0.0.1&#x27;, //数据库的IP地址 user: &#x27;root&#x27;,//登录数据库的账号 password: &#x27;admin123&#x27;, // 登录数据库的密码 database: &#x27;my_db_01&#x27; //指定要操作哪个数据库&#125;) 3.测试mysql 模块能否正常工作调用db.query0函数,指定要执行的SQL语句,通过回调函数拿到执行的结果: 123456//检测mysq1模块能否正常工作db.query(&#x27;SELECT 1&#x27;, (err, results) =&gt;&#123; if (err) return console.log(err.message) //只要能打印出[ RowDataPacket &#123;&#x27;1&#x27;: 1&#125; ]的结果,就证明数据库连接正常 console.log(results)&#125;) 4.在项目中操作MySQL4.3 使用mysql 模块操作MySQL数据库1.查询数据 查询users表中所有的数据: 1234567//查询users表中所有的用户数据db.query(&#x27;SELECT * FROM users&#x27;, (err, results) =&gt; &#123; //查询失败 if (err) return console.log(err.message) //查询成功 console.log(results)&#125;) 2.插入数据 向users表中新增数据,其中username 为Spider-Man, ,password 为 pcc321,示例代码如下: 1234567891011//1.要插入到users表中的数据对象const user = &#123;username: &#x27;Spider-Man&#x27;, password: &#x27;pcc321&#x27; )//2.待执行的SQL语句,其中英文的?表示占位符const sqlStr = &#x27;INSERT INTO users (username, password) VALUES (?, ?)&#x27;//3.使用数组的形式,依次为?占位符指定具体的值db.query(sqlStr, [user.username, user.password], (err, results) =&gt; &#123; if (err) return console.log(err.message)//1 失败 if(results.affectedRows === 1) &#123; console.log(&#x27;插入数据成功&#x27;)&#125; // 成功&#125;) 3.插入数据的便捷方式向表中新增数据时,如果数据对象的每个属性和数据表的字段一-对应,则可以通过如下方式快速插入数据: 123456789//1.要插入到users 表中的数据对象const user = &#123; username: &#x27;Spider-Man2&#x27;, password: &#x27;pcc4321&#x27;&#125;//2.待执行的SQL 语句,其中英文的?表示占位符const sqlStr = &#x27;INSERT INTO users SET ?&#x27;// 3.直接将数据对象当作占位符的值db.query(sqlStr, user, (err, results) =&gt;&#123; if (err) return console.log(err.message) // 失败 if(results.affectedRows===1)&#123;console.log(&#x27;插入数据成功&quot;)&#125;//成功 &#125;) 4.更新数据可以通过如下方式,更新表中的数据: 12345678//1.要更新的数据对象const user = &#123;id: 7, username: &#x27;aaa&#x27;, password: &#x27;000&#x27; &#125;//2.要执行的SQL 语句const sqlStr = &#x27;UPDATE users SET username=?, password=? WHERE id=?&quot;// 3.调用db.query()执行SQL语句的同时,使用数组依次为占位符指定具体的值db.query(sqlStr, [user.username, user.password, user.id], (err, results) =&gt; &#123; if (err) return console.log(err.message) // 失败 if (results.affectedRows === 1) &#123;console.log(&#x27;更新数据成功! &#x27;)&#125; //成功 5.更新数据的便捷方式 更新表数据时,如果数据对象的每个属性和数据表的字段--对应,则可以通过如下方式快速更新表数据: 12345678//1.要更新的数据对象const user = &#123;id: 7, username: &#x27;aaa&#x27;, password: &#x27;000&#x27; &#125;//2.要执行的SQL 语句const sqlStr = &#x27;UPDATE users SET ? WHERE id=?&quot;// 3.调用db.query()执行SQL语句的同时,使用数组依次为占位符指定具体的值db.query(sqlStr, [user, user.id], (err, results) =&gt; &#123; if (err) return console.log(err.message) // 失败 if (results.affectedRows === 1) &#123;console.log(&#x27;更新数据成功! &#x27;)&#125; //成功 6.删除数据 在删除数据时,推荐根据id这样的唯一标识,来删除对应的数据。示例如下: 12345678910//1.要执行的SQL语句const sqlStr = &#x27;DELETE FROM users WHERE id=?&#x27;//2.调用db.query()执行SQL语句的同时,为占位符指定具体的值//注意:如果SQL语句中有多个占位符,则必须使用数组为每个占位符指定具体的值//如果SQL语句中只有一个占位符,则可以省略数组db.query(sqlStr, 7, (err, results) =&gt; &#123; if (err) return console.log(err.message) // 失败 if (results.affectedRows=== 1) console.1og(&#x27;删除数据成功!&#x27;)&#125; //成功 &#125;) 7.标记删除 使用DELETE 语句,会把真正的把数据从表中删除掉。为了保险起见,推荐使用标记删除的形式,来模拟删除的动作。 所谓的标记删除,就是在表中设置类似于status这样的状态字段,来标记当前这条数据是否被删除。 当用户执行了删除的动作时,我们并没有执行DELETE 语句把数据删除掉,而是执行了UPDATE语句,将这条数据对应的status字段标记为删除即可。 12345//标记删除:使用UPDATE 语句替代 DELETE 语句;只更新数据的状态,并没有真正删除db.query(&#x27;UPDATE USERS SET status=1 WHERE id=?&#x27;, 6, (err, results) =&gt;&#123; if (err) return console.log(err.message) // 失败 if (results.affectedRows === 1) &#123;console.1og(&#x27;删除数据成功!)&#125; &#125;) 5.前后端的身份认证5.1 Web 开发模式目前主流的Web开发模式有两种,分别是: ① 基于服务端演染的传统Web开发模式 ②基于前后端分离的新型Web开发模式 5.1 Web 开发模式1.服务端宣染的Web开发模式 服务端演染的概念:服务器发送给客户端的HTML页面,是在服务器通过字符串的拼接,动态生成的。因此,客户端不需要使用Ajax这样的技术额外请求页面的数据。代码票例如下: 12345678app.get(&#x27;/index.html&#x27;, (req, res) =&gt;&#123; //1.要演染的数据 const user=&#123;name: &#x27;zs&#x27;, age: 20 ) // 2.服务器端通过字符申的拼接,动态生成HTML内容 const html = &#x27;&lt;h1&gt;姓名: $&#123;user.name&#125;, 年龄:$&#123;user.age&#125;&lt;/h1&gt;` //3.把生成好的页面内容响应给客户端。因此,客户端拿到的是带有真实数据的HTML页面 res.send(html)&#125;) 2.服务端宣染的优缺点 优点: 前端耗时少。因为服务器端负责动态生成HTML内容,浏览器只需要直接渲染页面即可。尤其是移动端,更省电。 有利于SEO。因为服务器端响应的是完整的HTML页面内容,所以爬虫更容易爬取获得信息,更有利于SEO。 缺点: ①占用服务器端资源。即服务器端完成HTML页面内容的拼接,如果请求较多,会对服务器造成一定的访问压力。 ②不利于前后端分离,开发效率低。使用服务器端演染,则无法进行分工合作,尤其对于前端复杂度高的项目,不利于项目高效开发。 3.前后端分离的Web开发模式 前后端分离的概念:前后端分离的开发模式,依赖于Ajax技术的广泛应用。简而言之,前后端分离的Web开发模式.就是后端只负责提供API接口,前端使用Ajax调用接口的开发模式。 4.前后端分离的优缺点优点: ①开发体验好。前端专注于UI页面的开发,后端专注于api的开发,且前端有更多的选择性。 用户体验好。Ajax技术的广泛应用,极大的提高了用户的体验,可以轻松实现页面的局部刷新。 减轻了服务器端的渲染压力。因为页面最终是在每个用户的浏览器中生成的。 缺点: 不利于SEO。因为完整的HTML页面需要在客户端动态拼接完成,所以爬虫对无法爬取页面的有效信息。(解决方案:利用Vue, React等前端框架的SSR (server side render)技术能够很好的解决SEO问题!) 5.如何选择Web开发模式 不谈业务场景而盲目选择使用何种开发模式都是耍流氓。 比如企业级网站,主要功能是展示而没有复杂的交互,并且需要良好的SEO,则这时我们就需要使用服务器端渲染: 而类似后台管理项目,交互性比较强,不需要考虑SEO,那么就可以使用前后端分离的开发模式。 另外,具体使用何种开发模式并不是绝对的,为了同时兼顾了首页的渲染速度和前后端分离的开发效率,一些网站采用了首屏服务器端谊染+其他页面前后端分离的开发模式。 5.2身份认证1.什么是身份认证 身份认证(Authentication)又称“身份验证”、“鉴权”,是指通过一定的手段,完成对用户身份的确认。 日常生活中的身份认证随处可见,例如:高铁的验票乘车,手机的密码或指纹解锁,支付宝或微信的支付密码等。 在Web开发中,也涉及到用户身份的认证,例如:各大网站的手机验证码登录、邮箱密码登录、二维码登录等。 2.为什么需要身份认证 身份认证的目的,是为了确认当前所声称为某种身份的用户,确实是所声称的用户。例如,你去找快递员取快递,你要怎么证明这份快递是你的。 在互联网项目开发中,如何对用户的身份进行认证,是一个值得深入探讨的问题。例如,如何才能保证网站不会错误的将“马云的存款数额”显示到“马化腾的账户”上。 3.不同开发模式下的身份认证 对于服务端渲染和前后端分离这两种开发模式来说,分别有着不同的身份认证方案: ①服务端演染推荐使用Session认证机制 2.前后端分离推荐使用JWT认证机制 5.3 Session 认证机制1. HTTP 协议的无状态性了解HTTP 协议的无状态性是进一步学习Session认证机制的必要前提。 HTTP 协议的无状态性,指的是客户端的每次HTTP 请求都是独立的,连续多个请求之间没有直接的关系,服务器不会主动保留每次HTTP 请求的状态。 2.如何突破HTTP无状态的限制 对于超市来说,为了方便收银员在进行结算时给VIP用户打折,超市可以为每个VIP用户发放会员卡。 注意:现实生活中的会员卡身份认证方式,在Web开发中的专业术语叫做Cookie. 3. 什么是CookieCookie 是存储在用户浏览器中的一段不超过4 KB 的字符串。它由一个名称(Name)、一个值(Value)和其它几个用于控制Cookie有效期、安全性、使用范围的可选属性组成。 不同域名下的Cookie各自独立,每当客户端发起请求时,会自动把当前域名下所有未过期的Cookie一同发送到服务器。 Cookie的几大特性: ① 自动发送 ②域名独立 ③过期时限 ④ 4KB 限制 4. Cookie 在身份认证中的作用 客户端第一次请求服务器的时候,服务器通过响应头的形式,向客户端发送一个身份认证的Cookie,客户端会自动将Cookie保存在浏览器中。 随后,当客户端浏览器每次请求服务器的时候,浏览器会自动将身份认证相关的Cookie,通过请求头的形式发送给服务器,服务器即可验明客户端的身份。 5. Cookie 不具有安全性 由于Cookie是存储在浏览器中的,而且浏览器也提供了读写Cookie的API,因此Cookie很容易被伪造,不具有安全性。因此不建议服务器将重要的隐私数据,通过Cookie的形式发送给浏览器。 注意:干万不要使用Cookie存储重要且隐私的数据!比如用户的身份信息、密码等。 6.提高身份认证的安全性 为了防止客户伪造会员卡,收银员在拿到客户出示的会员卡之后,可以在收银机上进行刷卡认证。只有收银机确认存在的会员卡,才能被正常使用。 这种“会员卡+刷卡认证”的设计理念,就是Session认证机制的精髓。 5.4 在Express中使用Session认证1. 安装 express-session 中间件 在Express 项目中,只需要安装 express-session中间件,即可在项目中使用Session认证: 1npm install express-session 2.配置 express-session 中间件express-session 中间件安装成功后,需要通过app.use()来注册 session中间件,示例代码如下: 12345678//1. 导入 session 中间件var session = require(&#x27;express-session&#x27;)// 2.配置Session中问件app.use(session(&#123; secret: &#x27;keyboard cat&#x27;, // secret 属性的值可以为任意字符串 resave: false, //固定写法 saveUninitialized: true // 固定写法&#125;)) 3.向session中存数据 当express-session中间件配置成功后,即可通过req.session来访问和使用session对象,从而存储用户的关健信息: 12345678app.post(&#x27;/api/login&#x27;, (req, res)=&gt;&#123; //判断用户提交的登录信息是否正确 if (req.body.username !==&#x27;admin&#x27; || req.body.password !== &#x27;000000&#x27;)&#123; return res.send(&#123; status:1 msg: &#x27;登录失败&#x27;&#125; )&#125; req.session.user=req.body //将用户的信息,存储到 Session中 req.session.islogin=true //将用户的登录状志,存储到Session中 res.send(&#123; status: 0, msg: &#x27;登录成功&#x27; &#125;)&#125;) 4. 从 session中取数据 可以直接从req.session对象上获取之前存储的数据,示例代码如下: 12345678//获取用户姓名的接口app.get(&#x27;/api/username&#x27;, (req, res) =&gt; &#123; //判断用户是否登录 if (!req.session.islogin) &#123; return res.send(&#123;status: 1, msg: &#x27;fail&#x27; &#125;) &#125; res.send(&#123; status: 0, msg: &#x27;success&#x27;, username: req.session.user.username &#125;)&#125;) 5. 清空session 调用req.session.destroy()函数,即可清空服务器保存的session信息。 123456//退出登录的接口app.post(&#x27;/api/logout&#x27;, (req, res) =&gt;&#123; //清空当前客户端对应的session信息 req.session.destroy() res.send(&#123;status: 0,msg: &#x27;退出登录成功&#x27;&#125;)&#125;) 5.5 JWT 认证机制1.了解Session认证的局限性 Session认证机制需要配合 Cookie才能实现。由于Cookie默认不支持跨域访问,所以,当涉及到前端跨域请求后端接口的时候,需要做很多额外的配置,才能实现跨域Session认证。 注意: 当前端请求后端接口不存在跨域问题的时候,推荐使用Session身份认证机制。 当前端需要跨域请求后端接口的时候,不推荐使用Session身份认证机制,推荐使用JWT认证机制。 2. 什么是JWTJWT(英文全称: JSON Web Token)是目前最流行的跨域认证解决方案。 3. JWT 的工作原理 总结:用户的信息通过Token字符串的形式,保存在客户端浏览器中。服务器通过还原Token字符串的形式来认证用户的身份。 4. JWT 的组成部分 JWT通常由三部分组成,分别是Header (头部)、Payload (有效荷载)、Signature (签名)。 三者之间使用英文的“.\"分隔,格式如下: 1Header.Payload.Signature 下面是JWT字符串的示例: 1eyJhbGcioiJIUZI1NiIsInR5cCI6IkpxVCJ9.yJpZCI6MSwidXN1cmShbwuioiJhzG1pbiIsInBhc3N3b3JkIjoiliwibmlja25hbWUi0iLms6X1t7T1t7QiLCJlbWFpbCI6Im5pYmFiYUBpdGNhc3QuY24iLCJ1c2VyX3BpYyI61iIsImlhdCI6MTU30DAZNJY4Miw1ZXhwIjoxNTC4MDcyNjgyfwq7GqCXJPK-EA8LNrtMG0411Kdz3359KBL3XeuBxuI 6. JWT 的三个部分各自代表的含义 JWT 的三个组成部分,从前到后分别是 Header, Payload, Signature. 其中: Payload 部分才是真正的用户信息,它是用户信息经过加密之后生成的字符串。 Header 和Signature 是安全性相关的部分,只是为了保证Token的安全性。 7. JWT 的使用方式 客户端收到服务器返回的JWT 之后,通常会将它储存在localStorage 或 sessionStorage中。 此后,客户端每次与服务器通信,都要带上这个JWT的字符串,从而进行身份认证。推荐的做法是把JWT放在HTTP请求头的Authorization字段中,格式如下: 1Authorization: Bearer &lt;token&gt; 5.6 在Express 中使用JWT 1.安装JWT相关的包运行如下命令,安装如下两个JWT相关的包: 1npm install jsonwebtoken express-jwt jsonwebtoken 用于生成 JWT 字符串 express-jwt 用于将 JWT 字符串解析还原成 JSON对象 2.导入JWT 相关的包 使用require()函数,分别导入JWT相关的两个包: 1234//1.导入用于生成JWT 字符串的包const jwt = require(&#x27;jsonwebtoken&#x27;)//2.导入用于将客户端发送过来的JWT字符串,解析还原成 JSON对象的包const express_jwT = require(&#x27;express-jwt&#x27;) 3.定义secret密钥 为了保证JWT字符串的安全性,防止JWT字符串在网络传输过程中被别人破解,我们需要专门定义一个用于加密和解密的secret密钥: ①当生成JWT字符串的时候,需要使用secret密钥对用户的信息进行加密,最终得到加密好的JWT字符串 ②当把JWT字符串解析还原成JSON对象的时候,需要使用secret密钥进行解密 12// 3. secret 密的本质:就是一个字符串const secretKey = &#x27;itheima No1&#x27; 4.在登录成功后生成 JWT字符串 调用jsonwebtoken包提供的sign()方法,将用户的信息加密成JWT字符串,响应给客户端: 123456789//登录接口app.post(&#x27;/api/login&#x27;, function(req, res)&#123; //...省略登录失败情况下的代码 //用户登录成功之后,生成 JWT字符申,通过token属性响应给客户 res.send(&#123;status: 200,message: &#x27;登录成功!&#x27;, //调用jwt,sign()生成JwT字符串,三个参数分别是:用户信息对象、加密密销、配置对象 token: jwt.sign(&#123;username:userinfo.username&#125;, secretKey, &#123; expiresIn: &#x27;30s&#x27; &#125;) &#125;)&#125;) 5.将JWT 字符串还原为JSON对象 客户端每次在访问那些有权限接口的时候,都需要主动通过请求头中的Authorization字段,将Token字符串发送到服务器进行身份认证。 此时,服务器可以通过express-jwt这个中间件,自动将客户端发送过来的Token解析还原成JSON对象: 1234//使用app.use()来注册中间件// expressJWT(&#123;secret: secretKey &#125;)就是用来解析 Token 中件// .unless(&#123;path: [/^\\/api\\//] &#125;)用来指定哪些接口不需要访问权限app.use(expressJWT(&#123; secret: secretKey,algorithms: [&#x27;HS256&#x27;] &#125;).unless(&#123; path: [/^\\/api\\//]&#125;)) 6.使用req.user获取用户信息 当express-jwt这个中间件配置成功之后,即可在那些有权限的接口中,使用req.user对象,来访问从JWT字符串中解析出来的用户信息了,示例代码如下: 123456789//这是一个有权限的API接口app.get(&#x27;/admin/getinfo&#x27;, function(req, res)&#123; console.log(req.user) res.send (&#123; status: 200, message: &#x27;获取用户信息成功!&#x27;, data: req.user &#125;)&#125;) 7.捕获解析JWT失败后产生的错误 当使用express-jwt 解析Token字符串时,如果客户端发送过来的Token字符串过期或不合法,会产生一个解析失败的错误,影响项目的正常运行。我们可以通过Express的错误中间件,捕获这个错误并进行相关的处理,示例代码如下: 1234567app.use((err, req, res, next) =&gt;&#123; // token 解析失败导致的错误 if(err.name=== &#x27;UnauthorizedError&#x27;)&#123; return res.send(&#123; status: 401, message: &#x27;无效的token&#x27; &#125;)&#125; //其它原因导致的错误 res.send(&#123; status: 500, message: &#x27;未知错误&#x27; &#125;)&#125;)","categories":[{"name":"前端","slug":"前端","permalink":"https://2486125878.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"nodeJs","slug":"nodeJs","permalink":"https://2486125878.github.io/tags/nodeJs/"}]},{"title":"jQuery","slug":"jquery","date":"2024-03-13T07:16:31.000Z","updated":"2024-03-13T08:21:22.000Z","comments":true,"path":"2024/03/13/jquery/","permalink":"https://2486125878.github.io/2024/03/13/jquery/","excerpt":"","text":"1.jQuery概述1.1 JavaScript库仓库:可以把很多东西放到这个仓库里面。找东西只需要到仓库里面查找到就可以了。 JavaScript库: 即library ,是一个封装好的特定的集合(方法和函数)。从封装一大堆函数的角度理解库,就是在这个库中,封装了很多预先定义好的函数在里面,比如动画animate, hide, show ,比如获取元素等。 简单理解:就是一个JS文件,里面对我们原生j代码进行了封装,存放到里面。这样我们可以快速高效的使用这些封装好的功能了。 比如jQuery,就是为了快速方便的操作DOM,里面基本都是函数(方法)。 常见的Javascript库 jQuery Prototype YUI Dojo Ext JS 移动端的zepto 这些库都是对原生JavaScript的封装,内部都是用JavaScript实现的,我们主要学习的是jQuery. 1.2 jQuery的概念jQuery是一个快速、简洁的JavaScript库,其设计的宗旨是”write Less , Do More” ,即倡导写更少的代码,做更多的事情。 j就是JavaScript; Query查询;意思就是查询js ,把js中的DOM操作做了封装,我们可以快速的查询使用里面的功能。 jQuery封装了JavaScript常用的功能代码,优化了DOM操作、事件处理、动画设计和Ajax交互。 jQuery出现的目的是加快前端人员的开发速度,我们可以非常方便的调用和使用它,从而提高开发效率。 1.2 jQuery的优点优点轻量级。核心文件才几+kb,不会影响页面加载速度 跨浏览器兼容。基本兼容了现在主流的浏览器 链式编程、隐式迭代 对事件、样式、动画支持,大大简化了DOM操作 支持插件扩展开发。有着丰富的第三方的插件,例如:树形菜单、日期控件、轮播图等 免费、开源 2.1 jQuery的下载官网地址: https://jquery.com/ 版本： 1x :兼容IE 678等低版本浏览器,官网不再更新 2x:不兼容1E678等低版本浏览器,官网不再更新 3x :不兼容IE 678等低版本浏览器,是官方主要更新维护的版本 各个版本的下载: https://code.jquery.com/ 2.jQuery的基本使用2.3 jQuery的入口函数$ (function () { ………&#x2F;&#x2F;此处是页面DOM加载完成的入口 }); $ (document) .ready (function () { ..&#x2F;&#x2F;此处是页面DOM載完成的入口 }); 1,等着DOM结构渲染完毕即可执行内部代码,不必等到所有外部资源加载完成, jQuery帮我们完成了封装。 2,相当于原生js中的DOMContentloaded, 3,不同于原生js中的load事件是等页面文档、外部的js文件、css文件、图片加载完毕才执行内部代码。 4,更推荐使用第一种方式 2.4 jQuery的顶级对象$1.$是jQuery的别称,在代码中可以使用jQuery代替$,但一般为了方便,通常都直接使用$。 2.$是jQuery的顶级对象,相当于原生JavaScript中的window,把元素利用包装成Query对象,就可以调用jQuery的方法。 2.5 jQuery对象和DOM对象DOM对象: 用原生js获取过来的对象就是DOM对象 jQuery对象: 用jquery方式获取过来的对象是iQuery对象。 本质:通过$把DOM元素进行了包装（伪数组形式存储)。 jquery对象只能使用jQuery方法, DOM对象则使用原生的Javascirpt属性和方法 DOM对象与jQuery对象之间是可以相互转换的。 因为原生js比jQuery更大,原生的一些属性和方法jQuery没有给我们封装.要想使用这些属性和方法需要把. jQuery对象转换为DOM对象才能使用。 1.DOM对象转换为jQuery对象: $(DOM对象) $(‘div’) 2.jQuery对象转换为DOM对象(两种方式) $(‘div’) [index] index是索引号 $(‘div’).get(index) index是索引号 jQuery常用API1.jQuery选择器1.1 jQuery基础选择器原生j S获取元素方式很多,很杂,而且兼容性情况不一致,因此jQuery给我们做了封装,使获取元素统一标准。 $( “选择器” ) &#x2F;&#x2F;里面选择器直接写CSS选择器即可,但是要加引号 名称 用法 描述 ID选择器 $(“#id”) 获取指定ID的元素 全选选择器 $(*) 匹配所有元素 类选择器 $(“.class”) 获取同一类class的元素 标签选择器 $(“div”) 获取同一类标签的所有元素 并集选择器 $(“div,p,li”) 选取多个元素 交集选择器 $(“li.current”) 交集元素 1.2 jQuery层级选择器名称 用法 描述 子代选择器 $(“ul&gt;li”); 使用&gt;号,获取亲儿子层级的元素;注意,并不会获取孙子层级的元素 后代选择器 $(“ul li”); 使用空格,代表后代选择器,获取ul下的所有元素,包括孙子等 知识铺垫jQuery设置样式 $(‘div’).css(‘属性’,’值’) 1.3隐式迭代(重要)遍历内部DOM元素(伪数组形式存储)的过程就叫做隐式迭代。 简单理解:给匹配到的所有元素进行循环遍历,执行相应的方法,而不用我们再进行循环,简化我们的操作,方便我们调用。 1.4 jQuery筛选选择器语法 用法 描述 :first $(‘li:first’) 获取第一个li元素 :last $(‘li:last’) 获取最后一个元素 :eq(index) $(“li:eq(2)”) 获取到的li元素中,选择索引号为2的元素,索引号index从0开始。 :odd $(“li:odd”) 获取到的li元素中,选择索引号为奇数的元素 :even $(“li:even”) 获取到的li元素中,选择索引号为偶数的元素 1.5 jQuery 筛选方法( 重点)语法 用法 说明 parent() $(“li”).parent(); 查找父级 children(selector) $(“ul”).children(“li”) 相当于$(“ul&gt;li”),最近一级(亲儿子) find(selector) $(“ul”).find(“li”); 相当于$(“ul li”),后代选择器 siblings(selector) $(“.first”).siblings(“li”); 查找兄弟节点,不包括自己本身 nextAll ([expr]) $(“.first”).nextAll() 查找当前元素之后所有的同辈元素 prevAll ([expr]) $(“.last”).prevAll() 查找当前元素之前所有的同辈元素 hasClass(class) $(‘div’).hasClass (“protected”) 检查当前的元素是否含有某个特定的类,如果有,则返回true eq(index) $(“li”).eq(2); 相当于s(“li :eq (2)”), index从0开始 重点记住: parent() children() find() siblings() eq() 1.6 jQuery里面的排他思想想要多选一的效果,排他思想:当前元素设置样式,其余的兄弟元素清除样式。 1.5链式编程链式编程是为了节省代码量,看起来更优雅。 $(this).css(&#96;color’, ‘red’).sibling().css(‘color’, ‘ ‘); 使用链式编程一定注意是哪个对象执行样式 2.1操作css方法jQuery可以使用css方法来修改简单元素样式;也可以操作类,修改多个样式。 1·参数只写属性名,则是返回属性值 $(this). css(“color”); 2,参数是属性名,属性值,逗号分隔,是设置一组样式,属性必须加引号,值如果是数字可以不用跟单位和引号 $(this).css(color”, “red”); 3,参数可以是对象形式,方便设置多组样式。属性名和属性值用冒号隔开,属性可以不用加引号, $(this).css({color:”white”, “font-size”:”20px”}); 2.2设置类样式方法作用等同于以前的classlist, 可以操作类样式,注意操作类里面的参数不要加点。 1.添加类 $( “div” ).addClass(“current”); 2．移除类 $( “div” ).removeClass(“current”); 3.切换类 $( “div” ).toggleClass(“current”); 2.3类操作与className区别原生IS 中className会覆盖元素原先里面的类名。 jQuery里面类操作只是对指定类进行操作,不影响原先的类名。 3.jQuery效果 jQuery给我们封装了很多动画效果,最为常见的如下: 显示隐藏 show() hide() toggle() 滑动 slideDown() slideUpl() slideToggle() 淡入淡出 fadeln() fadeOut() fadeToggle() fadeTo() 自定义动画 animate() 3.1显示隐藏效果1,显示语法规范 show ([speed, [easing] , [fn]] hide ( [speed, [easing] , [fn]]) 2.显示参数 (1)参数都可以省略,无动画直接显示。 (2) speed:三种预定速度之一的字符串( “slow”, “normal” ,or “fast” )或表示动画时长的毫秒数值(如: 1000) (3) easing : (Optional)用来指定切换效果,默认是”swing” ,可用参数”inear” (4) fn:回调函数,在动画完成时执行的函数,每个元素执行一次。 3.2滑动效果1,下滑效果语法规范 slidepown ( [speed, [easing], [fn]]) 2.上滑效果语法规范 slideup ( [speed, [easing], [fn]]) 3滑动切换效果语法规范 slideToggle ( [speed, [easing), [fn]]) 4,下滑上滑切换效果参数 (1)参数都可以省略。 (2) speed:三种预定速度之一的字符串(“slow”, “normal”,or “fast” )或表示动画时长的毫秒数值(如: 1000) (3) easing:Optional)用来指定切换效果,默认是”swing” ,可用参数”linear (4) fn:回调函数,在动画完成时执行的函数,每个元素执行一次。 3.3事件切换hoverl([over,]out) (1) over:标移到元素上要触发的函数(相当mouseenter ) (2) out:鼠标移出元素要触发的函数(相当于mouseleave) 3.4动画队列及其停止排队方法1·动画或效果队列· 动画或者效果一旦触发就会执行,如果多次触发,就造成多个动画或者效果排队执行。 2·停止排队stop() (1) stop()方法用于停止动画或效果。 (2)注意: stop()写到动画或者效果的前面,相当于停止结束上一次的动画。 3.5淡入淡出效果1,淡入效果语法规范 fadeIn ([speed, [easing), [fn]]) 1,淡出效果语法规范 fadeout ( [speed, [easing], [fn]) 1,淡入淡出切换效果语法规范 fadeToggle ( Ispeed, [easing), (fn]) 2·淡入效果参数 (1)参数都可以省略。 (2) speed:三种预定速度之一的字符串( “slow” , “normal” ,or “fast” )或表示动画时长的毫秒数值(如: 1000), (3) easing : (Optional)用来指定切换效果,默认是”swing” ,可用参数”linear” (4) fn:回调函数,在动画完成时执行的函数,每个元素执行一次。 1·渐进方式调整到指定的不透明度 fadeTo ( [ [speed], opacity, [easing] , [fn]]) 2·效果参数 (1) opacity透明度必须写,取值0-1之间。 (2) speed :三种预定速度之一的字符串( “slow” , “normal” ,or “fast” )或表示动画时长的毫秒数值(如: 1000)。必须写 (3) easing : (Optional)用来指定切换效果,默认是”swing” ,可用参数”linear” (4) fn:回调函数,在动画完成时执行的函数,每个元素执行一次。 3.6自定义动画animate1.语法 animate (params, [speed] , [easing], [fn]) 2.参数 (1) params:想要更改的样式属性,以对象形式传递,必须写。属性名可以不用带引号,如果是复合属性则需要采取驼峰命名法borderleft,其余参数都可以省略。 (2) speed:三种预定速度之一的字符串( “slow” , “normal” , or “fast”)或表示动画时长的毫秒数值(如:1000), (3) easing : (Optional)用来指定切换效果,默认是”swing” ,可用参数”inear” (4) fn:回调函数,在动画完成时执行的函数,每个元素执行一次。 5.jQuery属性操作5.1设置或获取元素固有属性值prop()所谓元素固有属性就是元素本身自带的属性,比如元素里面的href ,比如元素里面的type. 1,获取属性语法 prop(“属性”) 2、设置属性语法 prop(“属性”,”属性值”) 5.2设置或获取元素自定义属性值attr()用户自己给元素添加的属性,我们称为自定义属性。比如给div添加index &#x3D;”1” 1,获取属性语法 attr(“属性”) &#x2F;&#x2F;类似原生getAttribute() 2.设置属性语法 attr(“属性,”属性值”) &#x2F;&#x2F;类似原生setAttribute() 改方法也可以获取H5自定义属性 5.3数据缓存data()data()方法可以在指定的元素上存取数据,并不会修改DOM元素结构。一旦页面刷新,之前存放的数据都将被移除 6.jQuery内容文本值主要针对元素的内容还有表单的值操作。 1.普通元素内容html() (相当原生inner HTML) html()&#x2F;&#x2F;获取元素的内容 html(“内容”) &#x2F;&#x2F;获取设置元素文本内容 2,普通元素文本内容text() (相当与原生innerText) text()&#x2F;&#x2F;获取元素的文本内容 text(“文本内容”) &#x2F;&#x2F;设置元素的文本内容 3,表单的值val() (相当于原生value) val(“赋值”) &#x2F;&#x2F;设置表单的值 parents(“.p-num”) 返回指定的祖先元素 toFixed(2) 可以让我们保留2位小数 6.jQuery元素操作主要是遍历、创建、添加、删除元素操作。 6.1遍历元素jQuery隐式迭代是对同一类元素做了同样的操作。如果想要给同一类元素做不同操作,就需要用到遍历. 语法1： $(“div”).each (function (index, domEle) (xxx; }) 1, each0方法遍历匹配的每一个元素,主要用DOM处理, each每一个 2,里面的回调函数有2个参数: index是每个元素的索引号; demEle是每个DOM元素对象,不是jquery对象 语法2: $.each (object, function (inde, element) { xxx; )) 1.$.each()方法可用于遍历任何对象。主要用于数据处理,比如数组,对象 2.里面的函数有2个参数: index是每个元素的索引号; element遍历内容 6.2创建元素语法 $(“( “); 动态的创建了一个 6.3添加元素1.内部添加 element.append(“内容”) 把内容放入匹配元素内部最后面,类似原生appendChild. 2.外部添加 element.after(内容”) &#x2F;&#x2F;把内容放入目标元素后面 element.before(“内容) &#x2F;&#x2F;把内容放入目标元素前面 内部添加元素，生成之后，它们是父子关系。 外部添加元素,生成之后,他们是兄弟关系。 6.4删除元素element.remove() &#x2F;&#x2F;删除匹配的元素(本身) element.empty() &#x2F;&#x2F;删除匹配的元素集合中所有的子节点 element.html(“”) &#x2F;&#x2F;清空匹配的元素内容 7.jQuery尺寸、位置操作7.1 jQuery尺寸语法 用法 width() &#x2F; height() 取得匹配元素宽度和高度值只算width &#x2F; height innerWidth()&#x2F; innerHieght() 取得匹配元素宽度和高度值包含padding outerWidth() &#x2F; outerHeight() 取得匹配元素宽度和高度值包含padding, border outerWidth(true) &#x2F; outerHeight(true). 取得匹配元素宽度和高度值包含padding、 borde, margin 以上参数为空,则是获取相应值,返回的是数字型 如果参数为数字,则是修改相应值。 参数可以不必写单位。 7.2 jQuery位置位置主要有三个: offset(), position(). scrollTop()&#x2F;scrollLeft() 1.offset()设置或获取元素偏移 1.offset()方法设置或返回被选元素相对于文档的偏移坐标,跟父级没有关系。 2.该方法有2个属性left, top. offset().top用于获取距离文档顶部的距离, offset().left用于获取距离文档左侧的距离。 3.可以设置元素的偏移: offset(top: 10, left: 30)); 2.position()获取元素偏移 1.position()方法用于返回被选元素相对于带有定位的父级偏移坐标,如果父级都没有定位,则以文档为准。 3.scrollTop()&#x2F;scrollLeft()置或获取元素被卷去的头部和左侧 1.scrollTop()方法设置或返回被选元素被卷去的头部。 1.jQuery 事件注册单个事件注册语法: element.事件(function () {} $(“div”).click (function () {事件处理程序}) 其他事件和原生基本一致。比如mouseover, mouseout, blur, focus. change. keydown, keyup, resize, scroll等 2.jQuery事件处理2.1事件处理on()绑定事件on()方法在匹配元素上绑定一个或多个事件的事件处理函数 语法: element. on (events, [selector], fn) 1, events:一个或多个用空格分隔的事件类型,如”click”或keydown”. 2.selector:元素的子元素选择器。 3.fn:回调函数即绑定在元素身上的侦听函数。 on()方法优势1:可以绑定多个事件,多个处理事件处理程序。 $(“div”).on ({ mouseover: function(){}, mouseout: function() {}, click: function() {} })； $(“div”) .on (“mouseover mouseout”, function() { $ (this) .toggleclass (“current”); }); on()方法优势2:可以事件委派操作。事件委派的定义就是,把原来加给子元素身上的事件绑定在父元素身上,就是把事件委派给父元素。 $ (‘ul’).on (‘click, ‘li’, function() { alert (‘hello world!); })； 在此之前有bind(), live() delegate()等方法来处理事件绑定或者事件委派,最新版本的请用on替代他们。 on()方法优势3:动态创建的元素, click()没有办法绑定事件, on()可以给动态生成的元素绑定事件 2.2事件处理off()解绑事件off()方法可以移除通过on()方法添加的事件处理程序。 $(“p”) .off () &#x2F;&#x2F;解绑p元素所有事件处理程序 $(“p”off( “click”) &#x2F;&#x2F;解绑元素上面的点击事件后面的foo是侦听函数名 $(“ul”).off (“click”, “li”); &#x2F;&#x2F;解绑事件委托 如果有的事件只想触发一次,可以使用one()来绑定事件。 2.3自动触发事件trigger()有些事件希望自动触发,比如轮播图自动播放功能跟点击右侧,钮一致。 可以利用定时器自动触发右侧按钮点击事件,不必鼠标点击触发。 element.click() &#x2F;&#x2F;第一种简写形式 element.triqqer (“type”) &#x2F;&#x2F;第二种自动触发模式 element.triggerHandler (type) &#x2F;&#x2F;第三种自动触发模式 3.jQuery事件对象事件被触发,就会有事件对象的产生。 element. on (events, [selector] , function (event) {}) 阻止默认行为: event.preventDefault()或者return false 阻止冒泡: event.stopPropagation() 1.jQuery对象拷贝如果想要把某个对象拷贝(合并)给另外一个对象使用,此时可以使用$.extend ()方法 语法： $.extend ( [deep], target, object1, [objectN]) 1.deep:如果设为true为深考贝,默认为false浅拷贝 2.target:要拷贝的目标对象 3.object1:待考贝到第一个对象的对象。 4.objectN.待拷贝到第N个对象的对象。 5.浅拷贝是把被拷贝的对象复杂数据类型中的地址拷贝给目标对象,修改目标对象会影响被拷贝对象。 6,深拷贝,前面加true ,完全克隆(拷贝的对象,而不是地址),修改目标对象不会影响被拷贝对象。 2.jQuery 多库共存问题概述 jQuery使用$作为标示符,随着jQuery的流行,其他js库也会用这$作为标识符,这样一起使用会引起冲突。 客观需求 需要一个解决方案,让Query和其他的js库不存在冲突,可以同时存在,这就叫做多库共存。 Query解决方案: 1·把里面的$符号统一改为jQuery.,比如jQuery(“ div’) 2.jQuery 变量规定新的名称: S.noConflictovar xx &#x3D; $.noConflict(); 3.jQuery插件jQuery功能比较有限,想要更复杂的特效效果,可以借助于jQuery插件完成。 注意:这些插件也是依赖于jQuery来完成的,所以必须要先引入jQuery文件,因此也称为jQuery插件。 jQuery插件常用的网站: 1.jQuery插件库http://www.jq22.com/ 2, jQuery之家http://www.htmleaf.com/ Query 插件使用步骤: 1.引入相关文件. (jquery文件和插件文件) 2,复制相关html, css、 js 调用插件)。 jQuery插件演示:1瀑布流 2.图片懒加载(图片使用延迟加载在可提高网页下载速度。它也能帮助减轻服务器负载)当我们页面滑动到可视区域，再显示图片。 3.我们使用jquery插件库Easylazyload.注意,此时的js引入文件和js调用必须写到DOM元素(图片)最后面 3.全屏滚动(fullpage.js ) gitHub : https://github.com/alvarotrigo/fullPage.js 中文翻译网站: http://www.dowebok.com/demo/2014/77/ bootstrap JS插件: bootstrap框架也是依赖于jQuery开发的,因此里面的js插件使用,也必须引入jQuery文件。","categories":[{"name":"前端","slug":"前端","permalink":"https://2486125878.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://2486125878.github.io/tags/jQuery/"}]},{"title":"javascript","slug":"js","date":"2024-03-13T07:14:59.000Z","updated":"2024-03-13T08:21:42.000Z","comments":true,"path":"2024/03/13/js/","permalink":"https://2486125878.github.io/2024/03/13/js/","excerpt":"","text":"1.4浏览器执行JS简介浏览器分成两部分:渲染引擎和JS引擎 渲染引擎:用来解析HTML与CSS ,俗称内核,比如chrome浏览器的blink ,老版本的webkit Js引擎:也称为JS解释器。用来读取网页中的JavaScript代码,对其处理后运行,比如chrome浏览器的V8 浏览器本身并不会执行IS代码,而是通过内置JavaScript引擎(解释器)来执行JS代码。S引擎执行代码时逐行解释每一句源码(转换为机器语言) ,然后由计算机去执行,所以JavaScript语言归为脚本语言,会逐行解释执行。 ​ JavaScript ECMAScript Javascript语法 DOM 页面文档对象模型 BOM 浏览器对象模型 可以将单行或少量JS代码写在HTML标签的事件属性中(以on开头的属性),如: onclick 注意单双引号的使用:在HTML中我们推荐使用双引号,JS中我们推荐使用单引号 可读性差,在html中编写IS大量代码时,不方便阅读;引号易错, 引号多层嵌套匹配时,非常容易弄混; 特殊情况下使用 单行注释ctrl +&#x2F; 多行注释 默认的快捷键shift + alt +a 多行注释 vscode中修改多行注释的快捷键: ctrl + shift +&#x2F; 方法 说明 归属 alert(msg) 浏览器弹出警示框 浏览器 console.log(msg) 浏览器控制台打印输出信息 浏览器 prompt(info) 浏览器弹出输入框,用户可以输入 浏览器 1.2变量的数据类型变量是用来存储值的所在处,它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的内存中。 JavaScript是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型,在程序运行过程中,类型会被自动确定。 var age &#x3D; 10;&#x2F;&#x2F;这是一个数字型 var arexouok &#x3D;‘是的’; &#x2F;&#x2F;这是一个字符串 在代码运行时,变量的数据类型是由JS引擎根据&#x3D;右边变量值的数据类型来判断的,运行完毕之后,变量就确定了数据类型。 Javascript拥有动态类型,同时也意味着相同的变量可用作不同的型: var x&#x3D;6;x为数字 var x&#x3D; “Bil”;x为字符串 2.1简单数据类型(基本数据类型)JavaScript中的简单数据类型及其说明如下: 简单数据类型 说明 默认值 Number 数字型,包含整型值和浮点型值,如21、0.21 0 Boolean 布尔值类型,如true、false,等价于1和0 false string 字符串类型,如”张三”注意咱们js里面,字符串都带引号 “” Undefined var a;声明了变量a但是没有给值,此时a&#x3D; undefined undefined Null var a &#x3D;null;声明了变量a为空值 null 现阶段我们只需要记住,在JS中八进制前面加0,十六进制前面加Ox JavaScriptthf的最大和最小值 alert (Number.MAX_VALUE); &#x2F;&#x2F; 1.7976931348623157e+308 alert (Number.MIN VALUE); &#x2F;&#x2F; 5e-324 数字型三个特殊值 alert(Infinity); &#x2F;&#x2F; Infinity alert(nfinity) ; &#x2F;&#x2F;-Infinity alert (NaN);NaN Infinity ,代表无穷大,大于任何数值 -Infinity ,代表无穷小,小于任何数值 NaN , Not a number,代表一个非数值 4.isNaN()用来判断一个变量是否为非数字的类型,返回true或者falsex x是数字,返回false isNaN (x) x不是数字,返回true x是一个非数字类型 1,字符串引号嵌套JS可以用单引号嵌套双引号,或者用双引号碳套单引号(外双内单,外单内双) 2.字符串转义符类似HTML面的特殊字符,字符串中也有特殊字符,我们称之为转义符。 转义符都是\\开头的,常用的转义符及其说明如下: 转义符 解释说明 \\n 换行符,n是newline的意思 \\\\ 斜杠 \\‘ 单引号 \\“ 双引号 \\t tab缩进 \\b 空格,b是blank的意思 字符串是由若干字符组成的,这些字符的数量就是字符串的长度。通过字符串的length属性可以获取整个字符串的长度。 console. log(true +1); &#x2F;&#x2F; 2 console.log (false + 1); &#x2F;&#x2F; 1 4.2转换为字符串方式 说明 案例 toString() 转成字符串 var num&#x3D; 1; alert(num.toString(); String()强制转换 转成字符串 var num &#x3D;1; alert(String(null); 加号拼接字符串 和字符串拼接的结果都是字符串 var num &#x3D;1; alert(num+ “我是字符串”); toString0和String0使用方式不一样。 三种转换方式,我们更喜欢用第三种加号拼接字符串转换方式,这一种方式也称之为隐式转换。 4.3转换为数字型(重点)方式 说明 案例 parselnt(string)函数 将string类型转成整数数值型 parselnt(78’) parseFloat(string)函数 将string类型转成浮点数数值型 parsefloat(‘78.21’) Number()强制转换函数 将string类型转换为数值型 Number(‘12’) js隐式转换(- * &#x2F;) 利用算术运算隐式转换为数值型案例 ‘12-0’ 4.4转换为布尔型方式 说明 案例 Boolean()函数 其他类型转成布尔值 Boolean(‘true’); 代表空、否定的值会被转换为false ,如 0,NaN, null, undefined 其余值都会被转换为true tml标签marquee可以实现多种滚动效果，而且不仅可以移动文字，也可以移动图片，表格等。语法：…；说明：在标记之间添加要进行滚动的内容。 marquee常用到的两个事件：onMouseOut&#x3D;“this.start()” 当鼠标移出该区域时onMouseOver&#x3D;“this.stop()” 当鼠标移入该区域时 代码示例：marquee常用到的两个事件 marquee的重要属性：1.behavior设置滚动的方式；scroll:循环滚动，默认效果；slide:只滚动一次就停止；alternate:来回交替进行滚动。语法：… 2.direction设置滚动的方向；可选值有 left, right, up and down。如果未指定值，默认值为 left。语法：…3.scrollamount设置滚动的速度；以像素为单位，默认值为 6。语法：…4.scrolldelay设置两次滚动的时间间隔；以毫秒为单位，默认值为 85。 除非指定 truespeed 值，否则将忽略任何小于 60 的值，并改为使用 60。5.loop设置 marquee 滚动的次数；如果未指定值，默认值为 −1，表示 marquee 将连续滚动。6.width、height设置滚动的范围；7.hspace、vspace设置水平和垂直边距；8.bgcolor设置滚动的背景颜色。 函数3.4小结函数可以带參数也可以不带参数 声明函数的时候,函数名括号里面的是形参,形参的默认值为undefined 调用函数的时候,函数名括号里面的是实参 多个参数中间用逗号分隔 形参的个数可以和实参个数不配,但是结果不可预计,我们尽量要匹配 4.5 break,continue ,return的区别.break :结束当前的循环体(如for, while ) continue :跳出本次循环,继续执行下次循环(如for, while ) return :不仅可以退出循环,还能够返回return语句中的值,同时还可以结束当前的函数体内的代码 5.arguments的使用当我们不确定有多少个参数传递的时候,可以用arguments来获取。 在JavaScript中, arguments实际上它是当前函数的一个内置对象。 所有函数都内置了一个arguments对象, arguments对象中存储了传递的所有实参。 arguments展示形式是一个伪数组,因此可以进行遍历。伪数组具有以下特点: 具有length属性 按索引方式储存数据 不具有数组的push, pop等方法 Javascript作用域Javascript作用域: 就是代码名字在某个范围内起作用和效果 目的是为了提高程序的可靠性更重要的是减少命名冲突 js的作用域(es6)之前: 全局作用域 局部作用域 全局作用域: 整个script标签或者是一个单独的js文件 局部作用域(函数作用域)：在函数内部就是局部作用域这个代码的名字只在函数内部起效果和作用 注意：如果在函数内部没有声明直接赋值的变量也属于全局变量 注意: 函数的形参也可以看做是局部变量 3,从执行效率来看全局变量和局部变量 1全局变量只有浏览器关闭的时候才会销毁,比较占内存资源 2局部变量当我们程序执行完毕就会销毁 比较节约内存资源 2.2全局变量在全局作用域下声明的变量叫做全局变量(在函数外部定义的变量) 全局变量在代码的任何位置都可以使用 在全局作用域下var声明的变量是全局变量 特殊情况下,在函数内不使用var声明的变量也是全局变量(不建议使用) 2.2局部变量在局部作用域下声明的变量叫做局部变量(在函数内部定义的变量 局部变量只能在该函数内部使用 在函数内部var声明的变量是局部变量 函数的形参实际上就是局部变量 2.3全局变量和局部变量的区别全局变量:在任何一个地方都可以使用,只有在浏览器关闭时才会被销毁,因此比较占内存 局部变量:只在函数内部使用,当其所在的代码块被执行时,会被初始化;当代码块运行结束后,就会被·销毁,因此更节省内存空间 js中没有块级作用域 js的作用域: 全局作用域 局部作用域 现阶段我们js没有块级作用域 我们is也是在es6的时候新增的块级作用域 块级作用域 {} if{} for {} 3作用域链：内部函数访问外部函数的变量,采取的是链式查找的方式来决定取那个值这种结构我们称为作用域链只要是代码，就至少有一个作用域 写在函数内部的局部作用域 如果函数中还有函数,那么在这个作用域中就又可以诞生一个作用域 根据在内部函数可以访问外部函数变量的这种机制,用链式查找决定哪些数据能被内部函数访问,就称作作用域链 就近原则 对象1.1什么是对象?现实生活中:万物皆对象,对象一个具体的事物1看得见摸得着的实物。例如,一本书、-辆汽车、一个人可以是”对象” ,一个数据库、张网页、一写远程服务器的连接也可以是“对象” 在Javascript 中,对象是一组无序的相关属性和方法的集合,所有的事物都是对象,例如字符串、数值、数组、函数等。 对象是由属性和方法组成的。 属性:事物的特征,在对象中用属性来表示(常用名词) 方法：事物的行为,在对象中用方法来表示(常用动词) 1.2为什么需要对象保存一个值时,可以使用变量,保存多个值(一组值)时,可以使用数组。如果要保存一个人的完整信息呢? 例如,将”张三疯”的个人的信息保存在数组中的方式为: var arr &#x3D;[‘张三疯’,男’, 128,154]; JS中的对象表达结构更清晰,更强大。张三疯的个人信息在对象中的表达结构如下: 张三疯.姓名&#x3D; ‘’张三疯’; 张三疯.性别&#x3D;’男’; 张三疯.年龄&#x3D;129; 张三疯.身高&#x3D;154; person. name &#x3D; ‘张三疯’; person.sex&#x3D;男; person.age &#x3D;128; person.height &#x3D; 154; 2．创建对象的三种方式在Javascript中,现阶段我们可以采用三种方式创建对象(object) : 利用字面量创建对象 利用new Object创建对象 利用构造函数创建对象 2.1利用字面量创建对象对象字面量:就是花括号()里面包含了表达这个具体事物(对象)的属性和方法。 对象的调用对象里面的属性调用:对象 属性名,这个小点.就理解为”的“ 对象里面属性的另一种调用方式:对象[‘属性名‘ ],注意方括号里面的属性必须加引号,我们后面会用对象里面的方法调用:对象方法名(),注意这个方法名字后面一定加括号 console.log (star.name) &#x2F;&#x2F;调用名字属性 console.log (star [‘name’]) &#x2F;&#x2F;调用名字属性 star.sayHi(); &#x2F;&#x2F;调用sayHi方法,注意,一定不要忘记带后面的括号 变量、属性、函数、方法总结变量:单独声明赋值,单独存在 属性:对象里面的变量称为属性,不需要声明,用来描述该对象的特征 函数:单独存在的,通过”函数名()”的方式就可以调用 方法:对象里面的函数称为方法,方法不需要声明,使用“对象方法名()”的方式就可以调用,方法用来描述该对象的行为和功能。 2.3利用构造函数创建对象构造函数:是一种特殊的函数,主要用来初始化对象,即为对象成员变量赋初值,它总与new运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来,然后封装到这个函数里面。 2.4构造函数和对象构造函数,如Stars() ,抽象了对象的公共部分,封装到了函数里面,它泛指某一大类(class) 创建对象,如new Stars(),特指某一个,通过new关键字创建对象的过程我们也称为对象实例化 new在执行时会做四件事情:1,在内存中创建一个新的空对象。 2．让this指向这个新的对象。 3.执行构造函数里面的代码,给这个新对象添加属性和方法。 4.返回这个新对象(所以构造函数里面不需要return). for in 语句用于对数组或者对象的属性进行循环操作。小结1.对象可以让代码结构更清晰 2,对象复杂数据类型object 3·本质:对象就是一组无序的相关属性和方法的集合 4.构造函数泛指某一大类,比如苹果,不管是红色苹果还是绿色苹果,都统称为苹果。 5.for..in 用于对对象的属性进行循环操作。 内置对象Javascript中的对象分为3种:自定义对象、内置对象、浏览器对象 前面两种对象是&#x2F;S基础内容,属于ECMAScript ;第三个浏览器对象属于我们Js独有的,我们JS APl讲解 内置对象就是指JS语言自带的一些对象,这些对象供开发者使用,并提供了一些常用的或是最基本而必要的功能(属性和方法) 内置对象最大的优点就是帮助我们快速开发 Javascript提供了多个内置对象: Math, Date、Array, string等 查文档2.1 MDN学习一个内置对象的使用只要学会其常用成员的使用即可我们可以通过查文档学习,可以通过MDN&#x2F;W3C来查询。 Mozilla开发者网络(MDN )提供了有关开放网络技术(Open Web )的信息,包括HTML, CSS和万维网及HTML5应用的API MDN: https://developer.mozilla.org/zh-CN/ 2.2如何学习对象中的方法1．查阅该方法的功能 2．查看里面参数的意义和类型 3.查看返回值的意义和类型 4.通过demo进行测试 MathMath是一个内置对象,它具有数学常数和函数的属性和方法。不是一个函数对象。 描述与其它全局对象不同的是, Math不是一个构造器 Math 的所有属性和方法都是静态的,你用到的常数p可以用Math.PI 表示用 x 作参数 Math.sin (x) 调sin函数 JavaScript中的常数,是以全精度的实数定义的 3.1 Math概述Math对象不是构造函数,它具有数学常数和函数的属性和方法。跟数学相关的运算(求绝对值,取整、最大值等)可以使用Math中的成员。 Math.PI&#x2F;&#x2F;圆周率 Math.floor()&#x2F;&#x2F;向下取整 Math.ceil ()&#x2F;&#x2F;向上取整 Math.round()&#x2F;&#x2F;四舍五入 就近取整 注意-3.5 结果是-3 Math.abs ()&#x2F;&#x2F;绝对值 Math.max () &#x2F;Math.min() &#x2F;&#x2F;求最大和最小值 random()随机生成小数随机生成整数 function getRandom(min, max) { ​ return Math.floor(Math.random() * (max - min + 1)) + min; ​ } 构造函数new Date(); 需要注意的是只能通过调用Date构這函 来实例化日期对象:以常规函数调用它, (即不加new操作符)将会返回一个字符串,而不是一个日期对象。另外,不像其他JavaScript类型, Date对象没有字面量格式。 如果没有输入 可容数,则Date的构造器会依据系统设置的当前时间来创建一个Date对象。 如果提供了至少两个参数,其余的参数均会默认设置为1 (如果没有提供day参数)或者0 &#x2F;&#x2F;参数常用写法 数字型参数 常用的写法数字型 2019, 10, 01或者是 字符型’2019-10-1 8:8:8’’ ​ var date1 &#x3D; new Date(2019, 10, 1); ​ console.log(date1); &#x2F;&#x2F;返回的是11月不是10月 ​ var date2 &#x3D; new Date(‘2019-10-1 8:8:8’); ​ console.log(date2); &#x2F;&#x2F;准确建议使用 4.1 Date概述Date对象和Math对象不一样,他是一个构造函数,所以我们需要实例化后才能使用 Date实例用来处理日期和时间 4.2 Date()方法的使用1,获取当前时间必须实例化 var now &#x3D; new Date (); console.log (now); 2.Date)构造函数的参数 如果括号里面有时间,就返回参数里面的时间。例如日期格式字符串为‘2019-5-1’ ,可以写成new Date(2019-5-1)或者new Date(’2019&#x2F;5&#x2F;1‘) 4.3日期格式化 我们想要2019-8-88:8:8格式的日期,要怎么办? 需要获取日期指定的部分,所以我们要手动的得到这种格式。 方法名 说明 代码 getFullYear() 获取当年 dObj.getFullYear() getMonth() 获取当月(0-11) dobj.getMonth() getDate() 获取当天日期 dObi.getDate() getDay() 获取星期几(周日0到周六6) dObj.getDay() getHours() 获取当前小时 dobj.getHours() getMinutes() 获取当前分钟 dobj.getMinutes() getSeconds() 获取当前秒钟 dObj.getSeconds() 不需要参数 4.4获取日期的总的毫秒形式Date对象是基于1970年1月1日(世界标准时间)起的毫秒数 为什么计算机起始时间从1970年开始? 我们经常利用总的毫秒数来计算时间,因为它更精确 4.日期对象案例分析倒计时算法 ①核心算法:输入的时间减去现在的时间就是剩余的时间,即倒计时,但是不能拿着时分秒相减,比如05分减去25分,结果会是负数的。 用时间戳来做。用户输入时间总的毫秒数减去现在时间的总的毫秒数,得到的就是剩余时,间的毫秒数。 把剩余时间总的毫秒数转换为天、时、分、秒(时间戳转换为时分秒) 转换公式如下: d &#x3D; parselnt(总秒数&#x2F;60&#x2F;60&#x2F;24); &#x2F;&#x2F;计算天数 h &#x3D; parselnt(总秒数&#x2F;60&#x2F;60%24) &#x2F;&#x2F;计算小时 m &#x3D; parselnt(总秒数&#x2F;60 %60); &#x2F;&#x2F;计算分数 s&#x3D; parselnt(总秒数%60); &#x2F;&#x2F;计算当前秒数 5.数组对象instanceof和isArray当检测Array实例时, Array.isArray优于instanceof,因为Array. isArray能检测iframes. 5.3添加删除数组元素的方法方法名 说明 返回值 push(参数1..) 末尾添加一个或多个元素,注意修改原数组 并返回新的长度 pop() 删除数组最后一个元素,把教组长度减1无参数、修改原数组 返回它删除的元素的值 unshift(参数… ) 向数组的开头添加一个或更多元素,注意修改原数组 并返回新的长度 shift() 删除数组的第一个元素,数组长度减1无参数、修改原数组 并返回第一个元素的值 5.4数组排序方法名 说明 是否修改原数组 reverse() 颠倒数组中元素的顺序,无参数 该方法会改变原来的数组返回新数组 sort() 对数组的元素进行排序 该方法会改变原来的数组返回新数组 5.5数组索引方法方法名 说明 返回值 indexOf() 数组中查找给定元素的第一个索引 如果存在返回索引号如果不存在,则返回-1 lastindexOf() 在数组中的最后一个的索引, 如果存在返回素引号如果不存在,则返回-1. 有一个数组[‘c’, ‘a’, ‘2’, ‘a’, ‘x’, ‘a’, ‘x’, ‘c’,’b’],要求去除数组中重复的元素。 核心算法:我们遍历日数组,然后拿着旧数组元素去查询新数组,如果该元素在新数组里面没有出现过,我们就添加,否则不添加。 我们怎么知道该元素没有存在?利用新数组.indexOf(数组元素)如果返回时-1就说明新数组里面没有改元素 5.6数组转换为字符串方法名 说明 返回值 toString() 把数组转换成字符串,逗号分隔每一项 返回一个字符串 join(‘分隔符’) 方法用于把数组中的所有元素转换为一个字符串。 返回一个字符串 5.7课下查询方法名 说明 返回值 concat() 连接两个或多个数组不影响原数组 返回一个新的数组 slice() 数组截取slice(begin, end) 返回被截取项目的新数组 splice() 数组删除splice(第几个开始,要删除个数) 返回被删除项目的新数组注意,这个会影响原数组 slice()和splice()目的基本相同,建议同学们重点看下splice() 6.1基本包装类型为了方便操作基本数据类型, Javascript还提供了三个特殊的引用类型: String, Number和Boolean. 基本包装类型就是把简单数据类型包装成为复杂数据类型,这样基本数据类型就有了属性和方法 6.2字符串的不可变指的是里面的值不可变,虽然看上去可以改变内容,但其实是地址变了,内存中新开辟了一个内存空间。 6.3根据字符返回位置字符串所有的方法,都不会修改字符串本身字符串是不可变的,操作完成会返回一个新的字符串。 方法名 说明 indexof(要查找的字符,开始的位置) 返回指定内容在元字符串中的位置,如果找不到就返回-1,开始的位置是index索引号 lastlindexof() 从后往前找,只找第一个匹配的 6.4根据位置返回字符(重点)方法名 说明 使用 charAt(index) 返回指定位置的字符(index字符串的索引号) str.charAt(0) charCodeAt(index) 获取指定位置处字符的ASCI1码(index素引号) str.charCodeAt(0) charAt(index) 获取指定位置处字符 HTML5, IE8+支持和charAt()等效 6.5字符串操作方法(重点)方法名 说明 concat(str1,str2,str3…. concat()方法用于连接两个或多个字符串。拼接字符串,等效于+, +更常用 substr(start,length) 从start位置开始(索引号) , length取的个数重点记住这个 slice(start, end) 从start位置开始,截取到end位置, end取不到(他们俩都是索引号) substring(start, end) 从start位置开始,截取到end位置, end取不到基本和slice相同但是不接受负值 6.8课下查阅toUpperCase()&#x2F;&#x2F;转换大写 tolowerCase() &#x2F;&#x2F;转换小写 1.简单类型与复杂类型简单类型又叫做基本数据类型或者 值类型,复杂类型又叫做 引用类型。· 值类型:简单数据类型基本数据类型,在存储时变量中存储的是值本身,因此 做值类型 string , number, boolean , undefined, null 引用类型:复杂数据类型,在存储时变量中存储的仅仅是地址(引用) ,因此叫做引用数据类型 通过new关键字创建的对象(系统对象、自定义对象) ,如Object,Array. Date等 2.堆和栈堆栈空间分配区别： 1、栈(操作系统) :由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈; 简单数据类型存放到栈里面 2、堆(操作系统) :存储复杂类型对象,一般由程序员分配释放,若程序员不释放,由垃圾回收机制回收。 复杂数据类型存放到堆里面 注意: JavaScriot中没有堆栈的概念,通过堆栈的方式,可以让大家更容易理解代码的一些执行方式,便于将来学习其他语言 3.简单类型的内存分配值类型(简单数据类型) : string , number , boolean , undefined , null 值类型变量的数据直接存放在变量(栈空间)中 6.复杂类型传参函数的形参也可以看做是一个变量,当我们把一个值类型变量作为参数传给函数的形参时,其实是把变量在栈空间里的值复制了一份给形参,那么在方法内部对形参做任何修改,都不会影响到的外部变量。 函数的形参也可以看做是一个变量,当我们把引用类型变量传给形参时,其实是把变量在栈空间里保存的堆地址复制给了形参,形参和实参其实葆存的是同一个堆地址,所以操作的是同一个对象。 Web APIs介绍1.1 JS的组成 1.2JS基础阶段以及Web APIs阶段JS基础阶段 我们学习的是ECMAScript标准规定的基本语法 要求同学们掌握Js基础语法 只学习基本语法,做不了常用的网页交互效果 目的是为了Js后面的课程打基础、做铺垫 Web APis阶段Web APIs是w3c组织的标准 Web APIs a Doм和BOM Web APIs是我们Js所独有的部分 我们主要学习页面交互功能 需要使用Js基础的课程内容做基础 Js基础学习ECMAScript基础语法为后面作铺垫, web APIs是Js的应用,大量使用Js基础语法做交互效果 2.1 APIAPI (Application Programming Interface,应用程序编程接口)是一些预先定义的函数,目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力,而又无需访问源码,或理解内部工作机制的细节。 简单理解: API是给程序员提供的一种工具,以便能更轻松的实现想要完成的功能。 2.2 Web APIWeb API是浏览器提供的一套操作浏览器功能和页面元素的API (BOM和DOM). 现阶段我们主要针对于浏览器讲解常用的API,主要针对浏览器做交互效果。 比如我们想要浏览器弹出一个警示框,直接使用alert( 弹出 ) MDN详细API : https://developer.mozilla.org/zh-CN/docs/Web/API 因为Web API很多,所以我们将这个阶段称为Web APls 2.3 API和Web API总结1.API是为我们程序员提供的一个接口,帮助我们实现某种功能,我们会使用就可以了,不必纠结内部如何实现 2.Web API主要是针对于浏览器提供的接口,主要针对于浏览器做交互效果。 3.Web API一般都有输入和输出(函数的传参和返回值) , WebAPI很多都是方法(函数) 4.学习Web APl可以结合前面学习内置对象方法的思路学习 DOM(重点)1.1什么是DOM文档对象模型( Document Object Model ,简称DOM ) ,是W3C组织推荐的处理可扩展标记语言(HTML或者XML )的标准编程接口。 W3C已经定义了一系列的DOM接口,通过这些DOM接口可以改变网页的内容、结构和样式。 1.2 DOM树 文档:一个页面就是一个文档, DOM中使用document表示 元素:页面中的所有标签都是元素, DOM中使用element表示 节点:网页中的所有内容都是节点(标签、属性、文本、注释等) , DOM中使用node表示 DOM把以上内容都看做是对象 2.1如何获取页面元素DOM在我们实际开发中主要用来操作元素。 我们如何来获取页面中的元素呢? 获取页面中的元素可以使用以下几种方式: 根据ID获取 根据标签名获取 通过HTML5新增的方法获取 特殊元素获取 2.2根据ID获取使用getElementByld()方法可以获取带有ID的元素对象。 Document的方法getElementByld())返回一个匹配特定1D的元素由于元素的ID在大部分情况下要求是独一无二的,这个方法自然而然地成为了一个高效查找特库元素的方法。 element是一个Element对象。如果当前文档中拥有特定ID的元素不存在则返回null id是写的字,代表了所要查找的元素的唯一ID. 返回一个匹配到ID的DOM ElementE,若在当前Document下没有找到,则返回null 2.3根据标签名获取使用getElementsByTagName()方法可以返回带有指定标签名的对象的集合。 还可以获取某个元素(3元素)内部所有指定标签名的子元素. element.getElementsByTagName (‘标签名‘); 注意:父元素必须是单个对象(必须指明是哪一个元素对象).获取的时候不包括元素自己。 2.4通过HTML5新增的方法获取i9以上浏览器可以使用1.document.getElementsByClassName (类名’) ; &#x2F;&#x2F;根据类名返回元素对象集合 2.document.querySelector (‘选择器’); &#x2F;&#x2F;根据指定选择器返回第一个元素对象 3.document.querySelelctorAll (,選择器’);&#x2F;&#x2F;根据指定选择器返回 2.5获取特殊元素( body , html )获取body元素 doucumnet.body &#x2F;&#x2F;返回body元素对象 获取html元素 document-documentElement &#x2F;&#x2F;返回html元素对象 3.事件基础3.1事件概述JavaScript使我们有能力创建动态页面,而事件是可以被Javascript侦测到的行为。 简单理解:触发–响应机制。 网页中的每个元素都可以产生某些可以触发JavaScript的事件,例如,我们可以在用户点击某按钮时产生一个事件,然后去执行某些操作。 3.3执行事件的步骤1.获取事件源 2注册事件（绑定事件) 3.添事件处理程序(采取函数赋值形式) 3.3常见的鼠标事件鼠标事件 触发条件 onclick 鼠标点击左键触发 onmouseover 鼠标经过触 onmouseout 鼠标离开触发 onfocus 获得鼠标焦点触发 onblur 失去鼠标焦点触发 onmousemove 鼠标移动触发 onmouseup 鼠标弹起触发 onmousedown 鼠标按下触发 4·操作元素JavaScript的DOM操作可以改变网页内容、结构和样式,我们可以利用DOM操作元素来改变元素里面的内容、属性等。注意以下都是属性 4.1改变元素内容element. innerText 从起始位置到终止位置的内容,但它去除html标签,同时空格和换行也会去掉 element. innerHTML 起始位置到终止位置的全部内容,包括html标签,同时保留空格和换行 4.2常用元素的属性操作1.innerText. innerHTMI改变元素内容 2.src, href 3.id, alt, title 4.3表单元素的属性操作利用DOM可以操作如下表单元素的属性: type, value, checked, selected, disabled 4.4样式属性操作我们可以通过IS修改元素的大小、颜色、位置等样式。 element.style 行内样式操作——-用行内样式覆盖了 element.className类名样式操作——-样式很多用 注意: 1.Js里面的样式采取驼峰命名法比如fontSize, backgroundColor 2.Js修改style样式操作,产生的是行内样式, css权重比较高 注意： 1,如果样式修改较多,可以采取操作类名方式更改元素样式。 2.class因为是个保留字,因此使用className来操作元素类名属性 3.className会直接更改元素的类名,会覆盖原先的类名。 可以利用for循环设置一组元素的精灵图背景 首先精灵图图片排列有规律的核心思路: 利用for循环修改精灵图片的背景位置background-position 剩下的就是考验你的数学功底了 i循环里面的i索引号*44就是每个图片的y坐标 首先表单需要2个新事件,获得焦点onfocus失去焦点onblur 如果获得焦点,判断表单里面内容是否为默认文字,如果是默认文字,就清空表单内容 如果失去焦点,判断表单内容是否为空,如果为空,则表单内容改为默认文字 4·操作元素总结操作元素是DOM核心内容 4.6自定义属性的操作1·获取属性值 element.属性 获取属性值 element.getAttribute (属性); 区别: element.属性 获取内置属性值(元素本身自带的属性) element .getattribute ( ‘属性’);主要获得自定义的属性(标准)我们程序员自定义的属性 2,设置属性值 element.属性&#x3D; ‘值’ 设置内置属性值。 element .setAttribute (‘属性’,‘值’); 3.移除属性 element. removeAttribute (‘’属性”); 4.7 H5自定义属性自定义属性目的:是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。 自定义属性获取是通过getAttribute (属性”)获取。但是有些自定义属性很容易引起歧义,不容易判断是元素的内 属性还是自定义属性。 H5给我们新增了自定义属性: 1·设置H5自定义属性H5规定自定义属性data开头做为属性名并且赋值 比如 或者使用JS设置 element.setAttribute( ‘data-index’ ,2) 2,获取H5自定义属性 1,兼容性获取element.getAttribute( ‘data-index ‘) H5新增element.dataset.index或者element.dataset ’index’ ] ie 11才开始支持 5．节点操作5.1为什么学节点操作1,利用DOM提供的方法获取元素document.getElementByld(） document.getElementsByTagName() document.querySelector等 逻辑性不强、繁琐 2·利用节点层级关系获取元素利用父子兄节点关系获取元素 逻辑性强,但是兼容性稍差 这两种方式都可以获取元素节点,我们后面都会使用,但是节点操作更简单 5.2节点概述网页中的所有内容都是节点(标签、属性、文本、注程等) ,在DOM中,节点使用node来表示。HTMILDOM树中的所有节点均可通过Javascript进行访问,所有HTML元素(节点)均可被修改,也可以创建或删除。 一般地,节点至少拥有nodeType (节点类型)、nodeName (节点名称)和nodeValue (节点值)这三个基本属性。 元素节点nodeType为1 属性节点nodeType为2 文本节点nodelype为3 (文本节点包含文字、空恪、换行等) 我们在实际开发中,节点操作主要操作的是元素节点 5.3节点层级利用DOM树可以把节点划分为不同的层级关系,常见的是父子兄层级关系。 1,父级节点 node.parentNode parentNode属性可返回某节点的父节点,注意是最近的一个父节点 如果指定的节点没有父节点则返回null 2.子节点 1. parentNode. childNodes (标准） parentNode. childNodes返回包含指定节点的子节点的集合,该集合为即时更新的集合。 注意：返回值里面包含了所有的子节点,包括元素节点,文本节点等。如果只想要获得里面的元素节点,则需要专门处理。所以我们一般不提倡使用childNodes var ul &#x3D; document. queryselector (‘ul’); for(var i&#x3D; 0; i &lt; ul.childNodes.length;i++) { if (ul.childNodes [i].nodeType&#x3D;&#x3D;1) { &#x2F;&#x2F; ul.childNodes [i]是元素节点 console. log (ul.childNodes [i]); } } children获取所有的子元素节点 2.parentNode. children (非标准) firstChild返回第一个子节点,找不到则返回null,同样,也是包含所有的节点。 3.parentNode.firstChild lastchild返回第一个子节点,找不到则返回null,同样,也是包含所有的节点。 4.parentNode.lastchild 5.parentNode .firstElementChild firstElementchild返回第一个子元素节点,找不到则返回null 6.parent Node .lastElementChild lastElenentchild返回最后一个子元素节点,找不到则返回null 注意:这两个方法有兼容性问题, IE9以上才支持。 实际开发中, firstChild和lastchild包含其他节点,操作不方便,而firstElementchild和lastElementchila又有兼容性问题,那么我们如何获取第一个子元素节点或最后一个子元素节点呢? 3.兄弟节点1.node.nextsibling nextsibling返回当前元素的下一个兄弟节点,找不到则返回nu11。同样,也是包含所有的节点。 2.node.previoussibling previoussibling返回当前元素上一个兄弟节点,找不到则返回nu11。同样,也是包含所有的节点 3.node.nextElementsibling nextElementsibling返回当前元素下一个兄弟元素节点,找不到则返回null. 4.node.previousElementsibling previousElementsibling返回当前元素上一个兄弟节点,找不到则返回null. 主意:这两个方法有兼容性问题, 1E9以上才支持。 如何解决兼容性问题? 自己封装一个兼容性的函数 function getNextElementsibling (element) { var el &#x3D; element; while (el &#x3D; el.nextsibling) { if (el.nodeType &#x3D;&#x3D;1) { return el; } } return null; } 5.4创建节点document. createElement (“tagName ‘)document. createlement () 方法创建由tagName指定的HTML元素。因为这些元素原先不存在,是根据我们的需求动态生成的,所以我们也称为动态创建元素节点。 5.5添加节点1.node.appendchild (child) node. appendchild()方法将一个节点添加到指定父节点的子节点列表未尾。类似于css里面的after伪元素。 2.node.insertBefore (child,指定元素) node. insert Be fore ()方法将一个节点添加到父节点的指定子节点前面。类似于css里面的before伪元素。 5.5删除节点node. removechild (child) node.removechild()方法从DoM中删除一个子节点,返回删除的节点 5.6复制节点(克隆节点)node.cloneNode ()node.cloneNode (1)方法返回调用该方法的节点的一个副本。也称为克隆节点&#x2F;拷贝节点 注意： 1,如果括号参数为空或者为false ,则是浅拷贝,即只克隆复制节点本身,不克隆里面的子节点。 2,如果括号参数为true,则是深度拷贝,会复制节点本身以及里面所有的子节点。 5.8三种动态创建元素区别document.write () element .innerHTML document. creeateElement (). 区别. 1. document.write是直接将内容写入页面的内容流,但是文档流执行完毕,则它会导致页面全部重绘 2.innerHTML是将内容写入某个DoM节点,不会导致页面全部重绘 3.innerHTML创建多个元素效率更高(不要拼接字符串,采取数组形式拼接) ,结构稍微复杂 4.createElement ()创建多个元素效率稍低一点点,但是结构更清材 总结:不同浏览器下, innerHTM效率要比creatElement高 6.DOM重点核心文档对象模型( Document Object Model,简称DOM ) ,是W3C组织推荐的处理可扩展标记语言(HTML或者XML )的标准编程接口 W3C已经定义了一系列的DOM接口,通过这些DOM接口可以改变网页的内容、结构和样式 1,对于JavaScript,为了能够使lavaScript操作HTML , JavaScript就有了一套自己的dom编程接口。 2,对于HTMIL, dom使得html形成一棵dom树,包含文档、元素、节点 我们获取过来的DOM元素是一个对象(object) , 所以称为文档对象模型 关于dom操作,我们主要针对于元素的操作。主要有创建、增、删、改、查、属性操作、事件操作。 6.1创建 document.write innerHTML createElement 6.2增 appendChild insertBefore 6.3删 removeChild 6.4改主要修改dom的元素属性, dom元素的内容、属性,表单的值等 1.修改元素属性: src, href, titte等 2,修改普通元素内容: innerHTML, innerText 3,修改表单元素: value, type, disabled等 4.修改元素样式: style, className 6.5查主要获取查询dom的元素 DOM提供的API方法: getElementByld, getElementsByTagName 古老用法不太推荐 H5提供的新方法: querySelector, querySelectorAll提倡 “利用节点操作获取元素:父(parentNode),子(children), 兄(previousElementSibling \\ nextElementSibling )提倡 6.6属性操作主要针对于自定义属性。 setAttribute :设置dom的属性值 getAttribute :得到dom的属性值 removeAttribute移除属性 6.7 事件操作给元素注册事件,采取事件源事件类型&#x3D;事件处理程序 1.注册事件(绑定事件)1.1注册事件概述给元素添加事件,称为注册事件或者绑定事件。 注册事件有两种方式:传统方式和方法监听注册方式 传统注册方式 利用on开头的事件onclick btn.onclick &#x3D; function(){} 特点：注册事件的唯一性, 同一个元素同一个事件只能设置一个处理函数,最后注册的处理函数将会覆盖前面注册的处理函数 方法监听注册方式 w3c标准推荐方式 addEventListener()它是一个方法 IE9之前的IE不变持此方法,可使用attachEvent()代替 特点:同一个元素同一个事件可以注册多个监听器 按注册顺序依次执行 1.2 addEventListener事件监听方式eventTarget.addEventListener (type, listener [, usecapture]). eventTarget.addEventListener ()方法将指定的监听器注册到eventTarget (目标对象)上,当该对象触发指定的事件时,就会执行事件处理函数。 该方法接收三个参数: type:事件类型字符串,比如click, mouseover ,注意这里不要带on listener:事件处理函数,事件发生时,会调用该监听函数 useCapture:可选参数,是一个布尔值,默认是false,学完DOM事件流后,我们再进步学习 1.3 attachEvent事件监听方式eventrarget. attachEvent (eventNamewithOn, callback). eventTarget. attachEvent ()方法将指定的监听器注册到eventTarget (目标对象)上,当该对象触发指定的事件时,指定的回调函数就会被执行。 该方法接收两个参数: eventNameWithOn :事件类型字符串,比如onclick, onmouseover ,这里要带on callback :事件处理函数,当目标触发事件时回调函数被调用 1.4注册事件兼容性解决方案function addEventzistener (element, eventName, fn) { &#x2F;&#x2F;判断当前浏览器是否支持addEventListener方法 if (element. addEventListener) { element.addiventListener (eventName, fn); &#x2F;&#x2F;第三个参数默认是false } else if (element.attachEvent) { element. attachEvent (‘on’ + eventName, fn); } else{ &#x2F;&#x2F;相当于element.onclick&#x3D;fn; element[‘on’ + eventName] &#x3D; fn; } 兼容性处理的原则:首先照顾大多数浏览器,再处理特殊浏览器 2.删除事件（解绑事件).2.1删除事件的方式1.传统注册方式 eventTarget.onclick &#x3D; null; 2.方法监听注册方式. eventTarget. removeEventListener (type, listenerl, useCapturel); ventrarget. detachEvent (eventNamewithon, callback); 2.2删除事件兼容性解决方案functiont removeEventListener (element, eventName, fn) &#x2F;&#x2F;判断当前浏览器是否支持removeEventistener方法 if (element. removeEventListener) { element.removeEventListener (eventName, fn); &#x2F;&#x2F;第三个参数默认是false } else if (element.detaEvent) { element. detachEvent (‘on’ + eventName, fn); } else { element[‘on’ + eventName] &#x3D; null; } 3.DOM事件流事件流描述的是从页面中接收事件的顺序。 事件发生时会在元素节点之间按照特定的顺字传播,这个传播过程即DOM事件流。 事件冒泡: IE最早提出,事件开始时由最具体的元素接收,然后逐级向上传播到到DOM最顶层节点的过程。 事件捕获:网景最早提出,由DOM最顶层节点开始,然后逐级向下传播到到最具体的元素接收的过程。 我们向水里面扔一块石头,首先它会有一个下降的过程,这个过程就可以理解为从最顶层向事件发生的最具体元素(目标点)的捕获过程;之后会产生泡泡,会在最低点(最具体元素)之后漂浮到水面上,这个过程相当于事件冒泡。 事件发生时会在元素节点之间按照特定的顺序传播,这个传播过程即DoM事件流。 注意. 1. Js代码中只能执行捕获或者冒泡其中的一个阶段。 2.onclick和attachEvent只能得到冒泡阶段 3.addEventListener (type, listenert, usecapture] ) 第三个参数如果是true ,表示在事件捕获阶段调用事件处理程序; 如果是false (不写默认就是false ) ,表示在事件冒泡阶段调用事件处理程序。 4,实际开发中我们很少使用事件捕获,我们更关注事件冒泡。 5,有些事件是没有冒泡的,比如onblur, onfocus, onmouseenter, onmouseleave 6·事件冒泡有时候会带来麻烦,有时候又会帮助很巧妙的做某些事件,我们后面讲解。 4.1什么是事件对象eventTarget. onclick &#x3D; function (event) {} &#x2F;&#x2F;这个event就是事件对象,我们还喜欢的写成e或者evt eventTarget.addEventListener (‘click’, function (event) {}) &#x2F;&#x2F;这个event就是事件对象,我们还喜欢的写成e或者evt 官方解释: event对象代表事件的状态 比如键盘按键的状态鼠标的位置、鼠标按钮的状态。 简单理解:事件发生后,跟事件相关的一系列信息数据的集合都放到这个对象里面,这个对象就是事件对象event,它有很多属性和方法。 比如： 1谁绑定了这个事件。 2鼠标触发事件的话,会得到鼠标的相关信息,如鼠标位置。 3键盘触发事件的话,会得到腱盘的相关信息,如按了哪个键。 这个event是个形参,系统帮我们设定为事件对象,不需要传递实参过去。 当我们注册事件时, event对象就会被系统自动创建,并依次传递给事件监听器(事件处理函数)。 4.3事件对象的兼容性方案事件对象本身的获取存在兼容问题: 1,标准浏览器中是浏览器给方法传递的参数,只需要定义形参e就可以获取到。 2.在1E6-8中,浏览器不会给方法传递参数,如果需要的话,需要到window.event中获取查找。 解决:e &#x3D;e Il window.event 4.4事件对象的常见属性和方法事件对象属性方法 说明 e.target 返回触发事件的对象标准 e.srcElement 返回触发事件的对象非标准1e6-8使用 e.type 返回事件的类型比如click mouseover不带on e.cancelBubble 该属性阻止冒泡非标准ie6-8使用 e.returnValue 该属性阻止默认事件(默认行为)非标准ie6-8使用比如不让链接跳转 e.preventDefault() 该方法阻止默认事件(默认行为)标准比如不让链接跳转 e.stopPropagation() 阻止冒泡标准 5.1阻止事件冒泡的两种方式事件冒泡:开始时由最具体的元素接收,然后逐级向上传播到到DOM最页层节点。 事件冒泡本身的特性,会带来的坏处,也会带来的好处,需要我们灵活掌握。 阻止事件冒泡标准写法: 利用事件对象里面的stopPropagation()方法 &#x2F;&#x2F;stop停止 Propagation 传播 e.cancelBubble &#x3D; true;&#x2F;&#x2F;cancel 取消bubble泡泡 5.2阻止事件冒泡的兼容性解决方案if (e &amp;&amp; e.stopPropagation) { e.stopPropagation(); }else{ window.event.cancelBubble &#x3D; true; } 6．事件委托（代理、委派)事件冒泡本身的特性,会带来的坏处,也会带来的好处,需要我们灵活掌握,生活中有如下场景: 咱们班有100个学生,快递员有100个快递,如果一个个的送花费时间较长。同时每个学生领取的时候,也需要排队领取，也花费时间较长,何如? 解决方案:快递员把100个快递,委托给班主任,班主任把这些快递放到办公室,同学们下课自行领取即可。 优势:快递员省事,委托给班主任就可以走了。同学们领取也方便,因为相信班主任。 事件冒泡本身的特性,会带来的坏处,也会带来的好处,需要我们灵活掌握。程序中也有如此场景: 1. 知否知否,应该有弹框在手 知否知否,应该有弹框在手 知否知否,应该有弹框在手 知否知否,应该有弹框在手 知否知否,应该有弹框在手 1. 点击每个li都会弹出对话框,以前需要给每个 注册事件,是非常辛苦的,而且访问DOM的次数越多,这就会延长整个页面的交互就绪时间。 事件委托事件委托也称为事件代理,在jQuery里面称为事件委派。 事件委托的原理(重要)不是每个子节点单独设置事件监听器,而是事件监听器设置在其父节点上,然后利用冒泡原理影响设置每个子节点。 以上案例:给ul注册点击事件,然后利用事件对象的target来找到当前点击的l1,因为点击li,事件会冒泡到ul上,ul有注册事件,就会触发事件监听器。 事件委托的作用我们只操作了一次DOM,提高了程序的性能。 7．常用的鼠标事件7.1常用的鼠标事件1.禁止鼠标右键菜单 contextmenu主要控制应该何时显示上下文菜单,主要用于程序员取消默认的上下文某单document.addEventListener (‘contextmenu’, function(e) { e.preventDefault (); }) 2.禁止鼠标选中( selectstart开始选中) document.addEventListener (‘selectstart’, function(e) { e.preventDefault (); }) 7.2鼠标事件对象event对象代表事件的状态,跟事件相关的一系列信息的集合。现阶段我们主要是用鼠标事件对象 MouseEvent和键盘事件对象KeyboardEvent. 鼠标事件对象 说明 e.clientx 返回鼠标相对于浏览器窗口可视区的×坐标 e.clientY 返回鼠标相对于浏览器窗口可视区的Y坐标 e.pagex 返回鼠标相对于文档页面的x坐标1E9+支持 e.pageY 返回鼠标相对于文档页面的Y坐标1E9+支持 e.screenX 返回鼠标相对于电脑屏幕的x坐标 e.screenY 返回鼠标相对于电脑屏幕的Y坐标 8.1常用键盘事件事件除了使用鼠标触发,还可以使用鍵盘触发。 键盘事件 触发条件 onkeyup 某个键盘按键被松开时触发 onkeydown 某个鍵盘按键被按下时触发 onkeypress 某个键盘按键被按下时触发 但是它不识别功能键比如ctrl shift箭头等 注意: 1,如果使用addEventListener不需要加on 2.onkeypress和前面2个的区别是,它不识别功能键,比如左右箭头, shift等。 3.三个事件的执行顺序是: keydown–keypress —keyup 8.2键盘事件对象键盘事件对象属性 说明 keyCode 返回该键的ASCII值 注意: onkeydown和onkeyup不区分字母大与, onkeypress区分字母大小写. 在我们实际开发中,我们更多的使用keydown和keyup ,它能识别所有的键(包括功能键) Keypress不识别功能键,但是keyCode属性能区分大小写,返回不同的ASCI值 BOM1.1什么是BOMBOM (Browser Object Model )即浏览器对象模型,它提供了独立于内容而与浏览器窗口进行交互的对象,其核心对象是window. BOM由一系列相关的对象构成,并且每个对象都提供了很多方法与属性。BOM缺乏标准, Javascript语法的标准化组织是ECMA, DOM的标准化组织是W3C, BOM最初是Netscape浏览器标准的一部分。 DOM 文档对象模型 DOM就是把「文档」当做一个「对象」来看待 DOM的顶级对象是document DOM主要学习的是操作页面元素 DOM是W3C标准规范 BOM 浏览器对象模型 把「浏览器」当做一个「对象」来看待 BOM的顶级对象是window BOM学习的是浏览器窗口交互的一些对象 BOM是浏览器厂商在各自浏览器上定义的,兼容性较差 вом比DOM更大,包含DOM. 1.2 BоM的构成 window对象是浏览器的顶级对象,它具有双重角色。 1,它是JS访问浏览器窗口的一个接口。 2,它是一个全局对象。定义在全局作用域中的变量、函数都会变成window对象的属性和方法。在调用的时候可以省略window ,前面学习的对话框都属于window对象方法,如alert(), prompt()等。 注意： window下的一个特殊属性window.name 2.1窗口加载事件window.onload &#x3D; function (){} 或者window.addEventListener (“load”, function () {}); window.onload是窗口(页面)加载事件,当文档内容完全加载完成会触发该事件(包括图像、脚本文件、CSs文件等),就调用的处理函数。 注意: 1,有了window.onload就可以把JS代码写到页面元素的上方,因为onload是等页面内容全部加载完毕,再去执行处理函数。 2. window.onload传统注册事件方式只能写一次,如果有多个,会以最后一个window.onload为准。 3,如果使用addEventnistener则没有限制 document.addEventListener (‘DOMContentLoaded’, function(){}) DOMContentLoaded事件触发时,仅当DOM加载完成,不包括样式表,图片, flash等等。le9以上才支持 如果页面的图片很多的话,从用户访问到onload触发可能需要较长的时间,交互效果就不能实现,必然影响用户的体验,此时用DOMContentloaded事件比较合适。 总结load等页面内容全部加载完毕,包含页面dom元素图片flash css等等DOMContentLoaded是DOM加载完毕,不包含图片falsh css等就可以执行加载速度比load更快一些 2.2调整窗口大小事件window.onresize &#x3D; function(){} window.addEventListener(“resize”, function(){}); window.onresize是调整窗口大小加载事件,当触发时就调用的处理函数。注意: 1,只要窗口大小发生像素变化,就会触发这个事件。 2,我们经常利用这个事件完成响应式布局.window.innerWidth当前屏幕的宽度 3.1两种定时器window对象给我们提供了2个非常好用的方法-定时器。 setTimeout() setlnterval() 3.2 setTimeout()定时器window.setTimeout (调用函数, [延迟的毫秒数]); setTimeout()方法用于设置一个定时器,该定时器在定时器到期后执行调用函数。 这个window在调用的时候可以省略 这个延时时间单位是毫秒但是可以省略,如果省略默认的是0 这个调用函数可以直接写函数还可以写函数名 还有一个写法,’函数名()’ &#x2F;&#x2F;我们不提倡这个写法 页面中可能有很多的定时器,我们经常给定时器加标识符(名字) setTimeout()这个调用函数我们也称为回调函数callback 普通函数是按照代码顺序直接调用。 而这个函数,需要等待时间,时间到了才去调用这个函数,因此称为回调函数。 简单理解:回调,就是回头调用的意思。上一件事干完,再回头再调用这个函数。 以前我们讲的element.onclick&#x3D;functiono(){}或者element.addeventistener(“clik”, fn);里面的函数也是回调函数。 3.3停止setTimeout()定时器（只调用一次）window.clearTimeout (timeoutID)—(定时器名字) clearTimeout (1)方法取消了先前通过调用setTimeout ()建立的定时器。 注意：1. window可以省略。 3.4 setInterval()定时器（重复调用）window.set Interval (回 函数, [间隔的毫秒数] ); setinterval()方法重复调用一个函数,每隔这个时间,就去调用一次回调函数。 注意： window可以省略 这个调用函数可以直接写函数,或者写函数名或者采取字符串函数名0三种形式。 间隔的毫秒数省略默认是0,如果写,必须是毫秒,表示每隔多少毫秒就自动调用这个函数。 因为定时器可能有很多,所以我们经常给定时器赋值一个标识符。 3.5停止setInterval()定时器window. clearInterval (intervalID); clearInterval ()方法取消了先前通过调用setInterval ()建立的定时器。 注意: 1.window可以省略。 2.里面的参数就是定时器的标识符。 3.6 thisthis的指向在函数定义的时候是确定不了的,只有函数执行的时候才能确定 this到底指向谁,一般情况下this的最终指向的是那个调用它的对象 现阶段,我们先了解一下几个this指向 1,全局作用域或者普通函数中this指向全局对象window (注意定时器里面的this指向window ) 4.JS执行机制4.1JS单线程JavaScript语言的一大特点就是单线程,也就是说,同一个时间只能做一件事。这是因为Javascript这门脚本语言诞生的使命所致-JavaScript是为处理页面中用户的交互,以及操作DOM而诞生的。比如我们对某个DOM元素进行添加和删除操作,不能同时进行。应该先进行添加,之后再删除。 单线程就意味着,所有任务需要排队,前一个任务结束,才会执行后一个任务。这样所导致的问题是:如果JS执行的时间过长,这样就会造成页面的渲染不连贯,导致页面渲染加载阻塞的感觉。 4.3同步和异步为了解决这个问题,利用多核CPU的计算能力, HTML5提出Web Worker标准,允许JavaScript脚本创建多个线程。于是，JS中出现了同步和异步。 同步 前一个任务结束后再执行后一个任务,程序的执行顺字与任务的排列顺序是一致的、同步的。比如做饭的同步做法:我们要烧水煮饭,等水开了(10分钟之后) ,再去切菜,炒菜。 异步 你在做一件事情时,因为这件事情会花费很长时间,在做这件事的同时,你还可以去处理其他事情。比如做饭的异步做法,我们在烧水的同时,利用这10分钟,去切菜,炒菜。 他们的本质区别：这条流水线上各个流程的执行顺序不同。 同步任务 同步任务都在主线程上执行,形成一个执行栈。 异步任务 JS的异步是通过回调函数实现的。 一般而言,异步任务有以下三种类型 1、普通事件,如click, resize等 2、资源加载,如load, error等 3、定时器,包括setInterval, setTimeout等 异步任务相关回调函数添加到任务队列中(任务队列也称为消息队列)。 4.4 JS执行机制1.先执行执行栈中的同步任务。 2异步任务(回调函数)放入任务队列中。 3,一旦执行栈中的所有同步任务执行完毕,系统就会按次序读取任务队列中的异步任务,于是被读取的异步任务结束等待状态,进入执行栈，开始执行。 由于主线程不断的重复获得任务、执行任务、再获取任务、再执行,所以这种机制被称为事件循环( event loop). 5.location对象5.1什么是location对象window对象给我们提供了一个location属性用于获取或设置窗体的URL ,并且可以用于解析URL。 因为这个属性返回的是一个对象,所以我们将这个属性也称为location对象。 5.2 URL统一资源定位符(Uniform Resource Locator, URL)是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL,它包含的信息指出文件的位置以及浏览器应该怎么处理它 URL的一股语法格式为: protocol:&#x2F;&#x2F;host [:port]&#x2F;path&#x2F; [?query]#fragment http://www.itcast.cn/index.html ?name-andysage&#x3D;18#link 组成 说明 protocol 通信协议常用的http,ftp,maito等 host 主机(域名) www.itheima.com port 端口号可选,省略时使用方案的默认端口如http的默认端口为80 path 路径由零或多个&#x2F;符号隔开的字符串,一般用来表示主机上的一个目录或文件地址 query 参数以键值对的形式,通过&amp;符号分隔开来 fragment 片段#后面内容常见于链接锚点 5.3 location对象的属性location对象属性 返回值 location.href 获取或者设置整个URL location. host 返回主机(域名) www.itheima.com location.port 返回端口号如果未写返回空字符串 location.pathname 返回路径 location. search 返回参数 location. hash 返回片段#后面内容常见于链接锚点 重点记住: href和search 5.4 location对象的方法location对象方法 返回值 location.assign() 跟href一样,可以跳转页面(也称为重定向页面) location.replace() 替换当前页面,因为不记录历史,所以不能后退页面 location.reload() 重新加载页面,相当于刷新按钮或者f5如果参数为true强制刷新ctrl+5 6.navigator对象navigator对象包含有关浏览器的信息,它有很多属性,我们最常用的是userAgent ,该属性可以返回由客户机发送服务器的user-agent头部的值。 下面前端代码可以判断用户那个终端打开页面,实现跳转 if ( (navigator. userAgent. match (&#x2F; (phone lpadl podl iPhone lipodl ios l iPad I Androidl tMobile IBlackBerryl IEMobi le IMOOBrowserl JuC I Fennec IwOSBrowser I BrowserNG| WebosI Symbian Iwindows Phone)&#x2F;i))) { window.location.href&#x3D;””;&#x2F;&#x2F;手机 } else { window. location.href &#x3D;””;&#x2F;&#x2F;电脑 } 7.history对象window对象给我们提供了一个history对象,与浏览器历史记录进行交互。该对象包含用户(在浏览器窗口中)访问过的URL history对象方法 作用 back() 可以后退功能 forward() 前进功能 go(参数) 前进后退功能参数如果是1前进1个页面如果是-1后退1个页面 1·元素偏移量offset系列1.1 offset概述offset 翻译过来就是偏移量,我们使用offset系列相关属性可以动态的得到该元素的位置(偏移)、大小等。 获得元素距离带有定位父元素的位置 获得元素自身的大小(宽度高度) 注意:返回的数值都不带单位 offset系列常用属性: offset系列属性 作用 element.offsetParent 返回作为该元素带有定位的父级元素如果父级都没有定位则返回body element.offsetTop 返回元素相对带有定位父元素上方的偏移 element.offsetLeft 返回元素相对带有定位父元素左边框的偏移 element.offsetWidth 返回自身包括padding、边框、内容区的宽度,返回数值不带单位 element.offsetHeight 返回自身包括padding、边框、内容区的高度,返回数值不带单位 1.2 offset与style区别offset offset可以得到任意样式表中的样式值 offset系列获得的数值是没有单位的 offsetwidth 包含padding+border+width offsetidth等属性是只读属性,只能获取不能赋值 所以,我们想要获取元素大小位置,用offset更合适 style style只能得到行内样式表中的样式值 style.width获得的是带有单位的字符串 style.width获得不包含padding和border 的值 style.width是可读写属性,可以获取也可以赋值 所以,我们想要给元素更改值,则需要用style改变 2,元素可视区client系列client翻译过来就是客户端,我们使用clent系列的相关属性来获取元素可视区的相关信息。通过client系列的相关属性可以动态的得到该元素的边框大小、元素大小等。 elient系列属性 作用 element.clientTop 返回元素上边框的大小 element.clientLeft 返回元素左边框的大小 element.clientWidth 返回自身包括padding、内容区的宽度,不含边框返回数值不带单位 element.clientHeight 返回自身包括padding、内容区的高度,不含边框,返回数值不带单位 3.立即执行函数立即执行函数 (functiono(){})() 或者 (function(){}()) 主要作用:创建一个独立的作用域。避免了命名冲突问题 案例：淘宝flexible.js源码分析下面三种情况都会刷新页面都会触发load事件。 1.a标签的超链接 2.F5或者刷新按钮(强制刷断) 3.前进后退按钮 但是火狐中,有个特点,有个”往返缓存” ,这个缓存中不仅保存着页面数据,还保存了DOM和JavaScript的状态;实际上是将整个页面都保存在了内存里。 所以此时后退按钮不能刷新页面。 此时可以使用pageshow事件来触发。,这个事件在页面显示时触发,无论页面是否来自缓存。在重新加载页面中, pageshow会在load或件触发后触发;根据事件对象中的persisted来判断是否是缓存中的页面触发的pageshow事件,注意这个事件给window添加。 3.1元素scroll系列属性scroll翻译过来就是滚动的,我们使用scroll系列的相关属性可以动态的得到该元素的大小、滚动距离等。 scroll系列属性 作用 element.scrollTop 返回被卷去的上侧距离,返回数值不带单位 element.scrollLeft 返回被卷去的左侧距离,返回数值不带单位 element.scrollWidth 返回自身实际的宽度,不含边框,返回数值不带单位 element.scrollHeight 返回自身实际的高度,不含边框,返回数值不带单位 内容的实际大小 3.2页面被卷去的头部如果浏览器的高(或宽)度不足以显示整个页面时,会自动出现滚动条。当滚动条向下滚动时,页面上面被隐藏掉的高度,我们就称为页面被卷去的头部。滚动条在滚动时会触发onscroll事件。 需要用到页面滚动事件scroll因为是页面滚动,所以事件源是document ②滚动到某个位置,就是判断页面被卷去的上部值。 3页面被卷去的头部:可以通过window.pageYoffset获得 如果是被卷去的左侧window.pagexoffset ④注意,元素被卷去的头部是element.scolTop,如果是页面被卷去的头部则是window.pageYofset 3,新方法window.pageroffset和window. pagexoffset , IE9开始支持 function getscroll() { return { left: window.pagexoffset I I document.documentElement.scrollleft II document.body.scrollleft I I0, top: window.pageYoffset II document.documentElement.scrollTop II document.body.scrollTop II0}; } 使用的时候getScroll ().left 三大系列总结三大系列大小对比 作用 element.offsetWidth 返回自身包括padding.(边框)内容区的宽度,返回数值不带单位 element.clientWidth 返回自身包括padding、内容区的宽度,不含边框,返回数值不带单位 element.scrollWidth 返回自身实际的宽度,不含边框,返回数值不带单位 他们主要用法: 1.offst系列经常用于获得元素位置offsetLeft offsetTop 2.client经常用于获取元素大小clientwidth clientHeight 3, scroll经常用于获取滚动距离scrollTop scrolleft 4,注意页面滚动的距离通过window.pagexoffset获得 mouseenter和mouseover的区别mouseenter鼠标事件当鼠标移动到元素上时就会触发mouseenter事件 类似mouseover,它们两者之间的差别是 mouseover鼠标经过自身盒子会触发,经过子盒子还会触发。mouseenter只会经过自身盒子触发 之所以这样,就是因为mouseenter不会冒泡 跟mouseenter搭配鼠标离开mouseleave同样不会冒泡 4．动画函数封装4.1动画实现原理核心原理:通过定时器setinterval()不断移动盒子位置。 实现步骤： 1获得盒子当前位置 2.让盒子在当前位置加上1个移动距离 3,利用定时器不断重复这个操作 4.加一个结束定时器的条件 5,注意此元素需要添加定位,才能使用element.style.left 4.2动画函数简单封装注意函数需要传递2个参数，动画对象和移动到的距离。 4.4缓动效果原理,缓动动画就是让元素运动速度有所变化,最常见的是让速度慢慢停下来 思路:1,让盒子每次移动的距离慢慢变小,速度就会慢慢落下来。 核心算法: (目标值·现在的位置) &#x2F; 10做为每次移动的距离步长 停止的条件是:让当前盒子位置等于目标位置就停止定时器 5．常见网页特效案例5.1节流阀防止轮播图按纽连续点击造成播放过快. 节流阀目的:当上一个函数动画内容执行完毕,再去执行下一个函鼓动画,让事件无法连续身发。 核心实现思路:利用回调函数,添加一个变量来控制,锁住函数和解锁函数 开始设置一个变量 var flag&#x3D; true; If(flag) (flag &#x3D; false; do somethng) 闭水龙头 利用回调函数动画执行完毕, flag&#x3D;true打开水龙头 移动端1.触屏事件1.1触屏事件概述移动端浏览器兼容性较好,我们不需要考虑以前JS的兼容性问题,可以放心的使用原生JS书写效果,但是移动端也有自己独特的地方。比如触屏事件touch (也称触摸事件) , Android和IOS都有。 touch对象代表一个触摸点。触摸点可能是一根手指,也可能是一根触摸笔。触屏事件可响应用户手指(或触空笔）对屏幕或者触控板操作。 触屏touch事件 说明 touchstart 手指触摸到一个DOM元素时触发 touchmove 手指在一个DOM元素上滑动时触发 touchend 手指从一个DOM元素上移开时触发 1.2触摸事件对象(TouchEvent )TouchEvent是一类描述手指在触莫平面(触摸屏、触莫板等)的状态变化的事件。这类事件用于描述一个或多个触点,使开发者可以检测触点的移动,触点的增加和减少,等等 touchstart, touchmove, touchend三个事件都会各自有事件对象。 触摸列表 说明 touches 正在触摸屏幕的所有手指的一个列表 targetTouches 正在触摸当前DOM元素上的手指的一个列表 changedTouches 手指状态发生了改变的列表,从无到有,从有到无变化 因为平时我们都是给元素注册触摸事件,所以重点记住targetTocuhes 1.3移动端拖动元素1.touchstart, touchmove, touchend可以实现拖动元素 2,但是拖动元素需要当前手指的坐标值我们可以使用targetTouches[0]里面的pagex和pageY 3,移动端拖动的原理: 手指移动中,计算出手指移动的距离。然后用盒子原来的位置+手指移动的距离 4,手指移动的距离:手指滑动中的位置减去手指刚开始触摸的位置 拖动元素三步曲: (1)触摸元素touchstart :获取手指初始坐标,同时获得盒子原来的位置 (2)移动手指touchmove :计算手指的滑动距离,并且移动盒子 (3)离开手指touchend: 注意:手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动e.preventDefault(); 2.移动端常见特效classList属性 classlist属性是HTML5新增的一个属性,返回元素的类名。但是ie10以上版本支持。 该属性用于在元素中添加,移除及切换CSS类。 有以下方法 添加类： element.classlist.add ( 类名” ) ; 移除类: element.classlist.remove (‘类名’ ); 切换类 element.classlist.toggle (‘类名’ ) ; 2.2 click延时解决方案移动端click事件会有300ms的延时,原因是移动端屏幕双击会缩放(double tapto zoom)页面。 解决方案:1,禁用缩放。浏览器禁用默认的双击缩放行为并且去掉300ms的点击延迟。 1. 2.利用touch事件自己封装这个事件解决300ms延迟。 原理就是: 1,当我们手指触摸屏幕,记录当前触摸时间 2,当我们手指离开屏幕,用离开的时间减去触莫的时间 3.如果时间小于150ms ,并且没有滑动过屏幕,那么我们就定义为点击 &#x2F;&#x2F;封装tap,解决click 300ms延时 function tap (obj, callback) { var isMove &#x3D; false; var startTime &#x3D;0; &#x2F;&#x2F;记录触摸时候的时间变量 obj.addeventListener (‘touchstart’, function (e){ startrime &#x3D; Date.now(); &#x2F;&#x2F;记录触摸时间 }); obj.addEventListener (‘touchmove’, function (e) { isMove &#x3D;true; &#x2F;&#x2F;看看是否有滑动,有滑动算拖拽,不算点击 }); obj.addeventListener (‘touchend’, function (e) { if (isMove &amp;&amp; (Date.now() -startTime) &lt; 150) { &#x2F;&#x2F;如果手指触摸和离开时间小于150ms算点击 callback &amp;&amp; callback(); &#x2F;&#x2F;执行回调函数 }isMove &#x3D; false; &#x2F;&#x2F; 取反重置 startTime &#x3D; 0; }); &#x2F;&#x2F;调用 tap(div, function(){ &#x2F;&#x2F;执行代码}); 3.移动端常用开发插件3.1什么是插件移动端要求的是快速开发,所以我们经常会借助于一些插件来帮我完成操作,那么什么是插件呢? Js插件是js文件,它遵循一定规范编写,方便程序展示效果,拥有特定功能目方便调用。如轮播图和瀑布流插件。 特点:它一般是为了解决某个问题而专门存在,其功能单一,并且比较小。 我们以前写的animatejs也算一个最简单的插件 fastclick插件解决300ms延迟。使用延时 GitHub官网地址: https://github.com/ftlabs/fastclick 3.3 Swiper插件的使用中文官网地址: https://www.swiper.com.cn/1. 引入插件相关文件 按照规定语法使用 3.4其他移动端常见插件superslide : http://www.superslide2.com/ iscroll: https://github.com/cubiq/iscroll 3.5插件的使用总结1,确认插件实现的功能 2,去官网查看使用说明 3.下载插件 4,打开demo实例文件,查看需要引入的相关文件,并且引入 5.复制demo实例文件中的结构html,样式ss以及s代码 3.6练习移动端视频插件zy.media.jsH5给我们提供了video标签,但是浏览器的支持情况不同。 不同的视频格式文件,我们可以通过source解决。 但是外观样式,还有暂停,播放,全屏等功能我们只能自己写代码解决。 这个时候我们可以使用插件方式来制作。 4.移动端常用开发框架4.1框架概述框架,顾名思义就是一套架构,它会基于自身的特点向用户提供一套较为完整的解决方案。框架的控制权在框架本身,使用者要按照框架所规定的某种规范进行开发。 插件一般是为了解决某个问题而专门存在,其功能单一,并且比较小。 前端常用的框架有Bootstrap, Vue, Angular, React等。既能开发PC端,也能开发移动端 前端常用的移动端插件有swiper, superslide, iscrol等 框架:大而全,一整套解决方案 插件：小而专一,某个功能的解决方案 4.2 BootstrapBootstrap是一个简洁、直观、强悍的前端开发框架,它让web开发更迅速、简单。它能开发PC端,也能开发移动端 Bootstrap JS插件使用步骤: 1,引入相关js文件 2.复制HTML结构 3,修改对应样式 4,修改相应JS参数 1.本地存储随着互联网的快速发展,基于网页的应用越来越普遍,同时也变的越来越复杂,为了满足各种各样的需求,会常性在本地存储大量的数据, HTMI5规范提出了相关解决方案 本地存储特性 1、数据存储在用户浏览器中 2、设置、读取方便、甚至页面刷新不丢失数据 3、容量较大, sessionStorage约5M, localstorage约20M 4、只能存储字符串,可以将对象JSON.stringifyo编码后存储 2.window.sessionStorage 1.生命周期为关闭浏览器窗口 2.在同一个窗口(页面)下数据可以共享 3,以键值对的形式存储使用 存储数据： sessionStorage.setltem(key, value) 获取数据: sessionStorage.getitem(key) 删除数据: sessionStorage.removeltem(key) 删除所有数据: sessionStorage.clear() 3.window.localStorage.1、生命周期永久生效,除非手动删除否则关闭页面也会存在 2、可以多窗口(页面)共享(同一浏览器可以共享) 3,以键值对的形式存储使用 存储数据: localStorage.setitem(key, value) 获取数据: localStorage.getltem(key) 删除数据: localStorage.removeltem(key) 删除所有数据: localStorage.clear()","categories":[{"name":"前端","slug":"前端","permalink":"https://2486125878.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://2486125878.github.io/tags/javascript/"}]},{"title":"服务器的基本概念与初识Ajax","slug":"ajax","date":"2024-03-13T07:13:48.000Z","updated":"2024-03-13T08:42:06.000Z","comments":true,"path":"2024/03/13/ajax/","permalink":"https://2486125878.github.io/2024/03/13/ajax/","excerpt":"","text":"1.客户端与服务器1.2服务器上网过程中,负责存放和对外提供资源的电脑,叫做服务器。 1.3客户端上网过程中,负责获取和消费资源的电脑,叫做客户端。 2.URL地址2.1 URL地址的概念URL (全称是UniformResourcelocator)中文叫统一资源定位符,用于标识互联网上每个资源的唯一存放位置。浏览器只有通过URL地址,才能正确定位资源的存放位置,从而成功访问到对应的资源。 常见的URL举例: http://www.baidu.com http://www.taobao.com http://www.cnblogs.com/liulongbinblogs/p/11649393.html 2.2 URL地址的组成部分URL地址一般由三部组成: ①客户端与服务器之间的通信协议 ②存有该资源的服务器名称 ③资源在服务器上具体的存放位置 3·客户端与服务器的通信过程3.1图解客户端与服务器的通信过程客户端与服务器之间的通信过程,分为请求一处理一响应三个步骤。 网页中的每一个资源,都是通过请求-处理-响应的方式从服务器获取回来的。 3.2基于浏览器的开发者工具分析通信过程1,打开Chrome浏览器 2.Ctrl+Shift+1打开Chrome的开发者工具 3·切换到Network面板 4.选中Doc页签5,刷新页面,分析客户端与服务器的通信过程 4.服务器对外提供了哪些资源4.1例举网页中常见的资源文字内容Image 图片Audio音频Video视频 4.2数据也是资源网页中的数据,也是服务器对外提供的一种资源。例如股票数据、各行业排行榜等。 数据是网页的灵魂HTML是网页的骨架 CSS是网页的颜值 Javascript是网页的行为 数据,则是网页的灵魂 骨架、颜值、行为質为数据服务数据,在网页中无处不在 4.4网页中如何请求数据数据,也是服务器对外提供的一种资源。只要是资源,必然要通过请求一处理-响应的方式进行获取。 如果要在网页中请求服务器上的数据资源,则需要用到XMLHttpRequest对象。 XMLHttpRequest (简称xhr)是浏览器提供的js成员,通过它,可以请求服务器上的数据资源。 12//最简单的用法var xhrObj= new XMLHttpRequest() 4.5资源的请求方式客户端请求服务器时,请求的方式有很多种,最常见的两种请求方式分别为get和post请求。 get请求通常用于获取服务端资源(向服务器要资源) 例如:根据URL地址,从服务器获取HTML文件、css文件、js文件、图片文件、数据资源等 post请求通常用于向服务器提交数据(往服务器发送资源) 例如:登录时向服务器提交的登录信息、注册时向服务器提交的注册信息、添加用户时向服务器提交的用户信息等各种数据提交操作 5.了解Ajax5.1 什么是 AjaxAjax的全称是Asynchronous Javascript And XML (异步JavaScript和XML) 通俗的理解:在网页中利用XMLHttpRequest对象和服务器进行数据交互的方式,就是Ajax. 5.2为什么要学Ajax之前所学的技术,只能把网页做的更美观漂亮,或添加一些动画效果,但是, Ajax能让我们轻松实现网页与服务器之间的数据交互。 5.3 Ajax的典型应用场景用户名检测:注册用户时,通过ajax的形式,动态检测用户名是否被占用 搜索提示:当输入搜索关键字时,通过ajax的形式,动态加载搜索提示列表 数据分页显示:当点击页码值的时候,通过ajax的形式,根据页码值动态刷新表格的数据 数据的增删改查:数据的添加、删除、修改、查询操作,都需要通过ajax的形式,来实现数据的交互 6.jQuery 的Ajax6.1了解jQuery中的Ajax浏览器中提供的XMLHttpRequest用法比较复杂,所以jQuery对XMLHtpRequest进行了封装,提供了一系列Ajax相关的函数,极大地降低了Ajax的使用难度。 jQuery中发起Ajax请求最常用的三个方法如下: 12345$.get()$.post()$.ajax() 6.2$.get()函数的语法jQuery 中$.get0函数的功能单一,专门用来发起get请求,从而将服务器上的资源请求到客户端来进行使用。 123$.get()函数的语法如下:$.get (url, [data], [callback]) 其中,三个参数各自代表的含义如下: 参数名 参数类型 是否必选 说明 url string 是 要请求的资源地址 data object 否 请求资源期间要携带的参数 callback function 否 请求成功时的回调函数 6.2 $.get()发起不带参数的请求使用$.get()函数发起不带参数的请求时,直接提供请求的URL地址和请求成功之后的回调函数即可,示例代码如下: 12345$.get (&#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;, function (res) &#123;(console.log (res) //这里的res是服务器述回的数据&#125;) 6.2 $.get()发起带参数的请求使用$.get()函数发起带参数的请求时,示例代码如下: 12345$.get (&#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;, &#123; id: 1 &#125;, function (res)&#123;console.log (res)&#125;) 6.3 $.post0函数的语法jQuery中$.post()函数的功能单一,专门用来发起post请求,从而向服务器提交数据。 123//$.post0函数的语法如下:$.post (url, [data], [callback]) 其中,三个参数各自代表的含义如下: 参数名 参数类型 是否必选 说明 url string 是 要提交的资源地址 data object 否 要提交的数据 callback function 否 数据提交成功时的回调函数 6.3 $.post()向服务器提交数据使用$posto向服务器提交数据的示例代码如下: 12345678910$:post(&#x27;http://www.liulongbin.top:3006/api/addibook&#x27;, // 请求的URL地址&#123; bookname: 水浒传., author: 施耐庵., publisher: &#x27;上海图书出版社&#x27;&#125;, //提交的数据function (res) &#123;//回调函数console.log (res)&#125;&#125; 6.4 $.ajax()函数的语法相比于$.get()和$.post()函数, jQuery中提供的$.ajax()函数,是一个功能比较综合的函数,它允许我们对Ajax请求进行更详细的配置。 12345678910111213$.ajax()函数的基本语法如下:$.ajax(&#123;type: &#x27;&#x27;, //请求的方式,例如GET或POSTurl; &#x27;&#x27; ,//请求的URL地址data: &#123;&#125;,//这次请求要携带的数据success: function (res) &#123;&#125;//请求成功之后的回调函数&#125;) 6.4使用$.ajax()发起GET请求使用12345678910111213141516$.ajax()起GET请求时,只需要将type属性的值设置为,GET,即可:$.ajax(&#123;type: &#x27;GET&#x27;, //请求的方式url: &#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;, //请求的URL地址data: &#123;id: 1&#125;,//这次请求要携带的数据success: function (res) &#123; //请求成功之后的回调函数console. log (res)&#125;&#125;) 6.4使用$.ajax()发起POST请求使用123456789101112131415161718192021222324//$.ajax()起GET请求时,只需要将type属性的值设置为,post,即可:$. ajax(&#123;type: &#x27;POST&#x27;, //请求的方式url: &#x27;http://www.liulongbin.top:3006/api/addbooks&#x27;, //请求的URL地址data: &#123;//提交给服务器的数据bookname: ‘水浒传’,author: ‘施耐庵’,publisher: &#x27;上海图书出版社&#x27;&#125;,success: function (res) &#123; //请求成功之后的回调函数**console. log (res)&#125;&#125;) 7.接口7.1接口的概念使用Ajax请求数据时,被请求的URL地址,就叫做数据接口(简称接口) 。同时,每个接口必须有请求方式。 例如: http://www.liulongbin.top:3006/api/getbooks 获取图书列表的接口(GET请求) http://www.liulongbin.top:3006/api/adabook 添加图书的接口(post请求) 7.2分析接口的请求过程1,通过GET方式请求接口的过程 2.通过POST方式请求接口的过程 7.3接口测试工具1,什么是接口测试工具 为了验证接口能否被正常被访问,我们常常需要使用接口测试工具,来对数据接口进行检测。 好处:接口测试工具能让我们在不写任何代码的情况下,对接口进行调用和测试。 2.下载并安装PostMan 访问PostMan的官方下载网址https://www.getpostman.com/downloadsl,下载所需的安装程序后,直接安装即可。 7.5使用PostMan测试POST接口步骤: 1选择请求的方式 2.填写请求的URL地址” 3.选择Body面板并勾选数据格式 4,填写要发送到服务器的数据 5·点击Send按钮发起POST请求 7.6接口文档1.什么是接口文档 接口文档,顾名思义就是接口的说明文档,它是我们调用接口的依据。好的接口文档包含了对接口URL,参数以及输出内容的说明,我们参照接口文档就能方便的知道接口的作用,以及接口如何进行调用。 2,接口文档的组成部分 接口文档可以包含很多信息,也可以按需进行精简,不过,一个合格的接口文档,应该包含以下6项内容,从而为接口的调用提供依据: 1, 接口名称:用来标识各个接口的简单说明,如登录接口,获取图书列表接口等。 2.接口URL:接口的调用地址。 3.调用方式:接口的调用方式,如GET或POST. 4·参数格式:接口需要传递的参数,每个参数必须包含参数名称、参数类型、是否必选、参数说明这4项内容。 5· 响应格式:接口的返回值的详细描述,一般包含数据名称、数据类型、说明3项内容。 6,返回示例(可选) :通讨对象的形式,例举服务器返回数据的结构。 8.案例-图书管理8.2案例用到的库和插件用到的css库bootstrap.css 用到的javascript库jquery.js 用到的vs code插件Bootstrap 3 Snippets 8.3渲染图书列表(核心代码)1234567891011121314151617181920212223242526function getBookList () &#123;//1.发起ajax请求获取图书列表数据$.get (&#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;, function(res)&#123;//2.获取列表数据是否成功if (res.status !== 200) return alert(&#x27;获取图书列表失败! &quot;)//3.渲染页面结构var rows = []$.each(res.data, function(i, item) &#123;// 4.循环拼接字符串rows.push(&#x27;&lt;tr&gt;&lt;td&gt;&#x27; + item.id + &#x27;&lt;/td&gt;&lt;td&gt;&#x27; + item.bookname +&#x27;&lt;/td&gt;&lt;td&gt;&#x27; + item.author + &#x27;&lt;/td&gt;&lt;td&gt;&#x27; + item.publisher + &#x27;&lt;/td&gt;&lt;td&gt;&lt;a href=&quot;javascript:; &quot;&gt;删除&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&#x27;)&#125;)$ (&#x27;#bookBody&#x27; ) .empty () .append (rows.join ( &#x27;&#x27;)) // 5,渲染表格结构&#125;)&#125; 1.form表单的基本使用1.1什么是表单表单在网页中主要负责数据采集功能。HTMIL中的标签,就是用于采集用户输入的信息,并通过标签的提交操作,把采集到的信息提交到服务器端进行处理。 1.2表单的组成部分表单由三个基本部分组成: 表单标签 表单域 表单按钮 表单域:包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框和文件上传框等。 1.3 标签的属性1.标签用来采集数据, 标签的属性则是用来规定如何把采集到的数据发送到服务器。 属性 值 描述 action URL地址 规定当提交表单时,向何处发送表单数据 method get或post 规定以何种方式把表单数据提交到action URL enctype application&#x2F;x-www-form-urlencoded 规定在发送表单数据之前如何对其进行编码 ​ multipart&#x2F;form-data ​ text&#x2F;plain **target _blank 规定在何处打开action URL 在新窗口中打开。 ** ​ _self 默认。在相同的框架中打开。 ​ _parent 在父框架集中打开。(很少用) ​ _top 在整个窗口中打开。(很少用) ​ _framename 在指定的框架中打开。(很少用) 1.action action属性用来规定当提交表单时,向何处发送表单数据。 action属性的值应该是后端提供的一个URL地址,这个URL地址专门负责接收表单提交过来的数据。 当表单在未指定action属性值的情况下, action的默认值为当前页面的URL地址。 注意:当提交表单后,页面会立即跳转到action属性指定的URL地址 2.target target属性用来规定在何处打开action URL. 它的可选值有5个,默认情况下, target的值是_self,表示在相同的框架中打开action URL. 3, method method属性用来规定以何种方式把表单数据提交到action URL 它的可选值有两个,分别是get和post. 默认情况下, method的值为get,表示通过URL地址的形式,把表单数据提交到action URL. 注意:get方式适合用来提交少量的、简单的数据。 post方式绩合用来提交大量的、复杂的、或包含文件上传的数据。 在实际开发中, 表单的past提交方式用的最多,很少用get,例如登录、注册、添加数据等表单操作,都需要使用post方式来提交表单。 4.enctype enctype属性用来规定在发送表单数据之前如何对数据进行编码 它的可选值有三个,默认情况下, enctype的值为application&#x2F;x-www-form-urlencoded,表示在发送前编码所有的字符。 **enctype application&#x2F;x-www-form-urlencoded 在发送前编码所有字符(默认) ** ​ multipart&#x2F;form-data 不对字符编码。在使用包含文件上传控件的表单时,必须使用该值。 ​ text&#x2F;plain 空格转换为”+”加号,但不对特殊字符编码。(很少用) 注意: 在涉及到文件上传的操作时,必须将enctype的值设置为multipart&#x2F;form-data 如果表单的提交不涉及到文件上传操作,则直接将enctype的值默认设置为application&#x2F;x-www-form-urlencoded 即可 1.4表单的同步提交及缺点’1.什么是表单的同步提交 通过点击submit按钮,触发表单提交的操作,从而使页面跳转到action URL的行为,叫做表单的同步提交。 2,表单同步提交的缺点 1.1.表单同步提交后,整个页面会发生跳转,跳转到action URL所指向的地址,用户体验很差。 1.2.表单同步提交后,页面之前的状态和数据会丢失。 3,如何解决表单同步提交的缺点 解决方案:表单只负责采集数据, Ajax负责将数据提交到服务器。 2.通过Ajax提交表单数据2.1监听表单提交事件在jQuery 中,可以使用如下两种方式,监听到表单的提交事件: $(‘#form1’).submit (function (e){ alert (‘监听到了表单的提交事件’) }) $(‘#form1’).on (‘submit’, function(e) { alert (“监听到了表单的提交事件’’) }) 2.2阻止表单默认提交行为当监听到表单的提交事件以后,可以调用事件对象的event.preventDefaulto函数,来阻止表单的提交和页面的跳转,示例代码如下: $(‘#forml’) .subpit (function (e) { &#x2F;&#x2F;阻止表单的提交和页面的跳转 e.preventDefault () }) $(‘#form1’).on (‘submit’, function(e){ &#x2F;&#x2F;阻止表单的提交和页面的跳转 e.preventDefault () }) 2.3快速获取表单中的数据1.serialize()函数 为了简化表单中数据的获取操作, jQuery提供了 serialize0函数,其语法格式如下: 1$ (selector).serialize () serializeo函数的好处:可以一次性获取到表单中的所有的数据。 2.serialize()函数示例 提交 1$(&#x27;#forml &#x27;).serialize () &#x2F;&#x2F;调用的结果: &#x2F;&#x2F; username&#x3D;用户名的值&amp;password&#x3D;密码的值 注意:在使用serialize()函数快速获取表单数据时,必须为每个表单元素添加name属性! 4,模板引擎的基本概念4.1渲染U1结构时遇到的问题题123456789var rows = []$.each(res.data, function (i, item) &#123; //循环拼接字符串rows.push(&#x27;&lt;li class=&quot;list-group-item&quot;&gt;&#x27;+ item.content +&#x27;&lt;span class=&quot;badgecmt-date&quot;&gt;评论时间: &#x27;+ item.time +&#x27;&lt;/span&gt;&lt;span class=&quot;badge cnt-person&quot;&gt;评论人: &#x27;+item. usernane +&#x27;&lt;/span&gt;&lt;/li&gt;&#x27;)&#125;)$(&#x27;#cmt-list&#x27; ) .empty () . append (rows.join (&#x27; &#x27;)) //渲染列表的UI结构 上述代码是通过字符串拼接的形式,来渲染UI结构 如果UI结构比较复杂,则拼接字符串的时候需要格外注意引号之前的嵌套。且一旦需求发生变化,修改起来也非常麻烦。 4.2什么是模板引擎模板引擎,顾名思义,它可以根据程序员指定的模板结构和数据,自动生成一个完整的HTML页面。 4.3模板引擎的好处减少了字符串的拼接操作 使代码结构更清晰 使代码更易于阅读与维护 5.art-template模板引擎5.1 art-template简介art-template是一个简约、超快的模板引擎。中文官网首页为http://aui.github.io/art-template/zh-cn/index.html 5.3 art-template模板引擎的基本使用1,使用传统方式渲染U1结构 123456789101112131415var data = &#123;title: &#x27;&lt;h3&gt;用户信息&lt;/h3&gt;&#x27;,name: &#x27;zs&#x27;, age: 20 ,isvIP: true,regrime: new Date (),hobby: [&#x27;吃饭&quot;,&#x27; 睡觉&#x27;, &#x27;打豆豆&#x27;]&#125; 2.art-template的使用步骤 导入 art-template 定义数据 定义模板 调用template函数 渲染HTML结构 5.4 art-template标准语法1.什么是标准语法art-template提供了 1这种语法格式,在&#123;&#123;&#125;&#125;内可以进行变量输出,或循环数组等操作,这种&#123;&#123;&#125;&#125;语法在art-template中被称为标准语法。 2.标准语法-输出 1234567&#123;&#123;value&#125;&#125;&#123;&#123;obj.key&#125;&#125;&#123;&#123;obj[&#x27;key&#x27;]&#125;&#125;&#123;&#123;a?b: c&#125;&#125;&#123;&#123;a || b&#125;&#125;&#123;&#123;a+b&#125;&#125;在&#123;&#123;&#125;&#125;语法中,可以进行变量的输出、对象属性的输出、三元表达式输出、逻辑或输出、加减乘除等表达式输出 3.标准语法-原文输出 1&#123;&#123;@ value &#125;&#125; 如果要输出的value值中,包含了HTML标签结构,则需要使用原文输出语法,才能保证HTML标签被正常渲染。 4,标准语法-条件输出 12345如果要实现条件输出,则可以在&#123;&#123;&#125;&#125;中使用if ...else if...../if进行按需输出。&#123;&#123;if value&#125;&#125;按需输出的内容&#123;&#123;/if&#125;&#125;&#123;&#123;if v1&#125;&#125;按需输出的内容&#123;&#123;else if v2&#125;&#125;按需输出的内容&#123;&#123;/if&#125;&#125; 5·标准语法-循环输出 1234567如果要实现循环输出,则可以在&#123;&#123;&#125;&#125;内,通过each语法循环数组,当前循环的索引使用$index进行访问,当前的循环项使用$value进行访问。&#123;&#123;each arr&#125;&#125;&#123;&#123;$index)&#125; &#123;&#123;$value&#125;&#125;&#123;&#123;/each)&#125; 6．标准语法-过滤器 需处理的值———–参数——–过滤器函数———返回值———–输出新值 过滤器的本质,就是一个function处理函数。 1&#123;&#123;value | filterName &#125;&#125; 过滤器语法类似管道操作符,它的上一个输出作为下一个输入。 定义过滤器的基本语法如下: 1template.defaults.imports.filterName = function (value) &#123;/*return处理的结果*/&#125; 定义一个格式化时间的过滤器dateFormat如下: 123456//1.&lt;div&gt;注册时间: &#123;iregTime | dateFormat)&#125;&lt;/div&gt;template.defaults.imports.dateFoxmat = function (date)&#123; var y = date.getFullYear() var m = date.getMonth() +1 var d = date.getDate () return y+&#x27;-&#x27;+m+&#x27;-&#x27;+d //注意,过滤器最后一定要return一个值 6.模板引擎的实现原理6.1正则与字符串操作1,基本语法 exec()函数用于检索字符串中的正则表达式的匹配。 如果字符串中有匹配的值,则返回该u配值,否则返回null. RegExpobject.exec (string) 示例代码如下: 1234567var str = &#x27;hello&#x27;var pattern =/o///输出的结果[&quot;o&quot;, index: 4, input: &quot;hello&quot;, groups: undefined]console.log (pattern.exec (str)). 2.分组 正则表达式中()包起来的内容表示一个分组,可以通过分组来提取自己想要的内容,示例代码如下: 123456var str =&#x27;&lt;div&gt;我是 &#123;&#123;name)&#125;&lt;/div&gt;&#x27;var pattern = /&#123;&#123;([a-zA-Z]+) &#125;&#125;/var patternResult = pattern.exec(str)console.log (patternResult)//得到name相关的分组信息// [&quot;&#123;&#123;name&#125;&#125; &#125;&quot;, &quot;name&quot;, index: 7, input: &quot;&lt;div&gt;我是&#123;&#123;name&#125;&#125;&lt;/div&gt;&quot;, groups: undefined] 3.字符串的replace函数 replace()函数用于在字符串中用一些字符替换另一些字符,语法格式如下: 1var result = &#x27;123456. .replace (&#x27;123&#x27;, &#x27;abc&#x27;) //的result的值为字符串&#x27;abc456 示例代码如下 123456var str =&#x27;&lt;div&gt;我是&#123;&#123;nane&#125;&#125;&lt;/div&gt;&#x27;var pattern = / &#123;&#123;([a-zA-Z]+)&#125;&#125;/var patternResult = pattern.exec (str)str = str.replace (patternResult [0], patternResult [1]) // replace函数返回值为替换后的新字符串//输出的内容是: &lt;div&gt;我是name&lt;/div&gt;console. log (str) 4.多次replace 12345678910var str=&#x27;&lt;div&gt;&#123;&#123;name&#125;&#125;今年&#123;&#123; age &#125;&#125;岁了&lt;/div&gt;&#x27;var pattern = /&#123;&#123;\\s*([a-zA-Z]+)\\s*&#125;&#125;/var patternResult = pattern.exec (str)str = str.replace (patternResult [0], patternResult [1])console.1og (str) //输出&lt;div&gt;name今年&#123;&#123;age &#125;&#125;岁了&lt;/div&gt;patternResult = pattern.exec (str)str = str.replace (patternResult [0], patternResult [1])console.log (str) //输出&lt;div&gt;name今年age岁了&lt;/div&gt;patternResult = pattern.exec (str)console.log (patternResult) //输出null 5,使用while循环replące 1234567var str = &#x27;&lt;div&gt;&#123;&#123;name&#125;&#125;今年&#123;&#123; age &#125;&#125;岁了&lt;/div&gt;&#x27;var pattern = /&#123;&#123;\\s*([a-zA-Z]+)\\s*&#125;)/var patternResult = nullwhile (patternResult = pattern.exec (str) ) &#123; str = str.replace (patternResult [0], patternResult [1])&#125; console.1og (str) //输出&lt;div&gt;name今年age岁了&lt;/div&gt; 6.replace替换为真值 12345678var data&#123;name:&#x27;张三&#x27;,age:20&#125;var str = &#x27;&lt;div&gt;&#123;&#123;name&#125;&#125;今年&#123;&#123; age &#125;&#125;岁了&lt;/div&gt;&#x27;var pattern = /&#123;&#123;\\s*([a-zA-Z]+)\\s*&#125;)/var patternResult = nullwhile (patternResult = pattern.exec (str) ) &#123; str = str.replace (patternResult [0], data[patternResult[1]])&#125; console.1og (str) //输出&lt;div&gt;name今年age岁了&lt;/div&gt; 6.2实现简易的模板引擎1,实现步骤 定义模板结构 预调用模板引擎 封装template函数 导入并使用自定义的模板引擎 2,定义模板结构 123456&lt;script type=&quot;text/html&quot; id=&quot;tpl-user&quot;&gt; &lt;div&gt;姓名: &#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;div&gt;年龄: &#123;&#123; age &#125;&#125;&lt;/div&gt; &lt;div&gt;性别: &#123;&#123;gender&#125;&#125;&lt;/div&gt; &lt;div&gt;住址: &#123;&#123;address &#125;&#125;&lt;/div&gt;&lt;/script&gt; 3.预调用模板引擎 12345678&lt;script&gt; //定义数据 var data =&#123; name: &#x27;zs&#x27;, age: 28, gender: &#x27;男&#x27;, address: &#x27;北京顺义马坡&#x27; &#125; //调用模板函数 var htmlstr = template (&#x27;tpl-user&#x27;, data) //渲染HTMI结构 document.getElementById (&#x27;user-box&#x27;).innerHTML = htmlstr &lt;/script&gt; 4.封装template函数 12345678function template (id,data)&#123; var str = document.getElementById (id).innerHTML var pattern =/&#123;&#123;\\s*([a-zA-Z]+)\\s*&#125;&#125;/ var pattResult = null while (pattResult = pattern.exec (str))&#123; str =str.replace (pattResult [0], data[pattResult [1])&#125; return str 5,导入并使用自定义的模板引擎 # 1.XMLHttpRequest的基本使用 ## 1.1什么XMLHttpRequest **XMLHtpRequest (简称xhr)是浏览器提供的Javascript对象,通过它,可以请求服务器上的数据资源。之前所学的jQuery中的Ajax函数,就是基于xhr对象封装出来的。** ## **1.2使用xhr起GET请求** **步骤** **创建xhr对象** **调用xhr.open()函数** **调用xhr.send()函数** **听xhr.onreadystatechange事件** 1234567891011121314//1.创建XHR对象var xhr =new XMLHttpRequest ()//2.调用open函数,指定请求方式与URL地址xhr.open (&#x27;GET&#x27;, &#x27;http://www.liulongbin.top:3006/api/getbooks &#x27;)//3.调用send函数,发起Ajax请求xhr.send ()// 4.监听onreadystatechange事件xhr.onreadystatechange = function()&#123; //4.1监听xhr对象的请求状态readystate ;与服务器响应的状态status if (xhr.readystate === 4 &amp;&amp; xhr.status === 200) &#123; //4.2打印服务器响应回来的数据 console.log(xhr.resnserext) &#125;&#125; ## 1.3了解xhr对象的readyState属性 **XMLHttpRequest对象的readyState属性,用来表示当前Ajax请求所处的状态。每个Ajax请求必然处于以下状态中的一个:** **值 状态 描述** **0 UNSENT XMLHtpRequest对象已被创建,但尚未调用open方法。** **1 OPENED open()方法已经被调用。** **2 HEADERS_RECEIVED send()方法已经被调用,响应头也已经被接收。** **3 LOADING 数据接收中,此时response属性中已经包含部分数据。** **4 DONE Ajax请求完成,这意味着数据传输已经彻底完成或失败** ## 1.4使用xhr发起带参数的GET请求 123// ……省略不必要的代码xhr.open (&#x27;GET&#x27;, &#x27;http://www.liulongbin.top:3006/api/getbooks?id=1&#x27;)// ….省略不必要的代码 **这种在URL地址后面拼接的参数,叫做查询字符串** ## 1.5查询字符串 **1,什么是查询字符串** **定义:查询字符串(URL参数)是指在URL的末尾加上用于向服务器发送信息的字符串(变量)** **格式:将英文的?放在URL的末尾,然后再加上参数=值,想加上多个参数的话,使用&符号进行分隔。以这个形式,可以将想要发送给服务器的数据添加到URL中。** 123456//不带参数的URL地址http://www.liulongbin.top: 3006/api/getbooks//带一个参数的URL地址http://www.liulongbin.top: 3006/api/getbooks?id=1//带两个参数的URL地址http://ww.1iulongbin.top:3006/api/getbooks?id=1&amp;bookname=西游记 **2.GET请求携带参数的本质** **无论使用S.ajax(),还是使用$.get(),又或者直接使用xhr对象发起GET请求,当需要携带参数的时候,本质上,都是直接将参数以查询字符串的形式,追加到URL地址的后面,发送到服务器的。** 1234567$.get (&#x27;url&#x27;, (name: &#x27;zs&#x27;, age: 20), function() &#123;&#125;)//等价于$.get (&#x27;url?name=zs&amp;age=20&#x27;, function() &#123;&#125;)$.ajax(&#123; method: &#x27;GET&#x27;, url: &#x27;url&#x27;, data: &#123;name: &#x27;zs&#x27;, age: 20&#125;, success: function() &#123;&#125;&#125;)//等价于$.ajax(&#123;method: &#x27;GET&#x27;, url: &#x27;url?name=zs&amp;age=20&#x27;, success: function() &#123;&#125;&#125;) ## 1.6 URL编码与解码 **1.什么是URL编码** **URL地址中,只允许出现英文相关的字母、标点符号、数字,因此,在URL地址中不允许出现中文字符。** **如果URL中需要包念中文这样的字符,则必须对中文字符进行编码(转义)** **URL编码的原则:使用安全的字符(没有特殊用途或者特殊意义的可打印字符)去表示那些不安全的字符。** **URL编码原则的通俗理解:使用英文字符去表示非英文字符。** 12345http://ww.liulongbin.top:3006/api/getbooks?id=1&amp;bookname=西游记//经过URL编码之后, URL地址变成了如下格式 http://www.liulongbin.top:3006/api/getbooks?id=1&amp;bookname=%E8%A5%BF %BF%B%BF%BF%BF%BF 2,如何对URL进行编码与解码 浏览器提供了URL编码与解码的API,分别是: encodeURI()编码的函数 decodeURI()解码的函数 1234encodeURI (&#x27;黑马程序员&#x27;)//输出字符串E9BB91E9A9ACE7AB8BE5BA8FE59198decodeURI (&#x27;8E98BB8918E98A98AC&#x27;)//输出字符串 黑马 **3.URL编码的注意事项** **由于浏览器会自动对URL地址进行编码操作,因此,大多数情况下,程序员不需要关心URL地址的编码与解码操作。** **更多关于URL编码的知识,请参孝如下博客:** **https://blog.csdn.net/xd_0111/article/details/78028889** ## 1.7使用xhr发起POsT请求 **步骤:** **创建xhr对象** **调用xh.open()函数** **设置Content-Type属性(固定写法)** **调用xhr.send()函数,同时指定要发送的数据** **监听xhr.onreadystatechange事件** 1234567891011121314//1.创建xhr对象var xhr = new XMLHttpRequest ()//2.调用open()xhr.open (&#x27;POST&#x27;, &#x27;http://www.liulongbin.top:3006/api/addbook&#x27;)//3.置Content-Type属性(固定写法)xhr.setRequestHeader (&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;)//4.调用send(),同时将数据以查询字符串的形式,提交给服务器xhr.send (&#x27;bookname=水浒传&amp;author=施耐庵&amp;publisher=天津图书出版社&#x27;)//5.监听onreadystatechange事件xhr.onreadystatechange = function()&#123; if (xhr.readystate === 4&amp;&amp; xhr.status === 200)&#123; console.log(xhr.responseText) &#125;&#125; # 2,数据交换格式 ## 2.1什么是数据交换格式 **数据交换格式,就是服务器端与客户端之间进行数据传输与交换的格式。前端领域,经常提及的两种数据交换格式分别是XML和JSON,其中XML用的非常少,所以,我们重点要学习的数据交换格式就是JSON.** ​ **数据传输与交换** **web服务器------------------XML------JSON-----------用户的电脑(客户端)** ## 2.2 XML **1.什么是XML** **XML的英文全称是EXtensible Markup Language,即可扩展标记语言。因此, XML和HTML类似也是一种标记语音。** 123456&lt;note&gt; &lt;to&gt;1s&lt;/to&gt; &lt;from&gt;zs&lt;/from&gt; &lt;heading&gt;通知&lt;/heading&gt; &lt;body&gt;晚上开会&lt;/body&gt;&lt;/note&gt; **2.XML和HTML的区别** **XML和HTML虽然都是标记语言,但是,它们两者之间没有任何的关系。** **HTML被设计用来描述网页上的内容,是网页内容的载体** **XML被设计用来传输和存储数据,是数据的载体** **3.XML的缺点** **XML格式臃肿,和数据无关的代码多,体积大,传输效率低** **在Javascript中解析XML比较麻烦** ## 2.3 JSON **1.什么是JSON** **概念: JSON的英文全称是JavaScript Object Notation,即\"JavaScript对象表示法\"。简单来讲** **JSON就是Javascript对象和数组的字符申表示法,它使用文本表示一个JS对象或数组的信息,因此,JSON的本质是字符串** **作用: JSON是一种轻量级的文本数据交换格式,在作用上类似于XML,专门用于存储和传输数据,但是JSON比XML更小、更快、更易解析。** **现状: JSON是在2001年开始被推广和使用的数据格式,到现今为止, JSON已经成为了主流的数据交换格式。** **2.JSON的两种结构** **JSON就是用字符串来表示Javascript的对象和数组。所以, JSON中包含对象和数组两种结构,通过这两种结构的相互嵌套,可以表示各种复杂的数据结构。** **对象结构:对象结构在JSON中表示为()括起来的内容。数据结构为( key: value, key: value . ..)的键值对结构。其中, key必须是使用英文的双引号包裹的字符串, value的数据类型可以是数字、字符串.布尔值、null、数组、对象6种类型。** 1234567&#123; &quot;name&quot;: &quot;2s&quot;, &quot;age&quot;: 20, &quot;gender&quot;: &quot;男&quot;, &quot;address&quot;: null, &quot;hobby&quot;: [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;打豆豆&quot;]&#125; **数组结构:数组结构在JSON中表示为[]括起来的内容。数据结构为[\"java\" \"javascript\", 30,true...]数组中数据的类型可以是数字、字符串、布尔值、null、数组、对象6种类型。** 12345[&quot;java&quot;, &quot;python&quot;, &quot;php&quot; ][ 100, 200, 300.5 ][true, false, null][ &#123;&quot;name&quot;: &quot;zs&quot;, &quot;age&quot;: 20&#125;, &#123;&quot;name&quot;: &quot;1s&quot;, &quot;age&quot;: 30&#125; ][[&quot;苹果&quot;, &quot;榴莲&quot;, &quot;椰子&quot;], [4, 50, 5] ] **3.JSON语法注意事项** **属性名必须使用双引号包裹** **字符串类型的值必须使用双引号包裹** **JSON中不允许使用单引号表示字符串** **JSON中不能写注释** **JSON的最外层必须是对象或数组格式** **不能使用undefined或函数作为JSON的值** **JSON的作用:在计算机与网络之间存储和传输数据。** **JSON的本质:用字符串来表示Javascript对象数据或数组数据** **4.JSON和JS对象的关系** **JSON是JS对象的字符串表示法,它使用文本表示一个JS对象的信息,本质是一个字符串。例如:** 1234//这是一个对象var obj =&#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;//这是一个JSON字符串,本质是一个字符串var json =&#x27;(&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125; &#x27; **5.JSON和JS对象的互转** **要实现从ISON字符串转换为JS对象,使用JSON.parse()方法:** 12var obj = JSON.parse (&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;world&quot;&#125;&#x27;)//结果是&#123;a: &#x27;He11o&#x27;, d: &#x27;World&#x27;&#125; **要实现从JS对象转换为JSON字符串,使用JSON.stringify()方法:** 12var json =JsoN. stringify (&#123;a: &#x27;Hello&#x27;, b: &#x27;wor14&#x27;&#125;)//结果是&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;world&quot;&#125;&#x27; **6,序列化和反序列化** **把数据对象转换为字符串的过程,叫做序列化,例如:调用JSON.stringify0函数的操作,叫做JSON序列化。** **把字符串转换为数据对象的过程,叫做反序列化,例如:调用ISON.parse0函数的操作,叫做JSON反序列化。** ## 3.1要实现的效果 123456789101112&lt;script src=&quot;./itheima.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //2.调用自定义的itheima函数,发起Ajax数据请求 itheima(&#123; method: &#x27;请求类型&#x27;, url: &#x27;请求地址&#x27;, data: &#123;/*请求参数对象*/&#125;, success: function (res) &#123; //成功的回调函数 console.log(res) //打印数据 &#125;&#125;)&lt;/script&gt; ## 3.2定义options参数选项 **itheima()函数是我们自定义的Ajax函数,它接收一个配置对象作为参数,配置对象中可以配置如下属性:** **method 请求的类型** **url 请求的URL地址** **data 请求携带的数据** **success 请求成功之后的回调函数** ## 3.3处理data参数 **需要把data对象,转化成查询字符串的格式,从而提交给服务器,因此提前定义resolveData函数如下:** 12345678910//处理data 参数//@param (data)需要发送到服务器的数据//@returns (string)返回拼接好的查询字符串name=zs&amp;age=10function resolveData (data) &#123; var arr= [] for (let k in data)&#123; arr.push (k +&#x27;=&#x27; + data[k]) &#125; return arr.join (&#x27;&amp;&#x27;)&#125; ## 3.4定义itheima函数 **在itheima0函数中,需要创建xhr对象,并监听onreadystatechange事件:** 123456789101112function itheima (options) &#123; var xhr = new XMLHttpRequest () //拼接查询字符串 var qs = resolveData (options.data) //监听请求状态改变的事件 xhr.onreadystatechange = function()&#123; if (xhr.readystate ===4 &amp;&amp; xhr.status===200)&#123; var result = JSON.parse (xhr.responseText) options.success(result) &#125; &#125;&#125; ## 3.5判断请求的类型 **不同的请求类型,对应xhr对象的不同操作,因此需要对请求类型进行if..else ...的判断** 12345678910if (options.method.toUpperCase ()===&#x27;GET&#x27;) &#123; //发起GET请求 xhr.open (options.method, options.url + &#x27;?&#x27; + qs) xhr.send ()&#125;else if (options.method.toUpperCase ()===&#x27;post&#x27;)&#123; //发起POST请求 xhr.open (options.method, options.url) xhr.setRequestHeader (&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;) xhr.send (qs)&#125; # 4.XMLHttpRequest Level2的新特性 ## 4.1认识XMLHttpRequest Level2 **1.旧版XMLHttpRequest的缺点** **只支持文本数据的传输,无法用来读取和上传文件** **传送和接收数据时,没有进度信息,只能提示有没有完成，** **2.XMLHttpRequest Level2的新功能** **可以设置HTTP请求的时限** **可以使用FormData对象管理表单数据** **可以上传文件** **可以获得数据传输的进度信息** ## 4.2设置HTTP请求时限 **有时, Ajax操作很耗时,而且无法预知要花多少时间。如果网速很慢,用户可能要等很久。新版本的XMLHttpRequest对象,增加了timeout属性,可以设置HTTP请求的时限:** 1xhr.timeout = 3000 **上面的语句,将最长等待时间设为3000毫秒。过了这个时限,就自动停止HTTP请求。与之配套的还有一个timeout事件,用来指定回调函数:** 123xhr.ontimeout = function (event)&#123; alert (&#x27;请求超时! &#x27;)&#125; ## 4.3 FormData对象管理表单数据 **Ajax操作往往用来提交表单数据。为了方便表单处理, HTML5新增了一个FormData对象,可以模拟表单操作:** 1234567891011//1.新建FormData对象var fd =new FormData ()//2为Formbata添加表单项fd.append (&#x27;uname&#x27;, &#x27;zs&#x27;)fd.append (&#x27;upwd&#x27;, &#x27;123456&#x27;)//3.创建XHR对象var xhr = new XMIHttpRequest()//4·指定请求类型与URL地址xhr.open (&#x27;POST&#x27;, &#x27;http://www.liulongbin.top: 3006/api/formdata&#x27;)//5．直接提交FormData对象，这与提交网页表单的效果，完全一样xhr.send (fd) **FormData对象也可以用来获取网页表单的值,示例代码如下:** 123456789101112//获取表单元素var form = document.querySelector (&#x27;#form1&#x27;)//监听表单元素的submit事件form.addEventListener (&#x27;submit&#x27;, function(e)&#123; e.preventDefault () //根据form表单创建FormData对象,会自动将表单数据填充到FormData对象中 var fd = new FormData (form) var xhr = new XMLHttpRequest () xhr.open(&#x27;POST&#x27;,&#x27;http://www.liulongbin.top:3006/api/formdata&#x27;) xhr.send (fd) xhr.onreadystatechange = function() &#123;&#125;&#125;) ## 4.4上传文件 **新版XMLHttpRequest对象,不仅可以发送文本信息,还可以上传文件。** **实现步骤:** **①定义UI结构** **②验证是否选择了文件** **向FormData中追加文件** **使用xhr发起上传文件的请求** **监听onreadystatechange事件** **1.定义UI结构** 1234567&lt;!--1.文件选择框--&gt; &lt;input type=&quot;file&quot; id=&quot;filel&quot; /&gt;&lt;!--2.上传按钮--&gt; &lt;button id=&quot;btnUpload&quot;&gt;上传文件&lt;/button&gt;&lt;br /&gt;&lt;!--3,显示上传到服务器上的图片--&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; id=&quot;img&quot; width=&quot;800&quot; /&gt; **2.验证是否选择了文件** 1234567891011//1.获取上传文件的按钮var btnUpload =document.querySeleator(&#x27;#btnUpload&#x27;)//2. 按钮添加click事件监听btnUpload.addEventListener (&#x27;click&#x27;, function() &#123;//3.获取到选择的文件列表var files = document.querySeleator (&#x27;#filel&#x27;).files if (files.length &lt;=0) &#123; return alert(&#x27;请选择要上传的文件!&#x27;) &#125; //....后续业务逻辑&#125;) **3.向FormData中追加文件** 1234//1.创建FormData对象var fd = new FormData()//2.向FormData中追加文件fd.append ( &#x27;avatar&#x27;, files[0]) **4,使用xhr发起上传文件的请求** 123456//1.创建xhr对象var xhr =new xMLHttpRequest ()// 2,调用open函数,指定请求类型与URL地址。其中,请求类型必须为PoSTxhr.open(&quot;POST&#x27;,&#x27;http://www.liulongbin.top:3006/api/upload/avatar&#x27;)//3.发起请求xhr.send (fd) **5.监听onreadystatechange事件** 1234567891011xhr.onreadystatechange = function() &#123; if (xhr.readystate =4 &amp;&amp; xhr.status =200) &#123; var data = JsoN.parse (xhr.responseText) if (data.status=200) &#123; //上传文件成功 //将服务器返回的图片地址,设置为&lt;img&gt;标签的src属性 document.queryselector(&#x27;#img&#x27;).src=&#x27;http://www.liulongbin.top: 3006&#x27; + data.url1 &#125;else&#123;//上传文件失败 console.log (data, message) &#125; &#125;&#125; ## 4.5显示文件上传进度 **新版本的XMLHttpRequest对象中,可以通过监听xhr.upload.onprogress事件,来获取到文件的上传进度语法格式如下:** 1234567891011//创建xHR对象var xhr =new XMLHttpRequest ()//监听xhr.upload的onprogress事件xhr.upload. onprogress = function(e)&#123; // e.lenghcomputable是一个布尔值,表示当前上传的资源是否具有可计算的长度if (e.lengthcomputable)&#123; // e.loaded已传输的字节 // e.total需传输的总字节 var percentcomplete =Math.ceil ((e.loaded / e.total) *100) &#125;&#125; **2.bootstap进度条** 123456789&lt;!-- 文件选择器 --&gt; &lt;input type=&quot;file&quot; id=&quot;file1&quot; /&gt; &lt;!--上传文件按钮 --&gt; &lt;button id=&quot;btnUpload&quot;&gt;上传文件&lt;/button&gt; &lt;div class=&quot;progress&quot; style=&quot;width: 500px; margin: 15px 10px;&quot;&gt; &lt;div class=&quot;progress-bar progress-bar-striped active&quot; style=&quot;width: 0%&quot; id=&quot;percent&quot;&gt; 0% &lt;/div&gt; &lt;/div&gt; **3,监听上传进度的事件** 1234567891011xhr.upload.onprogress =function(e) &#123; if (e.lengthcomputable) &#123; //1.计算出当前上传进度的百分比 var percentcomplete =Math.ceil ((e.loaded / e.total) * 100) $(&#x27;#percerki) //2.设置进度条的宽度 .attr (&#x27;style&#x27;, &#x27;width:&#x27; + percentComplete + &#x27; %&#x27;) //3.显示当前的上传进度百分比 .html (percentComplete +&#x27;%&#x27;) &#125; &#125; **4,监听上传完成的事件** 12345678xhr.upload.onload = function()&#123; $ (&#x27;#percent&#x27;) //移除上传中的类样式 .removeclass () //添加上传完成的类样式 .addclass (&#x27;progress-bar progress-bar-success&#x27;)&#125; # 5.jQuery高级用法 ## 5.1 jQuery实现文件上传 **1.定义UI结构** 123456&lt;!--导入jQuery-&gt;&lt;script src=&quot;./lib/jquery.js&quot;&gt;&lt;/script&gt;&lt;!--文件选择框--&gt;&lt;input type=&quot;file&quot; id=&quot;file1&quot; /&gt;&lt;!--上传文件按钮--&gt;&lt;button id=&quot;btnUpload&quot;&gt;上传&lt;/button&gt; **2.验证是否选择了文件** 12345678$(&#x27;#btnUpload&#x27;).on (&#x27;click&#x27;, function() &#123; //1,将jQuery对象转化为DOM对象,并获取选中的文件列表 var files =$(&#x27;#filel&#x27;) [0] .files // 2.判断是否选择了文件 if (files.length &lt;= 0)&#123; return alert(&#x27;请选择图片后再上传!&#x27;) &#125;&#125;) **3.向FormData中追加文件** 123//向FormData中追加文件var fd = new FormData ()fd.append (&#x27;avatar&#x27;, files [0]) **4,使用jQuery发起上传文件的请求** 123456789101112$.ajax(&#123; method: &quot;POST&quot;, url: &#x27;http://www.liulongbin.top:3006/api/upload/avatar&#x27;, data: fd, //不修改content-Type属性,使用FormData默认的content-Type值 contentType: false, //不对FormData中的数据进行ur1编码,而是将FormData数据原样发送到服务器 processData: false, success: fuction(res)&#123; console.1og (res)&#125;&#125;) ## 5.2 jQuery实现loading效果 **1.ajaxStart(callback)** **Ajax请求开始时,执行ajaxStart函数。可以在ajaxStart的callback中显示loading效果,示例代码如下:** 1234//自jQuery版本1.8起,该方法只能被附加到文档$(document).ajaxstart (function() &#123; $(&#x27;#loading&#x27;).show ()&#125;) **注意: $(document).jaxStart()函数会监听当前文档内所有的Ajax请求。** **2.ajaxStop(callback)** **Ajax请求结束时,执行ajaxstop函数。可以在ajaxStop的callback中隐藏loading效果,示例代码如下:** 1234//自jguery版本1.8起,该方法只能被附加到文档$(document).ajaxstop (function()&#123; $(&#x27;#loading&#x27;).hide()&#125; ) # 6.axios ## 6.1什么是axios **Axios是专注于网络数据请求的库。** **相比于原生的XMLHttpRequest对象, axios简单易用。** **相比于jQuery, axios更加轻量化,只专注于网络数据请求。** ## 6.2 axios发起GET请求 **axios发起get请求的语法:** 1axios.get (&#x27;url&#x27;, &#123; params: &#123;/*参数*/&#125; &#125;).then (callback) **具体的请求示例如下:** 12345678910//请求的URL地址var url = &#x27;http://www.liulongbin.top:3006/api/get&#x27;//请求的参数对象var paramsobj=&#123; name: &#x27;zs&#x27;, age: 20 &#125;//调用axios.get()发起GET请求axios.get (url, &#123; params: paramsobj &#125;) .then (function(res) &#123; // res.data是服务器返回的数据 var result = res.data console. log (res)&#125;) ### 6.3 axios发起POST请求 **axios发起post请求的语法:** 1axios.post (&#x27;url&#x27;, &#123;/*参数*/ &#125;) .then (callback) **具体的请求示例如下:** 12345678910//请求的URL地址var url = &#x27;http://www.liulongbin.top:3006/api/post&#x27;//要提交到服务器的数据var dataobj=&#123; location: &#x27;北京&#x27;, address: &#x27;顺义&#x27; &#125;//调用axios.post()发起POST请求axios.post (url, dataobj).then (fuction(res)&#123;// res.data是服务器返回的数据 var result =res.data console.log (result) &#125;) ## 6.4直接使用axios发起请求 **axios也提供了类似于jQuery中$.ajax()的函数,语法如下:** 123456axios (&#123; method: &#x27;请求类型&#x27;, url: &#x27;请求的URI地址&#x27;, data: &#123;/*POST数据*/&#125;, params: &#123;/* GET参数*/ &#125;&#125;).then (callback) **1,直接使用axios发起GET请求** 12345678910axios (&#123; method: &#x27;GET&#x27;, url: &#x27;http://www.liulongbin.top:3006/api/get&#x27;, params: &#123;// GET参数要通过params属性提供 name: &#x27;zs&#x27;, age: 20 &#125;&#125;) .then (function (res)&#123; console.log (res.data)&#125;) **2.直接使用axios发起POST请求** 12345678910axios (&#123; method: &#x27;post&#x27; url: &#x27;http:/www.liulongbin.top:3006/api/post&#x27;, data: &#123;// POST数据要通过data属性提供 bookname: &#x27;程序员的自我修养&#x27;, price: 666&#125;&#125;).then (function (res) &#123; console.log (res.data)&#125;) # 1.了解同源策略和跨域 ## 1.1同源策略 **1.什么是同源** **如果两个页面的协议,域名和端口都相同,则两个页面具有相同的源。** **例如,下表给出了相对于http://www.test.com/index.html页面的同源检测:** **URL 是否同源 原因** **http://www.test.com/other.html 是 同源(协议、域名、端口相同)** **https://www.test.com/about.html 否 协议不同(http与https)** **http://blog.test.com/movie.html 否 域名不同(www.test.com与blog.test.com)** **http://www.test.com:7001/home.html 否 端口不同(默认的80端口与7001端** **http://www.test.com:80/main.html 是 同源(协议、域名、端口相同)** **2·什么是同源策略** **同源策略(英文全称Same origin policy)是浏览器提供的一个安全功能** **MDN官方给定的概念:同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。** **通俗的理解:浏览器规定, A网站的JavaScript,不允许和非同源的网站C之间,进行资源的交互,例如:** **无法读取非同源网页的Cookie, LocalStorage和IndexedDB,** **无法接触非同源网页的DOM** **无法向非同源地址发送Ajax请求** ## 1.2跨域 **1.什么是跨域** **同源指的是两个URL的协议、域名、端口一致,反之,则是跨域** **出现跨域的根本原因:浏览器的同源策略不允许非同源的URL之间进行资源的交互。** **网页: http://www.test.com/index.html** **接口: http://www.api.com/userlist** **2.浏览器对跨域请求的拦截** **注意:浏览器允许发起跨域请求,但是,跨域请求回来的数据,会被浏览器拦截,无法被页面获取到** **3,如何实现跨域数据请求** **现如今,实现跨域数据请求,最主要的两种解决方案,分别是JSONP和CORS.** **JSONP:出现的早,兼容性好(兼容低版本IE) 。是前端程序员为了解决跨域问题,被迫想出来的一种临时解决方案。缺点是只支持GET请求,不支持POST请求。** **CORS:出现的较晚,它是w3C标准,属于跨域Ajax请求的根本解决方案。支持GET和POST请求。缺点是不兼容某些低版本的浏览器。** # 2.JSONP ## 2.1什么是JSONP **JSONP (ISON with Padding)是JSON的一种“使用模式\" ,可用于解决主流浏览器的跨域数据访问的问题。** ## 2.2 JSONP的实现原理 **由于浏览器同源策略的限制,网页中无法通过Ajax请求非同源的接口数据。但是标签不受浏览器同源策略的影响,可以通过src属性,请求非同源的js脚本** **因此, JSONP的实现原理,就是通过标签的src属性,请求跨域的数据接口,并通过函数调用的形式,接收跨域接口响应回来的数据。** ## 2.3自己实现一个简单的JSONP **定义一个success回调函数:** 123456&lt;script&gt; function suocesa (data) &#123; console.log (&#x27;获取到了data数据&#x27;) console.log (data)&#125;&lt;/script&gt; **通过标签,请求接口数据:** 1&lt;script src=&quot;http://ajax.frontend.itheina.net:3006/api/jsonp?callback=success&amp;name=zs&amp;age=20&quot;&gt;&lt;/script&gt; ## 2.4 JSONP的缺点 **由于JSONP是通过标签的src属性,来实现跨域数据获取的,所以, JSONP只支持GET数据请求,不支持POST请求。** **注意: JSONP和Ajax之间没有任何关系,不能把JSONP请求数据的方式叫做Ajax,因为JSONP没有用到XMLHttpRequest这个对象** ## 2.5 jQuery中的JSONP **jQuery提供的S.ajax0函数,除了可以发起真正的Ajax数据请求之外,还能够发起JSONP数据请求,例如:** 12345678$.ajax (&#123; url: &#x27;http://ajax.frontend.itheima.net:3006/api/jsonp?name=zs&amp;age=20&#x27;, //如果要使用s.ajax()发起JSONP请求,必须指定datatype为jsonp dataType:&#x27; jsonp&#x27;, success: function(res) &#123; console.1og (res) &#125;&#125;) **默认情况下,使用jQuery发起JSONP请求,会自动携带一个callback-jQueryxxx的参数, jQueryxx是随机生成的一个回调函数名称。** ## 2.6自定义参数及回调函数名称 **在使用jQuery发起ISONP请求时,如果想要自定义JSONP的参数以及回调函数名称,可以通过如下两个参数来指定:** 1234567891011$.ajax (&#123; url:&#x27;http://ajax.frontend.itheima.net:3006/api/jsonp?name=zs&amp;age=20&#x27;, dataType: &#x27;jsonp&#x27;, //发送到服务端的参数名称,默认值为callback jsonp: &#x27;callback&#x27;, //自定义的回调函数名称,默认值为jqueryxxx格式 jsonpCallback: &#x27;abc&#x27;, success: function(res) &#123; console.log (res) &#125;&#125;) ## 2.7 jQuery中JSONP的实现过程 **jQuery中的JSONP,也是通过标签的src属性实现跨域数据访问的,只不过, jQuery采用的是动态创建和移除标签的方式,来发起JSONP数据请求。** **在发起JSONP请求的时候,动态向 中append一标签;** **在JSONP请求成功以后,动态从中移除刚才append进去的标签;** # 3.案例-淘宝搜索 ## 3.2获取用户输入的搜索关键词 **为了获取到用户每次按下键盘输入的内容,需要监听 入框的keyup事件,示例代码如下:** 12345678910//监听文本框的keyup事件$(&#x27;#ipt&#x27;).on (&#x27;keyup&#x27;, function()&#123; //获取用户输入留内容 var keywords = $(this).val().trim () //判断用户输入的内容是否为空 if (keywords.length &lt;=0) &#123; return &#125; // TODO:获取搜索建议列表 &#125;) ## 3.3封装getSuggestList函数 **将获取搜索建议列表的代码,封装到getSuggestList函数中,示例代码如下:** 1234567891011function getSuggestList (kw) &#123; $.ajax(&#123; //指定请求的URL,地址,其中,q是用户输入的关键字 url: &#x27;https://suggest.taobao.com/sug?q=&#x27; +kw, // 定要发起的是JSONP请求 dataType: &#x27;jsonp&#x27;, //成功的回调函数 success: function(res) &#123; console.log (res) &#125; &#125;)&#125; ## 3.4渲染建议列表的U1结构 **1,定义搜索建议列表** 12345678&lt;div class=&quot;box&quot;&gt; &lt;!-- tab栏区域--&gt; &lt;div class=&quot;tabs&quot;&gt;&lt;/div&gt; &lt;!--搜索区域--&gt; &lt;div class=&quot;search-box&quot;x&lt;/div&gt; &lt;!--搜索建议列表--&gt; &lt;div id=&quot;suggest-list&quot;×&lt;/div&gt;&lt;/div&gt; **2,定义模板结构** 123456&lt;!--模板结构--&gt; &lt;script type=&quot;text/html&quot; id=&quot;tpl-suggestList&quot;&gt; &#123;&#123;each result&#125;&#125; &lt;div class=&quot;suggest-item&quot;&gt;&#123;&#123;$value[0]&#125;&#125;&lt;/div&gt; &#123;&#123;/each&#125;&#125; &lt;/script&gt; **3·定义渲染模板结构的函数** 12345678910//渲染建议列表function renderSuggestList (res)&#123; //如果没有需要渲染的数据,则直接return if (res.result.length &lt;=o) &#123; return $(&#x27;#sugqest-list&#x27;).empty () .hide () &#125; //渲染模板结构 var htmlstr = template (&#x27;tpl-suggestList&#x27;, res) $(&#x27;#suggest-1ist&#x27;).html (htmlstr) .show ()&#125; **4,搜索关键词为空时隐藏搜索建议列表** 12345678910$(&#x27;#ipt&#x27;).on (&#x27;keyup&#x27;, function()&#123; //获取用户输入的内容 var keywords =$(this).val().trim() //判断用户输入的内容是否为空 if (keywords.length &lt;= 0) //如果关键词为空,则清空后隐藏搜索建议列表 return $(&#x27;#suggest-list&#x27;).empty () .hide ()&#125; getSuggestzist (keywords)&#125;) ## 3.5输入框的防抖 **1.什么是防抖** **防抖策略(debounce)是当事件被触发后,延迟n秒后再执行回调,如果在这n秒内事件又被触发,则重新计时。** **2·防抖的应用场景** **用户在输入框中连续输入一串字符时,可以通过防抖策略、只在输入完后,才执行查询的请求,这样可以有效减少请求次数,节约请求资源;** **3,实现输入框的防抖** 1234567891011121314//1.防抖动的timervar timer = nullfunction debounceSearch (keywords) &#123;// 2.定义防抖的函数 timer = setTimeout (function() &#123; //发起JSONP请求 getsuggestlist (keywords) &#125;, 500)&#125;$(&#x27;#ipt&#x27;).on (&#x27;keyup&#x27;, function () &#123; // 3.在触发keyup事件时,立即清空timer clearTimeout (timer) // .省略其他代码 debounceSearch (keywords)&#125;) ## 3.6缓存搜索的建议列表 **1,定义全局缓存对象** 12//缓存对象var cacheobj =&#123;&#125; **2,将搜索结果保存到缓存对象中** 12345678//渲染建议列表function renderSuggestList (res) &#123; // …..省略其他代码 //将搜索的结果，添加到缓存对象中 var k =$(&#x27;#ipt&#x27;).val ().trim() cacheobj [k] =res&#125; **3·优先从缓存中获取搜索建议** 12345678910//监听文本框的keyup事件$(&#x27;#ipt&#x27;).on (&#x27;keyup&#x27;, function()&#123; // …..省略其他代码 //优先从缓存中获取搜索建议 if (cacheopj [keywords])&#123; return renderSuggestList (cacheobj [keywords]) &#125; //获取搜索建议列表 debounceSearch (keywords)&#125;) ## 4.1什么是节流 **节流策略(throttle) ,顾名思义,可以减少一段时间内事件的触发频率。** ## 4.2节流的应用场景 **鼠标连续不断地触发某事件(如点击) ,只在单位时间内只触发一次;** **懒加载时要监听计算滚动条的位置,但不必每次滑动都触发,可以降低计算的频率,而不必去浪费CPU资源;** ## 4.3节流案例-鼠标跟随效果 **1.渲染U结构并美化样式** 12345678910&lt;!--UI结构--&gt; &lt;img src=&quot;./assets/angel.gif&quot; alt=&quot;&quot; id=&quot;angel&quot; /&gt; /*scss样式*/html,body&#123; margin: 0; padding: 0; overflow: hidden;#angel &#123;position: absolute;&#125; **2,不使用节流时实现鼠标跟随效果** 1234567$ (function ()&#123; //获取图片元素 var angel =$(&#x27;angel&#x27;) //监听文档的mousemove事件 $ (document) .on (&quot;mousemove&#x27;, function(e)&#123; //设置图片的位 $ (angel) .css (&#x27;left&#x27;, e.pagex +&#x27;px&#x27;).css(&#x27;top&#x27;, e.pageY + &#x27;px&#x27;)&#125;)&#125;) **3,节流阀的概念** **高铁卫生间是否被占用,由红绿灯控制,红灯表示被点用,绿灯表示可使用。** **假设每个人上卫生间都需要花费5分钟,则五分钟之内,被占用的卫生间无法被其他人使用。** **上一个人使用完毕后,需要将红灯重置为绿灯,表示下一个人可以使用卫生间。** **下一个人在上卫生间之前,需要先判断控制灯是否为绿色,来知晓能否上卫生间。** **节流阔为空,表示可以执行下次操作;不为空,表示不能执行下次操作。** **当前操作执行完,必须将节流阀重置为空,表示可以执行下次操作了。** **每次执行操作前,必须先判断节流阀是否为空。** **4,使用节流优化鼠标跟随效果** 12345678910$(function()&#123; var angel =$(&#x27;#angel) var timer = nul1 // 1.预定义一个timer节流阀 $ (document) .on (&#x27;mousemove, function(e) &#123; if (timer) &#123; return &#125; // 3.判断节流阀是否为空,如果不为空,则证明距离上次执行间隔不足16毫秒 timer=setTimeout (function ()&#123; $(angel) .css (&#x27;left&#x27;, e.pagex + &#x27;px&#x27;) .css (&#x27;top&#x27;, e.pageY + &#x27;px&#x27;) timer =null //2.当设置了鼠标跟随效果后,清空timer节流阀,方便下次开启延时器&#125;, 16) &#125;)&#125;) ## 4.4总结防抖和节流的区别 **防抖:如果事件被频繁触发,防抖能保证只有最有一次触发生效!前面N多次的触发都会被忽略!** **节流:如果事件被频繁触发,书流能够减少事件触发的频率,因此,节流是有选择性地执行一部分事件** # HTTP协议加强 ## 1.1什么是通信 **通信,就是信息的传递和交换。** **通信三要素:** **通信的主体** **通信的内容** **通信的方式** **1,现实生活中的通信** **案例:张三要把自己考上传智专修学院的好消息写信告诉自己的好朋友李四。** **其中:** **通信的主体是张三和李四;** **通信的内容是考上传智专修学院;** **通信的方式是写信:** **2,互联网中的通信** **案例:服务器把传智专修学院的简介通过响应的方式发送给客户端浏览器。** **其中,** **通信的主体是服务器和客户端浏览器;** **通信的内容是传智专修学院的简介;** **通信的方式是响应** ## 1.2什么是通信协议 **通信协议(Communication Protocol)是指通信的双方完成通信所必须遵守的规则和约定。** **通俗的理解:通信双方采用约定好的格式来发送和接收消息,这种事先约定好的通信格式,就叫做通信协议。** **1.现实生活中的通信协议** **张三与李四采用写信的方式进行通信,在填写信封时,写信的双方需要遵守固定的规则。信封的填写规则就是一种通信协议。** **2.互联网中的通信协议** **客户端与服务器之间要实现网页内容的传输,则通信的双方必须遵守网页内容的传输协议。** **网页内容又叫做超文本,因此网页内容的传输协议又叫做超文本传输协议(HyperText Transfer Protocol)简称HTTP协议** ## 1.3 НТТP **1,什么是HTTP协议** **HTTP协议即超文本传送协议(HyperText Transfer Protocol) ,它规定了客户端与服务器之间进行网页内容传输时所必须遵守的传输格式。** **列如:** **客户端要以HTTP协议要求的格式把数据提交到服务器** **服务器要以HTTP协议要求的格式把内容响应给客户端** **2.HTTP协议的交互模型** **HTTP协议采用了请求/响应的交互模型。** ## 2.1什么是HTTP请求消息 **由于HTTP协议属于客户端浏览器和服务器之间的通信协议。因此,客户端发起的请求叫做HTTP请求,客户端发送到服务器的消息,叫做HTTP请求消息。** **注意: HTTP请消息叫做HTTP请求报文** ## 2.2 HTTP请求消息的组成部分 **HTTP请求消息由请求行(request line) 、请求头部( header ) 、空行和请求体4个部分组成,** **1.请求行** **请求行由请求方式、URL和HTTP协议版本3个部分组成,他们之间使用空格隔开** **2,请求头部** **请求头部用来描述客户端的基本信息,从而把客户端相关的信息告知服务器。** **比如:** **User-Agent用来说明当前是什么类型的浏览器;** **Content-Type用来描述发送到服务器的数据格式;** **Accept用来描述客户端能够接收什么类型的返回内容;** **Accept-Language用来描述客户端期望接收哪种人类语言的文本内容。** **请求头部由多行键/值对组成,每行的键和值之间用英文的冒号分隔。** **2,请求头部-常见的请求头字段** **头部字段 说明** **Host 要请求的服务器域名** **Connection 客户端与服务器的连接方式(close或keepalive)** **Content-Length 用来描述请求体的大小** **Accept 客户端可识别的响应内容类型列表** **User-Agent 产生请求的浏览器类型** **Content-Type 客户端告诉服务器实际发送的教据类型** **Accept-Encoding 客户端可接收的内容压缩编码形式** **Accept-Language 用户期望获得的自然语言的优先顺序** **关于更多请求头字段的描述,可以查看MDN官方文档: https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers** **3.空行** **最后一个请求头字段的后面是一个空行,通知服务器请求头部至此结束。** **请求消息中的空行,用来分隔请求头部与请求体。** **4,请求体** **请求体中存放的,是要通过POST方式提交到服务器的数据。** **注意:只有POST请求才有请求体, GET请求没有请求体** ## 3.2 HTTP响应消息的组成部分 **HTTP响应消息由状态行、响应头部、空行和响应体4个部分组成,如下图所示:** **1.状态行** **状态行由HTTP协议版本、状态码和状态码的描述文本3个部分组成,他们之间使用空格隔开;** **2,响应头部** **响应头部用来描述服务器的基本信息,响应头部由多行键/值对组成,每行的键和值之间用英文的冒号分隔。** **关于更多响应头字段的描述,可以查看MDN官方文档: https://developer.mozillaorg/zh-CN/docs/Web/HTTP/Headers** **3.空行** **在最后一个响应头部字段结束之后,会紧跟一个空行,用来通知客户端响应头部至此结束。响应消息中的空行,用来分隔响应头部与响应体** **4.响应体** **响应体中存放的,是服务器响应给客户端的资源内容。** ## 4.1什么是HTTP请求方法 **HTTP请求方法,属于HTTP协议中的一部分,请求方法的作用是:用来表明要对服务器上的资源执行的操作。最常用的请求方法是GET和POST** **序号 方法 描述** **1 GET 查询发送请求来获得服务器上的资源,请求体中不会包含请求数据,请求数据放在协议头中,** **2 POST (新增)向服务器提交资源(例如提交表单或上传文件) 。数据被包含在请求体中提交给服务器** **3 PUT (修改)向服务器提交资源,并使用提交的新资源,替换掉服务器对应的旧资源。** **4 DELETE (删除)请求服务器删除指定的资源** **5 HEAD HEAD方法请求一个与GET请求的响应相同的响应,但没有响应体。** **6 OPTIONS 获取http服务器支持的http请求方法,允许客户端查看服务器的性能,比如ajax跨域时的预检等。** **7 CONNECT 建立一个到由目标资源标识的服务器的隧道。** **8 TRACE 沿着到目标资源的路径执行一个消息环回测试,主要用于测试或诊断** **9 PATCH 是对PUT方法的补充,用来对已知资源进行局部更新。** ## 5.1什么是HTTP响应状态码 **HTTP响应状态码(HTTP Status Code) ,也属于HTTP协议的一部分,用来标识响应的状态。** **响应状态码会随着响应消息一起被发送至客户端浏览器,浏览器根据服务器返回的响应状态码,就能知道这次HTTP请求的结果是成功还是失败了.** **HTTP状态码由三个十进制数字组成,第一个十进制数字定义了状态码的类型,后两个数字用来对状态码进行细分。,** **HTTP状态码共分为5种类型:** **分类 分类描述** **1\\** 信息,服务器收到请求,需要请求者继续执行操作(实际开发中很少遇到1\\**类型的状态码)** **2\\** 成功,操作被成功接收并处理** **3\\** 重定向,需要进一步的操作以完成请求** **4\\** 客户端错误,请求包含语法错误或无法完成请求** **5\\** 服务器错误,服务器在处理请求的过程中发生了错误** **1.2成功相关的响应状态码** **2\\**范围的状态码,表示服务器已成功接收到请求并进行处理。常见的2**类型的状态码如下:** **状态码 状态码英文名称 中文描述** **200 OK 201Created请求成功。一般用于GET与POST请求** **201 Created 已创建。成功请求并创建了新的资源,通常用于POST或PUT请求** **2.3重定向相关的响应状态码** **3范围的状态码,表示服务器要求客户端重定向,需要客户端进一步的操作以完成资源的请求。常见的3类型的状态码如下:** **状态码 状态码英文名称 中文描述** **301 MovedPermanently 永久移动。请求的资源已被永久的移动到新URI,返回信息会包括新的URI,浏览器会自动定向到新URI,今后任何新的请求都应使用新的URI代替** **302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI** **304 Not Modified 未修改。所请求的资源未修改,服务器返回此状态码时,不会返回任何资源(响应消息中不包含响应体) 。客户端通常会缓存访问过的资源。** **3.4\\**户端错误相关的响应状态码** **4\\**范围的状态码,表示客户端的请求有非法内容,从而导致这次请求失败。常见的4类型的状态码如下:** **状态码 状态码英文名称 中文描述** **400 Bad Request 1、语义有误,当前请求无法被服务器理解。除非进行修改,否则客户端不应该重复提交这个请求。2、请求参数有误。** **401 Unauthorized 当前请求需要用户验证。** **403 Forbidden 服务器已经理解请求,但是拒绝执行它。** **404 Not FoundRequest 服务器无法根据客户端的请求找到资源(网页)** **408 Timeout 请求超时。服务器等待客户端发送的请求时间过长,超时。** **4.5*服务端错误相关的响应状态码** **5\\**范围的状态码,表示服务器未能正常处理客户端的请求而出现意外错误。常见的5类型的状态码如下:** **状态码 状态码英文名称 中文描述** **500 Internal ServerError 服条器内部错误,无法完成请求。** **501 Not Implemented 服务器不支持该请求方法,无法完成请求。只有GET和HEAD请求方法是要求每个服务器必须支持的,其它请求方法在不支持的服务器上会返回501** **503 Service Unavailable 由于超载或系统维护,服务器暂时的无法处理客户端的请求。**","categories":[{"name":"前端","slug":"前端","permalink":"https://2486125878.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://2486125878.github.io/tags/Ajax/"}]},{"title":"thinkphp_sql","slug":"thinkphp-sql","date":"2024-03-13T07:06:20.000Z","updated":"2024-03-13T08:23:16.000Z","comments":true,"path":"2024/03/13/thinkphp-sql/","permalink":"https://2486125878.github.io/2024/03/13/thinkphp-sql/","excerpt":"","text":"1.thinkphp之SQL查询语句一：字符串条件查询12345//直接实例化Model$user=M(&#x27;user1&#x27;);var_dump($user-&gt;where (&#x27;id=1 OR age=55&#x27;)-&gt;select()); 最终生成的sql语句为：SELECT * FROM user1 WHERE ( id&#x3D;1 OR age&#x3D;55 ) PS:where 查询方法里面只要包含条件即可，多个条件加上 AND 等连接符即可 二：使用索引数组作为查询条件1234567891011$user=M(&#x27;user1&#x27;);$condition[&#x27;age&#x27;]=&#x27;55&#x27;;$condition[&#x27;name&#x27;]=&#x27;zs&#x27;;// 索引数组查询的默认逻辑关系是 AND，如果想改变为 OR，可以使用_logic 定义查询逻辑$condition[&#x27;_logic&#x27;] = &#x27;OR&#x27;;var_dump($user-&gt;where($condition)-&gt;select()); 最终生成的sql语句为：SELECT * FROM user1 WHERE id &#x3D; ‘1’ AND name &#x3D; ‘zs’ 三：使用对象方式查询123456789101112131415161718192021&lt;?phpnamespace Home\\Controller;use Think\\Controller;use Think\\stdClass;class EleController extends Controller&#123; $user=M(&#x27;user1&#x27;); $condition=new \\stdClass; $condition-&gt;id = &#x27;1&#x27;; var_dump($user-&gt;where($condition)-&gt;select());&#125; 最终生成的sql语句为：SELECT * FROM user1 WHERE id &#x3D; ‘1’ 四：表达式查询查询表达式格式：$map[‘字段名’] &#x3D; array(‘表达式’,’查询条件’); 12345$user=M(&#x27;user1&#x27;);$map[&#x27;age&#x27;] = array(&#x27;eq&#x27;, 55); //where 为 age=55var_dump($user-&gt;where($map)-&gt;select()); 五：快捷查询1234567891011121314151617//使用相同查询条件 $user = M(&#x27;user1&#x27;); $map[&#x27;name|email&#x27;] = &#x27;a&#x27;; //&#x27;|&#x27;换成&#x27;&amp;&#x27;变成AND var_dump($user-&gt;where($map)-&gt;select()); // 不同字段不同查询条件 //使用不同查询条件 $user = M(&#x27;user1&#x27;); $map[&#x27;name&amp;email&#x27;] =array(&#x27;a&#x27;,&#x27;test@qq.com&#x27;,&#x27;_multi&#x27;=&gt;true); var_dump($user-&gt;where($map)-&gt;select()); 第一条查询的结果：SELECT * FROM user1 WHERE ( name &#x3D; ‘a’ OR email &#x3D; ‘a’ ) 第二条查询的结果：SELECT * FROM user1 WHERE ( (name &#x3D; ‘a’) AND (email &#x3D; ‘&#x74;&#x65;&#x73;&#x74;&#64;&#x71;&#113;&#46;&#99;&#x6f;&#x6d;‘) ) 六：区间查询1234567891011121314151617// 区间查询 $user = M(&#x27;user1&#x27;); $map[&#x27;id&#x27;] = array(array(&#x27;gt&#x27;, 1), array(&#x27;lt&#x27;, 4)); var_dump($user-&gt;where($map)-&gt;select()); //第三个参数设置逻辑OR $user = M(&#x27;User1&#x27;); $map[&#x27;id&#x27;] = array(array(&#x27;gt&#x27;, 1), array(&#x27;lt&#x27;, 4), &#x27;OR&#x27;); var_dump($user-&gt;where($map)-&gt;select()&#125; 七：组合查询组合查询是基于索引数组查询方式的一个扩展性查询，添加了字符串查询(_string)、复合查询(_complex)、请求字符串查询(_query)，由于采用的是索引数组，重复的会被覆盖。 12345678910111213141516171819202122232425262728293031323334353637//字符串查询(_string) $user = M(&#x27;user1&#x27;); $map[&#x27;name&#x27;] = array(&#x27;eq&#x27;, &#x27;zs&#x27;); $map[&#x27;_string&#x27;] =&#x27;age=&quot;30&quot; AND email=&quot;zs@qq.com&quot;&#x27;; var_dump($user-&gt;where($map)-&gt;select()); //请求字符串查询(_query) $user = M(&#x27;user1&#x27;); $map[&#x27;id&#x27;] = array(&#x27;eq&#x27;, &quot;1&quot;); $map[&#x27;_query&#x27;] =&#x27;name=zs&amp;email=zs@qq.com&amp;_logic=OR&#x27;; var_dump($user-&gt;where($map)-&gt;select()); //复合查询(_complex) $user = M(&#x27;user1&#x27;); $where[&#x27;name&#x27;] = array(&#x27;like&#x27;, &#x27;z&#x27;); $where[&#x27;id&#x27;] = 1; $where[&#x27;_logic&#x27;] = &#x27;OR&#x27;; $map[&#x27;_complex&#x27;] = $where; $map[&#x27;id&#x27;] = 3; $map[&#x27;_logic&#x27;] = &#x27;OR&#x27;; var_dump($user-&gt;where($map)-&gt;select()); 第一条查询语句：SELECT * FROM user1 WHERE name &#x3D; ‘zs’ AND ( age&#x3D;”30” AND email&#x3D;”&#x7a;&#x73;&#64;&#x71;&#x71;&#46;&#99;&#111;&#109;“ ) 第二条查询语句：SELECT * FROM user1 WHERE name &#x3D; ‘zs’ AND ( age&#x3D;”30” AND email&#x3D;”&#122;&#x73;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#109;“ ) AND ( name &#x3D; ‘zs’ OR email &#x3D; ‘&#x7a;&#x73;&#x40;&#x71;&#x71;&#46;&#x63;&#x6f;&#109;‘ ) 第三条查询语句：SELECT * FROM user1 WHERE name &#x3D; ‘zs’ OR ( age&#x3D;”30” AND email&#x3D;”&#x7a;&#115;&#x40;&#113;&#113;&#x2e;&#x63;&#111;&#x6d;“ ) OR ( name &#x3D; ‘zs’ OR email &#x3D; ‘&#122;&#x73;&#x40;&#113;&#x71;&#46;&#99;&#111;&#x6d;‘ ) OR ( name LIKE ‘z’ OR id &#x3D; 1 ) 八：统计查询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//数据总条数 //SHOW COLUMNS FROM `user1` $user = M(&#x27;user1&#x27;); var_dump($user-&gt;count()); //字段总条数，遇到NULL不统计 //SELECT COUNT(*) AS tp_count FROM `user1` LIMIT 1 $user = M(&#x27;user1&#x27;); var_dump($user-&gt;count(&#x27;email&#x27;)); //最大值 //SELECT MAX(id) AS tp_max FROM `user1` LIMIT 1 $user = M(&#x27;user1&#x27;); var_dump($user-&gt;max(&#x27;id&#x27;)); //最小值 //SELECT MIN(id) AS tp_min FROM `user1` LIMIT 1 $user = M(&#x27;user1&#x27;); var_dump($user-&gt;min(&#x27;id&#x27;)); //平均值 //SELECT AVG(id) AS tp_avg FROM `user1` LIMIT 1 $user = M(&#x27;user1&#x27;); var_dump($user-&gt;avg(&#x27;id&#x27;)); //求总和 //SELECT SUM(id) AS tp_sum FROM `user1` LIMIT 1 $user = M(&#x27;user1&#x27;); var_dump($user-&gt;sum(&#x27;id&#x27;)); 九：动态查询12345678910111213141516171819// 1.getBy 动态查询 //查找email=xiaoin@163.com的数据 //SELECT * FROM `user1` LIMIT 1 $user = M(&#x27;user1&#x27;); var_dump($user-&gt;getByemail(&#x27;zs@qq.com&#x27;)); // 2.getFieldBy 动态查询 //通过user得到相对应id值 //SELECT `id` FROM `user1` LIMIT 1 $user = M(&#x27;user1&#x27;); var_dump($user-&gt;getFieldByUser(&#x27;ls&#x27;, &#x27;id&#x27;)); 十：SQL查询12345678910111213141516171819202122 // 1.query 读取//查询结果集，如果采用分布式读写分离，则始终在读服务器执行//SELECT * FROM user1$user = M(&#x27;user1&#x27;);var_dump($user-&gt;query(&#x27;SELECT * FROM user1&#x27;));// 2.execute写入//更新和写入，如果采用分布式读写分离，则始终在写服务器执行//UPDATE user1 set name=&quot;xuexi&quot; WHERE id=&quot;1&quot;;$user = M(&#x27;user1&#x27;);var_dump($user-&gt;execute(&#x27;UPDATE user1 set name=&quot;xuexi&quot; WHERE id=&quot;1&quot;;&#x27;)); 十一：连贯查询 通过连贯操作可以有效的提供数据存取的代码清晰度和开发效率，并且支持所有的 CURD 操作 12345678910111213141516171819202122232425262728293031//连贯操作 //PS：这里的 where、order 和 limit 方法都是连贯操作方法，所以它们都能返回$user本身，可以互换位置。而 select 方法不是连贯方法，需要放在最后，用以显示数据集。 //SELECT * FROM `user1` WHERE ( id in (1,2,3,4) ) LIMIT 2 $user=M(&#x27;user1&#x27;); var_dump($user-&gt;where(&#x27;id in (1,2,3,4)&#x27;)-&gt;limit(2)-&gt;select()); //数组操作 //SELECT * FROM `user1` WHERE id in (1,2,3,4) LIMIT 2 $user = M(&#x27;user1&#x27;); var_dump($user-&gt;select(array(&#x27;where&#x27;=&gt;&#x27;id in (1,2,3,4)&#x27;, &#x27;limit&#x27;=&gt;&#x27;2&#x27;, ))); // CURD处理 // SELECT * FROM `user1` WHERE ( id=1 ) LIMIT 1 // DELETE FROM `user1` WHERE ( id=2 ) $user = M(&#x27;user1&#x27;); var_dump($user-&gt;where(&#x27;id=1&#x27;)-&gt;find()); var_dump($user-&gt;where(&#x27;id=2&#x27;)-&gt;delete()); 1.where(支持字符串条件、数组条件（推荐用法）和多次调用。)1234567891011121314151617181920212223242526//字符串方式 //SELECT * FROM `user1` WHERE ( id=6 ) var_dump($user-&gt;where(&#x27;id=6&#x27;)-&gt;select()); //索引数组方式 // SELECT * FROM `user1` WHERE `id` = 6 $map[&#x27;id&#x27;]=6; var_dump($user-&gt;where($map)-&gt;select()); //多次调用方式 SELECT * FROM `user1` WHERE `id` = 6 AND ( name=&quot;test&quot; ) $map[&#x27;id&#x27;]=array(&#x27;eq&#x27;,6); var_dump($user-&gt;where($map)-&gt;where(&#x27;name=&quot;test&quot;&#x27;)-&gt;select()); 2.order 用于对结果集排序1234567891011121314151617181920212223// 倒序 // SELECT * FROM `user1` ORDER BY id desc var_dump($user-&gt;order(&#x27;id desc&#x27;)-&gt;select()); // 第二排序 // SELECT * FROM `user1` ORDER BY id desc,age desc var_dump($user-&gt;order(&#x27;id desc,age desc&#x27;)-&gt;select()); //数组形式，防止字段和mysql关键字冲突 // SELECT * FROM `user1` ORDER BY `id` DESC,`email` DESC $map[&#x27;id&#x27;]=1; var_dump($user-&gt;order(array(&#x27;id&#x27;=&gt;&#x27;DESC&#x27;,&#x27;email&#x27;=&gt;&#x27;DESC&#x27;))-&gt;select()); 3.feild（feild 方法可以返回或操作字段，可以用于查询和写入操作。）123456789101112131415161718192021222324252627282930313233343536 // 只显示id和name两个字段 // SELECT `id`,`name` FROM `user1` var_dump($user-&gt;field(&#x27;id,name&#x27;)-&gt;select()); //使用SQL函数和别名 // SELECT SUM(id) as count,`name` FROM `user1` var_dump($user-&gt;field(&#x27;SUM(id) as count,name&#x27;)-&gt;select()); // 使用数组参数结合SQL函数 // SELECT `id`,LEFT(name,1) AS `left_user` FROM `user1` var_dump($user-&gt;field(array(&#x27;id&#x27;,&#x27;LEFT(name,1)&#x27;=&gt;&#x27;left_user&#x27;))-&gt;select()); //获取所有字段 // SELECT * FROM `user1` var_dump($user-&gt;field()-&gt;select()); //用于写入 $user-&gt;field(&#x27;name,email&#x27;)-&gt;create(); 4.limit（主要用于指定查询和操作的数量）12345678910111213//限制结果集数量 // SELECT * FROM `user1` LIMIT 2 var_dump($user-&gt;limit(2)-&gt;select()); //分页查询 // SELECT * FROM `user1` LIMIT 1,2 var_dump($user-&gt;limit(1,2)-&gt;select()); 5.page（page 方法完全用于分页查询）12345//page分页 // SELECT * FROM `user1` LIMIT 3,3 var_dump($user-&gt;page(2,3)-&gt;select()); 6.table（用于数据表操作，主要是切换数据表或多表操作）12345//切换数据表 // SELECT * FROM `test_user` var_dump($user-&gt;table(&#x27;test_user&#x27;)-&gt;select()); 7.alias （用于设置数据表别名）12345// 设置别名 // SELECT * FROM user1 a var_dump($user-&gt;alias(&#x27;a&#x27;)-&gt;select()); 8.group（用于对结合函数统计的结果集分组）12345 // 分组统计// SELECT `name`,max(id) FROM `user1` GROUP BY idvar_dump($user-&gt;field(&#x27;name,max(id)&#x27;)-&gt;group(&#x27;id&#x27;)-&gt;select()); 9.having（用于配合 group 方法完成从分组的结果中再筛选数据）12345//分组统计结合having // SELECT `user`,max(id) FROM `user1` GROUP BY id HAVING id&gt;2 var_dump($user-&gt;field(&#x27;user,max(id)&#x27;)-&gt;group(&#x27;id&#x27;)-&gt;having(&#x27;id&gt;2&#x27;)-&gt;select()); 10.comment （用于对 SQL 语句进行注释）12345//SQL注释 // SELECT * FROM `user1` /* test */ var_dump($user-&gt;comment(&#x27;test&#x27;)-&gt;select()); 2.ThinkPHP 数据的增删改查1、增ThinkPHP 内置的 add 方法用于向数据表添加数据，相当于 SQL 中的 INSERT INTO 行为。 12345678910111213 1 public function insert()&#123; 2 header(&quot;Content-Type:text/html; charset=utf-8&quot;); 3 $Dao = M(&quot;User&quot;); // 实例化模型类 4 5 // 构建写入的数据数组 6 $data[&quot;username&quot;] = &quot;小王&quot;; 7 $data[&quot;password&quot;] = md5(&quot;123456&quot;); 8 $data[&quot;email&quot;] = &quot;12345@163.com&quot;; 9 $data[&quot;regdate&quot;] = time();10 11 // 写入数据12 $insertM = $Dao-&gt;add($data)；13 &#125; 等同于SQL语句： 1INSERT INTO user(username,password,email,regdate) VALUES (&#x27;小王&#x27;,&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;,&#x27;12345@163.com&#x27;,1486974334); 2、删delete() 方法执行成功返回操作影响（删除）的记录数。 1234561 public function del()&#123;2 header(&quot;Content-Type:text/html; charset=utf-8&quot;);3 $Dao = M(&quot;User&quot;);4 // 删除 uid=5 的数据记录5 $result = $Dao-&gt;where(&#x27;uid = 5&#x27;)-&gt;delete();6 &#125; 等同于SQL语句： 1DELETE FROM user WHERE uid = 5; 3、改ThinkPHP 内置的 save() 方法用于向数据表更新数据，相当于 SQL 中的 UPDATE 行为。 1234567891011 1 public function update()&#123; 2 header(&quot;Content-Type:text/html; charset=utf-8&quot;); 3 $Dao = M(&quot;User&quot;); 4 5 // 需要更新的数据 6 $data[&#x27;email&#x27;] = &#x27;Jack@163.com&#x27;; 7 // 更新的条件 8 $condition[&#x27;username&#x27;] = &#x27;Jack&#x27;; 9 $result = $Dao-&gt;where($condition)-&gt;save($data);10 //或者：$resul t= $Dao-&gt;where($condition)-&gt;data($data)-&gt;save();11 &#125; 等同于SQL语句： 1UPDATE user SET email=&#x27;Jack@163.com&#x27; WHERE username=&#x27;Jack&#x27;; 提示 为了保证数据库的安全，避免出错更新整个数据表，如果没有任何更新条件，数据对象本身也不包含主键字段的话，save方法不会更新任何数据库的记录。 因此要使用 save() 方法更新数据，必须指定更新条件或者更新的数据中包含主键字段。 4、查 ThinkPHP 查询数据主要提供以下几类查询： 1）select是 ThinkPHP 中最常用的普通查询方法，得到的是一个二维数组。 12345678910111213141516171819202122232425262728293031 1 //方法php 2 public function read()&#123; 3 $Dao = M(&quot;User&quot;); 4 5 // 查询数据 6 $list = $Dao-&gt;select(); 7 //dump($list); // 用 dump() 可以在调试阶段查看数据是否已读取 8 9 // 模板变量赋值10 $this-&gt;assign(&quot;list&quot;, $list);11 // 输出模板12 $this-&gt;display();13 &#125;14 15 //模板html16 &lt;table border=&quot;1&quot;&gt;17 &lt;tr&gt;18 &lt;th width=&quot;10%&quot;&gt;ID&lt;/th&gt;19 &lt;th width=&quot;30%&quot;&gt;用户名&lt;/th&gt;20 &lt;th width=&quot;30%&quot;&gt;电子邮件&lt;/th&gt;21 &lt;th&gt;注册时间&lt;/th&gt;22 &lt;/tr&gt;23 &lt;volist name=&quot;list&quot; id=&quot;vo&quot;&gt;//循环显示24 &lt;tr&gt;25 &lt;td align=&quot;center&quot;&gt;&#123;$vo[&#x27;uid&#x27;]&#125;&lt;/td&gt;26 &lt;td&gt;&#123;$vo[&#x27;username&#x27;]&#125;&lt;/td&gt;27 &lt;td&gt;&#123;$vo[&#x27;email&#x27;]&#125;&lt;/td&gt;28 &lt;td&gt;&#123;$vo[&#x27;regdate&#x27;]|date=&#x27;Y-m-d H:i&#x27;,###&#125;&lt;/td&gt;29 &lt;/tr&gt;30 &lt;/volist&gt;31 &lt;/table&gt; 2）find该方法是和 select() 用法类似的一个方法，不同之处 find() 查询出来的始终只有一条数据，即系统自动加上了 LIMIT 1 限制。 12345678910111213141516 1 //当确认查询的数据记录只能是一条记录时，建议使用 find() 方法查询，如用户登录账号检测： 2 3 public function chekUser()&#123; 4 header(&quot;Content-Type:text/html; charset=utf-8&quot;); 5 $Dao = M(&quot;User&quot;); 6 7 // 构造查询条件 8 $condition[&#x27;username&#x27;] = &#x27;Admin&#x27;; 9 $condition[&#x27;password&#x27;] = MD5(&#x27;123456&#x27;);10 // 查询数据11 $list = $Dao-&gt;where($condition)-&gt;find();12 &#125;13 14 //与 select() 的另一个不同之处在于，find() 返回的是一个一维数组，可以在模板里直接输出数组单元的值而无需使用 volist 等标签循环输出：15 16 &lt;p&gt;&#123;$list[&#x27;username&#x27;]&#125;&lt;/p&gt; 3）getBy动态查询是一个魔术方法，可以根据某个字段名称动态得到对应的一条数据记录。 12345671 public function chekUser()&#123;2 header(&quot;Content-Type:text/html; charset=utf-8&quot;);3 $Dao = M(&quot;User&quot;);4 5 // 查询数据6 $user = $Dao-&gt;getByUsername(&#x27;Admin&#x27;);7 &#125; 等同于SQL语句： 1SELECT * FROM user WHERE username = &#x27;Admin&#x27; LIMIT 1 提示： 请注意，在getBy之后紧跟着的字段名称，首字母必须大写。对于如 user_name 这样的字段名称，以驼峰法自动识别下划线，即： 1$user = $Dao-&gt;getByUserName(&#x27;Admin&#x27;); 实际使用中可以灵活根据查询的字段名来定义 getBy 放入，如：getByEmail、getByTitle、getById 等。 4）getField是专门用于获取某个字段的值或者多个字段的索引数组。该方法与 field方法 不同，是一个独立的方法而不需要再使用 find 或者 select 。 参数 说明 fields 必须，需要查询的字段名称，可以是一个或多个字段 condition 可选，查询条件，可以是字符或数组，参考 select 方法查询条件 spea 可选，多个字段数据生成关联数组时，数据间隔符号，默认为空格 1234567891011121314 1 public function select()&#123; 2 header(&quot;Content-Type:text/html; charset=utf-8&quot;); 3 $Dao = M(&quot;User&quot;); 4 $list = $Dao-&gt;getField(&#x27;uid,username,email&#x27;,&#x27;uid &lt; 4&#x27;,&#x27;|&#x27;); 5 dump($list); 6 &#125; 7 8 //dump 打印出的结果是： 9 10 array(3) &#123;11 [1] =&gt; string(21) &quot;admin|admin@5idev.com&quot;12 [2] =&gt; string(23) &quot;小明|xiaoming@163.com&quot;13 [3] =&gt; string(19) &quot;Jack|jack@gmail.com&quot;14 &#125; 5）区间查询取得符合查询条件的区间记录 1234567891011 1 public function read()&#123; 2 $Dao = M(&#x27;User&#x27;); 3 $condition[&#x27;uid&#x27;] = array(array(&#x27;gt&#x27;,1),array(&#x27;lt&#x27;,5));//(uid &gt; 1) AND (uid &lt; 5)3.1 $condition[&#x27;uid&#x27;] = array(array(&#x27;gt&#x27;,3),array(&#x27;lt&#x27;,10), &#x27;or&#x27;);//(uid &lt; 1) OR (uid &gt; 10)3.2 $condition[&#x27;username&#x27;] = array(array(&#x27;like&#x27;,&#x27;%a%&#x27;), array(&#x27;like&#x27;,&#x27;%b%&#x27;), &#x27;Admin&#x27;,&#x27;or&#x27;);//(username LIKE &#x27;%a%&#x27;) OR (username LIKE &#x27;%b%&#x27;) OR (username = &#x27;Admin&#x27;) 4 $list = $Dao-&gt;where($condition)-&gt;select(); 5 if($list)&#123; 6 $this-&gt;assign(&#x27;list&#x27;, $list); 7 $this-&gt;display(); 8 &#125; else &#123; 9 $this-&gt;error($Dao-&gt;getError());10 &#125;11 &#125; 等同于SQL语句： 1SELECT * FROM user WHERE ( (uid &gt; 1) AND (uid &lt; 5) ); 6）原生SQL查询尽管ThinkPHP内置了大量的数据操作方法，但ThinkPHP仍保留了对原生SQL查询的支持，以便满足复杂查询的需要和一些特殊的数据操作。SQL查询的返回值是直接返回DB类的查询结果，没有做任何的处理，而且可以支持查询缓存。 原生SQL查询有 query() 和 execute() 两个方法： 123456789101112131415161718192021222324252627 1 //query() 方法是用于 SQL 查询操作，和select()方法一样返回符合查询条件的数据集。 2 //对于 query() 方法返回的数据集，跟 select() 一样，可以在模板里直接循环输出。 3 public function read()&#123; 4 // 实例化一个空模型，没有对应任何数据表 5 $Dao = M(); 6 //或者使用 $Dao = new Model(); 7 8 $list = $Dao-&gt;query(&quot;select * from user where uid&lt;5&quot;); 9 if($list)&#123;10 $this-&gt;assign(&#x27;list&#x27;, $list );11 $this-&gt;display();12 &#125; else &#123;13 $this-&gt;error($Dao-&gt;getError());14 &#125;15 &#125;16 17 18 //execute() 方法用于更新和写入数据的 SQL 操作（注：非查询操作，无返回数据集），返回影响的记录数。19 20 public function read()&#123;21 header(&quot;Content-Type:text/html; charset=utf-8&quot;);22 // 实例化一个空模型，没有对应任何数据表23 $Dao = M();24 //或者使用 $Dao = new Model();25 26 $num = $Dao-&gt;execute(&quot;update user set email = &#x27;12345@xxx.com&#x27; where uid=3&quot;);27 &#125; 7）统计查询取得符合查询条件的统计数据 count()方法用于统计数据行数。 12345678910 1 public function read()&#123; 2 $Dao = M(&#x27;User&#x27;); 3 // 获取用户数： 4 $userCount = $Dao-&gt;count(); 5 // 添加条件： 6 $userCount2 = $Dao-&gt;where(&#x27;uid &gt; 10&#x27;)-&gt;count(); 7 8 $this-&gt;assign(&#x27;userCount&#x27;, $userCount); 9 $this-&gt;display();10 &#125;//可以在模板中直接输出得到的统计数据：共有用户 &#123;$userCount&#125; 人。 两个查询语句实际执行的 SQL 为： 121 SELECT COUNT(*) AS tp_count FROM user LIMIT 1 2 SELECT COUNT(*) AS tp_count FROM user WHERE uid &gt; 10 LIMIT 1 max()方法用于统计某个字段最大数据。 121 //统计用户最大积分例子：2 $maxScore = $Dao-&gt;max(&#x27;score&#x27;); 实际执行的 SQL 为： 1SELECT MAX(score) AS tp_max FROM user LIMIT 1 ; min()统计某个字段最小数据。 121 //获取积分大于 0 的用户的最小积分例子：2 $minScore = $Dao-&gt;where(&#x27;score&gt;0&#x27;)-&gt;min(&#x27;score&#x27;); 实际执行的 SQL 为： 1SELECT MIN(score) AS tp_min FROM user WHERE score&gt;0 LIMIT 1; avg()统计某个字段平均数据。 121 //获取用户的平均积分例子：2 $avgScore = $Dao-&gt;avg(&#x27;score&#x27;); 实际执行的 SQL 为： 1SELECT AVG(score) AS tp_avg FROM user LIMIT 1; sum()统计某个字段数据之和。 121 //统计积分排名前 10 名用户的积分之和：2 $sumScore = $Dao-&gt;order(&#x27;score DESC&#x27;)-&gt;limit(&#x27;10&#x27;)-&gt;sum(&#x27;score&#x27;); 实际执行的 SQL 为： 1SELECT SUM(score) AS tp_sum FROM user ORDER BY score DESC LIMIT 10; 5.软删除123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293Login.php&lt;?phpnamespace app\\index\\controller;use think\\Controller;use Gregwar\\Captcha\\CaptchaBuilder;use think\\Loader;use app\\index\\model\\Data;use think\\Db;class Login extends Controller&#123;public function _initialize()&#123;//parent::__construct();$this-&gt;data = Loader::model(&#x27;data&#x27;);&#125;public function delData()&#123;//删除id=16的记录$res = Data::destroy(16);//返回int(1)受影响记录数量dump($res);&#125;//删除后进行查询验证public function selData()&#123;//返回为null，表示删除成功//dump(Data::get(16));$res = Data::select();foreach ($res as $k =&gt; $v) &#123;//getData()函数可以获取对象里面的数据dump($v-&gt;getData());&#125;&#125;//默认情况下，查询到的数据不包含软删除数据，如果需要包含软删除的数据public function selData1()&#123;//查询单条数据$res = Data::withTrashed(true)-&gt;find();dump($res-&gt;getData());//查询多条数据$res = Data::withTrashed(true)-&gt;select();foreach ($res as $k =&gt; $v) &#123;dump($v-&gt;getData());&#125;&#125;//如果只想删除软删除的数据，相当于查看回收站public function selData2()&#123;//单条数据$res = Data::onlyTrashed(true)-&gt;find();dump($res-&gt;getData());//多条数据$res = Data::onlyTrashed(true)-&gt;select();foreach ($res as $key =&gt; $val) &#123;dump($val-&gt;getData());&#125;&#125; //恢复软删除记录//控制器中将被软删除的delete_time更新为null即可public function selData3()&#123;$res = Data::update([&#x27;delete_time&#x27; =&gt; null,], [&#x27;id&#x27; =&gt; 16]);dump($res);//现在就可以获取重新被软删除的记录了$res = Data::get(16);dump($res-&gt;getData());&#125; //物理删除是指彻底将该记录从表中移除，不可恢复。给destroy()方法传入第二个参数truepublic function delReal()&#123;//删除id为16的记录$res = Data::destroy(16, true);dump($res);//使用delete(true)实现物理删除$res = Data::where(&#x27;id&#x27;, 18)-&gt;delete();dump($res);&#125;&#125; Data.php 123456789101112131415161718192021222324Data.php&lt;?phpnamespace app\\index\\model;use think\\Db;use think\\Model;use traits\\model\\SoftDelete;class Data extends Model&#123;//在当前类导入，就可以使用其中的方法啦use SoftDelete;//如果你的字段名为框架默认的delete_time,可省略protected $deleteTime = &#x27;delete_time&#x27;;protected $table = &#x27;bbs_data&#x27;;public function getMenu()&#123;$res = Db::name($this-&gt;table)-&gt;select();return $res;&#125;&#125; 3.TP5框架model操作【增删改查、聚合、时间戳、软删除等 使用model 查询数据，添加数据，修改数据，删除数据 聚合操作 获取器，修改器 自动添加时间戳（创建时间，修改时间） 软删除 1、使用model查询数据12345$res = User::get(1); //获取主键为1的数据，得到的是一个对象 $res = $res- toArray(); //将对象转化为数组 dump($res- name); //获取 $res 里 name 字段的值 12345//使用闭包函数查询 id=1 的记录$res = User::get(function($query)&#123; $query- where(&quot;id&quot;,&quot;eq&quot;,1) - field(&#x27;name&#x27;)&#125;); 12345$res = User::where(&quot;id&quot;,10)- value(&#x27;name&#x27;);$res = User::where(&quot;id&quot;,10)- field(&#x27;name&#x27;)- find(); $res = User::column(&#x27;email&#x27;); //查询所有的 email 字段值 $res = User::where(&quot;id&quot;,&quot; &quot;,5)- select(); //查询所有id大于5的记录 12345$res = User::all(&#x27;1,2&#x27;); //查询主键等于 1 或2 的记录foreach($res as $val) //转化为数组&#123; dump($val- toArray());&#125; 12345//使用闭包函数查询 id&lt;5 的记录$res = User::get(function($query)&#123; $query- where(&quot;id&quot;,&quot;&lt;&quot;,5) - field(&#x27;name&#x27;)&#125;); 2、使用model添加数据1234567$res = User::create([ &#x27;name&#x27; = &#x27;yulong&#x27;, &#x27;pwd&#x27; = &#x27;123&#x27;],true); //第二个参数为true时，只添加数据表中已有的字段，不报错，不写则默认为false；；；true 也可以换成一个数组，数组里存放数据表中的字段，表示仅允许数组中的字段添加数据$res- id; //本次添加的自增iddump($res); 123456789$usermodel = new User;$res = $usermodel - allowField(true) //仅允许添加数据表中存在的字段，也可以写成数组 - save([ &#x27;name&#x27; = &#x27;yulong&#x27;, &#x27;pwd&#x27; = &#x27;123&#x27; ]); dump($res- id); //获取新添加数据的自增id 1234567$usermodel = new User;$res = $usermodel- saveAll([ //一次保存多条数据 &#x27;name&#x27; = &#x27;yulong001&#x27;, &#x27;name&#x27; = &#x27;yulong002&#x27;]); dump($ers); 3、使用model更新数据123456789101112$res = User::update([ &#x27;name&#x27; = &#x27;yulong002&#x27;],[&#x27;id&#x27;= 1]); //更新 id=1 的记录 $res = User::update([ &#x27;name&#x27; = &#x27;yulong002&#x27;],function()&#123; $query- where(&quot;id&quot;,&quot;LT&quot;,5); //使用闭包函数更新 id&lt;5 的记录&#125;); dump($res); 1234$res = User::where(&quot;id&quot;,&quot;&lt;&quot;,6) //返回值是被更新数据的行数 - update([ &#x27;name&#x27; = &#x27;hahahaha&#x27; ]); 4、使用model删除数据12345678910$res = User::destriy(1); //删除主键为1的记录，返回影响数据的行数，也可以传递数组 $usermodel = User::get(1);$res = $usermodel- delete(); $res = User::where(&quot;id&quot;,5)- delete(); // where() 里面有三个参数， 字段值，条件，数值 dump($res); 5、使用model聚合操作12345$res = User::where(&quot;id&quot;,&quot; &quot;,5)- count(); //查询id大于5的记录条数 // max 可以换成其他的 如 min / sum / avg$res = User::max(&#x27;num&#x27;); //查询 num 字段中的最大值$res = User::where(&quot;id&quot;,&quot;&lt;&quot;,5)- max(&#x27;num&#x27;); //id&lt;5 的记录中的 num 最大值 6、使用模型获取器1234567891011121314151617//model //方法名： get字段名Attr//controller中获取原始数据使用 $res- getData() public function getSexSttr($val)&#123; switch($val)&#123; case &#x27;1&#x27;: return &quot;男&quot;; break; case &#x27;2&#x27;; return &#x27;女&#x27;; break; default: return &#x27;未知&#x27;; break; &#125;&#125; 7、使用模型修改器12345678910//model 修改器命名 set字段名Attr//修改器作用：在往数据库添加字段时，控制器中写未处理的数据，在模型中的修改器中写处理数据的方法，这样添加到数据库中的数据就是处理过得数据了public function setPwdAttr($val)&#123; return md5($val);&#125; // $val代表 pwd 字段，$data代表接收到的所有数据 ，返回的值就是 pwd+email public function setPwdAttr($val,$data)&#123; return $val.$data[&#x27;email&#x27;];&#125; 8、自动往[数据库]中添加时间戳12345678910111213141516//自动往 time 字段中加入时间戳public function setTimeAttr()&#123; return time();&#125; //在数据添加时发生改变protected $insert = [ &#x27;time_insert&#x27; ]; //设置字段public function setTimeInsertAttr()&#123; //将字段值设置为当前时间 return time();&#125; //在更新数据时发生改变protected $update = [ &#x27;time_update&#x27; ]; //设置字段public function setTimeUpdateAttr()&#123; //将字段值设置为当前时间 return time();&#125; 9、model时间戳 123456789// 数据库中的字段 create_time update_time// database.php 中更改配置 &#x27;auto_timeStamp&#x27; = true// 不推荐使用此方法，因为如果你的数据库表中没有 对应的字段 ，程序可能就会报错// 可以单独在 某个模型中 添加属性 protected $autoWriteTimeStamp = true; //开启自动加入时间戳 protected $createTime = &#x27;create_at&#x27;; //设置 创建的时候写入 的字段 ，值可以为false，关闭操作protedted $updateTime = &#x27;update_at&#x27;; //设置 创建和更新的时候写入 的字段 ，值可以为false，关闭操作 10、软删除 12345678910111213141516171819202122// model// 数据表中的字段 delete_time，默认值可以为 null use traits\\model\\SoftDelete; //使用软删除的类 class User extends Model&#123; use SoftDelete; //在类的开头 use SoftDelete; protected $deleteTime = &#x27;delete_at&#x27;; //设置软删除的字段，默认为 delete_time&#125; $res = User::destroy(3,true); //删除主键为3的记录，第二个参数为 true 时，不是软删除，是tm真删了 $ress = User::get(4);$res = $ress- delete(true); // delete() 没值时，为软删除；值为true，tm的真删 // controller 获取到 软删除 的记录$res = User::withTrashed(true)- find(1); //得到id为1 的经过软删除 删除的记录dump($res- getData()); //获取原始数据 $res = User::onlyTrashed()- select(); //获取所有软删除的数据 4.ThinkPHP 5 操作数据库三种方法一、原生的sql语句1. query：查询操作query简单粗暴的方法 1234public function getDetail($id)&#123; $data= Db::query(&#x27;select * from test&#x27;); return $data; &#125; 可以传参数；用占位符或者命名占位符绑定 1234public function getDetail($id)&#123; $data= Db::query(&#x27;select * from test where id=?&#x27;,[$id]); return $data; &#125; 2. execute：写入操作execute 插入数据，返回值是影响的记录数 12$data= Db::execute(&#x27;insert into test (name) values (?)&#x27;,[&#x27;thinkphp&#x27;]); return $data; 二、使用查询构建器备注：TP5框架有助手函数Db::table(‘user’) 相当于 db(‘user’) 1.find、selectfind()只能返回第一条数据（建议单个查询使用）；select()是把所有符合的查询出来细节： find 方法查询结果不存在，返回 nullselect 方法查询结果不存在，返回空数组 12345678//链式表达式 //链式操作where(&#x27;字段名&#x27;,&#x27;表达式&#x27;,&#x27;查询条件&#x27;)//这里的等号可以缺审$data=Db::table(&#x27;test&#x27;)-&gt;where(&#x27;id&#x27;,1)-&gt;find();$data=Db::table(&#x27;test&#x27;)-&gt;select();//助手函数$data =db(&#x27;test&#x27;)-&gt;where(&#x27;id&#x27;,1)-&gt;find();$data =db(&#x27;test&#x27;)-&gt;select(); 2.insert update 方法返回影响数据的条数，没修改任何数据返回 0 123456789101112131415//插入单条数据 $aa = [&#x27;name&#x27; =&gt; &#x27;good&#x27;]; $data=Db::table(&#x27;test&#x27;)-&gt;insert($aa);//插入多条数据 $bb = [ [&#x27;name&#x27; =&gt; &#x27;bb&#x27;], [&#x27;name&#x27; =&gt; &#x27;cc&#x27;], [&#x27;name&#x27; =&gt; &#x27;dd&#x27;], ]; $data = Db::table(&#x27;test&#x27;)-&gt;insertAll($bb);//函数助手// 添加单条数据 db(&#x27;user&#x27;)-&gt;insert($aa);// 添加多条数据 db(&#x27;user&#x27;)-&gt;insertAll($bb); 3.update1234//更新某一条记录 $data = Db::table(&#x27;test&#x27;)-&gt;where(&#x27;id&#x27;,1)-&gt;update([&#x27;name&#x27;=&gt;&#x27;老张&#x27;]);//更新某条记录的某个字段的值： $data=Db::table(&#x27;test&#x27;)-&gt;where(&#x27;id&#x27;,2)-&gt;setField(&#x27;name&#x27;, &#x27;老四&#x27;); 4.delete delete 方法返回影响数据的条数，没有删除返回 0 1234// 根据主键删除 $data=Db::table(&#x27;test&#x27;)-&gt;delete(6);//可以传入数组，进行批量删除 $data=Db::table(&#x27;test&#x27;)-&gt;delete([7,8]); 5.自增或自减一个字段的值自增或自减一个字段的值setInc&#x2F;setDec 如不加第二个参数，默认值为1；第三个参数是延迟时间，单位秒 12345678// score 字段加 1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;id&#x27;, 1)-&gt;setInc(&#x27;score&#x27;);// score 字段加 5Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;id&#x27;, 1)-&gt;setInc(&#x27;score&#x27;, 5);// score 字段减 1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;id&#x27;, 1)-&gt;setDec(&#x27;score&#x27;);//延迟更新，第三个参数是时间单位秒Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;id&#x27;, 1)-&gt;setInc(&#x27;score&#x27;, 1, 10); 6.使用Query或闭包查询12345678910使用查询对象进行查询$query = new \\think\\db\\Query();$query-&gt;table(&#x27;think_user&#x27;)-&gt;where(&#x27;status&#x27;,1);Db::find($query);Db::select($query);//使用闭包函数查询Db::select(function($query)&#123; $query-&gt;table(&#x27;think_user&#x27;)-&gt;where(&#x27;status&#x27;,1);&#125;); 7.查询表达式 where(‘字段名’,‘表达式’,‘查询条件’);whereOr(‘字段名’,‘表达式’,‘查询条件’);表达式不分大小写，支持的查询表达式有下面几种，分别表示的含义是： 表达式 含义 EQ、&#x3D; 等于（&#x3D;） NEQ、&lt;&gt; 不等于（&lt;&gt;） GT、&gt; 大于（&gt;） EGT、&gt;&#x3D; 大于等于（&gt;&#x3D;） LT、&lt; 小于（&lt;） ELT、&lt;&#x3D; 小于等于（&lt;&#x3D;） LIKE 模糊查询 [NOT] BETWEEN （不在）区间查询 [NOT] IN （不在）IN 查询 [NOT] NULL 查询字段是否（不）是NULL [NOT] EXISTS EXISTS查询 EXP 表达式查询，支持SQL语法 &gt; time 时间比较 &lt; time 时间比较 between time 时间比较 notbetween time 时间比较 显示简略信息 8.链式操作 操作名称 所有的连贯操作都返回当前的模型实例对象（this），其中带*标识的表示支持多次调用。 连贯操作 作用 支持的参数类型 where* 用于AND查询 字符串、数组和对象 whereOr* 用于OR查询 字符串、数组和对象 wheretime* 用于时间日期的快捷查询 字符串 table 用于定义要操作的数据表名称 字符串和数组 alias 用于给当前数据表定义别名 字符串 field* 用于定义要查询的字段（支持字段排除） 字符串和数组 order* 用于对结果排序 字符串和数组 limit 用于限制查询结果数量 字符串和数字 page 用于查询分页（内部会转换成limit） 字符串和数字 group 用于对查询的group支持 字符串 having 用于对查询的having支持 字符串 join* 用于对查询的join支持 字符串和数组 union* 用于对查询的union支持 字符串、数组和对象 view* 用于视图查询 字符串、数组 distinct 用于查询的distinct支持 布尔值 lock 用于数据库的锁机制 布尔值 cache 用于查询缓存 支持多个参数 relation* 用于关联查询 字符串 with* 用于关联预载入 字符串、数组 bind* 用于数据绑定操作 数组或多个参数 comment 用于SQL注释 字符串 force 用于数据集的强制索引 字符串 master 用于设置主服务器读取数据 布尔值 strict 用于设置是否严格检测字段名是否存在 布尔值 sequence 用于设置Pgsql的自增序列名 字符串 failException 用于设置没有查询到数据是否抛出异常 布尔值 partition 用于设置分表信息 数组 字符串 三、模型ORM1.定义 默认主键为自动识别，如果需要指定，可以设置属性： protected $pk = &#39;uid&#39;; 2.引用+获取数据 (get 、all)获取单个数据123456789101112//引用use app\\index\\model\\Test as TestModel;...//获取主键为1的数据 $data = TestModel::get(1);//数组的方法 $data = TestModel::get([&#x27;id&#x27;=&gt;1]);//闭包的方法 $data = TestModel::get(function($query)&#123; $query-&gt;where(&#x27;id&#x27;, 1); &#125;); ... 获取多个数据12345678910111213141516171819202122//引用use app\\index\\model\\Test as TestModel;...//获取所有数据 $data =TestModel::all();// 根据主键获取多个数据$list = User::all(&#x27;1,2,3&#x27;);// 或者使用数组$list = User::all([1,2,3]);foreach($list as $key=&gt;$user)&#123; echo $user-&gt;name;&#125;// 使用数组查询$list = User::all([&#x27;status&#x27;=&gt;1]);// 使用闭包查询$list = User::all(function($query)&#123; $query-&gt;where(&#x27;status&#x27;, 1)-&gt;limit(3)-&gt;order(&#x27;id&#x27;, &#x27;asc&#x27;);&#125;);foreach($list as $key=&gt;$user)&#123; echo $user-&gt;name;&#125; 实例化的方法1234567$user = new Test(); // 查询单个数据 $data=$user-&gt;where(&#x27;id&#x27;, 1) -&gt;find(); return $data; &#125; 3.新增（save、saveAll）新增一条1234567891011121314151617//新增一条$test = new Test;$test-&gt;name = &#x27;thinkphp&#x27;;$test-&gt;save();//data数组批量赋值$test = new Test;$test-&gt;data([ &#x27;name&#x27; =&gt; &#x27;thinkphp&#x27;,]);$test-&gt;save();//直接在实例化的时候传入数据$test = new Test([ &#x27;name&#x27; =&gt; &#x27;thinkphp&#x27;,]);$test-&gt;save(); 批量新增123456$test = new Test;$list = [ [&#x27;name&#x27;=&gt;&#x27;thinkphp&#x27;], [&#x27;name&#x27;=&gt;&#x27;onethink&#x27;]];$test-&gt;saveAll($list); 4.更新（save、saveAll、update）查询与更新12345678910111213//在取出数据后，更改字段内容后更新数据。$test = new Test;$test= Test::get(1);$test-&gt;name = &#x27;thinkphp&#x27;;$test-&gt;save();.....//也可以直接带更新条件来更新数据$test = new Test;// save方法第二个参数为更新条件$test-&gt;save([ &#x27;name&#x27; =&gt; &#x27;thinkphp&#x27;,],[&#x27;id&#x27; =&gt; 1]); 批量更新 批量更新仅能根据主键值进行更新，其它情况请使用foreach遍历更新。 123456$test = new Test;$list = [ [&#x27;id&#x27;=&gt;1, &#x27;name&#x27;=&gt;&#x27;thinkphp&#x27;], [&#x27;id&#x27;=&gt;2, &#x27;name&#x27;=&gt;&#x27;onethink&#x27;]];$test-&gt;saveAll($list); 静态方法更新1234567$data=Test::where(&#x27;id&#x27;, 1) -&gt;update([&#x27;name&#x27; =&gt; &#x27;thinkphp&#x27;]);//$data是受影响行数//或者使用：$data=Test::update([&#x27;id&#x27; =&gt; 1, &#x27;name&#x27; =&gt; &#x27;thinkphp&#x27;]);//$data返回结果集 5.删除（delete、destroy）1234567891011121314151617//delete方法$data = Test::get(5);$data-&gt;delete();//根据主键删除//或者直接调用静态方法User::destroy(1);// 支持批量删除多个数据User::destroy(&#x27;1,2,3&#x27;);// 或者User::destroy([1,2,3]);//条件删除// 删除状态为0的数据User::destroy([&#x27;status&#x27; =&gt; 0]);//或者通过数据库类的查询条件删除User::where(&#x27;id&#x27;,&#x27;&gt;&#x27;,10)-&gt;delete(); V5.0.9+版本开始当destroy方法传入空值（包括空字符串和空数组）的时候不会做任何的数据删除操作，但传入0则是有效的","categories":[{"name":"后端","slug":"后端","permalink":"https://2486125878.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"php","slug":"php","permalink":"https://2486125878.github.io/tags/php/"}]},{"title":"thinkphp","slug":"thinkphp","date":"2024-03-13T07:04:55.000Z","updated":"2024-03-13T08:23:04.000Z","comments":true,"path":"2024/03/13/thinkphp/","permalink":"https://2486125878.github.io/2024/03/13/thinkphp/","excerpt":"","text":"Thinkphp5目录架构12345678910111213141516171819202122232425262728293031323334353637383940414243444546thinkphp 应用部署目录├─application 应用目录（可设置）│ ├─common 公共模块目录（可更改）│ ├─index 模块目录(可更改)│ │ ├─config.php 模块配置文件│ │ ├─common.php 模块函数文件│ │ ├─controller 控制器目录│ │ ├─model 模型目录│ │ ├─view 视图目录│ │ └─ ... 更多类库目录│ ├─command.php 命令行工具配置文件│ ├─common.php 应用公共（函数）文件│ ├─config.php 应用（公共）配置文件│ ├─database.php 数据库配置文件│ ├─tags.php 应用行为扩展定义文件│ └─route.php 路由配置文件├─extend 扩展类库目录（可定义）├─public WEB 部署目录（对外访问目录）│ ├─static 静态资源存放目录(css,js,image)│ ├─index.php 应用入口文件│ ├─router.php 快速测试文件│ └─.htaccess 用于 apache 的重写├─runtime 应用的运行时目录（可写，可设置）├─vendor 第三方类库目录（Composer）├─thinkphp 框架系统目录│ ├─lang 语言包目录│ ├─library 框架核心类库目录│ │ ├─think Think 类库包目录│ │ └─traits 系统 Traits 目录│ ├─tpl 系统模板目录│ ├─.htaccess 用于 apache 的重写│ ├─.travis.yml CI 定义文件│ ├─base.php 基础定义文件│ ├─composer.json composer 定义文件│ ├─console.php 控制台入口文件│ ├─convention.php 惯例配置文件│ ├─helper.php 助手函数文件（可选）│ ├─LICENSE.txt 授权说明文件│ ├─phpunit.xml 单元测试配置文件│ ├─README.md README 文件│ └─start.php 框架引导文件├─build.php 自动生成定义文件（参考）├─composer.json composer 定义文件├─LICENSE.txt 授权说明文件├─README.md README 文件├─think 命令行入口文件 命名空间规范应用类库的根命名空间统一为app(可以设置app_namespace配置参数更改)；例如：app\\index\\controller\\Index 和 app\\index\\model\\User 属性命名 类的命名采用驼峰法，并且首字母大写，例如User、UserType，默认不需要添加后缀，例如UserController应该直接命名为User; 在Thinkphp3中需要UserController等命名方式； 函数的命名使用小写和下划线（小写字母开头的方式），例如get_client_ip ; 方法的命名使用驼峰法，并且首字母小写，例如getUserName ; 属性的命名使用驼峰法，并且首字母小写，例如tableName 、 instance 变量类型方法 方法 描述 param 获取当前请求的变量 get 获取 $_GET 变量 post 获取 $_POST 变量 put 获取 $_PUT 变量 delete 获取 $_DELETE 变量 session 获取 $_SESSION 变量 cookie 获取 $_COOKIE 变量 request 获取 $_REQUEST 变量 server 获取 $_SERVER 变量 env 获取 $_ENV 变量 route 获取 路由（包括PATHINFO） 变量 file 获取 $_FILE 变量 获取PARAM参数12345input(&#x27;param.name&#x27;); // 获取单个参数input(&#x27;param.&#x27;); // 获取全部参数// 下面是等效的input(&#x27;name&#x27;); input(&#x27;&#x27;); Thinkphp5目录架构#12345678910111213141516171819202122232425262728293031323334353637383940414243444546thinkphp 应用部署目录├─application 应用目录（可设置）│ ├─common 公共模块目录（可更改）│ ├─index 模块目录(可更改)│ │ ├─config.php 模块配置文件│ │ ├─common.php 模块函数文件│ │ ├─controller 控制器目录│ │ ├─model 模型目录│ │ ├─view 视图目录│ │ └─ ... 更多类库目录│ ├─command.php 命令行工具配置文件│ ├─common.php 应用公共（函数）文件│ ├─config.php 应用（公共）配置文件│ ├─database.php 数据库配置文件│ ├─tags.php 应用行为扩展定义文件│ └─route.php 路由配置文件├─extend 扩展类库目录（可定义）├─public WEB 部署目录（对外访问目录）│ ├─static 静态资源存放目录(css,js,image)│ ├─index.php 应用入口文件│ ├─router.php 快速测试文件│ └─.htaccess 用于 apache 的重写├─runtime 应用的运行时目录（可写，可设置）├─vendor 第三方类库目录（Composer）├─thinkphp 框架系统目录│ ├─lang 语言包目录│ ├─library 框架核心类库目录│ │ ├─think Think 类库包目录│ │ └─traits 系统 Traits 目录│ ├─tpl 系统模板目录│ ├─.htaccess 用于 apache 的重写│ ├─.travis.yml CI 定义文件│ ├─base.php 基础定义文件│ ├─composer.json composer 定义文件│ ├─console.php 控制台入口文件│ ├─convention.php 惯例配置文件│ ├─helper.php 助手函数文件（可选）│ ├─LICENSE.txt 授权说明文件│ ├─phpunit.xml 单元测试配置文件│ ├─README.md README 文件│ └─start.php 框架引导文件├─build.php 自动生成定义文件（参考）├─composer.json composer 定义文件├─LICENSE.txt 授权说明文件├─README.md README 文件├─think 命令行入口文件 规范# ThinkPHP5.0的URl访问受路由决定，如果关闭路由或者没有匹配路由的情况下，则是基于： http://serverName/index.php(或者其他应用入口文件，可省略) &#x2F;模块&#x2F; 控制器&#x2F;操作 &#x2F; 参数 &#x2F;值 在Thinkphp5.0框架中，在url地址栏里面如果不写模块、控制器和操作名，默认访问的就是index模块下面的index控制器下面的index操作，可以在config.php文件中进行修改。 入口文件# 用户请求的PHP文件，负责处理一个请求（注意，不一定是URL请求）的生命周期，最常见的入口文件就是index.php, 有时候也会为了某些特殊的需求而增加新的入口文件，例如给后台模块单独设置的一个入口文件admin.php或者一个控制器程序入口think都属于入口文件。 命名空间规范#应用类库的根命名空间统一为app(可以设置app_namespace配置参数更改)；例如：app\\index\\controller\\Index 和 app\\index\\model\\User; 属性命名# 类的命名采用驼峰法，并且首字母大写，例如User、UserType，默认不需要添加后缀，例如UserController应该直接命名为User; 在Thinkphp3中需要UserController等命名方式； 函数的命名使用小写和下划线（小写字母开头的方式），例如get_client_ip ; 方法的命名使用驼峰法，并且首字母小写，例如getUserName ; 属性的命名使用驼峰法，并且首字母小写，例如tableName 、 instance; 应用类库命名空间规范#应用类库的根命名空间统一为app(可以设置app_namespace配置参数更改)；例如：app\\index\\controller\\Index 和 app\\index\\model\\User; 请求#Thinkphp助手参数#判断变量是否定义12input(&#x27;?get.id&#x27;);input(&#x27;?post.name&#x27;); 变量类型方法: 方法 描述 param 获取当前请求的变量 get 获取 $_GET 变量 post 获取 $_POST 变量 put 获取 $_PUT 变量 delete 获取 $_DELETE 变量 session 获取 $_SESSION 变量 cookie 获取 $_COOKIE 变量 request 获取 $_REQUEST 变量 server 获取 $_SERVER 变量 env 获取 $_ENV 变量 route 获取 路由（包括PATHINFO） 变量 file 获取 $_FILE 变量 获取PARAM参数12345input(&#x27;param.name&#x27;); // 获取单个参数input(&#x27;param.&#x27;); // 获取全部参数// 下面是等效的input(&#x27;name&#x27;); input(&#x27;&#x27;); 获取GET参数123456// 获取单个变量input(&#x27;get.id&#x27;);// 使用过滤方法获取 默认为空字符串input(&#x27;get.name&#x27;);// 获取全部变量input(&#x27;get.&#x27;); 使用过滤方法123input(&#x27;get.name&#x27;,&#x27;&#x27;,&#x27;htmlspecialchars&#x27;); // 获取get变量 并用htmlspecialchars函数过滤input(&#x27;username&#x27;,&#x27;&#x27;,&#x27;strip_tags&#x27;); // 获取param变量 并用strip_tags函数过滤input(&#x27;post.name&#x27;,&#x27;&#x27;,&#x27;org\\Filter::safeHtml&#x27;); // 获取post变量 并用org\\Filter类的safeHtml方法过滤 使用变量修饰符1234input(&#x27;get.id/d&#x27;);input(&#x27;post.name/s&#x27;);input(&#x27;post.ids/a&#x27;); 修饰符 修饰符 作用 s 强制转换为字符串类型 d 强制转换为整形类型 b 强制转换为布尔类型 a 强制转换为数组类型 f 强制转换为浮点类型 请求Request对象的主要职责是统一和更安全地获取当前的请求信息，你需要避免直接操作 $_GET、$_POST、$_REQUEST、$_SESSION、$_COOKIE、$_FILES等全局变量， 而是统一使用Request对象提供的方法来获取请求变量。 ThinkPHP5的Request对象由think\\Request类完成。 $request &#x3D; Request::instance(); 也可以使用助手函数 $request = request(); 123`$request = Request::instance();`// 获取当前域名`echo &#x27;domain: &#x27; . $request-&gt;domain() . &#x27;&lt;br/&gt;&#x27;;` 方法 描述 param 获取当前请求的变量（自动识别GET、POST、PUT请求的一种变量获取方式，是系统推荐的获取请求参数方法） get 获取$_GET变量 post 获取$_POST变量 put 获取PUT变量 delete 获取DELETE变量 session 获取$_SESSION变量 cookie 获取$_COOKIE变量 request 获取$_REQUEST变量 server 获取$_SERVER变量 env 获取$_ENV变量 file 获取$_FILES变量 改变变量 如果需要更改请求变量的值，可以通过下面的方式： 更改GET变量 Request::instance()-&gt;get([&#39;id&#39;=&gt;10]); 更改POST变量 Request::instance()-&gt;post([&#39;name&#39;=&gt;&#39;thinkphp&#39;]); 尽量避免直接修改$_GET或者$_POST 数据,同时也不能直接修改param变量，例如下面的操作是无效的。 更改请求变量 Request::instance()-&gt;param([&#39;id&#39;=&gt;10]); 伪静态 URL伪静态通常是为了满足更好的SEO效果，ThinkPHP支持伪静态URL设置，可以通过设置url_html_suffix参数随意在URL的最后增加你想要的静态后缀，而不影响当前操作的正常执行。例如，我们设置 &#39;url_html_suffix&#39;=&gt;&#39;shtml&#39; 如果要获取当前的伪静态后缀，可以使用Request对象的ext方法。 路由路由功能由\\think\\Route类完成。 由于ThinkPHP5.0默认采用的URL规则是： 1http://server/module/controller/action/param/value/..... 路由的作用是简化URL访问地址，并根据定义的路由类型做出正确的解析。 路由模式ThinkPHP5.0的路由比较灵活，并且不需要强制定义，可以总结归纳为如下三种方式： 普通模式关闭路由，完全使用默认的PATH_INFO方式URL： 1url_route_on =&gt; false, 路由关闭后，不会解析任何路由规则，采用默认的PATH_INFO模式访问URL: 1http://serverName/index.php/module/controller/action/param/value/... 混合模式开启路由，并使用路由定义+默认PATH_INFO方式的混合: 12&#x27;url_route_on&#x27; =&gt; true,&#x27;url_route_must&#x27; =&gt; false, 该方式下面，只需要对需要定义路由规则的访问地址定义路由规则，其他的仍然按照第一种普通模式的PATH_INFO模式访问URL。 强制模式开启路由，并设置必须定义路由才能访问： 12url_route_on =&gt; true,url_route_must =&gt; true, 这种方式下面必须严格给每一个访问地址定义路由规则（包括首页），否则将抛出异常。 首页的路由规则采用/定义即可，例如下面把网站首页路由输出Hello,world!我们需要在route.php这个文件中配置路由，要使用官方的 use think\\Route 123Route::get(&#x27;/&#x27;,function()&#123; return &#x27;Hello,world!&#x27;;&#125;); 路由定义路由注册可以采用方法动态单个和批量注册，也可以直接定义路由定义文件的方式进行集中注册。 动态注册路由定义采用\\think\\Route类的rule方法注册，通常是在应用的路由配置文件 application/route.php进行注册，格式是： 1234567Route::rule(&#x27;路由表达式&#x27;，&#x27;路由地址&#x27;，&#x27;请求类型&#x27;，&#x27;路由参数（数组）&#x27;，&#x27;变量规则（数组）&#x27;);use think\\Route;// 注册路由到index模块的Index控制器的list操作Route::rule(&#x27;new/:id&#x27;,&#x27;index/Index/list&#x27;);//表示定义的路由规则在POST请求下才有效。注意：请求类型参数必须大写。Route::rule(&#x27;new/:id&#x27;,&#x27;News/update&#x27;,&#x27;POST&#x27;); 请求类型包括： 类型 GET GET请求 POST POST请求 PUT PUT请求 DELETE DELETE请求 * 任何请求类型 系统提供了为不同的请求类型定义路由规则的简化方法，例如：12345Route::get(&#x27;new/:id&#x27;,&#x27;News/read&#x27;); // 定义GET请求路由规则Route::post(&#x27;new/:id&#x27;,&#x27;News/update&#x27;); // 定义POST请求路由规则Route::put(&#x27;new/:id&#x27;,&#x27;News/update&#x27;); // 定义PUT请求路由规则Route::delete(&#x27;new/:id&#x27;,&#x27;News/delete&#x27;); // 定义DELETE请求路由规则Route::any(&#x27;new/:id&#x27;,&#x27;News/read&#x27;); // 所有请求都支持的路由规则 如果要定义get和post请求支持的路由规则，也可以用：1Route::rule(&#x27;new/:id&#x27;,&#x27;News/read&#x27;,&#x27;GET|POST&#x27;); 也可以批量注册路由规则123Route::rule([&#x27;new/:id&#x27;=&gt;&#x27;News/read&#x27;,&#x27;blog/:name&#x27;=&gt;&#x27;Blog/detail&#x27;]);Route::get([&#x27;new/:id&#x27;=&gt;&#x27;News/read&#x27;,&#x27;blog/:name&#x27;=&gt;&#x27;Blog/detail&#x27;]);Route::post([&#x27;new/:id&#x27;=&gt;&#x27;News/update&#x27;,&#x27;blog/:name&#x27;=&gt;&#x27;Blog/detail&#x27;]); 注册多个路由规则后，系统会依次遍历注册过的满足请求类型的路由规则，一旦匹配到正确的路由规则后则开始调用控制器的操作方法，后续规则就不再检测。定义路由配置文件除了支持动态注册，也可以直接在应用目录下面的route.php的最后通过返回数组的方式直接定义路由规则 1234return [ &#x27;new/:id&#x27; =&gt; &#x27;News/read&#x27;, &#x27;blog/:id&#x27; =&gt; [&#x27;Blog/update&#x27;,[&#x27;method&#x27; =&gt; &#x27;post|put&#x27;], [&#x27;id&#x27; =&gt; &#x27;\\d+&#x27;]],]; 路由动态注册和配置定义的方式可以并存。由于检测机制问题，动态注册的性能比路由配置要高一些，尤其是多种请求类型混合定义的时候。 默认情况下，只会加载一个路由配置文件route.php，如果需要定义多个路由文件，可以修改route_config_file的配置参数，例如： 12定义路由配置文件（数组）&#x27;route_config_file&#x27; =&gt; [&#x27;route&#x27;, &#x27;route1&#x27;, &#x27;route2&#x27;], 资源路由5.0支持设置RESTFul请求的资源路由，方式如下： Route::resource(‘blog’,’index&#x2F;blog’); 或者在路由配置文件中使用__rest__添加资源路由定义： 123456return [ // 定义资源路由 &#x27;__rest__&#x27;=&gt;[ // 指向index模块的blog控制器 &#x27;blog&#x27;=&gt;&#x27;index/blog&#x27;,], 设置过后会自动注册7个路由规则，如下： 标识 请求类型 生成路由规则 对应操作方法（默认） index GET blog index create GET blog/create create save POST blog save read GET blog/:id read edit GET blog/:id/edit edit update PUT blog/:id update delete DELETE blog/:id delete 具体指向的控制器由路由地址决定，例如上面的设置，会对应index模块的blog控制器，你只需要为Blog控制器创建以上对应的操作方法就可以支持下面的URL访问： 123http://serverName/blog/http://serverName/blog/128http://serverName/blog/28/edit Blog控制器中对应的方法如下: 12345678910111213141516namespace app\\index\\controller;class Blog &#123; public function index() &#123; dump(index); &#125; public function update($id) &#123; dump(update); &#125; public function delete($id) &#123; dump(delete); &#125;&#125; 快捷路由快捷路由允许你快速给控制器注册路由，并且针对不同的请求类型可以设置方法前缀 12// 给User控制器设置快捷路由Route::controller(&#x27;user&#x27;,&#x27;index/User&#x27;); User控制器定义如下： 12345678910111213141516171819namespace app\\index\\controller;class User &#123; public function getInfo() &#123; &#125; public function getPhone() &#123; &#125; public function postInfo() &#123; &#125; public function putInfo() &#123; &#125; public function deleteInfo() &#123; &#125;&#125; 我们可以通过下面的URL访问 12345get http://localhost/user/infoget http://localhost/user/phonepost http://localhost/user/infoput http://localhost/user/infodelete http://localhost/user/info 权限控制Base.php，需要鉴权继承该类即可 12345678910111213141516171819&lt;?phpnamespace app\\index\\controller;use think\\Controller;use think\\Request;class Base extends Controller&#123; //用来存放需要用户登录之后才能操作的方法的集合 protected $is_check_login = [&#x27;&#x27;]; public function _initialize() &#123; if (!$this-&gt;isLogin() &amp;&amp; (in_array(Request::instance()-&gt;action(), $this-&gt;is_check_login)||$this-&gt;is_check_login[0]==&#x27;*&#x27;))&#123; return $this-&gt;error(&#x27;请先登录系统！&#x27;,&#x27;index/Index/login&#x27;); &#125; &#125; public function isLogin() &#123; return session(&#x27;?name&#x27;); &#125;&#125; GoodsController,进行所有方法鉴权 123456789101112131415161718192021&lt;?phpnamespace app\\index\\controller;use app\\index\\controller\\Base;class Goods extends Base&#123; protected $is_check_login = [&#x27;*&#x27;]; public function add() &#123; echo &#x27;我想要购买商品&#x27;; &#125; public function edit() &#123; echo &#x27;我想退货&#x27;; &#125; public function delete() &#123; echo &#x27;我不想买了&#x27;; &#125;&#125; CommentController,仅对Add方法路由鉴权 1234567891011121314151617&lt;?phpnamespace app\\index\\controller;use app\\index\\controller\\Base;class Comment extends Base&#123; protected $is_check_login = [&#x27;add&#x27;]; public function add() &#123; echo &#x27;我想发表评论&#x27;; &#125; public function edit() &#123; echo &#x27;我想编辑一下自己的评论&#x27;; &#125;&#125; 数据库的操作ThinkPHP内置了抽象数据库访问层，把不同的数据库操作封装起来，我们只需要使用公共的Db类进行操作，而无需针对不同的数据库写不同的代码和底层实现，Db类会自动调用相应的数据库驱动来处理。采用PDO方式，目前包含了Mysql、SqlServer、PgSQL、Sqlite等数据库的支持。 1.基本使用配置了数据库连接信息后，我们就可以直接使用数据库运行原生SQL操作了，支持query（查询操作）和execute（写入操作）方法，并且支持参数绑定。 123456public function read()&#123; $sql = Db::query(&#x27;select * from news&#x27;); dump($sql); &#125; execute方法： 12345public function read()&#123; $sql = Db::execute(&#x27;insert into news (nid, rid) values (11, 11)&#x27;);; dump($sql);&#125; 也支持命名占位符绑定，例如： 12345public function read()&#123; $sql = Db::query(&#x27;select * from news where nid=:nid&#x27;,[&#x27;nid&#x27;=&gt;1]); dump($sql);&#125; execute方法： 12345public function read()&#123; $sql = Db::execute(&#x27;insert into news (nid, rid) values (:nid, :rid)&#x27;,[&#x27;nid&#x27;=&gt;18,&#x27;rid&#x27;=&gt;&#x27;121&#x27;]); dump($sql);&#125; 可以使用多个数据库连接: 2.查询构造器听名字就知道，很装X.. 先来看基本查询； 查询一个数据： 123// table方法必须指定完整的数据表名 $sql =Db::table(&#x27;news&#x27;)-&gt;where(&#x27;nid&#x27;,1)-&gt;find(); dump($sql); find &#x3D; 查询一条；并且查询结果不存在，返回 null 输出： 1Db::table(&#x27;think_user&#x27;)-&gt;where(&#x27;status&#x27;,1)-&gt;select(); 这条查询语句与上面同效，但是select 方法查询结果不存在，返回空数组 额 这个玩意叫查询数据集，没错！ 默认情况下，find和select方法返回的都是数组。 如果你要查询某个字段的值，咋整？ 123456public function read()&#123;// 返回某个字段的值 $sql =Db::table(&#x27;news&#x27;)-&gt;where(&#x27;nid&#x27;,18)-&gt;value(&#x27;rid&#x27;); dump($sql);&#125; 这样看输出，我求rid的值： 如果你需要处理成千上百条数据库记录，可以考虑使用chunk方法，该方法一次获取结果集的一小块，然后填充每一小块数据到要处理的闭包，该方法在编写处理大量数据库记录的时候非常有用。 1234567891011public function read()&#123; $sql =Db::table(&#x27;news&#x27;)-&gt;chunk(1,function($user)&#123; foreach($user as $u) &#123;dump($u); &#125; &#125;); &#125; 这个样子 就可以一条一条都给遍历出来了！ 是“一条一条·”，嘿！ 3.添加数据跟删除数据使用 Db 类的 insert 方法向数据库提交数据 1234567public function read()&#123;$data = [&#x27;ntitle&#x27; =&gt; &#x27;123&#x27;, &#x27;rid&#x27; =&gt; &#x27;456&#x27;];$sql = Db::table(&#x27;news&#x27;)-&gt;insert($data); dump($sql);&#125; 添加成功后insert 方法返回添加成功的条数，insert 正常情况返回 1 添加数据后如果需要返回新增数据的自增主键，可以使用getLastInsID方法： 12345678public function read()&#123;$data = [&#x27;ntitle&#x27; =&gt; &#x27;123&#x27;, &#x27;rid&#x27; =&gt; &#x27;345&#x27;];$sql = Db::table(&#x27;news&#x27;)-&gt;insert($data);$userId = Db::name(&#x27;news&#x27;)-&gt;getLastInsID(&#x27;nid&#x27;);dump($userId);dump($sql);&#125; 添加多条数据: 添加多条数据直接向 Db 类的 insertAll 方法传入需要添加的数据即可; 12345678910public function read()&#123;$data = [[&#x27;ntitle&#x27; =&gt;&#x27;gaga&#x27;,&#x27;rid&#x27; =&gt; &#x27;12&#x27;],[&#x27;ntitle&#x27; =&gt;&#x27;gaaaga&#x27;,&#x27;rid&#x27; =&gt; &#x27;123&#x27;]];$sql = Db::table(&#x27;news&#x27;)-&gt;insertAll($data);dump($sql);&#125; 这样的话，返回的应该是两条2 删除数据： 根据主键来删除 12345678public function read()&#123;// 根据主键 来删$sql = Db::table(&#x27;news&#x27;)-&gt;delete(1);//多删//$sql = Db::table(&#x27;news&#x27;)-&gt;delete(1,2,3);dump($sql);&#125; 执行成功返回影响行数； 还有一种是根据条件来删除的 12345678public function read()&#123;// 根据条件 来删$sql = Db::table(&#x27;news&#x27;)-&gt;where(&#x27;nid&#x27;,18)-&gt;delete();//多删//$sql = Db::table(&#x27;news&#x27;)-&gt;where(&#x27;nid&#x27;,&#x27;&lt;&#x27;,1)-&gt;delete();dump($sql);&#125; 执行成功也是返回影响行数； 4.查询方法：where方法： 可以使用where方法进行AND条件查询： 12345678public function read()&#123;$sql = Db::table(&#x27;news&#x27;)-&gt;where(&#x27;nid&#x27;,20)-&gt;where(&#x27;ntitle&#x27;,123)-&gt;find();dump($sql);&#125; whereOr方法： 使用whereOr方法进行OR查询： 12345678public function read()&#123;$sql = Db::table(&#x27;news&#x27;)-&gt;where(&#x27;nid&#x27;,20)-&gt;whereOr(&#x27;ntitle&#x27;,&#x27;like&#x27;,&#x27;%123%&#x27;)-&gt;find();dump($sql);&#125; 混合查询： where方法和whereOr方法在复杂的查询条件中经常需要配合一起混合使用 12345678910111213public function read()&#123;$sql = Db::table(&#x27;news&#x27;)-&gt;where(function($query)&#123; $query-&gt;where(&#x27;nid&#x27;,21)-&gt;where(&#x27;nid&#x27;,22);&#125;)-&gt;whereOr(function($query)&#123; $query-&gt;where(&#x27;ntitle&#x27;,&#x27;123&#x27;)-&gt;whereOr(&#x27;ntitle&#x27;,&#x27;123&#x27;);&#125;)-&gt;select();dump($sql);&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://2486125878.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"php","slug":"php","permalink":"https://2486125878.github.io/tags/php/"}]},{"title":"初创博客","slug":"hello-hexo","date":"2023-11-24T07:04:22.000Z","updated":"2023-11-24T11:04:34.000Z","comments":true,"path":"2023/11/24/hello-hexo/","permalink":"https://2486125878.github.io/2023/11/24/hello-hexo/","excerpt":"","text":"","categories":[],"tags":[{"name":"创建博客记录","slug":"创建博客记录","permalink":"https://2486125878.github.io/tags/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/"}]}],"categories":[{"name":"thinkphp项目","slug":"thinkphp项目","permalink":"https://2486125878.github.io/categories/thinkphp%E9%A1%B9%E7%9B%AE/"},{"name":"thinkphp查询","slug":"thinkphp查询","permalink":"https://2486125878.github.io/categories/thinkphp%E6%9F%A5%E8%AF%A2/"},{"name":"数据库","slug":"数据库","permalink":"https://2486125878.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"前端","slug":"前端","permalink":"https://2486125878.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"后端","slug":"后端","permalink":"https://2486125878.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"php","slug":"php","permalink":"https://2486125878.github.io/tags/php/"},{"name":"mysql","slug":"mysql","permalink":"https://2486125878.github.io/tags/mysql/"},{"name":"移动端","slug":"移动端","permalink":"https://2486125878.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"HTML","slug":"HTML","permalink":"https://2486125878.github.io/tags/HTML/"},{"name":"JAVA","slug":"JAVA","permalink":"https://2486125878.github.io/tags/JAVA/"},{"name":"数据可视化","slug":"数据可视化","permalink":"https://2486125878.github.io/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"name":"vue","slug":"vue","permalink":"https://2486125878.github.io/tags/vue/"},{"name":"nodeJs","slug":"nodeJs","permalink":"https://2486125878.github.io/tags/nodeJs/"},{"name":"jQuery","slug":"jQuery","permalink":"https://2486125878.github.io/tags/jQuery/"},{"name":"javascript","slug":"javascript","permalink":"https://2486125878.github.io/tags/javascript/"},{"name":"Ajax","slug":"Ajax","permalink":"https://2486125878.github.io/tags/Ajax/"},{"name":"创建博客记录","slug":"创建博客记录","permalink":"https://2486125878.github.io/tags/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/"}]}